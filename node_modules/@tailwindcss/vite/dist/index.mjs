var P=(s,i)=>(i=Symbol[s])?i:Symbol.for("Symbol."+s),M=s=>{throw TypeError(s)};var y=(s,i,e)=>{if(i!=null){typeof i!="object"&&typeof i!="function"&&M("Object expected");var t,p;e&&(t=i[P("asyncDispose")]),t===void 0&&(t=i[P("dispose")],e&&(p=t)),typeof t!="function"&&M("Object not disposable"),p&&(t=function(){try{p.call(this)}catch(f){return Promise.reject(f)}}),s.push([e,t,i])}else e&&s.push([e]);return i},w=(s,i,e)=>{var t=typeof SuppressedError=="function"?SuppressedError:function(a,l,o,c){return c=Error(o),c.name="SuppressedError",c.error=a,c.suppressed=l,c},p=a=>i=e?new t(a,i,"An error was suppressed during disposal"):(e=!0,a),f=a=>{for(;a=s.pop();)try{var l=a[1]&&a[1].call(a[2]);if(a[0])return Promise.resolve(l).then(f,o=>(p(o),f()))}catch(o){p(o)}if(e)throw i};return f()};import{compile as O,env as _,Features as h,Instrumentation as B,normalizePath as x,optimize as U,toSourceMap as V}from"@tailwindcss/node";import{clearRequireCache as G}from"@tailwindcss/node/require-cache";import{Scanner as J}from"@tailwindcss/oxide";import R from"fs/promises";import v from"path";var d=_.DEBUG,A=/[?&](?:worker|sharedworker|raw|url)\b/,K=/\?commonjs-proxy/,T=/[?&]index\=\d+\.css$/;function j(s={}){let i=[],e=null,t=!1,p=!0,f=!0,a=new C(l=>{let o=e.createResolver({...e.resolve,extensions:[".css"],mainFields:["style"],conditions:["style","development|production"],tryIndex:!1,preferRelative:!0});function c(u,m){return o(u,m,!0,t)}let r=e.createResolver(e.resolve);function n(u,m){return r(u,m,!0,t)}return new D(l,e.root,e?.css.devSourcemap??!1,c,n)});return[{name:"@tailwindcss/vite:scan",enforce:"pre",configureServer(l){i.push(l)},async configResolved(l){e=l,t=e.build.ssr!==!1&&e.build.ssr!==void 0,s.optimize!==void 0&&(p=s.optimize!==!1),f=p&&e.build.cssMinify!==!1,typeof s.optimize=="object"&&(f=s.optimize.minify!==!1)}},{name:"@tailwindcss/vite:generate:serve",apply:"serve",enforce:"pre",async transform(l,o,c){var m=[];try{if(!E(o))return;let r=y(m,new B);d&&r.start("[@tailwindcss/vite] Generate CSS (serve)");let n=a.get(o);let u=await n.generate(l,F=>this.addWatchFile(F),r);if(!u)return a.delete(o),l;d&&r.end("[@tailwindcss/vite] Generate CSS (serve)");return u}catch(b){var g=b,S=!0}finally{w(m,g,S)}}},{name:"@tailwindcss/vite:generate:build",apply:"build",enforce:"pre",async transform(l,o){var u=[];try{if(!E(o))return;let c=y(u,new B);d&&c.start("[@tailwindcss/vite] Generate CSS (build)");let r=a.get(o);let n=await r.generate(l,S=>this.addWatchFile(S),c);if(!n)return a.delete(o),l;d&&c.end("[@tailwindcss/vite] Generate CSS (build)");p&&(d&&c.start("[@tailwindcss/vite] Optimize CSS"),n=U(n.code,{minify:f,map:n.map}),d&&c.end("[@tailwindcss/vite] Optimize CSS"));return n}catch(m){var b=m,g=!0}finally{w(u,b,g)}}}]}function q(s){let[i]=s.split("?",2);return v.extname(i).slice(1)}function E(s){return s.includes("/.vite/")?void 0:(q(s)==="css"||s.includes("&lang.css")||s.match(T))&&!A.test(s)&&!K.test(s)}function z(s){return v.resolve(s.replace(/\?.*$/,""))}var C=class extends Map{constructor(e){super();this.factory=e}get(e){let t=super.get(e);return t===void 0&&(t=this.factory(e,this),this.set(e,t)),t}},D=class{constructor(i,e,t,p,f){this.id=i;this.base=e;this.enableSourceMaps=t;this.customCssResolver=p;this.customJsResolver=f}compiler;scanner;candidates=new Set;buildDependencies=new Map;async generate(i,e,t){let p=z(this.id);function f(r){r!==p&&(/[\#\?].*\.svg$/.test(r)||e(r))}let a=this.requiresBuild(),l=v.dirname(v.resolve(p));if(!this.compiler||!this.scanner||await a){G(Array.from(this.buildDependencies.keys())),this.buildDependencies.clear(),this.addBuildDependency(z(p)),d&&t.start("Setup compiler");let r=[];this.compiler=await O(i,{from:this.enableSourceMaps?this.id:void 0,base:l,shouldRewriteUrls:!0,onDependency:u=>{f(u),r.push(this.addBuildDependency(u))},customCssResolver:this.customCssResolver,customJsResolver:this.customJsResolver}),await Promise.all(r),d&&t.end("Setup compiler"),d&&t.start("Setup scanner");let n=(this.compiler.root==="none"?[]:this.compiler.root===null?[{base:this.base,pattern:"**/*",negated:!1}]:[{...this.compiler.root,negated:!1}]).concat(this.compiler.sources);this.scanner=new J({sources:n}),d&&t.end("Setup scanner")}else for(let r of this.buildDependencies.keys())f(r);if(!(this.compiler.features&(h.AtApply|h.JsPluginCompat|h.ThemeFunction|h.Utilities)))return!1;if(this.compiler.features&h.Utilities){d&&t.start("Scan for candidates");for(let r of this.scanner.scan())this.candidates.add(r);d&&t.end("Scan for candidates")}if(this.compiler.features&h.Utilities){for(let r of this.scanner.files)f(r);for(let r of this.scanner.globs){if(r.pattern[0]==="!")continue;let n=v.relative(this.base,r.base);n[0]!=="."&&(n="./"+n),n=x(n),f(v.posix.join(n,r.pattern));let u=this.compiler.root;if(u!=="none"&&u!==null){let m=x(v.resolve(u.base,u.pattern));if(!await R.stat(m).then(g=>g.isDirectory(),()=>!1))throw new Error(`The path given to \`source(\u2026)\` must be a directory but got \`source(${m})\` instead.`)}}}d&&t.start("Build CSS");let o=this.compiler.build([...this.candidates]);d&&t.end("Build CSS"),d&&t.start("Build Source Map");let c=this.enableSourceMaps?V(this.compiler.buildSourceMap()).raw:void 0;return d&&t.end("Build Source Map"),{code:o,map:c}}async addBuildDependency(i){let e=null;try{e=(await R.stat(i)).mtimeMs}catch{}this.buildDependencies.set(i,e)}async requiresBuild(){for(let[i,e]of this.buildDependencies){if(e===null)return!0;try{if((await R.stat(i)).mtimeMs>e)return!0}catch{return!0}}return!1}};export{j as default};
