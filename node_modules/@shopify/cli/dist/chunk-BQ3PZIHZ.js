import {
  __commonJS,
  __require,
  __toESM,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/branding.js
var require_branding = __commonJS({
  "../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/branding.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/messages.js
var require_messages = __commonJS({
  "../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/messages.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var inverted = Symbol("inverted"), expectNull = Symbol("expectNull"), expectUndefined = Symbol("expectUndefined"), expectNumber = Symbol("expectNumber"), expectString = Symbol("expectString"), expectBoolean = Symbol("expectBoolean"), expectVoid = Symbol("expectVoid"), expectFunction = Symbol("expectFunction"), expectObject = Symbol("expectObject"), expectArray = Symbol("expectArray"), expectSymbol = Symbol("expectSymbol"), expectAny = Symbol("expectAny"), expectUnknown = Symbol("expectUnknown"), expectNever = Symbol("expectNever"), expectNullable = Symbol("expectNullable"), expectBigInt = Symbol("expectBigInt");
  }
});

// ../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/overloads.js
var require_overloads = __commonJS({
  "../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/overloads.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var secret = Symbol("secret"), mismatch = Symbol("mismatch"), avalue = Symbol("avalue");
  }
});

// ../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/expect-type@1.2.1/node_modules/expect-type/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m2[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m2[k];
    }), __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p3 in m2) p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3) && __createBinding(exports2, m2, p3);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.expectTypeOf = void 0;
    __exportStar(require_branding(), exports);
    __exportStar(require_messages(), exports);
    __exportStar(require_overloads(), exports);
    __exportStar(require_utils(), exports);
    var fn2 = () => !0, expectTypeOf2 = (_actual) => {
      let nonFunctionProperties = [
        "parameters",
        "returns",
        "resolves",
        "not",
        "items",
        "constructorParameters",
        "thisParameter",
        "instance",
        "guards",
        "asserts",
        "branded"
      ], obj = {
        /* eslint-disable @typescript-eslint/no-unsafe-assignment */
        toBeAny: fn2,
        toBeUnknown: fn2,
        toBeNever: fn2,
        toBeFunction: fn2,
        toBeObject: fn2,
        toBeArray: fn2,
        toBeString: fn2,
        toBeNumber: fn2,
        toBeBoolean: fn2,
        toBeVoid: fn2,
        toBeSymbol: fn2,
        toBeNull: fn2,
        toBeUndefined: fn2,
        toBeNullable: fn2,
        toBeBigInt: fn2,
        toMatchTypeOf: fn2,
        toEqualTypeOf: fn2,
        toBeConstructibleWith: fn2,
        toMatchObjectType: fn2,
        toExtend: fn2,
        map: exports.expectTypeOf,
        toBeCallableWith: exports.expectTypeOf,
        extract: exports.expectTypeOf,
        exclude: exports.expectTypeOf,
        pick: exports.expectTypeOf,
        omit: exports.expectTypeOf,
        toHaveProperty: exports.expectTypeOf,
        parameter: exports.expectTypeOf
      };
      return nonFunctionProperties.forEach((prop) => Object.defineProperty(obj, prop, { get: () => (0, exports.expectTypeOf)({}) })), obj;
    };
    exports.expectTypeOf = expectTypeOf2;
  }
});

// ../../node_modules/.pnpm/@vitest+runner@3.2.1/node_modules/@vitest/runner/dist/chunk-hooks.js
init_cjs_shims();

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js
init_cjs_shims();

// ../../node_modules/.pnpm/@vitest+pretty-format@3.2.1/node_modules/@vitest/pretty-format/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
init_cjs_shims();

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/chunk-BVHSVHOK.js
init_cjs_shims();
var f = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, h = Object.entries(f);
function a(n) {
  return String(n);
}
a.open = "";
a.close = "";
function C(n = !1) {
  let e = typeof process < "u" ? process : void 0, i = e?.env || {}, g = e?.argv || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || e?.platform === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window < "u" && !!window.chrome;
}
function p(n = !1) {
  let e = C(n), i = (r2, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r2.substring(s2, o) + c, s2 = o + t.length, o = r2.indexOf(t, s2);
    while (~o);
    return l + r2.substring(s2);
  }, g = (r2, t, c = r2) => {
    let o = (l) => {
      let s2 = String(l), b = s2.indexOf(t, r2.length);
      return ~b ? r2 + i(s2, t, c, b) + t : r2 + s2 + t;
    };
    return o.open = r2, o.close = t, o;
  }, u2 = {
    isColorSupported: e
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t] of h)
    u2[r2] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a;
  return u2;
}

// ../../node_modules/.pnpm/tinyrainbow@2.0.0/node_modules/tinyrainbow/dist/node.js
import { isatty as s } from "tty";
var r = process.env.FORCE_TTY !== void 0 || s(1);
var u = p(r);

// ../../node_modules/.pnpm/@vitest+pretty-format@3.2.1/node_modules/@vitest/pretty-format/dist/index.js
function _mergeNamespaces(n, m2) {
  return m2.forEach(function(e) {
    e && typeof e != "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: !0,
          get: function() {
            return e[k];
          }
        });
      }
    });
  }), Object.freeze(n);
}
function getKeysOfEnumerableProperties(object2, compareKeys) {
  let rawKeys = Object.keys(object2), keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols)
    for (let symbol of Object.getOwnPropertySymbols(object2))
      Object.getOwnPropertyDescriptor(object2, symbol).enumerable && keys2.push(symbol);
  return keys2;
}
function printIteratorEntries(iterator, config2, indentation, depth, refs, printer2, separator = ": ") {
  let result = "", width = 0, current = iterator.next();
  if (!current.done) {
    result += config2.spacingOuter;
    let indentationNext = indentation + config2.indent;
    for (; !current.done; ) {
      if (result += indentationNext, width++ === config2.maxWidth) {
        result += "\u2026";
        break;
      }
      let name = printer2(current.value[0], config2, indentationNext, depth, refs), value = printer2(current.value[1], config2, indentationNext, depth, refs);
      result += name + separator + value, current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
    }
    result += config2.spacingOuter + indentation;
  }
  return result;
}
function printIteratorValues(iterator, config2, indentation, depth, refs, printer2) {
  let result = "", width = 0, current = iterator.next();
  if (!current.done) {
    result += config2.spacingOuter;
    let indentationNext = indentation + config2.indent;
    for (; !current.done; ) {
      if (result += indentationNext, width++ === config2.maxWidth) {
        result += "\u2026";
        break;
      }
      result += printer2(current.value, config2, indentationNext, depth, refs), current = iterator.next(), current.done ? config2.min || (result += ",") : result += `,${config2.spacingInner}`;
    }
    result += config2.spacingOuter + indentation;
  }
  return result;
}
function printListItems(list, config2, indentation, depth, refs, printer2) {
  let result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  let isDataView = (l) => l instanceof DataView, length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config2.spacingOuter;
    let indentationNext = indentation + config2.indent;
    for (let i = 0; i < length; i++) {
      if (result += indentationNext, i === config2.maxWidth) {
        result += "\u2026";
        break;
      }
      (isDataView(list) || i in list) && (result += printer2(isDataView(list) ? list.getInt8(i) : list[i], config2, indentationNext, depth, refs)), i < length - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
    }
    result += config2.spacingOuter + indentation;
  }
  return result;
}
function printObjectProperties(val, config2, indentation, depth, refs, printer2) {
  let result = "", keys2 = getKeysOfEnumerableProperties(val, config2.compareKeys);
  if (keys2.length > 0) {
    result += config2.spacingOuter;
    let indentationNext = indentation + config2.indent;
    for (let i = 0; i < keys2.length; i++) {
      let key = keys2[i], name = printer2(key, config2, indentationNext, depth, refs), value = printer2(val[key], config2, indentationNext, depth, refs);
      result += `${indentationNext + name}: ${value}`, i < keys2.length - 1 ? result += `,${config2.spacingInner}` : config2.min || (result += ",");
    }
    result += config2.spacingOuter + indentation;
  }
  return result;
}
var asymmetricMatcher = typeof Symbol == "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621, SPACE$2 = " ", serialize$5 = (val, config2, indentation, depth, refs, printer2) => {
  let stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining")
    return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}[${printListItems(val.sample, config2, indentation, depth, refs, printer2)}]`;
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining")
    return ++depth > config2.maxDepth ? `[${stringedValue}]` : `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config2, indentation, depth, refs, printer2)}}`;
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching" || stringedValue === "StringContaining" || stringedValue === "StringNotContaining")
    return stringedValue + SPACE$2 + printer2(val.sample, config2, indentation, depth, refs);
  if (typeof val.toAsymmetricMatcher != "function")
    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  return val.toAsymmetricMatcher();
}, test$5 = (val) => val && val.$$typeof === asymmetricMatcher, plugin$5 = {
  serialize: serialize$5,
  test: test$5
}, SPACE$1 = " ", OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]), ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
var test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$4 = (collection, config2, indentation, depth, refs, printer2) => {
  let name = collection.constructor.name;
  return ++depth > config2.maxDepth ? `[${name}]` : (config2.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}) : { ...collection }, config2, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config2, indentation, depth, refs, printer2)}]`);
}, plugin$4 = {
  serialize: serialize$4,
  test: test$4
};
function escapeHTML(str) {
  return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys2, props, config2, indentation, depth, refs, printer2) {
  let indentationNext = indentation + config2.indent, colors = config2.colors;
  return keys2.map((key) => {
    let value = props[key], printed = printer2(value, config2, indentationNext, depth, refs);
    return typeof value != "string" && (printed.includes(`
`) && (printed = config2.spacingOuter + indentationNext + printed + config2.spacingOuter + indentation), printed = `{${printed}}`), `${config2.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
  }).join("");
}
function printChildren(children, config2, indentation, depth, refs, printer2) {
  return children.map((child) => config2.spacingOuter + indentation + (typeof child == "string" ? printText(child, config2) : printer2(child, config2, indentation, depth, refs))).join("");
}
function printText(text, config2) {
  let contentColor = config2.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config2) {
  let commentColor = config2.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type3, printedProps, printedChildren, config2, indentation) {
  let tagColor = config2.colors.tag;
  return `${tagColor.open}<${type3}${printedProps && tagColor.close + printedProps + config2.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config2.spacingOuter}${indentation}${tagColor.open}</${type3}` : `${printedProps && !config2.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type3, config2) {
  let tagColor = config2.colors.tag;
  return `${tagColor.open}<${type3}${tagColor.close} \u2026${tagColor.open} />${tagColor.close}`;
}
var ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, FRAGMENT_NODE = 11, ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute == "function" && val.hasAttribute("is");
  } catch {
    return !1;
  }
}
function testNode(val) {
  let constructorName = val.constructor.name, { nodeType, tagName } = val, isCustomElement = typeof tagName == "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
var test$3 = (val) => {
  var _val$constructor;
  return (val == null || (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) && testNode(val);
};
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
var serialize$3 = (node, config2, indentation, depth, refs, printer2) => {
  if (nodeIsText(node))
    return printText(node.data, config2);
  if (nodeIsComment(node))
    return printComment(node.data, config2);
  let type3 = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  return ++depth > config2.maxDepth ? printElementAsLeaf(type3, config2) : printElement(type3, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => (props[attribute.name] = attribute.value, props), {}), config2, indentation + config2.indent, depth, refs, printer2), printChildren(Array.prototype.slice.call(node.childNodes || node.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation);
}, plugin$3 = {
  serialize: serialize$3,
  test: test$3
}, IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@", IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@", IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@", IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@", IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@", IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@", IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@", IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@", getImmutableName = (name) => `Immutable.${name}`, printAsLeaf = (name) => `[${name}]`, SPACE = " ", LAZY = "\u2026";
function printImmutableEntries(val, config2, indentation, depth, refs, printer2, type3) {
  return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type3)) : `${getImmutableName(type3) + SPACE}{${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2)}}`;
}
function getRecordEntries(val) {
  let i = 0;
  return { next() {
    if (i < val._keys.length) {
      let key = val._keys[i++];
      return {
        done: !1,
        value: [key, val.get(key)]
      };
    }
    return {
      done: !0,
      value: void 0
    };
  } };
}
function printImmutableRecord(val, config2, indentation, depth, refs, printer2) {
  let name = getImmutableName(val._name || "Record");
  return ++depth > config2.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config2, indentation, depth, refs, printer2)}}`;
}
function printImmutableSeq(val, config2, indentation, depth, refs, printer2) {
  let name = getImmutableName("Seq");
  return ++depth > config2.maxDepth ? printAsLeaf(name) : val[IS_KEYED_SENTINEL] ? `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer2) : LAZY}}` : `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config2, indentation, depth, refs, printer2) : LAZY}]`;
}
function printImmutableValues(val, config2, indentation, depth, refs, printer2, type3) {
  return ++depth > config2.maxDepth ? printAsLeaf(getImmutableName(type3)) : `${getImmutableName(type3) + SPACE}[${printIteratorValues(val.values(), config2, indentation, depth, refs, printer2)}]`;
}
var serialize$2 = (val, config2, indentation, depth, refs, printer2) => val[IS_MAP_SENTINEL] ? printImmutableEntries(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map") : val[IS_LIST_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "List") : val[IS_SET_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set") : val[IS_STACK_SENTINEL] ? printImmutableValues(val, config2, indentation, depth, refs, printer2, "Stack") : val[IS_SEQ_SENTINEL] ? printImmutableSeq(val, config2, indentation, depth, refs, printer2) : printImmutableRecord(val, config2, indentation, depth, refs, printer2), test$2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === !0 || val[IS_RECORD_SENTINEL] === !0), plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var reactIs$1 = { exports: {} }, reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf2(object2) {
    if (typeof object2 == "object" && object2 !== null) {
      var $$typeof = object2.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object2 = object2.type, object2) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object2;
            default:
              switch (object2 = object2 && object2.$$typeof, object2) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object2;
                case REACT_CONSUMER_TYPE:
                  return object2;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  return reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_production.ContextProvider = REACT_CONTEXT_TYPE, reactIs_production.Element = REACT_ELEMENT_TYPE, reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_production.Fragment = REACT_FRAGMENT_TYPE, reactIs_production.Lazy = REACT_LAZY_TYPE, reactIs_production.Memo = REACT_MEMO_TYPE, reactIs_production.Portal = REACT_PORTAL_TYPE, reactIs_production.Profiler = REACT_PROFILER_TYPE, reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_production.Suspense = REACT_SUSPENSE_TYPE, reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_production.isContextConsumer = function(object2) {
    return typeOf2(object2) === REACT_CONSUMER_TYPE;
  }, reactIs_production.isContextProvider = function(object2) {
    return typeOf2(object2) === REACT_CONTEXT_TYPE;
  }, reactIs_production.isElement = function(object2) {
    return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
  }, reactIs_production.isForwardRef = function(object2) {
    return typeOf2(object2) === REACT_FORWARD_REF_TYPE;
  }, reactIs_production.isFragment = function(object2) {
    return typeOf2(object2) === REACT_FRAGMENT_TYPE;
  }, reactIs_production.isLazy = function(object2) {
    return typeOf2(object2) === REACT_LAZY_TYPE;
  }, reactIs_production.isMemo = function(object2) {
    return typeOf2(object2) === REACT_MEMO_TYPE;
  }, reactIs_production.isPortal = function(object2) {
    return typeOf2(object2) === REACT_PORTAL_TYPE;
  }, reactIs_production.isProfiler = function(object2) {
    return typeOf2(object2) === REACT_PROFILER_TYPE;
  }, reactIs_production.isStrictMode = function(object2) {
    return typeOf2(object2) === REACT_STRICT_MODE_TYPE;
  }, reactIs_production.isSuspense = function(object2) {
    return typeOf2(object2) === REACT_SUSPENSE_TYPE;
  }, reactIs_production.isSuspenseList = function(object2) {
    return typeOf2(object2) === REACT_SUSPENSE_LIST_TYPE;
  }, reactIs_production.isValidElementType = function(type3) {
    return typeof type3 == "string" || typeof type3 == "function" || type3 === REACT_FRAGMENT_TYPE || type3 === REACT_PROFILER_TYPE || type3 === REACT_STRICT_MODE_TYPE || type3 === REACT_SUSPENSE_TYPE || type3 === REACT_SUSPENSE_LIST_TYPE || typeof type3 == "object" && type3 !== null && (type3.$$typeof === REACT_LAZY_TYPE || type3.$$typeof === REACT_MEMO_TYPE || type3.$$typeof === REACT_CONTEXT_TYPE || type3.$$typeof === REACT_CONSUMER_TYPE || type3.$$typeof === REACT_FORWARD_REF_TYPE || type3.$$typeof === REACT_CLIENT_REFERENCE || type3.getModuleId !== void 0);
  }, reactIs_production.typeOf = typeOf2, reactIs_production;
}
var reactIs_development$1 = {};
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, process.env.NODE_ENV !== "production" && function() {
    function typeOf2(object2) {
      if (typeof object2 == "object" && object2 !== null) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            switch (object2 = object2.type, object2) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
              case REACT_VIEW_TRANSITION_TYPE:
                return object2;
              default:
                switch (object2 = object2 && object2.$$typeof, object2) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                    return object2;
                  case REACT_CONSUMER_TYPE:
                    return object2;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    reactIs_development$1.ContextConsumer = REACT_CONSUMER_TYPE, reactIs_development$1.ContextProvider = REACT_CONTEXT_TYPE, reactIs_development$1.Element = REACT_ELEMENT_TYPE, reactIs_development$1.ForwardRef = REACT_FORWARD_REF_TYPE, reactIs_development$1.Fragment = REACT_FRAGMENT_TYPE, reactIs_development$1.Lazy = REACT_LAZY_TYPE, reactIs_development$1.Memo = REACT_MEMO_TYPE, reactIs_development$1.Portal = REACT_PORTAL_TYPE, reactIs_development$1.Profiler = REACT_PROFILER_TYPE, reactIs_development$1.StrictMode = REACT_STRICT_MODE_TYPE, reactIs_development$1.Suspense = REACT_SUSPENSE_TYPE, reactIs_development$1.SuspenseList = REACT_SUSPENSE_LIST_TYPE, reactIs_development$1.isContextConsumer = function(object2) {
      return typeOf2(object2) === REACT_CONSUMER_TYPE;
    }, reactIs_development$1.isContextProvider = function(object2) {
      return typeOf2(object2) === REACT_CONTEXT_TYPE;
    }, reactIs_development$1.isElement = function(object2) {
      return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
    }, reactIs_development$1.isForwardRef = function(object2) {
      return typeOf2(object2) === REACT_FORWARD_REF_TYPE;
    }, reactIs_development$1.isFragment = function(object2) {
      return typeOf2(object2) === REACT_FRAGMENT_TYPE;
    }, reactIs_development$1.isLazy = function(object2) {
      return typeOf2(object2) === REACT_LAZY_TYPE;
    }, reactIs_development$1.isMemo = function(object2) {
      return typeOf2(object2) === REACT_MEMO_TYPE;
    }, reactIs_development$1.isPortal = function(object2) {
      return typeOf2(object2) === REACT_PORTAL_TYPE;
    }, reactIs_development$1.isProfiler = function(object2) {
      return typeOf2(object2) === REACT_PROFILER_TYPE;
    }, reactIs_development$1.isStrictMode = function(object2) {
      return typeOf2(object2) === REACT_STRICT_MODE_TYPE;
    }, reactIs_development$1.isSuspense = function(object2) {
      return typeOf2(object2) === REACT_SUSPENSE_TYPE;
    }, reactIs_development$1.isSuspenseList = function(object2) {
      return typeOf2(object2) === REACT_SUSPENSE_LIST_TYPE;
    }, reactIs_development$1.isValidElementType = function(type3) {
      return typeof type3 == "string" || typeof type3 == "function" || type3 === REACT_FRAGMENT_TYPE || type3 === REACT_PROFILER_TYPE || type3 === REACT_STRICT_MODE_TYPE || type3 === REACT_SUSPENSE_TYPE || type3 === REACT_SUSPENSE_LIST_TYPE || typeof type3 == "object" && type3 !== null && (type3.$$typeof === REACT_LAZY_TYPE || type3.$$typeof === REACT_MEMO_TYPE || type3.$$typeof === REACT_CONTEXT_TYPE || type3.$$typeof === REACT_CONSUMER_TYPE || type3.$$typeof === REACT_FORWARD_REF_TYPE || type3.$$typeof === REACT_CLIENT_REFERENCE || type3.getModuleId !== void 0);
    }, reactIs_development$1.typeOf = typeOf2;
  }()), reactIs_development$1;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  return hasRequiredReactIs$1 || (hasRequiredReactIs$1 = 1, process.env.NODE_ENV === "production" ? reactIs$1.exports = requireReactIs_production() : reactIs$1.exports = requireReactIs_development$1()), reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1(), index$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports$1), ReactIs19 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [reactIsExports$1]), reactIs = { exports: {} }, reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f3 = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h3 = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p3 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u2;
  u2 = Symbol.for("react.module.reference");
  function v(a3) {
    if (typeof a3 == "object" && a3 !== null) {
      var r2 = a3.$$typeof;
      switch (r2) {
        case b:
          switch (a3 = a3.type, a3) {
            case d:
            case f3:
            case e:
            case m2:
            case n:
              return a3;
            default:
              switch (a3 = a3 && a3.$$typeof, a3) {
                case k:
                case h3:
                case l:
                case q:
                case p3:
                case g:
                  return a3;
                default:
                  return r2;
              }
          }
        case c:
          return r2;
      }
    }
  }
  return reactIs_production_min.ContextConsumer = h3, reactIs_production_min.ContextProvider = g, reactIs_production_min.Element = b, reactIs_production_min.ForwardRef = l, reactIs_production_min.Fragment = d, reactIs_production_min.Lazy = q, reactIs_production_min.Memo = p3, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = f3, reactIs_production_min.StrictMode = e, reactIs_production_min.Suspense = m2, reactIs_production_min.SuspenseList = n, reactIs_production_min.isAsyncMode = function() {
    return !1;
  }, reactIs_production_min.isConcurrentMode = function() {
    return !1;
  }, reactIs_production_min.isContextConsumer = function(a3) {
    return v(a3) === h3;
  }, reactIs_production_min.isContextProvider = function(a3) {
    return v(a3) === g;
  }, reactIs_production_min.isElement = function(a3) {
    return typeof a3 == "object" && a3 !== null && a3.$$typeof === b;
  }, reactIs_production_min.isForwardRef = function(a3) {
    return v(a3) === l;
  }, reactIs_production_min.isFragment = function(a3) {
    return v(a3) === d;
  }, reactIs_production_min.isLazy = function(a3) {
    return v(a3) === q;
  }, reactIs_production_min.isMemo = function(a3) {
    return v(a3) === p3;
  }, reactIs_production_min.isPortal = function(a3) {
    return v(a3) === c;
  }, reactIs_production_min.isProfiler = function(a3) {
    return v(a3) === f3;
  }, reactIs_production_min.isStrictMode = function(a3) {
    return v(a3) === e;
  }, reactIs_production_min.isSuspense = function(a3) {
    return v(a3) === m2;
  }, reactIs_production_min.isSuspenseList = function(a3) {
    return v(a3) === n;
  }, reactIs_production_min.isValidElementType = function(a3) {
    return typeof a3 == "string" || typeof a3 == "function" || a3 === d || a3 === f3 || a3 === e || a3 === m2 || a3 === n || a3 === t || typeof a3 == "object" && a3 !== null && (a3.$$typeof === q || a3.$$typeof === p3 || a3.$$typeof === g || a3.$$typeof === h3 || a3.$$typeof === l || a3.$$typeof === u2 || a3.getModuleId !== void 0);
  }, reactIs_production_min.typeOf = v, reactIs_production_min;
}
var reactIs_development = {};
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, REACT_MODULE_REFERENCE;
    REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
    function isValidElementType(type3) {
      return !!(typeof type3 == "string" || typeof type3 == "function" || type3 === REACT_FRAGMENT_TYPE || type3 === REACT_PROFILER_TYPE || enableDebugTracing || type3 === REACT_STRICT_MODE_TYPE || type3 === REACT_SUSPENSE_TYPE || type3 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type3 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type3 == "object" && type3 !== null && (type3.$$typeof === REACT_LAZY_TYPE || type3.$$typeof === REACT_MEMO_TYPE || type3.$$typeof === REACT_PROVIDER_TYPE || type3.$$typeof === REACT_CONTEXT_TYPE || type3.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      type3.$$typeof === REACT_MODULE_REFERENCE || type3.getModuleId !== void 0));
    }
    function typeOf2(object2) {
      if (typeof object2 == "object" && object2 !== null) {
        var $$typeof = object2.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type3 = object2.type;
            switch (type3) {
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
              case REACT_SUSPENSE_LIST_TYPE:
                return type3;
              default:
                var $$typeofType = type3 && type3.$$typeof;
                switch ($$typeofType) {
                  case REACT_SERVER_CONTEXT_TYPE:
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, SuspenseList = REACT_SUSPENSE_LIST_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1, hasWarnedAboutDeprecatedIsConcurrentMode = !1;
    function isAsyncMode(object2) {
      return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function isConcurrentMode(object2) {
      return hasWarnedAboutDeprecatedIsConcurrentMode || (hasWarnedAboutDeprecatedIsConcurrentMode = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function isContextConsumer(object2) {
      return typeOf2(object2) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object2) {
      return typeOf2(object2) === REACT_PROVIDER_TYPE;
    }
    function isElement(object2) {
      return typeof object2 == "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object2) {
      return typeOf2(object2) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object2) {
      return typeOf2(object2) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object2) {
      return typeOf2(object2) === REACT_LAZY_TYPE;
    }
    function isMemo(object2) {
      return typeOf2(object2) === REACT_MEMO_TYPE;
    }
    function isPortal(object2) {
      return typeOf2(object2) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object2) {
      return typeOf2(object2) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object2) {
      return typeOf2(object2) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object2) {
      return typeOf2(object2) === REACT_SUSPENSE_TYPE;
    }
    function isSuspenseList(object2) {
      return typeOf2(object2) === REACT_SUSPENSE_LIST_TYPE;
    }
    reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal, reactIs_development.Profiler = Profiler, reactIs_development.StrictMode = StrictMode, reactIs_development.Suspense = Suspense, reactIs_development.SuspenseList = SuspenseList, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isSuspenseList = isSuspenseList, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf2;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;
}
var reactIsExports = requireReactIs(), index = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports), ReactIs18 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [reactIsExports]), reactIsMethods = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
], ReactIs = Object.fromEntries(reactIsMethods.map((m2) => [m2, (v) => ReactIs18[m2](v) || ReactIs19[m2](v)]));
function getChildren(arg, children = []) {
  if (Array.isArray(arg))
    for (let item of arg)
      getChildren(item, children);
  else arg != null && arg !== !1 && arg !== "" && children.push(arg);
  return children;
}
function getType(element) {
  let type3 = element.type;
  if (typeof type3 == "string")
    return type3;
  if (typeof type3 == "function")
    return type3.displayName || type3.name || "Unknown";
  if (ReactIs.isFragment(element))
    return "React.Fragment";
  if (ReactIs.isSuspense(element))
    return "React.Suspense";
  if (typeof type3 == "object" && type3 !== null) {
    if (ReactIs.isContextProvider(element))
      return "Context.Provider";
    if (ReactIs.isContextConsumer(element))
      return "Context.Consumer";
    if (ReactIs.isForwardRef(element)) {
      if (type3.displayName)
        return type3.displayName;
      let functionName2 = type3.render.displayName || type3.render.name || "";
      return functionName2 === "" ? "ForwardRef" : `ForwardRef(${functionName2})`;
    }
    if (ReactIs.isMemo(element)) {
      let functionName2 = type3.displayName || type3.type.displayName || type3.type.name || "";
      return functionName2 === "" ? "Memo" : `Memo(${functionName2})`;
    }
  }
  return "UNDEFINED";
}
function getPropKeys$1(element) {
  let { props } = element;
  return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
var serialize$1 = (element, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(getType(element), config2) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config2, indentation + config2.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config2, indentation + config2.indent, depth, refs, printer2), config2, indentation), test$1 = (val) => val != null && ReactIs.isElement(val), plugin$1 = {
  serialize: serialize$1,
  test: test$1
}, testSymbol = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object2) {
  let { props } = object2;
  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
var serialize = (object2, config2, indentation, depth, refs, printer2) => ++depth > config2.maxDepth ? printElementAsLeaf(object2.type, config2) : printElement(object2.type, object2.props ? printProps(getPropKeys(object2), object2.props, config2, indentation + config2.indent, depth, refs, printer2) : "", object2.children ? printChildren(object2.children, config2, indentation + config2.indent, depth, refs, printer2) : "", config2, indentation), test = (val) => val && val.$$typeof === testSymbol, plugin = {
  serialize,
  test
}, toString = Object.prototype.toString, toISOString = Date.prototype.toISOString, errorToString = Error.prototype.toString, regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor == "function" && val.constructor.name || "Object";
}
function isWindow(val) {
  return typeof window < "u" && val === window;
}
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/, NEWLINE_REGEXP = /\n/g, PrettyFormatPluginError = class extends Error {
  constructor(message, stack) {
    super(message), this.stack = stack, this.name = this.constructor.name;
  }
};
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return `${val}n`;
}
function printFunction(val, printFunctionName2) {
  return printFunctionName2 ? `[Function ${val.name || "anonymous"}]` : "[Function]";
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
function printBasicValue(val, printFunctionName2, escapeRegex2, escapeString) {
  if (val === !0 || val === !1)
    return `${val}`;
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  let typeOf2 = typeof val;
  if (typeOf2 === "number")
    return printNumber(val);
  if (typeOf2 === "bigint")
    return printBigInt(val);
  if (typeOf2 === "string")
    return escapeString ? `"${val.replaceAll(/"|\\/g, "\\$&")}"` : `"${val}"`;
  if (typeOf2 === "function")
    return printFunction(val, printFunctionName2);
  if (typeOf2 === "symbol")
    return printSymbol(val);
  let toStringed = toString.call(val);
  return toStringed === "[object WeakMap]" ? "WeakMap {}" : toStringed === "[object WeakSet]" ? "WeakSet {}" : toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]" ? printFunction(val, printFunctionName2) : toStringed === "[object Symbol]" ? printSymbol(val) : toStringed === "[object Date]" ? Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val) : toStringed === "[object Error]" ? printError(val) : toStringed === "[object RegExp]" ? escapeRegex2 ? regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&") : regExpToString.call(val) : val instanceof Error ? printError(val) : null;
}
function printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val))
    return "[Circular]";
  refs = [...refs], refs.push(val);
  let hitMaxDepth = ++depth > config2.maxDepth, min = config2.min;
  if (config2.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON == "function" && !hasCalledToJSON)
    return printer(val.toJSON(), config2, indentation, depth, refs, !0);
  let toStringed = toString.call(val);
  return toStringed === "[object Arguments]" ? hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : isToStringedArrayType(toStringed) ? hitMaxDepth ? `[${val.constructor.name}]` : `${min || !config2.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config2, indentation, depth, refs, printer)}]` : toStringed === "[object Map]" ? hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config2, indentation, depth, refs, printer, " => ")}}` : toStringed === "[object Set]" ? hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config2, indentation, depth, refs, printer)}}` : hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min || !config2.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config2, indentation, depth, refs, printer)}}`;
}
var ErrorPlugin = {
  test: (val) => val && val instanceof Error,
  serialize(val, config2, indentation, depth, refs, printer2) {
    if (refs.includes(val))
      return "[Circular]";
    refs = [...refs, val];
    let hitMaxDepth = ++depth > config2.maxDepth, { message, cause, ...rest } = val, entries = {
      message,
      ...typeof cause < "u" ? { cause } : {},
      ...val instanceof AggregateError ? { errors: val.errors } : {},
      ...rest
    }, name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config2, indentation, depth, refs, printer2)}}`;
  }
};
function isNewPlugin(plugin3) {
  return plugin3.serialize != null;
}
function printPlugin(plugin3, val, config2, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin3) ? plugin3.serialize(val, config2, indentation, depth, refs, printer) : plugin3.print(val, (valChild) => printer(valChild, config2, indentation, depth, refs), (str) => {
      let indentationNext = indentation + config2.indent;
      return indentationNext + str.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, {
      edgeSpacing: config2.spacingOuter,
      min: config2.min,
      spacing: config2.spacingInner
    }, config2.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed != "string")
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  return printed;
}
function findPlugin(plugins2, val) {
  for (let plugin3 of plugins2)
    try {
      if (plugin3.test(val))
        return plugin3;
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  return null;
}
function printer(val, config2, indentation, depth, refs, hasCalledToJSON) {
  let plugin3 = findPlugin(config2.plugins, val);
  if (plugin3 !== null)
    return printPlugin(plugin3, val, config2, indentation, depth, refs);
  let basicResult = printBasicValue(val, config2.printFunctionName, config2.escapeRegex, config2.escapeString);
  return basicResult !== null ? basicResult : printComplexValue(val, config2, indentation, depth, refs, hasCalledToJSON);
}
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME), DEFAULT_OPTIONS = {
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: DEFAULT_THEME
};
function validateOptions(options) {
  for (let key of Object.keys(options))
    if (!Object.prototype.hasOwnProperty.call(DEFAULT_OPTIONS, key))
      throw new Error(`pretty-format: Unknown option "${key}".`);
  if (options.min && options.indent !== void 0 && options.indent !== 0)
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
}
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors, key) => {
    let value = DEFAULT_THEME[key], color = value && u[value];
    if (color && typeof color.close == "string" && typeof color.open == "string")
      colors[key] = color;
    else
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    return colors;
  }, /* @__PURE__ */ Object.create(null));
}
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors, key) => (colors[key] = {
    close: "",
    open: ""
  }, colors), /* @__PURE__ */ Object.create(null));
}
function getPrintFunctionName(options) {
  return options?.printFunctionName ?? DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options) {
  return options?.escapeRegex ?? DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options) {
  return options?.escapeString ?? DEFAULT_OPTIONS.escapeString;
}
function getConfig(options) {
  return {
    callToJSON: options?.callToJSON ?? DEFAULT_OPTIONS.callToJSON,
    colors: options?.highlight ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof options?.compareKeys == "function" || options?.compareKeys === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: options?.min ? "" : createIndent(options?.indent ?? DEFAULT_OPTIONS.indent),
    maxDepth: options?.maxDepth ?? DEFAULT_OPTIONS.maxDepth,
    maxWidth: options?.maxWidth ?? DEFAULT_OPTIONS.maxWidth,
    min: options?.min ?? DEFAULT_OPTIONS.min,
    plugins: options?.plugins ?? DEFAULT_OPTIONS.plugins,
    printBasicPrototype: options?.printBasicPrototype ?? !0,
    printFunctionName: getPrintFunctionName(options),
    spacingInner: options?.min ? " " : `
`,
    spacingOuter: options?.min ? "" : `
`
  };
}
function createIndent(indent) {
  return Array.from({ length: indent + 1 }).join(" ");
}
function format(val, options) {
  if (options && (validateOptions(options), options.plugins)) {
    let plugin3 = findPlugin(options.plugins, val);
    if (plugin3 !== null)
      return printPlugin(plugin3, val, getConfig(options), "", 0, []);
  }
  let basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  return basicResult !== null ? basicResult : printComplexValue(val, getConfig(options), "", 0, []);
}
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin,
  Error: ErrorPlugin
};

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/array.js
init_cjs_shims();

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/helpers.js
init_cjs_shims();
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, truncator = "\u2026";
function colorise(value, styleType) {
  let color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m` : String(value);
}
function normaliseOptions({
  showHidden = !1,
  depth = 2,
  colors = !1,
  customInspect = !0,
  showProxy = !1,
  maxArrayLength = 1 / 0,
  breakLength = 1 / 0,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate3 = 1 / 0,
  stylize = String
} = {}, inspect4) {
  let options = {
    showHidden: !!showHidden,
    depth: Number(depth),
    colors: !!colors,
    customInspect: !!customInspect,
    showProxy: !!showProxy,
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate3),
    seen,
    inspect: inspect4,
    stylize
  };
  return options.colors && (options.stylize = colorise), options;
}
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate(string2, length, tail = truncator) {
  string2 = String(string2);
  let tailLength = tail.length, stringLength = string2.length;
  if (tailLength > length && stringLength > tailLength)
    return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate(string2[end - 1]) && (end = end - 1), `${string2.slice(0, end)}${tail}`;
  }
  return string2;
}
function inspectList(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  let size = list.length;
  if (size === 0)
    return "";
  let originalLength = options.truncate, output = "", peek = "", truncated = "";
  for (let i = 0; i < size; i += 1) {
    let last = i + 1 === list.length, secondToLast = i + 2 === list.length;
    truncated = `${truncator}(${list.length - i})`;
    let value = list[i];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string2 = peek || inspectItem(value, options) + (last ? "" : separator), nextLength = output.length + string2.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
      break;
    if (output += string2, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
function quoteComplexKey(key) {
  return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key, value], options) {
  return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value = options.inspect(value, options), `${key}: ${value}`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/array.js
function inspectArray(array2, options) {
  let nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  let listContents = inspectList(array2, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/typedarray.js
init_cjs_shims();
var getArrayName = (array2) => typeof Buffer == "function" && array2 instanceof Buffer ? "Buffer" : array2[Symbol.toStringTag] ? array2[Symbol.toStringTag] : array2.constructor.name;
function inspectTypedArray(array2, options) {
  let name = getArrayName(array2);
  options.truncate -= name.length + 4;
  let nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i = 0; i < array2.length; i++) {
    let string2 = `${options.stylize(truncate(array2[i], options.truncate), "number")}${i === array2.length - 1 ? "" : ", "}`;
    if (options.truncate -= string2.length, array2[i] !== array2.length && options.truncate <= 3) {
      output += `${truncator}(${array2.length - array2[i] + 1})`;
      break;
    }
    output += string2;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/date.js
init_cjs_shims();
function inspectDate(dateObject, options) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null)
    return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/function.js
init_cjs_shims();
function inspectFunction(func, options) {
  let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
  return name ? options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/map.js
init_cjs_shims();
function inspectMapEntry([key, value], options) {
  return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value = options.inspect(value, options), `${key} => ${value}`;
}
function mapToEntries(map2) {
  let entries = [];
  return map2.forEach((value, key) => {
    entries.push([key, value]);
  }), entries;
}
function inspectMap(map2, options) {
  return map2.size === 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList(mapToEntries(map2), options, inspectMapEntry)} }`);
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/number.js
init_cjs_shims();
var isNaN = Number.isNaN || ((i) => i !== i);
function inspectNumber(number, options) {
  return isNaN(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate(String(number), options.truncate), "number");
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/bigint.js
init_cjs_shims();
function inspectBigInt(number, options) {
  let nums = truncate(number.toString(), options.truncate - 1);
  return nums !== truncator && (nums += "n"), options.stylize(nums, "bigint");
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/regexp.js
init_cjs_shims();
function inspectRegExp(value, options) {
  let flags = value.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/set.js
init_cjs_shims();
function arrayFromSet(set3) {
  let values = [];
  return set3.forEach((value) => {
    values.push(value);
  }), values;
}
function inspectSet(set3, options) {
  return set3.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList(arrayFromSet(set3), options)} }`);
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/string.js
init_cjs_shims();
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, hex = 16, unicodeLength = 4;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
function inspectString(string2, options) {
  return stringEscapeChars.test(string2) && (string2 = string2.replace(stringEscapeChars, escape)), options.stylize(`'${truncate(string2, options.truncate - 2)}'`, "string");
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/symbol.js
init_cjs_shims();
function inspectSymbol(value) {
  return "description" in Symbol.prototype ? value.description ? `Symbol(${value.description})` : "Symbol()" : value.toString();
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/promise.js
init_cjs_shims();
var getPromiseValue = () => "Promise{\u2026}";
try {
  let { getPromiseDetails, kPending, kRejected } = process.binding("util");
  Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue = (value, options) => {
    let [state, innerValue] = getPromiseDetails(value);
    return state === kPending ? "Promise{<pending>}" : `Promise${state === kRejected ? "!" : ""}{${options.inspect(innerValue, options)}}`;
  });
} catch {
}
var promise_default = getPromiseValue;

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/class.js
init_cjs_shims();

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/object.js
init_cjs_shims();
function inspectObject(object2, options) {
  let properties = Object.getOwnPropertyNames(object2), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
  if (properties.length === 0 && symbols.length === 0)
    return "{}";
  if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object2))
    return "[Circular]";
  options.seen.push(object2);
  let propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options, inspectProperty), symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options, inspectProperty);
  options.seen.pop();
  let sep2 = "";
  return propertyContents && symbolContents && (sep2 = ", "), `{ ${propertyContents}${sep2}${symbolContents} }`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/class.js
var toStringTag = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function inspectClass(value, options) {
  let name = "";
  return toStringTag && toStringTag in value && (name = value[toStringTag]), name = name || value.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject(value, options)}`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/arguments.js
init_cjs_shims();
function inspectArguments(args, options) {
  return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList(args, options)} ]`);
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/error.js
init_cjs_shims();
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject2(error, options) {
  let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1), name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message == "string" ? message = truncate(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
    return "[Circular]";
  options.seen.push(error);
  let propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/html.js
init_cjs_shims();
function inspectAttribute([key, value], options) {
  return options.truncate -= 3, value ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
}
function inspectHTMLCollection(collection, options) {
  return inspectList(collection, options, inspectHTML, `
`);
}
function inspectHTML(element, options) {
  let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ")), options.truncate -= propertyContents.length;
  let truncate3 = options.truncate, children = inspectHTMLCollection(element.children, options);
  return children && children.length > truncate3 && (children = `${truncator}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}

// ../../node_modules/.pnpm/loupe@3.1.3/node_modules/loupe/lib/index.js
var symbolsSupported = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect = !1;
try {
  let nodeUtil = __require("util");
  nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : !1;
} catch {
  nodeInspect = !1;
}
var constructorMap = /* @__PURE__ */ new WeakMap(), stringTagMap = {}, baseTypesMap = {
  undefined: (value, options) => options.stylize("undefined", "undefined"),
  null: (value, options) => options.stylize("null", "null"),
  boolean: (value, options) => options.stylize(String(value), "boolean"),
  Boolean: (value, options) => options.stylize(String(value), "boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value, options) => options.stylize("WeakSet{\u2026}", "special"),
  WeakMap: (value, options) => options.stylize("WeakMap{\u2026}", "special"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject2,
  HTMLCollection: inspectHTMLCollection,
  NodeList: inspectHTMLCollection
}, inspectCustom = (value, options, type3) => chaiInspect in value && typeof value[chaiInspect] == "function" ? value[chaiInspect](options) : nodeInspect && nodeInspect in value && typeof value[nodeInspect] == "function" ? value[nodeInspect](options.depth, options) : "inspect" in value && typeof value.inspect == "function" ? value.inspect(options.depth, options) : "constructor" in value && constructorMap.has(value.constructor) ? constructorMap.get(value.constructor)(value, options) : stringTagMap[type3] ? stringTagMap[type3](value, options) : "", toString2 = Object.prototype.toString;
function inspect(value, opts = {}) {
  let options = normaliseOptions(opts, inspect), { customInspect } = options, type3 = value === null ? "null" : typeof value;
  if (type3 === "object" && (type3 = toString2.call(value).slice(8, -1)), type3 in baseTypesMap)
    return baseTypesMap[type3](value, options);
  if (customInspect && value) {
    let output = inspectCustom(value, options, type3);
    if (output)
      return typeof output == "string" ? output : inspect(output, options);
  }
  let proto = value ? Object.getPrototypeOf(value) : !1;
  return proto === Object.prototype || proto === null ? inspectObject(value, options) : value && typeof HTMLElement == "function" && value instanceof HTMLElement ? inspectHTML(value, options) : "constructor" in value ? value.constructor !== Object ? inspectClass(value, options) : inspectObject(value, options) : value === Object(value) ? inspectObject(value, options) : options.stylize(String(value), type3);
}

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins, PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
function stringify(object2, maxDepth = 10, { maxLength, ...options } = {}) {
  let MAX_LENGTH = maxLength ?? 1e4, result;
  try {
    result = format(object2, {
      maxDepth,
      escapeString: !1,
      plugins: PLUGINS,
      ...options
    });
  } catch {
    result = format(object2, {
      callToJSON: !1,
      maxDepth,
      escapeString: !1,
      plugins: PLUGINS,
      ...options
    });
  }
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object2, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength,
    ...options
  }) : result;
}
var formatRegExp = /%[sdjifoOc%]/g;
function format2(...args) {
  if (typeof args[0] != "string") {
    let objects = [];
    for (let i2 = 0; i2 < args.length; i2++)
      objects.push(inspect2(args[i2], {
        depth: 0,
        colors: !1
      }));
    return objects.join(" ");
  }
  let len = args.length, i = 1, template = args[0], str = String(template).replace(formatRegExp, (x) => {
    if (x === "%%")
      return "%";
    if (i >= len)
      return x;
    switch (x) {
      case "%s": {
        let value = args[i++];
        return typeof value == "bigint" ? `${value.toString()}n` : typeof value == "number" && value === 0 && 1 / value < 0 ? "-0" : typeof value == "object" && value !== null ? typeof value.toString == "function" && value.toString !== Object.prototype.toString ? value.toString() : inspect2(value, {
          depth: 0,
          colors: !1
        }) : String(value);
      }
      case "%d": {
        let value = args[i++];
        return typeof value == "bigint" ? `${value.toString()}n` : Number(value).toString();
      }
      case "%i": {
        let value = args[i++];
        return typeof value == "bigint" ? `${value.toString()}n` : Number.parseInt(String(value)).toString();
      }
      case "%f":
        return Number.parseFloat(String(args[i++])).toString();
      case "%o":
        return inspect2(args[i++], {
          showHidden: !0,
          showProxy: !0
        });
      case "%O":
        return inspect2(args[i++]);
      case "%c":
        return i++, "";
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (err) {
          let m2 = err.message;
          if (m2.includes("circular structure") || m2.includes("cyclic structures") || m2.includes("cyclic object"))
            return "[Circular]";
          throw err;
        }
      default:
        return x;
    }
  });
  for (let x = args[i]; i < len; x = args[++i])
    x === null || typeof x != "object" ? str += ` ${x}` : str += ` ${inspect2(x)}`;
  return str;
}
function inspect2(obj, options = {}) {
  return options.truncate === 0 && (options.truncate = Number.POSITIVE_INFINITY), inspect(obj, options);
}
function objDisplay(obj, options = {}) {
  typeof options.truncate > "u" && (options.truncate = 40);
  let str = inspect2(obj, options), type3 = Object.prototype.toString.call(obj);
  if (options.truncate && str.length >= options.truncate)
    if (type3 === "[object Function]") {
      let fn2 = obj;
      return fn2.name ? `[Function: ${fn2.name}]` : "[Function]";
    } else {
      if (type3 === "[object Array]")
        return `[ Array(${obj.length}) ]`;
      if (type3 === "[object Object]") {
        let keys2 = Object.keys(obj);
        return `{ Object (${keys2.length > 2 ? `${keys2.splice(0, 2).join(", ")}, ...` : keys2.join(", ")}) }`;
      } else
        return str;
    }
  return str;
}
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/helpers.js
init_cjs_shims();
function createSimpleStackTrace(options) {
  let { message = "$$stack trace error", stackTraceLimit = 1 } = options || {}, limit = Error.stackTraceLimit, prepareStackTrace = Error.prepareStackTrace;
  Error.stackTraceLimit = stackTraceLimit, Error.prepareStackTrace = (e) => e.stack;
  let stackTrace = new Error(message).stack || "";
  return Error.prepareStackTrace = prepareStackTrace, Error.stackTraceLimit = limit, stackTrace;
}
function assertTypes(value, name, types) {
  let receivedType = typeof value;
  if (!types.includes(receivedType))
    throw new TypeError(`${name} value must be ${types.join(" or ")}, received "${receivedType}"`);
}
function toArray(array2) {
  return array2 == null && (array2 = []), Array.isArray(array2) ? array2 : [array2];
}
function isObject(item) {
  return item != null && typeof item == "object" && !Array.isArray(item);
}
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType2(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
  let collect = typeof collector == "function" ? collector : (key) => collector.add(key);
  Object.getOwnPropertyNames(obj).forEach(collect), Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
  let ownProps = /* @__PURE__ */ new Set();
  return isFinalObj(obj) ? [] : (collectOwnProperties(obj, ownProps), Array.from(ownProps));
}
var defaultCloneOptions = { forceWritable: !1 };
function deepClone(val, options = defaultCloneOptions) {
  return clone(val, /* @__PURE__ */ new WeakMap(), options);
}
function clone(val, seen, options = defaultCloneOptions) {
  let k, out;
  if (seen.has(val))
    return seen.get(val);
  if (Array.isArray(val)) {
    for (out = Array.from({ length: k = val.length }), seen.set(val, out); k--; )
      out[k] = clone(val[k], seen, options);
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val)), seen.set(val, out);
    let props = getOwnProperties(val);
    for (let k2 of props) {
      let descriptor = Object.getOwnPropertyDescriptor(val, k2);
      if (!descriptor)
        continue;
      let cloned = clone(val[k2], seen, options);
      options.forceWritable ? Object.defineProperty(out, k2, {
        enumerable: descriptor.enumerable,
        configurable: !0,
        writable: !0,
        value: cloned
      }) : "get" in descriptor ? Object.defineProperty(out, k2, {
        ...descriptor,
        get() {
          return cloned;
        }
      }) : Object.defineProperty(out, k2, {
        ...descriptor,
        value: cloned
      });
    }
    return out;
  }
  return val;
}
function objectAttr(source, path, defaultValue = void 0) {
  let paths = path.replace(/\[(\d+)\]/g, ".$1").split("."), result = source;
  for (let p3 of paths)
    if (result = new Object(result)[p3], result === void 0)
      return defaultValue;
  return result;
}
function createDefer() {
  let resolve4 = null, reject = null, p3 = new Promise((_resolve, _reject) => {
    resolve4 = _resolve, reject = _reject;
  });
  return p3.resolve = resolve4, p3.reject = reject, p3;
}
function isNegativeNaN(val) {
  if (!Number.isNaN(val))
    return !1;
  let f64 = new Float64Array(1);
  return f64[0] = val, new Uint32Array(f64.buffer)[1] >>> 31 === 1;
}

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/index.js
var jsTokens_1, hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens_1;
  hasRequiredJsTokens = 1;
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  return RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu, LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y, MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, SingleLineComment = /\/\/.*/y, JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y, JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y, JSXText = /[^<>{}]+/y, TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/, Newline = RegExp(LineTerminatorSequence.source), jsTokens_1 = function* (input, { jsx = !1 } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
    for ({ length } = input, lastIndex = 0, lastSignificantToken = "", stack = [
      { tag: "JS" }
    ], braces = [], parenNesting = 0, postfixIncDec = !1; lastIndex < length; ) {
      switch (mode = stack[stack.length - 1], mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)) && (RegularExpressionLiteral.lastIndex = lastIndex, match = RegularExpressionLiteral.exec(input))) {
            lastIndex = RegularExpressionLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };
            continue;
          }
          if (Punctuator.lastIndex = lastIndex, match = Punctuator.exec(input)) {
            switch (punctuator = match[0], nextLastIndex = Punctuator.lastIndex, nextLastSignificantToken = punctuator, punctuator) {
              case "(":
                lastSignificantToken === "?NonExpressionParenKeyword" && stack.push({
                  tag: "JSNonExpressionParen",
                  nesting: parenNesting
                }), parenNesting++, postfixIncDec = !1;
                break;
              case ")":
                parenNesting--, postfixIncDec = !0, mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting && (stack.pop(), nextLastSignificantToken = "?NonExpressionParenEnd", postfixIncDec = !1);
                break;
              case "{":
                Punctuator.lastIndex = 0, isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)), braces.push(isExpression), postfixIncDec = !1;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex, match = Template.exec(input), lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", postfixIncDec = !1, yield {
                        type: "TemplateMiddle",
                        value: match[0]
                      }) : (stack.pop(), postfixIncDec = !0, yield {
                        type: "TemplateTail",
                        value: match[0],
                        closed: match[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack.pop(), lastIndex += 1, lastSignificantToken = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop(), nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = !0;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack.push({ tag: "JSXTag" }), lastIndex += 1, lastSignificantToken = "<", yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = !1;
                break;
              default:
                postfixIncDec = !1;
            }
            lastIndex = nextLastIndex, lastSignificantToken = nextLastSignificantToken, yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          if (Identifier.lastIndex = lastIndex, match = Identifier.exec(input)) {
            switch (lastIndex = Identifier.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                lastSignificantToken !== "." && lastSignificantToken !== "?." && (nextLastSignificantToken = "?NonExpressionParenKeyword");
            }
            lastSignificantToken = nextLastSignificantToken, postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]), yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          if (StringLiteral.lastIndex = lastIndex, match = StringLiteral.exec(input)) {
            lastIndex = StringLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          if (NumericLiteral.lastIndex = lastIndex, match = NumericLiteral.exec(input)) {
            lastIndex = NumericLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          if (Template.lastIndex = lastIndex, match = Template.exec(input)) {
            lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", stack.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            }), postfixIncDec = !1, yield {
              type: "TemplateHead",
              value: match[0]
            }) : (postfixIncDec = !0, yield {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (JSXPunctuator.lastIndex = lastIndex, match = JSXPunctuator.exec(input)) {
            switch (lastIndex = JSXPunctuator.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "<":
                stack.push({ tag: "JSXTag" });
                break;
              case ">":
                stack.pop(), lastSignificantToken === "/" || mode.tag === "JSXTagEnd" ? (nextLastSignificantToken = "?JSX", postfixIncDec = !0) : stack.push({ tag: "JSXChildren" });
                break;
              case "{":
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                }), nextLastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1;
                break;
              case "/":
                lastSignificantToken === "<" && (stack.pop(), stack[stack.length - 1].tag === "JSXChildren" && stack.pop(), stack.push({ tag: "JSXTagEnd" }));
            }
            lastSignificantToken = nextLastSignificantToken, yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          if (JSXIdentifier.lastIndex = lastIndex, match = JSXIdentifier.exec(input)) {
            lastIndex = JSXIdentifier.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          if (JSXString.lastIndex = lastIndex, match = JSXString.exec(input)) {
            lastIndex = JSXString.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (JSXText.lastIndex = lastIndex, match = JSXText.exec(input)) {
            lastIndex = JSXText.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input[lastIndex]) {
            case "<":
              stack.push({ tag: "JSXTag" }), lastIndex++, lastSignificantToken = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              }), lastIndex++, lastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (WhiteSpace.lastIndex = lastIndex, match = WhiteSpace.exec(input)) {
        lastIndex = WhiteSpace.lastIndex, yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      if (LineTerminatorSequence.lastIndex = lastIndex, match = LineTerminatorSequence.exec(input)) {
        lastIndex = LineTerminatorSequence.lastIndex, postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      if (MultiLineComment.lastIndex = lastIndex, match = MultiLineComment.exec(input)) {
        lastIndex = MultiLineComment.lastIndex, Newline.test(match[0]) && (postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      if (SingleLineComment.lastIndex = lastIndex, match = SingleLineComment.exec(input)) {
        lastIndex = SingleLineComment.lastIndex, postfixIncDec = !1, yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex)), lastIndex += firstCodePoint.length, lastSignificantToken = firstCodePoint, postfixIncDec = !1, yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
  }, jsTokens_1;
}
var jsTokensExports = requireJsTokens();
var reservedWords = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
}, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict);
var SAFE_TIMERS_SYMBOL = Symbol("vitest:SAFE_TIMERS");
function getSafeTimers() {
  let { setTimeout: safeSetTimeout, setInterval: safeSetInterval, clearInterval: safeClearInterval, clearTimeout: safeClearTimeout, setImmediate: safeSetImmediate, clearImmediate: safeClearImmediate, queueMicrotask: safeQueueMicrotask } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis, { nextTick: safeNextTick } = globalThis[SAFE_TIMERS_SYMBOL] || globalThis.process || { nextTick: (cb) => cb() };
  return {
    nextTick: safeNextTick,
    setTimeout: safeSetTimeout,
    setInterval: safeSetInterval,
    clearInterval: safeClearInterval,
    clearTimeout: safeClearTimeout,
    setImmediate: safeSetImmediate,
    clearImmediate: safeClearImmediate,
    queueMicrotask: safeQueueMicrotask
  };
}

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/source-map.js
init_cjs_shims();
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  let c = chars.charCodeAt(i);
  intToChar[i] = c, charToInt[c] = i;
}
var UrlType;
(function(UrlType3) {
  UrlType3[UrlType3.Empty = 1] = "Empty", UrlType3[UrlType3.Hash = 2] = "Hash", UrlType3[UrlType3.Query = 3] = "Query", UrlType3[UrlType3.RelativePath = 4] = "RelativePath", UrlType3[UrlType3.AbsolutePath = 5] = "AbsolutePath", UrlType3[UrlType3.SchemeRelative = 6] = "SchemeRelative", UrlType3[UrlType3.Absolute = 7] = "Absolute";
})(UrlType || (UrlType = {}));
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  return input && input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r2) => r2.toUpperCase());
}
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd() {
  return typeof process < "u" && typeof process.cwd == "function" ? process.cwd().replace(/\\/g, "/") : "/";
}
var resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "", resolvedAbsolute = !1;
  for (let index2 = arguments_.length - 1; index2 >= -1 && !resolvedAbsolute; index2--) {
    let path = index2 >= 0 ? arguments_[index2] : cwd();
    !path || path.length === 0 || (resolvedPath = `${path}/${resolvedPath}`, resolvedAbsolute = isAbsolute(path));
  }
  return resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute), resolvedAbsolute && !isAbsolute(resolvedPath) ? `/${resolvedPath}` : resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, char = null;
  for (let index2 = 0; index2 <= path.length; ++index2) {
    if (index2 < path.length)
      char = path[index2];
    else {
      if (char === "/")
        break;
      char = "/";
    }
    if (char === "/") {
      if (!(lastSlash === index2 - 1 || dots === 1)) if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            let lastSlashIndex = res.lastIndexOf("/");
            lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = index2, dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "", lastSegmentLength = 0, lastSlash = index2, dots = 0;
            continue;
          }
        }
        allowAboveRoot && (res += res.length > 0 ? "/.." : "..", lastSegmentLength = 2);
      } else
        res.length > 0 ? res += `/${path.slice(lastSlash + 1, index2)}` : res = path.slice(lastSlash + 1, index2), lastSegmentLength = index2 - lastSlash - 1;
      lastSlash = index2, dots = 0;
    } else char === "." && dots !== -1 ? ++dots : dots = -1;
  }
  return res;
}
var isAbsolute = function(p3) {
  return _IS_ABSOLUTE_RE.test(p3);
}, CHROME_IE_STACK_REGEXP = /^\s*at .*(?:\S:\d+|\(native\))/m, SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\[native code\])?$/;
function extractLocation(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike];
  let parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/^\(|\)$/g, ""));
  if (!parts)
    return [urlLike];
  let url = parts[1];
  if (url.startsWith("async ") && (url = url.slice(6)), url.startsWith("http:") || url.startsWith("https:")) {
    let urlObj = new URL(url);
    urlObj.searchParams.delete("import"), urlObj.searchParams.delete("browserv"), url = urlObj.pathname + urlObj.hash + urlObj.search;
  }
  if (url.startsWith("/@fs/")) {
    let isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
    url = url.slice(isWindows ? 5 : 4);
  }
  return [
    url,
    parts[2] || void 0,
    parts[3] || void 0
  ];
}
function parseSingleFFOrSafariStack(raw) {
  let line = raw.trim();
  if (SAFARI_NATIVE_CODE_REGEXP.test(line) || (line.includes(" > eval") && (line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), !line.includes("@") && !line.includes(":")))
    return null;
  let functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/, matches = line.match(functionNameRegex), functionName2 = matches && matches[1] ? matches[1] : void 0, [url, lineNumber, columnNumber] = extractLocation(line.replace(functionNameRegex, ""));
  return !url || !lineNumber || !columnNumber ? null : {
    file: url,
    method: functionName2 || "",
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
function parseSingleStack(raw) {
  let line = raw.trim();
  return CHROME_IE_STACK_REGEXP.test(line) ? parseSingleV8Stack(line) : parseSingleFFOrSafariStack(line);
}
function parseSingleV8Stack(raw) {
  let line = raw.trim();
  if (!CHROME_IE_STACK_REGEXP.test(line))
    return null;
  line.includes("(eval ") && (line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
  let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, ""), location = sanitizedLine.match(/ (\(.+\)$)/);
  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
  let [url, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine), method = location && sanitizedLine || "", file = url && ["eval", "<anonymous>"].includes(url) ? void 0 : url;
  return !file || !lineNumber || !columnNumber ? null : (method.startsWith("async ") && (method = method.slice(6)), file.startsWith("file://") && (file = file.slice(7)), file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve(file), method && (method = method.replace(/__vite_ssr_import_\d+__\./g, "")), {
    method,
    file,
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  });
}

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/error.js
init_cjs_shims();

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/diff.js
init_cjs_shims();
var DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0, Diff = class {
  0;
  1;
  constructor(op, text) {
    this[0] = op, this[1] = text;
  }
};
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerstart = 0;
  for (; pointermin < pointermid; )
    text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid) ? (pointermin = pointermid, pointerstart = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
}
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0, pointermax = Math.min(text1.length, text2.length), pointermid = pointermax, pointerend = 0;
  for (; pointermin < pointermid; )
    text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend) ? (pointermin = pointermid, pointerend = pointermin) : pointermax = pointermid, pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  return pointermid;
}
function diff_commonOverlap_(text1, text2) {
  let text1_length = text1.length, text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  text1_length > text2_length ? text1 = text1.substring(text1_length - text2_length) : text1_length < text2_length && (text2 = text2.substring(0, text1_length));
  let text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0, length = 1;
  for (; ; ) {
    let pattern = text1.substring(text_length - length), found2 = text2.indexOf(pattern);
    if (found2 === -1)
      return best;
    length += found2, (found2 === 0 || text1.substring(text_length - length) === text2.substring(0, length)) && (best = length, length++);
  }
}
function diff_cleanupSemantic(diffs) {
  let changes = !1, equalities = [], equalitiesLength = 0, lastEquality = null, pointer = 0, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0;
  for (; pointer < diffs.length; )
    diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, length_insertions1 = length_insertions2, length_deletions1 = length_deletions2, length_insertions2 = 0, length_deletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? length_insertions2 += diffs[pointer][1].length : length_deletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality)), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, length_insertions1 = 0, length_deletions1 = 0, length_insertions2 = 0, length_deletions2 = 0, lastEquality = null, changes = !0)), pointer++;
  for (changes && diff_cleanupMerge(diffs), diff_cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      let deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlap_length1 = diff_commonOverlap_(deletion, insertion), overlap_length2 = diff_commonOverlap_(insertion, deletion);
      overlap_length1 >= overlap_length2 ? (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) && (diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1))), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1), diffs[pointer + 1][1] = insertion.substring(overlap_length1), pointer++) : (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) && (diffs.splice(pointer, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2))), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlap_length2), pointer++), pointer++;
    }
    pointer++;
  }
}
var nonAlphaNumericRegex_ = /[^a-z0-9]/i, whitespaceRegex_ = /\s/, linebreakRegex_ = /[\r\n]/, blanklineEndRegex_ = /\n\r?\n$/, blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer = 1;
  for (; pointer < diffs.length - 1; ) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1], commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        let commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        let score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
    }
    pointer++;
  }
}
function diff_cleanupMerge(diffs) {
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer = 0, count_delete = 0, count_insert = 0, text_delete = "", text_insert = "", commonlength;
  for (; pointer < diffs.length; )
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++, text_insert += diffs[pointer][1], pointer++;
        break;
      case DIFF_DELETE:
        count_delete++, text_delete += diffs[pointer][1], pointer++;
        break;
      case DIFF_EQUAL:
        count_delete + count_insert > 1 ? (count_delete !== 0 && count_insert !== 0 && (commonlength = diff_commonPrefix(text_insert, text_delete), commonlength !== 0 && (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL ? diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength) : (diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength))), pointer++), text_insert = text_insert.substring(commonlength), text_delete = text_delete.substring(commonlength)), commonlength = diff_commonSuffix(text_insert, text_delete), commonlength !== 0 && (diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1], text_insert = text_insert.substring(0, text_insert.length - commonlength), text_delete = text_delete.substring(0, text_delete.length - commonlength))), pointer -= count_delete + count_insert, diffs.splice(pointer, count_delete + count_insert), text_delete.length && (diffs.splice(pointer, 0, new Diff(DIFF_DELETE, text_delete)), pointer++), text_insert.length && (diffs.splice(pointer, 0, new Diff(DIFF_INSERT, text_insert)), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, count_insert = 0, count_delete = 0, text_delete = "", text_insert = "";
        break;
    }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let changes = !1;
  for (pointer = 1; pointer < diffs.length - 1; )
    diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), changes = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), changes = !0)), pointer++;
  changes && diff_cleanupMerge(diffs);
}
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two)
    return 6;
  let char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_), lineBreak1 = whitespace1 && char1.match(linebreakRegex_), lineBreak2 = whitespace2 && char2.match(linebreakRegex_), blankLine1 = lineBreak1 && one.match(blanklineEndRegex_), blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
}
var NO_DIFF_MESSAGE = "Compared values have no visual difference.", SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.", build = {}, hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1, Object.defineProperty(build, "__esModule", {
    value: !0
  }), build.default = diffSequence;
  let pkg = "diff-sequences", NOT_YET_SET = 0, countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    for (; aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex); )
      aIndex += 1, bIndex += 1, nCommon += 1;
    return nCommon;
  }, countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    for (; aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex); )
      aIndex -= 1, bIndex -= 1, nCommon += 1;
    return nCommon;
  }, extendPathsF = (d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0, kF = -d, aFirst = aIndexesF[iF], aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF(
      aFirst + 1,
      aEnd,
      bF + aFirst - kF + 1,
      bEnd,
      isCommon
    );
    let nF = d < iMaxF ? d : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d && aIndexPrev1 < aIndexesF[iF])
        aFirst = aIndexesF[iF];
      else if (aFirst = aIndexPrev1 + 1, aEnd <= aFirst)
        return iF - 1;
      aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  }, extendPathsR = (d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0, kR = d, aFirst = aIndexesR[iR], aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bR + aFirst - kR - 1,
      isCommon
    );
    let nR = d < iMaxR ? d : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d && aIndexesR[iR] < aIndexPrev1)
        aFirst = aIndexesR[iR];
      else if (aFirst = aIndexPrev1 - 1, aFirst < aStart)
        return iR - 1;
      aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aFirst - countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
    }
    return iMaxR;
  }, extendOverlappablePathsF = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bF = bStart - aStart, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapF = -baDeltaLength - (d - 1), kMaxOverlapF = -baDeltaLength + (d - 1), aIndexPrev1 = NOT_YET_SET, nF = d < iMaxF ? d : iMaxF;
    for (let iF = 0, kF = -d; iF <= nF; iF += 1, kF += 2) {
      let insert = iF === 0 || iF !== d && aIndexPrev1 < aIndexesF[iF], aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev + 1, bFirst = bF + aFirst - kF, nCommonF = countCommonItemsF(
        aFirst + 1,
        aEnd,
        bFirst + 1,
        bEnd,
        isCommon
      ), aLast = aFirst + nCommonF;
      if (aIndexPrev1 = aIndexesF[iF], aIndexesF[iF] = aLast, kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        let iR = (d - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          let bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1), nCommonR = countCommonItemsR(
            aStart,
            aLastPrev,
            bStart,
            bLastPrev,
            isCommon
          ), aIndexPrevFirst = aLastPrev - nCommonR, bIndexPrevFirst = bLastPrev - nCommonR, aEndPreceding = aIndexPrevFirst + 1, bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d - 1, d - 1 === aEndPreceding + bEndPreceding - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aEndPreceding, division.bEndPreceding = bEndPreceding), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aEndPreceding, division.bCommonPreceding = bEndPreceding), division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aFirst + 1, division.bCommonFollowing = bFirst + 1);
          let aStartFollowing = aLast + 1, bStartFollowing = bFirst + nCommonF + 1;
          return division.nChangeFollowing = d - 1, d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing), !0;
        }
      }
    }
    return !1;
  }, extendOverlappablePathsR = (d, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    let bR = bEnd - aEnd, aLength = aEnd - aStart, baDeltaLength = bEnd - bStart - aLength, kMinOverlapR = baDeltaLength - d, kMaxOverlapR = baDeltaLength + d, aIndexPrev1 = NOT_YET_SET, nR = d < iMaxR ? d : iMaxR;
    for (let iR = 0, kR = d; iR <= nR; iR += 1, kR -= 2) {
      let insert = iR === 0 || iR !== d && aIndexesR[iR] < aIndexPrev1, aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1, aFirst = insert ? aLastPrev : aLastPrev - 1, bFirst = bR + aFirst - kR, nCommonR = countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bFirst - 1,
        isCommon
      ), aLast = aFirst - nCommonR;
      if (aIndexPrev1 = aIndexesR[iR], aIndexesR[iR] = aLast, kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        let iF = (d + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          let bLast = bFirst - nCommonR;
          if (division.nChangePreceding = d, d === aLast + bLast - aStart - bStart ? (division.aEndPreceding = aStart, division.bEndPreceding = bStart) : (division.aEndPreceding = aLast, division.bEndPreceding = bLast), division.nCommonPreceding = nCommonR, nCommonR !== 0 && (division.aCommonPreceding = aLast, division.bCommonPreceding = bLast), division.nChangeFollowing = d - 1, d === 1)
            division.nCommonFollowing = 0, division.aStartFollowing = aEnd, division.bStartFollowing = bEnd;
          else {
            let bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1), nCommonF = countCommonItemsF(
              aLastPrev,
              aEnd,
              bLastPrev,
              bEnd,
              isCommon
            );
            division.nCommonFollowing = nCommonF, nCommonF !== 0 && (division.aCommonFollowing = aLastPrev, division.bCommonFollowing = bLastPrev);
            let aStartFollowing = aLastPrev + nCommonF, bStartFollowing = bLastPrev + nCommonF;
            d - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing ? (division.aStartFollowing = aEnd, division.bStartFollowing = bEnd) : (division.aStartFollowing = aStartFollowing, division.bStartFollowing = bStartFollowing);
          }
          return !0;
        }
      }
    }
    return !1;
  }, divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    let bF = bStart - aStart, bR = bEnd - aEnd, aLength = aEnd - aStart, bLength = bEnd - bStart, baDeltaLength = bLength - aLength, iMaxF = aLength, iMaxR = aLength;
    if (aIndexesF[0] = aStart - 1, aIndexesR[0] = aEnd, baDeltaLength % 2 === 0) {
      let dMin = (nChange || baDeltaLength) / 2, dMax = (aLength + bLength) / 2;
      for (let d = 1; d <= dMax; d += 1)
        if (iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d < dMin)
          iMaxR = extendPathsR(d, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsR(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        )
          return;
    } else {
      let dMin = ((nChange || baDeltaLength) + 1) / 2, dMax = (aLength + bLength + 1) / 2, d = 1;
      for (iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF), d += 1; d <= dMax; d += 1)
        if (iMaxR = extendPathsR(
          d - 1,
          aStart,
          bStart,
          bR,
          isCommon,
          aIndexesR,
          iMaxR
        ), d < dMin)
          iMaxF = extendPathsF(d, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsF(
            d,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        )
          return;
    }
    throw new Error(
      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
    );
  }, findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      if (transposed = !transposed, transposed && callbacks.length === 1) {
        let { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = {
          foundSubsequence: (nCommon, bCommon, aCommon) => {
            foundSubsequence2(nCommon, aCommon, bCommon);
          },
          isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex)
        };
      }
      let tStart = aStart, tEnd = aEnd;
      aStart = bStart, aEnd = bEnd, bStart = tStart, bEnd = tEnd;
    }
    let { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide(
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division
    );
    let {
      nChangePreceding,
      aEndPreceding,
      bEndPreceding,
      nCommonPreceding,
      aCommonPreceding,
      bCommonPreceding,
      nCommonFollowing,
      aCommonFollowing,
      bCommonFollowing,
      nChangeFollowing,
      aStartFollowing,
      bStartFollowing
    } = division;
    aStart < aEndPreceding && bStart < bEndPreceding && findSubsequences(
      nChangePreceding,
      aStart,
      aEndPreceding,
      bStart,
      bEndPreceding,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division
    ), nCommonPreceding !== 0 && foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding), nCommonFollowing !== 0 && foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing), aStartFollowing < aEnd && bStartFollowing < bEnd && findSubsequences(
      nChangeFollowing,
      aStartFollowing,
      aEnd,
      bStartFollowing,
      bEnd,
      transposed,
      callbacks,
      aIndexesF,
      aIndexesR,
      division
    );
  }, validateLength = (name, arg) => {
    if (typeof arg != "number")
      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    if (!Number.isSafeInteger(arg))
      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    if (arg < 0)
      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
  }, validateCallback = (name, arg) => {
    let type3 = typeof arg;
    if (type3 !== "function")
      throw new TypeError(`${pkg}: ${name} typeof ${type3} is not a function`);
  };
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength("aLength", aLength), validateLength("bLength", bLength), validateCallback("isCommon", isCommon), validateCallback("foundSubsequence", foundSubsequence);
    let nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0 && foundSubsequence(nCommonF, 0, 0), aLength !== nCommonF || bLength !== nCommonF) {
      let aStart = nCommonF, bStart = nCommonF, nCommonR = countCommonItemsR(
        aStart,
        aLength - 1,
        bStart,
        bLength - 1,
        isCommon
      ), aEnd = aLength - nCommonR, bEnd = bLength - nCommonR, nCommonFR = nCommonF + nCommonR;
      aLength !== nCommonFR && bLength !== nCommonFR && findSubsequences(
        0,
        aStart,
        aEnd,
        bStart,
        bEnd,
        !1,
        [
          {
            foundSubsequence,
            isCommon
          }
        ],
        [NOT_YET_SET],
        [NOT_YET_SET],
        {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        }
      ), nCommonR !== 0 && foundSubsequence(nCommonR, aEnd, bEnd);
    }
  }
  return build;
}
var buildExports = requireBuild(), diffSequences = /* @__PURE__ */ getDefaultExportFromCjs2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options) {
  let iLength = diffs.length, nContextLines = options.contextLines, nContextLines2 = nContextLines + nContextLines, jLength = iLength, hasExcessAtStartOrEnd = !1, nExcessesBetweenChanges = 0, i = 0;
  for (; i !== iLength; ) {
    let iStart = i;
    for (; i !== iLength && diffs[i][0] === DIFF_EQUAL; )
      i += 1;
    if (iStart !== i)
      if (iStart === 0)
        i > nContextLines && (jLength -= i - nContextLines, hasExcessAtStartOrEnd = !0);
      else if (i === iLength) {
        let n = i - iStart;
        n > nContextLines && (jLength -= n - nContextLines, hasExcessAtStartOrEnd = !0);
      } else {
        let n = i - iStart;
        n > nContextLines2 && (jLength -= n - nContextLines2, nExcessesBetweenChanges += 1);
      }
    for (; i !== iLength && diffs[i][0] !== DIFF_EQUAL; )
      i += 1;
  }
  let hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  nExcessesBetweenChanges !== 0 ? jLength += nExcessesBetweenChanges + 1 : hasExcessAtStartOrEnd && (jLength += 1);
  let jLast = jLength - 1, lines = [], jPatchMark = 0;
  hasPatch && lines.push("");
  let aStart = 0, bStart = 0, aEnd = 0, bEnd = 0, pushCommonLine = (line) => {
    let j = lines.length;
    lines.push(printCommonLine(line, j === 0 || j === jLast, options)), aEnd += 1, bEnd += 1;
  }, pushDeleteLine = (line) => {
    let j = lines.length;
    lines.push(printDeleteLine(line, j === 0 || j === jLast, options)), aEnd += 1;
  }, pushInsertLine = (line) => {
    let j = lines.length;
    lines.push(printInsertLine(line, j === 0 || j === jLast, options)), bEnd += 1;
  };
  for (i = 0; i !== iLength; ) {
    let iStart = i;
    for (; i !== iLength && diffs[i][0] === DIFF_EQUAL; )
      i += 1;
    if (iStart !== i)
      if (iStart === 0) {
        i > nContextLines && (iStart = i - nContextLines, aStart = iStart, bStart = iStart, aEnd = aStart, bEnd = bStart);
        for (let iCommon = iStart; iCommon !== i; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else if (i === iLength) {
        let iEnd = i - iStart > nContextLines ? iStart + nContextLines : i;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
          pushCommonLine(diffs[iCommon][1]);
      } else {
        let nCommon = i - iStart;
        if (nCommon > nContextLines2) {
          let iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options), jPatchMark = lines.length, lines.push("");
          let nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit, bStart = bEnd + nOmit, aEnd = aStart, bEnd = bStart;
          for (let iCommon = i - nContextLines; iCommon !== i; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
        } else
          for (let iCommon = iStart; iCommon !== i; iCommon += 1)
            pushCommonLine(diffs[iCommon][1]);
      }
    for (; i !== iLength && diffs[i][0] === DIFF_DELETE; )
      pushDeleteLine(diffs[i][1]), i += 1;
    for (; i !== iLength && diffs[i][0] === DIFF_INSERT; )
      pushInsertLine(diffs[i][1]), i += 1;
  }
  return hasPatch && (lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options)), lines.join(`
`);
}
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff2, i, diffs2) => {
    let line = diff2[1], isFirstOrLast = i === 0 || i === diffs2.length - 1;
    switch (diff2[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join(`
`);
}
var noColor = (string2) => string2, DIFF_CONTEXT_DEFAULT = 5, DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: u.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: u.red,
    bIndicator: "+",
    changeColor: u.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: u.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: !1,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: u.yellow,
    printBasicPrototype: !1,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys == "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
  return typeof contextLines == "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  };
}
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
  let a3 = 0, b = 0;
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        a3 += 1;
        break;
      case DIFF_INSERT:
        b += 1;
        break;
    }
  }), {
    a: a3,
    b
  };
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines)
    return "";
  let aRest = "", bRest = "";
  if (includeChangeCounts) {
    let aCount = String(changeCounts.a), bCount = String(changeCounts.b), baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length, aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff)), bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff)), baCountLengthDiff = bCount.length - aCount.length, aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff)), bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`, bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  let a3 = `${aIndicator} ${aAnnotation}${aRest}`, b = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a3)}
${bColor(b)}

`;
}
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options) {
  let normalizedOptions = normalizeDiffOptions(options), [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare) && (aLinesDisplay = [], aLinesCompare = []), isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare) && (bLinesDisplay = [], bLinesCompare = []), aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length)
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  let [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options), aIndex = 0, bIndex = 0;
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        diff2[1] = aLinesDisplay[aIndex], aIndex += 1;
        break;
      case DIFF_INSERT:
        diff2[1] = bLinesDisplay[bIndex], bIndex += 1;
        break;
      default:
        diff2[1] = bLinesDisplay[bIndex], aIndex += 1, bIndex += 1;
    }
  }), printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
function diffLinesRaw(aLines, bLines, options) {
  let truncate3 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = truncate3 ? Math.min(aLines.length, truncateThreshold) : aLines.length, bLength = truncate3 ? Math.min(bLines.length, truncateThreshold) : bLines.length, truncated = aLength !== aLines.length || bLength !== bLines.length, isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2], diffs = [], aIndex = 0, bIndex = 0;
  for (diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1)
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    for (; bIndex !== bCommon; bIndex += 1)
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1)
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
  }); aIndex !== aLength; aIndex += 1)
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  for (; bIndex !== bLength; bIndex += 1)
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  return [diffs, truncated];
}
function getType3(value) {
  if (value === void 0)
    return "undefined";
  if (value === null)
    return "null";
  if (Array.isArray(value))
    return "array";
  if (typeof value == "boolean")
    return "boolean";
  if (typeof value == "function")
    return "function";
  if (typeof value == "number")
    return "number";
  if (typeof value == "string")
    return "string";
  if (typeof value == "bigint")
    return "bigint";
  if (typeof value == "object") {
    if (value != null) {
      if (value.constructor === RegExp)
        return "regexp";
      if (value.constructor === Map)
        return "map";
      if (value.constructor === Set)
        return "set";
      if (value.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof value == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${value}`);
}
function getNewLineSymbol(string2) {
  return string2.includes(`\r
`) ? `\r
` : `
`;
}
function diffStrings(a3, b, options) {
  let truncate3 = options?.truncateThreshold ?? !1, truncateThreshold = Math.max(Math.floor(options?.truncateThreshold ?? 0), 0), aLength = a3.length, bLength = b.length;
  if (truncate3) {
    let aMultipleLines = a3.includes(`
`), bMultipleLines = b.includes(`
`), aNewLineSymbol = getNewLineSymbol(a3), bNewLineSymbol = getNewLineSymbol(b), _a = aMultipleLines ? `${a3.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a3, _b = bMultipleLines ? `${b.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b;
    aLength = _a.length, bLength = _b.length;
  }
  let truncated = aLength !== a3.length || bLength !== b.length, isCommon = (aIndex2, bIndex2) => a3[aIndex2] === b[bIndex2], aIndex = 0, bIndex = 0, diffs = [];
  return diffSequences(aLength, bLength, isCommon, (nCommon, aCommon, bCommon) => {
    aIndex !== aCommon && diffs.push(new Diff(DIFF_DELETE, a3.slice(aIndex, aCommon))), bIndex !== bCommon && diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex, bCommon))), aIndex = aCommon + nCommon, bIndex = bCommon + nCommon, diffs.push(new Diff(DIFF_EQUAL, b.slice(bCommon, bIndex)));
  }), aIndex !== aLength && diffs.push(new Diff(DIFF_DELETE, a3.slice(aIndex))), bIndex !== bLength && diffs.push(new Diff(DIFF_INSERT, b.slice(bIndex))), [diffs, truncated];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
}
var ChangeBuffer = class {
  op;
  line;
  lines;
  changeColor;
  constructor(op, changeColor) {
    this.op = op, this.line = [], this.lines = [], this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1])), this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(diff2) {
    this.line.push(diff2);
  }
  // Main input to buffer.
  align(diff2) {
    let string2 = diff2[1];
    if (string2.includes(`
`)) {
      let substrings = string2.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i) => {
        i < iLast ? (this.pushSubstring(substring), this.pushLine()) : substring.length !== 0 && this.pushSubstring(substring);
      });
    } else
      this.pushDiff(diff2);
  }
  // Output from buffer.
  moveLinesTo(lines) {
    this.isLineEmpty() || this.pushLine(), lines.push(...this.lines), this.lines.length = 0;
  }
}, CommonBuffer = class {
  deleteBuffer;
  insertBuffer;
  lines;
  constructor(deleteBuffer, insertBuffer) {
    this.deleteBuffer = deleteBuffer, this.insertBuffer = insertBuffer, this.lines = [];
  }
  pushDiffCommonLine(diff2) {
    this.lines.push(diff2);
  }
  pushDiffChangeLines(diff2) {
    let isDiffEmpty = diff2[1].length === 0;
    (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) && this.deleteBuffer.pushDiff(diff2), (!isDiffEmpty || this.insertBuffer.isLineEmpty()) && this.insertBuffer.pushDiff(diff2);
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines), this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff2) {
    let op = diff2[0], string2 = diff2[1];
    if (string2.includes(`
`)) {
      let substrings = string2.split(`
`), iLast = substrings.length - 1;
      substrings.forEach((substring, i) => {
        if (i === 0) {
          let subdiff = new Diff(op, substring);
          this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty() ? (this.flushChangeLines(), this.pushDiffCommonLine(subdiff)) : (this.pushDiffChangeLines(subdiff), this.flushChangeLines());
        } else i < iLast ? this.pushDiffCommonLine(new Diff(op, substring)) : substring.length !== 0 && this.pushDiffChangeLines(new Diff(op, substring));
      });
    } else
      this.pushDiffChangeLines(diff2);
  }
  // Output from buffer.
  getLines() {
    return this.flushChangeLines(), this.lines;
  }
};
function getAlignedDiffs(diffs, changeColor) {
  let deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor), insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor), commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  return diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff2);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff2);
        break;
      default:
        commonBuffer.align(diff2);
    }
  }), commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    let iLast = diffs.length - 1;
    return diffs.some((diff2, i) => diff2[0] === DIFF_EQUAL && (i !== iLast || diff2[1] !== `
`));
  }
  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
}
function diffStringsUnified(a3, b, options) {
  if (a3 !== b && a3.length !== 0 && b.length !== 0) {
    let isMultiline = a3.includes(`
`) || b.includes(`
`), [diffs, truncated] = diffStringsRaw(isMultiline ? `${a3}
` : a3, isMultiline ? `${b}
` : b, !0, options);
    if (hasCommonDiff(diffs, isMultiline)) {
      let optionsNormalized = normalizeDiffOptions(options), lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a3.split(`
`), b.split(`
`), options);
}
function diffStringsRaw(a3, b, cleanup, options) {
  let [diffs, truncated] = diffStrings(a3, b, options);
  return cleanup && diff_cleanupSemantic(diffs), [diffs, truncated];
}
function getCommonMessage(message, options) {
  let { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins, PLUGINS2 = [
  ReactTestComponent2,
  ReactElement2,
  DOMElement2,
  DOMCollection2,
  Immutable2,
  AsymmetricMatcher2,
  plugins.Error
], FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS2
}, FALLBACK_FORMAT_OPTIONS = {
  callToJSON: !1,
  maxDepth: 8,
  plugins: PLUGINS2
};
function diff(a3, b, options) {
  if (Object.is(a3, b))
    return "";
  let aType = getType3(a3), expectedType = aType, omitDifference = !1;
  if (aType === "object" && typeof a3.asymmetricMatch == "function") {
    if (a3.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof a3.getExpectedType != "function")
      return;
    expectedType = a3.getExpectedType(), omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b)) {
    let truncate3 = function(s2) {
      return s2.length <= MAX_LENGTH ? s2 : `${s2.slice(0, MAX_LENGTH)}...`;
    }, { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options), formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options), aDisplay = format(a3, formatOptions), bDisplay = format(b, formatOptions), MAX_LENGTH = 1e5;
    aDisplay = truncate3(aDisplay), bDisplay = truncate3(bDisplay);
    let aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`, bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (!omitDifference)
    switch (aType) {
      case "string":
        return diffLinesUnified(a3.split(`
`), b.split(`
`), options);
      case "boolean":
      case "number":
        return comparePrimitive(a3, b, options);
      case "map":
        return compareObjects(sortMap(a3), sortMap(b), options);
      case "set":
        return compareObjects(sortSet(a3), sortSet(b), options);
      default:
        return compareObjects(a3, b, options);
    }
}
function comparePrimitive(a3, b, options) {
  let aFormat = format(a3, FORMAT_OPTIONS), bFormat = format(b, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split(`
`), bFormat.split(`
`), options);
}
function sortMap(map2) {
  return new Map(Array.from(map2.entries()).sort());
}
function sortSet(set3) {
  return new Set(Array.from(set3.values()).sort());
}
function compareObjects(a3, b, options) {
  let difference, hasThrown = !1;
  try {
    let formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a3, b, formatOptions, options);
  } catch {
    hasThrown = !0;
  }
  let noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  if (difference === void 0 || difference === noDiffMessage) {
    let formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a3, b, formatOptions, options), difference !== noDiffMessage && !hasThrown && (difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`);
  }
  return difference;
}
function getFormatOptions(formatOptions, options) {
  let { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
  return {
    ...formatOptions,
    compareKeys,
    printBasicPrototype,
    maxDepth: maxDepth ?? formatOptions.maxDepth
  };
}
function getObjectsDifference(a3, b, formatOptions, options) {
  let formatOptionsZeroIndent = {
    ...formatOptions,
    indent: 0
  }, aCompare = format(a3, formatOptionsZeroIndent), bCompare = format(b, formatOptionsZeroIndent);
  if (aCompare === bCompare)
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  {
    let aDisplay = format(a3, formatOptions), bDisplay = format(b, formatOptions);
    return diffLinesUnified2(aDisplay.split(`
`), bDisplay.split(`
`), aCompare.split(`
`), bCompare.split(`
`), options);
  }
}
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  return getType2(data) === "Object" && typeof data.asymmetricMatch == "function";
}
function isReplaceable(obj1, obj2) {
  let obj1Type = getType2(obj1), obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(received, expected, options) {
  let { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
  if (typeof expected == "string" && typeof received == "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes(`
`) || received.includes(`
`))
      return diffStringsUnified(expected, received, options);
    let [diffs] = diffStringsRaw(expected, received, !0), hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL), printLabel = getLabelPrinter(aAnnotation, bAnnotation), expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2)), receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
    return `${expectedLine}
${receivedLine}`;
  }
  let clonedExpected = deepClone(expected, { forceWritable: !0 }), clonedReceived = deepClone(received, { forceWritable: !0 }), { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
  return diff(replacedExpected, replacedActual, options);
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  return actual instanceof Error && expected instanceof Error && typeof actual.cause < "u" && typeof expected.cause > "u" ? (delete actual.cause, {
    replacedActual: actual,
    replacedExpected: expected
  }) : isReplaceable(actual, expected) ? actualReplaced.has(actual) || expectedReplaced.has(expected) ? {
    replacedActual: actual,
    replacedExpected: expected
  } : (actualReplaced.add(actual), expectedReplaced.add(expected), getOwnProperties(expected).forEach((key) => {
    let expectedValue = expected[key], actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue))
      expectedValue.asymmetricMatch(actualValue) && (actual[key] = expectedValue);
    else if (isAsymmetricMatcher(actualValue))
      actualValue.asymmetricMatch(expectedValue) && (expected[key] = actualValue);
    else if (isReplaceable(actualValue, expectedValue)) {
      let replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual, expected[key] = replaced.replacedExpected;
    }
  }), {
    replacedActual: actual,
    replacedExpected: expected
  }) : {
    replacedActual: actual,
    replacedExpected: expected
  };
}
function getLabelPrinter(...strings) {
  let maxLength = strings.reduce((max, string2) => string2.length > max ? string2.length : max, 0);
  return (string2) => `${string2}: ${" ".repeat(maxLength - string2.length)}`;
}
var SPACE_SYMBOL = "\xB7";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
function printReceived(object2) {
  return u.red(replaceTrailingSpaces(stringify(object2)));
}
function printExpected(value) {
  return u.green(replaceTrailingSpaces(stringify(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? u.inverse(diff2[1]) : diff2[1] : ""), "");
}

// ../../node_modules/.pnpm/@vitest+utils@3.2.1/node_modules/@vitest/utils/dist/error.js
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@", IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v) {
  return v && (v[IS_COLLECTION_SYMBOL] || v[IS_RECORD_SYMBOL]);
}
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  return err instanceof Error ? `<unserializable>: ${err.message}` : typeof err == "string" ? `<unserializable>: ${err}` : "<unserializable>";
}
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val == "string")
    return val;
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON == "function") {
    let jsonValue = val.toJSON();
    return jsonValue && jsonValue !== val && typeof jsonValue == "object" && (typeof val.message == "string" && safe(() => jsonValue.message ?? (jsonValue.message = val.message)), typeof val.stack == "string" && safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack)), typeof val.name == "string" && safe(() => jsonValue.name ?? (jsonValue.name = val.name)), val.cause != null && safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)))), serializeValue(jsonValue, seen);
  }
  if (typeof val == "function")
    return `Function<${val.name || "anonymous"}>`;
  if (typeof val == "symbol")
    return val.toString();
  if (typeof val != "object")
    return val;
  if (isImmutable(val))
    return serializeValue(val.toJSON(), seen);
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && val instanceof Element)
    return val.tagName;
  if (typeof val.asymmetricMatch == "function")
    return `${val.toString()} ${format2(val.sample)}`;
  if (typeof val.toJSON == "function")
    return serializeValue(val.toJSON(), seen);
  if (seen.has(val))
    return seen.get(val);
  if (Array.isArray(val)) {
    let clone2 = new Array(val.length);
    return seen.set(val, clone2), val.forEach((e, i) => {
      try {
        clone2[i] = serializeValue(e, seen);
      } catch (err) {
        clone2[i] = getUnserializableMessage(err);
      }
    }), clone2;
  } else {
    let clone2 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone2);
    let obj = val;
    for (; obj && obj !== OBJECT_PROTO; )
      Object.getOwnPropertyNames(obj).forEach((key) => {
        if (!(key in clone2))
          try {
            clone2[key] = serializeValue(val[key], seen);
          } catch (err) {
            delete clone2[key], clone2[key] = getUnserializableMessage(err);
          }
      }), obj = Object.getPrototypeOf(obj);
    return clone2;
  }
}
function safe(fn2) {
  try {
    return fn2();
  } catch {
  }
}
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err != "object")
    return { message: String(_err) };
  let err = _err;
  (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) && (err.diff = printDiffOrStringify(err.actual, err.expected, {
    ...diffOptions,
    ...err.diffOptions
  })), "expected" in err && typeof err.expected != "string" && (err.expected = stringify(err.expected, 10)), "actual" in err && typeof err.actual != "string" && (err.actual = stringify(err.actual, 10));
  try {
    typeof err.message == "string" && (err.message = normalizeErrorMessage(err.message));
  } catch {
  }
  try {
    !seen.has(err) && typeof err.cause == "object" && (seen.add(err), err.cause = processError(err.cause, diffOptions, seen));
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e?.message}
Inner error message: ${err?.message}`));
  }
}

// ../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/index.mjs
init_cjs_shims();

// ../../node_modules/.pnpm/pathe@2.0.3/node_modules/pathe/dist/shared/pathe.M-eThtNZ.mjs
init_cjs_shims();
var _DRIVE_LETTER_START_RE2 = /^[A-Za-z]:\//;
function normalizeWindowsPath2(input = "") {
  return input && input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE2, (r2) => r2.toUpperCase());
}
var _IS_ABSOLUTE_RE2 = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function cwd2() {
  return typeof process < "u" && typeof process.cwd == "function" ? process.cwd().replace(/\\/g, "/") : "/";
}
var resolve2 = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath2(argument));
  let resolvedPath = "", resolvedAbsolute = !1;
  for (let index2 = arguments_.length - 1; index2 >= -1 && !resolvedAbsolute; index2--) {
    let path = index2 >= 0 ? arguments_[index2] : cwd2();
    !path || path.length === 0 || (resolvedPath = `${path}/${resolvedPath}`, resolvedAbsolute = isAbsolute2(path));
  }
  return resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute), resolvedAbsolute && !isAbsolute2(resolvedPath) ? `/${resolvedPath}` : resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString2(path, allowAboveRoot) {
  let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, char = null;
  for (let index2 = 0; index2 <= path.length; ++index2) {
    if (index2 < path.length)
      char = path[index2];
    else {
      if (char === "/")
        break;
      char = "/";
    }
    if (char === "/") {
      if (!(lastSlash === index2 - 1 || dots === 1)) if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            let lastSlashIndex = res.lastIndexOf("/");
            lastSlashIndex === -1 ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/")), lastSlash = index2, dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "", lastSegmentLength = 0, lastSlash = index2, dots = 0;
            continue;
          }
        }
        allowAboveRoot && (res += res.length > 0 ? "/.." : "..", lastSegmentLength = 2);
      } else
        res.length > 0 ? res += `/${path.slice(lastSlash + 1, index2)}` : res = path.slice(lastSlash + 1, index2), lastSegmentLength = index2 - lastSlash - 1;
      lastSlash = index2, dots = 0;
    } else char === "." && dots !== -1 ? ++dots : dots = -1;
  }
  return res;
}
var isAbsolute2 = function(p3) {
  return _IS_ABSOLUTE_RE2.test(p3);
};

// ../../node_modules/.pnpm/@vitest+runner@3.2.1/node_modules/@vitest/runner/dist/chunk-hooks.js
var PendingError = class extends Error {
  code = "VITEST_PENDING";
  taskId;
  constructor(message, task, note) {
    super(message), this.message = message, this.note = note, this.taskId = task.id;
  }
};
var fnMap = /* @__PURE__ */ new WeakMap(), testFixtureMap = /* @__PURE__ */ new WeakMap(), hooksMap = /* @__PURE__ */ new WeakMap();
function setFn(key, fn2) {
  fnMap.set(key, fn2);
}
function setTestFixture(key, fixture) {
  testFixtureMap.set(key, fixture);
}
function getTestFixture(key) {
  return testFixtureMap.get(key);
}
function setHooks(key, hooks) {
  hooksMap.set(key, hooks);
}
function getHooks(key) {
  return hooksMap.get(key);
}
function mergeScopedFixtures(testFixtures, scopedFixtures) {
  let scopedFixturesMap = scopedFixtures.reduce((map2, fixture) => (map2[fixture.prop] = fixture, map2), {}), newFixtures = {};
  testFixtures.forEach((fixture) => {
    let useFixture = scopedFixturesMap[fixture.prop] || { ...fixture };
    newFixtures[useFixture.prop] = useFixture;
  });
  for (let fixtureKep in newFixtures) {
    var _fixture$deps;
    let fixture = newFixtures[fixtureKep];
    fixture.deps = (_fixture$deps = fixture.deps) === null || _fixture$deps === void 0 ? void 0 : _fixture$deps.map((dep) => newFixtures[dep.prop]);
  }
  return Object.values(newFixtures);
}
function mergeContextFixtures(fixtures, context, runner2) {
  let fixtureOptionKeys = [
    "auto",
    "injected",
    "scope"
  ], fixtureArray = Object.entries(fixtures).map(([prop, value]) => {
    let fixtureItem = { value };
    if (Array.isArray(value) && value.length >= 2 && isObject(value[1]) && Object.keys(value[1]).some((key) => fixtureOptionKeys.includes(key))) {
      var _runner$injectValue;
      Object.assign(fixtureItem, value[1]);
      let userValue = value[0];
      fixtureItem.value = fixtureItem.injected ? ((_runner$injectValue = runner2.injectValue) === null || _runner$injectValue === void 0 ? void 0 : _runner$injectValue.call(runner2, prop)) ?? userValue : userValue;
    }
    return fixtureItem.scope = fixtureItem.scope || "test", fixtureItem.scope === "worker" && !runner2.getWorkerContext && (fixtureItem.scope = "file"), fixtureItem.prop = prop, fixtureItem.isFn = typeof fixtureItem.value == "function", fixtureItem;
  });
  return Array.isArray(context.fixtures) ? context.fixtures = context.fixtures.concat(fixtureArray) : context.fixtures = fixtureArray, fixtureArray.forEach((fixture) => {
    if (fixture.isFn) {
      let usedProps = getUsedProps(fixture.value);
      if (usedProps.length && (fixture.deps = context.fixtures.filter(({ prop }) => prop !== fixture.prop && usedProps.includes(prop))), fixture.scope !== "test") {
        var _fixture$deps2;
        (_fixture$deps2 = fixture.deps) === null || _fixture$deps2 === void 0 || _fixture$deps2.forEach((dep) => {
          if (dep.isFn && !(fixture.scope === "worker" && dep.scope === "worker") && !(fixture.scope === "file" && dep.scope !== "test"))
            throw new SyntaxError(`cannot use the ${dep.scope} fixture "${dep.prop}" inside the ${fixture.scope} fixture "${fixture.prop}"`);
        });
      }
    }
  }), context;
}
var fixtureValueMaps = /* @__PURE__ */ new Map(), cleanupFnArrayMap = /* @__PURE__ */ new Map();
function withFixtures(runner2, fn2, testContext) {
  return (hookContext) => {
    let context = hookContext || testContext;
    if (!context)
      return fn2({});
    let fixtures = getTestFixture(context);
    if (!fixtures?.length)
      return fn2(context);
    let usedProps = getUsedProps(fn2), hasAutoFixture = fixtures.some(({ auto }) => auto);
    if (!usedProps.length && !hasAutoFixture)
      return fn2(context);
    fixtureValueMaps.get(context) || fixtureValueMaps.set(context, /* @__PURE__ */ new Map());
    let fixtureValueMap = fixtureValueMaps.get(context);
    cleanupFnArrayMap.has(context) || cleanupFnArrayMap.set(context, []);
    let cleanupFnArray = cleanupFnArrayMap.get(context), usedFixtures = fixtures.filter(({ prop, auto }) => auto || usedProps.includes(prop)), pendingFixtures = resolveDeps(usedFixtures);
    if (!pendingFixtures.length)
      return fn2(context);
    async function resolveFixtures() {
      for (let fixture of pendingFixtures) {
        if (fixtureValueMap.has(fixture))
          continue;
        let resolvedValue = await resolveFixtureValue(runner2, fixture, context, cleanupFnArray);
        context[fixture.prop] = resolvedValue, fixtureValueMap.set(fixture, resolvedValue), fixture.scope === "test" && cleanupFnArray.unshift(() => {
          fixtureValueMap.delete(fixture);
        });
      }
    }
    return resolveFixtures().then(() => fn2(context));
  };
}
var globalFixturePromise = /* @__PURE__ */ new WeakMap();
function resolveFixtureValue(runner2, fixture, context, cleanupFnArray) {
  var _runner$getWorkerCont;
  let fileContext = getFileContext(context.task.file), workerContext = (_runner$getWorkerCont = runner2.getWorkerContext) === null || _runner$getWorkerCont === void 0 ? void 0 : _runner$getWorkerCont.call(runner2);
  if (!fixture.isFn) {
    var _fixture$prop;
    if (fileContext[_fixture$prop = fixture.prop] ?? (fileContext[_fixture$prop] = fixture.value), workerContext) {
      var _fixture$prop2;
      workerContext[_fixture$prop2 = fixture.prop] ?? (workerContext[_fixture$prop2] = fixture.value);
    }
    return fixture.value;
  }
  if (fixture.scope === "test")
    return resolveFixtureFunction(fixture.value, context, cleanupFnArray);
  if (globalFixturePromise.has(fixture))
    return globalFixturePromise.get(fixture);
  let fixtureContext;
  if (fixture.scope === "worker") {
    if (!workerContext)
      throw new TypeError("[@vitest/runner] The worker context is not available in the current test runner. Please, provide the `getWorkerContext` method when initiating the runner.");
    fixtureContext = workerContext;
  } else
    fixtureContext = fileContext;
  if (fixture.prop in fixtureContext)
    return fixtureContext[fixture.prop];
  cleanupFnArrayMap.has(fixtureContext) || cleanupFnArrayMap.set(fixtureContext, []);
  let cleanupFnFileArray = cleanupFnArrayMap.get(fixtureContext), promise = resolveFixtureFunction(fixture.value, fixtureContext, cleanupFnFileArray).then((value) => (fixtureContext[fixture.prop] = value, globalFixturePromise.delete(fixture), value));
  return globalFixturePromise.set(fixture, promise), promise;
}
async function resolveFixtureFunction(fixtureFn, context, cleanupFnArray) {
  let useFnArgPromise = createDefer(), isUseFnArgResolved = !1, fixtureReturn = fixtureFn(context, async (useFnArg) => {
    isUseFnArgResolved = !0, useFnArgPromise.resolve(useFnArg);
    let useReturnPromise = createDefer();
    cleanupFnArray.push(async () => {
      useReturnPromise.resolve(), await fixtureReturn;
    }), await useReturnPromise;
  }).catch((e) => {
    if (!isUseFnArgResolved) {
      useFnArgPromise.reject(e);
      return;
    }
    throw e;
  });
  return useFnArgPromise;
}
function resolveDeps(fixtures, depSet = /* @__PURE__ */ new Set(), pendingFixtures = []) {
  return fixtures.forEach((fixture) => {
    if (!pendingFixtures.includes(fixture)) {
      if (!fixture.isFn || !fixture.deps) {
        pendingFixtures.push(fixture);
        return;
      }
      if (depSet.has(fixture))
        throw new Error(`Circular fixture dependency detected: ${fixture.prop} <- ${[...depSet].reverse().map((d) => d.prop).join(" <- ")}`);
      depSet.add(fixture), resolveDeps(fixture.deps, depSet, pendingFixtures), pendingFixtures.push(fixture), depSet.clear();
    }
  }), pendingFixtures;
}
function getUsedProps(fn2) {
  let fnString = fn2.toString();
  /__async\((?:this|null), (?:null|arguments|\[[_0-9, ]*\]), function\*/.test(fnString) && (fnString = fnString.split(/__async\((?:this|null),/)[1]);
  let match = fnString.match(/[^(]*\(([^)]*)/);
  if (!match)
    return [];
  let args = splitByComma(match[1]);
  if (!args.length)
    return [];
  let first = args[0];
  if ("__VITEST_FIXTURE_INDEX__" in fn2 && (first = args[fn2.__VITEST_FIXTURE_INDEX__], !first))
    return [];
  if (!(first.startsWith("{") && first.endsWith("}")))
    throw new Error(`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received "${first}".`);
  let _first = first.slice(1, -1).replace(/\s/g, ""), props = splitByComma(_first).map((prop) => prop.replace(/:.*|=.*/g, "")), last = props.at(-1);
  if (last && last.startsWith("..."))
    throw new Error(`Rest parameters are not supported in fixtures, received "${last}".`);
  return props;
}
function splitByComma(s2) {
  let result = [], stack = [], start = 0;
  for (let i = 0; i < s2.length; i++)
    if (s2[i] === "{" || s2[i] === "[")
      stack.push(s2[i] === "{" ? "}" : "]");
    else if (s2[i] === stack[stack.length - 1])
      stack.pop();
    else if (!stack.length && s2[i] === ",") {
      let token = s2.substring(start, i).trim();
      token && result.push(token), start = i + 1;
    }
  let lastToken = s2.substring(start).trim();
  return lastToken && result.push(lastToken), result;
}
var _test;
function getCurrentTest() {
  return _test;
}
function createChainable(keys2, fn2) {
  function create(context) {
    let chain2 = function(...args) {
      return fn2.apply(context, args);
    };
    Object.assign(chain2, fn2), chain2.withContext = () => chain2.bind(context), chain2.setContext = (key, value) => {
      context[key] = value;
    }, chain2.mergeContext = (ctx) => {
      Object.assign(context, ctx);
    };
    for (let key of keys2)
      Object.defineProperty(chain2, key, { get() {
        return create({
          ...context,
          [key]: !0
        });
      } });
    return chain2;
  }
  let chain = create({});
  return chain.fn = fn2, chain;
}
var suite = createSuite(), test2 = createTest(function(name, optionsOrFn, optionsOrTest) {
  if (getCurrentTest())
    throw new Error('Calling the test function inside another test function is not allowed. Please put it inside "describe" or "suite" so it can be properly collected.');
  getCurrentSuite().test.fn.call(this, formatName(name), optionsOrFn, optionsOrTest);
}), describe = suite;
var runner, defaultSuite, currentTestFilepath;
function assert(condition, message) {
  if (!condition)
    throw new Error(`Vitest failed to find ${message}. This is a bug in Vitest. Please, open an issue with reproduction.`);
}
function getTestFilepath() {
  return currentTestFilepath;
}
function getRunner() {
  return assert(runner, "the runner"), runner;
}
function getCurrentSuite() {
  let currentSuite = collectorContext.currentSuite || defaultSuite;
  return assert(currentSuite, "the current suite"), currentSuite;
}
function createSuiteHooks() {
  return {
    beforeAll: [],
    afterAll: [],
    beforeEach: [],
    afterEach: []
  };
}
function parseArguments(optionsOrFn, optionsOrTest) {
  let options = {}, fn2 = () => {
  };
  if (typeof optionsOrTest == "object") {
    if (typeof optionsOrFn == "object")
      throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");
    console.warn("Using an object as a third argument is deprecated. Vitest 4 will throw an error if the third argument is not a timeout number. Please use the second argument for options. See more at https://vitest.dev/guide/migration"), options = optionsOrTest;
  } else typeof optionsOrTest == "number" ? options = { timeout: optionsOrTest } : typeof optionsOrFn == "object" && (options = optionsOrFn);
  if (typeof optionsOrFn == "function") {
    if (typeof optionsOrTest == "function")
      throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");
    fn2 = optionsOrFn;
  } else typeof optionsOrTest == "function" && (fn2 = optionsOrTest);
  return {
    options,
    handler: fn2
  };
}
function createSuiteCollector(name, factory = () => {
}, mode, each, suiteOptions, parentCollectorFixtures) {
  let tasks = [], suite2;
  initSuite(!0);
  let task = function(name2 = "", options = {}) {
    var _collectorContext$cur;
    let timeout = options?.timeout ?? runner.config.testTimeout, task2 = {
      id: "",
      name: name2,
      suite: (_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 ? void 0 : _collectorContext$cur.suite,
      each: options.each,
      fails: options.fails,
      context: void 0,
      type: "test",
      file: void 0,
      timeout,
      retry: options.retry ?? runner.config.retry,
      repeats: options.repeats,
      mode: options.only ? "only" : options.skip ? "skip" : options.todo ? "todo" : "run",
      meta: options.meta ?? /* @__PURE__ */ Object.create(null),
      annotations: []
    }, handler = options.handler;
    (options.concurrent || !options.sequential && runner.config.sequence.concurrent) && (task2.concurrent = !0), task2.shuffle = suiteOptions?.shuffle;
    let context = createTestContext(task2, runner);
    Object.defineProperty(task2, "context", {
      value: context,
      enumerable: !1
    }), setTestFixture(context, options.fixtures);
    let limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 15;
    let stackTraceError = new Error("STACK_TRACE_ERROR");
    if (Error.stackTraceLimit = limit, handler && setFn(task2, withTimeout(withAwaitAsyncAssertions(withFixtures(runner, handler, context), task2), timeout, !1, stackTraceError, (_, error) => abortIfTimeout([context], error))), runner.config.includeTaskLocation) {
      let error = stackTraceError.stack, stack = findTestFileStackTrace(error, task2.each ?? !1);
      stack && (task2.location = stack);
    }
    return tasks.push(task2), task2;
  }, test5 = createTest(function(name2, optionsOrFn, optionsOrTest) {
    let { options, handler } = parseArguments(optionsOrFn, optionsOrTest);
    typeof suiteOptions == "object" && (options = Object.assign({}, suiteOptions, options)), options.concurrent = this.concurrent || !this.sequential && options?.concurrent, options.sequential = this.sequential || !this.concurrent && options?.sequential;
    let test6 = task(formatName(name2), {
      ...this,
      ...options,
      handler
    });
    test6.type = "test";
  }), collectorFixtures = parentCollectorFixtures, collector = {
    type: "collector",
    name,
    mode,
    suite: suite2,
    options: suiteOptions,
    test: test5,
    tasks,
    collect,
    task,
    clear,
    on: addHook,
    fixtures() {
      return collectorFixtures;
    },
    scoped(fixtures) {
      let parsed = mergeContextFixtures(fixtures, { fixtures: collectorFixtures }, runner);
      parsed.fixtures && (collectorFixtures = parsed.fixtures);
    }
  };
  function addHook(name2, ...fn2) {
    getHooks(suite2)[name2].push(...fn2);
  }
  function initSuite(includeLocation) {
    var _collectorContext$cur2;
    if (typeof suiteOptions == "number" && (suiteOptions = { timeout: suiteOptions }), suite2 = {
      id: "",
      type: "suite",
      name,
      suite: (_collectorContext$cur2 = collectorContext.currentSuite) === null || _collectorContext$cur2 === void 0 ? void 0 : _collectorContext$cur2.suite,
      mode,
      each,
      file: void 0,
      shuffle: suiteOptions?.shuffle,
      tasks: [],
      meta: /* @__PURE__ */ Object.create(null),
      concurrent: suiteOptions?.concurrent
    }, runner && includeLocation && runner.config.includeTaskLocation) {
      let limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 15;
      let error = new Error("stacktrace").stack;
      Error.stackTraceLimit = limit;
      let stack = findTestFileStackTrace(error, suite2.each ?? !1);
      stack && (suite2.location = stack);
    }
    setHooks(suite2, createSuiteHooks());
  }
  function clear() {
    tasks.length = 0, initSuite(!1);
  }
  async function collect(file) {
    if (!file)
      throw new TypeError("File is required to collect tasks.");
    factory && await runWithSuite(collector, () => factory(test5));
    let allChildren = [];
    for (let i of tasks)
      allChildren.push(i.type === "collector" ? await i.collect(file) : i);
    return suite2.file = file, suite2.tasks = allChildren, allChildren.forEach((task2) => {
      task2.file = file;
    }), suite2;
  }
  return collectTask(collector), collector;
}
function withAwaitAsyncAssertions(fn2, task) {
  return async (...args) => {
    let fnResult = await fn2(...args);
    if (task.promises) {
      let errors = (await Promise.allSettled(task.promises)).map((r2) => r2.status === "rejected" ? r2.reason : void 0).filter(Boolean);
      if (errors.length)
        throw errors;
    }
    return fnResult;
  };
}
function createSuite() {
  function suiteFn(name, factoryOrOptions, optionsOrFactory) {
    var _currentSuite$options;
    let mode = this.only ? "only" : this.skip ? "skip" : this.todo ? "todo" : "run", currentSuite = collectorContext.currentSuite || defaultSuite, { options, handler: factory } = parseArguments(factoryOrOptions, optionsOrFactory), isConcurrentSpecified = options.concurrent || this.concurrent || options.sequential === !1, isSequentialSpecified = options.sequential || this.sequential || options.concurrent === !1;
    options = {
      ...currentSuite?.options,
      ...options,
      shuffle: this.shuffle ?? options.shuffle ?? (currentSuite == null || (_currentSuite$options = currentSuite.options) === null || _currentSuite$options === void 0 ? void 0 : _currentSuite$options.shuffle) ?? runner?.config.sequence.shuffle
    };
    let isConcurrent = isConcurrentSpecified || options.concurrent && !isSequentialSpecified, isSequential = isSequentialSpecified || options.sequential && !isConcurrentSpecified;
    return options.concurrent = isConcurrent && !isSequential, options.sequential = isSequential && !isConcurrent, createSuiteCollector(formatName(name), factory, mode, this.each, options, currentSuite?.fixtures());
  }
  return suiteFn.each = function(cases, ...args) {
    let suite2 = this.withContext();
    return this.setContext("each", !0), Array.isArray(cases) && args.length && (cases = formatTemplateString(cases, args)), (name, optionsOrFn, fnOrOptions) => {
      let _name = formatName(name), arrayOnlyCases = cases.every(Array.isArray), { options, handler } = parseArguments(optionsOrFn, fnOrOptions), fnFirst = typeof optionsOrFn == "function" && typeof fnOrOptions == "object";
      cases.forEach((i, idx) => {
        let items = Array.isArray(i) ? i : [i];
        fnFirst ? arrayOnlyCases ? suite2(formatTitle(_name, items, idx), () => handler(...items), options) : suite2(formatTitle(_name, items, idx), () => handler(i), options) : arrayOnlyCases ? suite2(formatTitle(_name, items, idx), options, () => handler(...items)) : suite2(formatTitle(_name, items, idx), options, () => handler(i));
      }), this.setContext("each", void 0);
    };
  }, suiteFn.for = function(cases, ...args) {
    return Array.isArray(cases) && args.length && (cases = formatTemplateString(cases, args)), (name, optionsOrFn, fnOrOptions) => {
      let name_ = formatName(name), { options, handler } = parseArguments(optionsOrFn, fnOrOptions);
      cases.forEach((item, idx) => {
        suite(formatTitle(name_, toArray(item), idx), options, () => handler(item));
      });
    };
  }, suiteFn.skipIf = (condition) => condition ? suite.skip : suite, suiteFn.runIf = (condition) => condition ? suite : suite.skip, createChainable([
    "concurrent",
    "sequential",
    "shuffle",
    "skip",
    "only",
    "todo"
  ], suiteFn);
}
function createTaskCollector(fn2, context) {
  let taskFn = fn2;
  taskFn.each = function(cases, ...args) {
    let test5 = this.withContext();
    return this.setContext("each", !0), Array.isArray(cases) && args.length && (cases = formatTemplateString(cases, args)), (name, optionsOrFn, fnOrOptions) => {
      let _name = formatName(name), arrayOnlyCases = cases.every(Array.isArray), { options, handler } = parseArguments(optionsOrFn, fnOrOptions), fnFirst = typeof optionsOrFn == "function" && typeof fnOrOptions == "object";
      cases.forEach((i, idx) => {
        let items = Array.isArray(i) ? i : [i];
        fnFirst ? arrayOnlyCases ? test5(formatTitle(_name, items, idx), () => handler(...items), options) : test5(formatTitle(_name, items, idx), () => handler(i), options) : arrayOnlyCases ? test5(formatTitle(_name, items, idx), options, () => handler(...items)) : test5(formatTitle(_name, items, idx), options, () => handler(i));
      }), this.setContext("each", void 0);
    };
  }, taskFn.for = function(cases, ...args) {
    let test5 = this.withContext();
    return Array.isArray(cases) && args.length && (cases = formatTemplateString(cases, args)), (name, optionsOrFn, fnOrOptions) => {
      let _name = formatName(name), { options, handler } = parseArguments(optionsOrFn, fnOrOptions);
      cases.forEach((item, idx) => {
        let handlerWrapper = (ctx) => handler(item, ctx);
        handlerWrapper.__VITEST_FIXTURE_INDEX__ = 1, handlerWrapper.toString = () => handler.toString(), test5(formatTitle(_name, toArray(item), idx), options, handlerWrapper);
      });
    };
  }, taskFn.skipIf = function(condition) {
    return condition ? this.skip : this;
  }, taskFn.runIf = function(condition) {
    return condition ? this : this.skip;
  }, taskFn.scoped = function(fixtures) {
    getCurrentSuite().scoped(fixtures);
  }, taskFn.extend = function(fixtures) {
    let _context = mergeContextFixtures(fixtures, context || {}, runner);
    return createTest(function(name, optionsOrFn, optionsOrTest) {
      let collector = getCurrentSuite(), scopedFixtures = collector.fixtures(), context2 = { ...this };
      scopedFixtures && (context2.fixtures = mergeScopedFixtures(context2.fixtures || [], scopedFixtures)), collector.test.fn.call(context2, formatName(name), optionsOrFn, optionsOrTest);
    }, _context);
  };
  let _test2 = createChainable([
    "concurrent",
    "sequential",
    "skip",
    "only",
    "todo",
    "fails"
  ], taskFn);
  return context && _test2.mergeContext(context), _test2;
}
function createTest(fn2, context) {
  return createTaskCollector(fn2, context);
}
function formatName(name) {
  return typeof name == "string" ? name : typeof name == "function" ? name.name || "<anonymous>" : String(name);
}
function formatTitle(template, items, idx) {
  (template.includes("%#") || template.includes("%$")) && (template = template.replace(/%%/g, "__vitest_escaped_%__").replace(/%#/g, `${idx}`).replace(/%\$/g, `${idx + 1}`).replace(/__vitest_escaped_%__/g, "%%"));
  let count = template.split("%").length - 1;
  template.includes("%f") && (template.match(/%f/g) || []).forEach((_, i) => {
    if (isNegativeNaN(items[i]) || Object.is(items[i], -0)) {
      let occurrence = 0;
      template = template.replace(/%f/g, (match) => (occurrence++, occurrence === i + 1 ? "-%f" : match));
    }
  });
  let formatted = format2(template, ...items.slice(0, count)), isObjectItem = isObject(items[0]);
  return formatted = formatted.replace(/\$([$\w.]+)/g, (_, key) => {
    var _runner$config;
    let isArrayKey = /^\d+$/.test(key);
    if (!isObjectItem && !isArrayKey)
      return `$${key}`;
    let arrayElement = isArrayKey ? objectAttr(items, key) : void 0, value = isObjectItem ? objectAttr(items[0], key, arrayElement) : arrayElement;
    return objDisplay(value, { truncate: runner == null || (_runner$config = runner.config) === null || _runner$config === void 0 || (_runner$config = _runner$config.chaiConfig) === null || _runner$config === void 0 ? void 0 : _runner$config.truncateThreshold });
  }), formatted;
}
function formatTemplateString(cases, args) {
  let header = cases.join("").trim().replace(/ /g, "").split(`
`).map((i) => i.split("|"))[0], res = [];
  for (let i = 0; i < Math.floor(args.length / header.length); i++) {
    let oneCase = {};
    for (let j = 0; j < header.length; j++)
      oneCase[header[j]] = args[i * header.length + j];
    res.push(oneCase);
  }
  return res;
}
function findTestFileStackTrace(error, each) {
  let lines = error.split(`
`).slice(1);
  for (let line of lines) {
    let stack = parseSingleStack(line);
    if (stack && stack.file === getTestFilepath())
      return {
        line: stack.line,
        column: each ? stack.column + 1 : stack.column
      };
  }
}
var now$2 = globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now;
function getNames(task) {
  let names = [task.name], current = task;
  for (; current?.suite; )
    current = current.suite, current?.name && names.unshift(current.name);
  return current !== task.file && names.unshift(task.file.name), names;
}
function getTestName(task, separator = " > ") {
  return getNames(task).slice(1).join(separator);
}
var now$1 = globalThis.performance ? globalThis.performance.now.bind(globalThis.performance) : Date.now, unixNow = Date.now;
var packs = /* @__PURE__ */ new Map(), eventsPacks = [], pendingTasksUpdates = [];
function sendTasksUpdate(runner2) {
  if (packs.size) {
    var _runner$onTaskUpdate;
    let taskPacks = Array.from(packs).map(([id, task]) => [
      id,
      task[0],
      task[1]
    ]), p3 = (_runner$onTaskUpdate = runner2.onTaskUpdate) === null || _runner$onTaskUpdate === void 0 ? void 0 : _runner$onTaskUpdate.call(runner2, taskPacks, eventsPacks);
    p3 && (pendingTasksUpdates.push(p3), p3.then(() => pendingTasksUpdates.splice(pendingTasksUpdates.indexOf(p3), 1), () => {
    })), eventsPacks.length = 0, packs.clear();
  }
}
async function finishSendTasksUpdate(runner2) {
  sendTasksUpdate(runner2), await Promise.all(pendingTasksUpdates);
}
function throttle(fn2, ms) {
  let last = 0;
  return function(...args) {
    let now3 = unixNow();
    if (now3 - last > ms)
      return last = now3, fn2.apply(this, args);
  };
}
var sendTasksUpdateThrottled = throttle(sendTasksUpdate, 100);
var now = Date.now, collectorContext = {
  tasks: [],
  currentSuite: null
};
function collectTask(task) {
  var _collectorContext$cur;
  (_collectorContext$cur = collectorContext.currentSuite) === null || _collectorContext$cur === void 0 || _collectorContext$cur.tasks.push(task);
}
async function runWithSuite(suite2, fn2) {
  let prev = collectorContext.currentSuite;
  collectorContext.currentSuite = suite2, await fn2(), collectorContext.currentSuite = prev;
}
function withTimeout(fn2, timeout, isHook = !1, stackTraceError, onTimeout) {
  if (timeout <= 0 || timeout === Number.POSITIVE_INFINITY)
    return fn2;
  let { setTimeout, clearTimeout } = getSafeTimers();
  return function(...args) {
    let startTime = now(), runner2 = getRunner();
    return runner2._currentTaskStartTime = startTime, runner2._currentTaskTimeout = timeout, new Promise((resolve_, reject_) => {
      var _timer$unref;
      let timer = setTimeout(() => {
        clearTimeout(timer), rejectTimeoutError();
      }, timeout);
      (_timer$unref = timer.unref) === null || _timer$unref === void 0 || _timer$unref.call(timer);
      function rejectTimeoutError() {
        let error = makeTimeoutError(isHook, timeout, stackTraceError);
        onTimeout?.(args, error), reject_(error);
      }
      function resolve4(result) {
        if (runner2._currentTaskStartTime = void 0, runner2._currentTaskTimeout = void 0, clearTimeout(timer), now() - startTime >= timeout) {
          rejectTimeoutError();
          return;
        }
        resolve_(result);
      }
      function reject(error) {
        runner2._currentTaskStartTime = void 0, runner2._currentTaskTimeout = void 0, clearTimeout(timer), reject_(error);
      }
      try {
        let result = fn2(...args);
        typeof result == "object" && result != null && typeof result.then == "function" ? result.then(resolve4, reject) : resolve4(result);
      } catch (error) {
        reject(error);
      }
    });
  };
}
var abortControllers = /* @__PURE__ */ new WeakMap();
function abortIfTimeout([context], error) {
  context && abortContextSignal(context, error);
}
function abortContextSignal(context, error) {
  let abortController = abortControllers.get(context);
  abortController?.abort(error);
}
function createTestContext(test5, runner2) {
  var _runner$extendTaskCon;
  let context = function() {
    throw new Error("done() callback is deprecated, use promise instead");
  }, abortController = abortControllers.get(context);
  abortController || (abortController = new AbortController(), abortControllers.set(context, abortController)), context.signal = abortController.signal, context.task = test5, context.skip = (condition, note) => {
    if (condition !== !1)
      throw test5.result ?? (test5.result = { state: "skip" }), test5.result.pending = !0, new PendingError("test is skipped; abort execution", test5, typeof condition == "string" ? condition : note);
  };
  async function annotate(message, location, type3, attachment) {
    let annotation = {
      message,
      type: type3 || "notice"
    };
    if (attachment) {
      if (!attachment.body && !attachment.path)
        throw new TypeError("Test attachment requires body or path to be set. Both are missing.");
      if (attachment.body && attachment.path)
        throw new TypeError('Test attachment requires only one of "body" or "path" to be set. Both are specified.');
      annotation.attachment = attachment, attachment.body instanceof Uint8Array && (attachment.body = encodeUint8Array(attachment.body));
    }
    if (location && (annotation.location = location), !runner2.onTestAnnotate)
      throw new Error("Test runner doesn't support test annotations.");
    await finishSendTasksUpdate(runner2);
    let resolvedAnnotation = await runner2.onTestAnnotate(test5, annotation);
    return test5.annotations.push(resolvedAnnotation), resolvedAnnotation;
  }
  return context.annotate = (message, type3, attachment) => {
    if (test5.result && test5.result.state !== "run")
      throw new Error(`Cannot annotate tests outside of the test run. The test "${test5.name}" finished running with the "${test5.result.state}" state already.`);
    let location, stack = new Error("STACK_TRACE").stack, index2 = stack.includes("STACK_TRACE") ? 2 : 1, stackLine = stack.split(`
`)[index2], parsed = parseSingleStack(stackLine);
    return parsed && (location = {
      file: parsed.file,
      line: parsed.line,
      column: parsed.column
    }), typeof type3 == "object" ? recordAsyncAnnotation(test5, annotate(message, location, void 0, type3)) : recordAsyncAnnotation(test5, annotate(message, location, type3, attachment));
  }, context.onTestFailed = (handler, timeout) => {
    test5.onFailed || (test5.onFailed = []), test5.onFailed.push(withTimeout(handler, timeout ?? runner2.config.hookTimeout, !0, new Error("STACK_TRACE_ERROR"), (_, error) => abortController.abort(error)));
  }, context.onTestFinished = (handler, timeout) => {
    test5.onFinished || (test5.onFinished = []), test5.onFinished.push(withTimeout(handler, timeout ?? runner2.config.hookTimeout, !0, new Error("STACK_TRACE_ERROR"), (_, error) => abortController.abort(error)));
  }, ((_runner$extendTaskCon = runner2.extendTaskContext) === null || _runner$extendTaskCon === void 0 ? void 0 : _runner$extendTaskCon.call(runner2, context)) || context;
}
function makeTimeoutError(isHook, timeout, stackTraceError) {
  let message = `${isHook ? "Hook" : "Test"} timed out in ${timeout}ms.
If this is a long-running ${isHook ? "hook" : "test"}, pass a timeout value as the last argument or configure it globally with "${isHook ? "hookTimeout" : "testTimeout"}".`, error = new Error(message);
  return stackTraceError?.stack && (error.stack = stackTraceError.stack.replace(error.message, stackTraceError.message)), error;
}
var fileContexts = /* @__PURE__ */ new WeakMap();
function getFileContext(file) {
  let context = fileContexts.get(file);
  if (!context)
    throw new Error(`Cannot find file context for ${file.name}`);
  return context;
}
var table = [];
for (let i = 65; i < 91; i++)
  table.push(String.fromCharCode(i));
for (let i = 97; i < 123; i++)
  table.push(String.fromCharCode(i));
for (let i = 0; i < 10; i++)
  table.push(i.toString(10));
function encodeUint8Array(bytes) {
  let base64 = "", len = bytes.byteLength;
  for (let i = 0; i < len; i += 3)
    if (len === i + 1) {
      let a3 = (bytes[i] & 252) >> 2, b = (bytes[i] & 3) << 4;
      base64 += table[a3], base64 += table[b], base64 += "==";
    } else if (len === i + 2) {
      let a3 = (bytes[i] & 252) >> 2, b = (bytes[i] & 3) << 4 | (bytes[i + 1] & 240) >> 4, c = (bytes[i + 1] & 15) << 2;
      base64 += table[a3], base64 += table[b], base64 += table[c], base64 += "=";
    } else {
      let a3 = (bytes[i] & 252) >> 2, b = (bytes[i] & 3) << 4 | (bytes[i + 1] & 240) >> 4, c = (bytes[i + 1] & 15) << 2 | (bytes[i + 2] & 192) >> 6, d = bytes[i + 2] & 63;
      base64 += table[a3], base64 += table[b], base64 += table[c], base64 += table[d];
    }
  return base64;
}
function recordAsyncAnnotation(test5, promise) {
  return promise = promise.finally(() => {
    if (!test5.promises)
      return;
    let index2 = test5.promises.indexOf(promise);
    index2 !== -1 && test5.promises.splice(index2, 1);
  }), test5.promises || (test5.promises = []), test5.promises.push(promise), promise;
}
function getDefaultHookTimeout() {
  return getRunner().config.hookTimeout;
}
var CLEANUP_TIMEOUT_KEY = Symbol.for("VITEST_CLEANUP_TIMEOUT"), CLEANUP_STACK_TRACE_KEY = Symbol.for("VITEST_CLEANUP_STACK_TRACE");
function beforeEach(fn2, timeout = getDefaultHookTimeout()) {
  assertTypes(fn2, '"beforeEach" callback', ["function"]);
  let stackTraceError = new Error("STACK_TRACE_ERROR"), runner2 = getRunner();
  return getCurrentSuite().on("beforeEach", Object.assign(withTimeout(withFixtures(runner2, fn2), timeout ?? getDefaultHookTimeout(), !0, stackTraceError, abortIfTimeout), {
    [CLEANUP_TIMEOUT_KEY]: timeout,
    [CLEANUP_STACK_TRACE_KEY]: stackTraceError
  }));
}
function afterEach(fn2, timeout) {
  assertTypes(fn2, '"afterEach" callback', ["function"]);
  let runner2 = getRunner();
  return getCurrentSuite().on("afterEach", withTimeout(withFixtures(runner2, fn2), timeout ?? getDefaultHookTimeout(), !0, new Error("STACK_TRACE_ERROR"), abortIfTimeout));
}
var onTestFailed = createTestHook("onTestFailed", (test5, handler, timeout) => {
  test5.onFailed || (test5.onFailed = []), test5.onFailed.push(withTimeout(handler, timeout ?? getDefaultHookTimeout(), !0, new Error("STACK_TRACE_ERROR"), abortIfTimeout));
}), onTestFinished = createTestHook("onTestFinished", (test5, handler, timeout) => {
  test5.onFinished || (test5.onFinished = []), test5.onFinished.push(withTimeout(handler, timeout ?? getDefaultHookTimeout(), !0, new Error("STACK_TRACE_ERROR"), abortIfTimeout));
});
function createTestHook(name, handler) {
  return (fn2, timeout) => {
    assertTypes(fn2, `"${name}" callback`, ["function"]);
    let current = getCurrentTest();
    if (!current)
      throw new Error(`Hook ${name}() can only be called inside a test`);
    return handler(current, fn2, timeout);
  };
}

// ../../node_modules/.pnpm/@vitest+runner@3.2.1/node_modules/@vitest/runner/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/vitest@3.2.1_@types+node@18.19.70_jiti@2.4.2_jsdom@20.0.3_msw@2.8.7_@types+node@18.19.7_59b23bdad58d2b08cdc86d448ade34f5/node_modules/vitest/dist/chunks/vi.bdSIJ99Y.js
init_cjs_shims();

// ../../node_modules/.pnpm/@vitest+expect@3.2.1/node_modules/@vitest/expect/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/@vitest+spy@3.2.1/node_modules/@vitest/spy/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/tinyspy@4.0.3/node_modules/tinyspy/dist/index.js
init_cjs_shims();
function assert2(condition, message) {
  if (!condition)
    throw new Error(message);
}
function isType(type3, value) {
  return typeof value === type3;
}
function isPromise(value) {
  return value instanceof Promise;
}
function define(obj, key, descriptor) {
  Object.defineProperty(obj, key, descriptor);
}
function defineValue(obj, key, value) {
  define(obj, key, { value, configurable: !0, writable: !0 });
}
var SYMBOL_STATE = Symbol.for("tinyspy:spy"), spies = /* @__PURE__ */ new Set(), reset = (state) => {
  state.called = !1, state.callCount = 0, state.calls = [], state.results = [], state.resolves = [], state.next = [];
}, defineState = (spy2) => (define(spy2, SYMBOL_STATE, {
  value: { reset: () => reset(spy2[SYMBOL_STATE]) }
}), spy2[SYMBOL_STATE]), getInternalState = (spy2) => spy2[SYMBOL_STATE] || defineState(spy2);
function createInternalSpy(cb) {
  assert2(
    isType("function", cb) || isType("undefined", cb),
    "cannot spy on a non-function value"
  );
  let fn2 = function(...args) {
    let state2 = getInternalState(fn2);
    state2.called = !0, state2.callCount++, state2.calls.push(args);
    let next = state2.next.shift();
    if (next) {
      state2.results.push(next);
      let [type22, result2] = next;
      if (type22 === "ok")
        return result2;
      throw result2;
    }
    let result, type3 = "ok", resultIndex = state2.results.length;
    if (state2.impl)
      try {
        new.target ? result = Reflect.construct(state2.impl, args, new.target) : result = state2.impl.apply(this, args), type3 = "ok";
      } catch (err) {
        throw result = err, type3 = "error", state2.results.push([type3, err]), err;
      }
    let resultTuple = [type3, result];
    return isPromise(result) && result.then(
      (r2) => state2.resolves[resultIndex] = ["ok", r2],
      (e) => state2.resolves[resultIndex] = ["error", e]
    ), state2.results.push(resultTuple), result;
  };
  defineValue(fn2, "_isMockFunction", !0), defineValue(fn2, "length", cb ? cb.length : 0), defineValue(fn2, "name", cb && cb.name || "spy");
  let state = getInternalState(fn2);
  return state.reset(), state.impl = cb, fn2;
}
function isMockFunction(obj) {
  return !!obj && obj._isMockFunction === !0;
}
var getDescriptor = (obj, method) => {
  let objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor)
    return [obj, objDescriptor];
  let currentProto = Object.getPrototypeOf(obj);
  for (; currentProto !== null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor)
      return [currentProto, descriptor];
    currentProto = Object.getPrototypeOf(currentProto);
  }
}, setPototype = (fn2, val) => {
  val != null && typeof val == "function" && val.prototype != null && Object.setPrototypeOf(fn2.prototype, val.prototype);
};
function internalSpyOn(obj, methodName, mock) {
  assert2(
    !isType("undefined", obj),
    "spyOn could not find an object to spy upon"
  ), assert2(
    isType("object", obj) || isType("function", obj),
    "cannot spyOn on a primitive value"
  );
  let [accessName, accessType] = (() => {
    if (!isType("object", methodName))
      return [methodName, "value"];
    if ("getter" in methodName && "setter" in methodName)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in methodName)
      return [methodName.getter, "get"];
    if ("setter" in methodName)
      return [methodName.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), [originalDescriptorObject, originalDescriptor] = getDescriptor(obj, accessName) || [];
  assert2(
    originalDescriptor || accessName in obj,
    `${String(accessName)} does not exist`
  );
  let ssr = !1;
  accessType === "value" && originalDescriptor && !originalDescriptor.value && originalDescriptor.get && (accessType = "get", ssr = !0, mock = originalDescriptor.get());
  let original;
  originalDescriptor ? original = originalDescriptor[accessType] : accessType !== "value" ? original = () => obj[accessName] : original = obj[accessName], original && isSpyFunction(original) && (original = original[SYMBOL_STATE].getOriginal());
  let reassign = (cb) => {
    let { value, ...desc } = originalDescriptor || {
      configurable: !0,
      writable: !0
    };
    accessType !== "value" && delete desc.writable, desc[accessType] = cb, define(obj, accessName, desc);
  }, restore = () => {
    originalDescriptorObject !== obj ? Reflect.deleteProperty(obj, accessName) : originalDescriptor && !original ? define(obj, accessName, originalDescriptor) : reassign(original);
  };
  mock || (mock = original);
  let spy2 = wrap(createInternalSpy(mock), mock);
  accessType === "value" && setPototype(spy2, original);
  let state = spy2[SYMBOL_STATE];
  return defineValue(state, "restore", restore), defineValue(state, "getOriginal", () => ssr ? original() : original), defineValue(state, "willCall", (newCb) => (state.impl = newCb, spy2)), reassign(
    ssr ? () => (setPototype(spy2, mock), spy2) : spy2
  ), spies.add(spy2), spy2;
}
var ignoreProperties = /* @__PURE__ */ new Set([
  "length",
  "name",
  "prototype"
]);
function getAllProperties(original) {
  let properties = /* @__PURE__ */ new Set(), descriptors2 = {};
  for (; original && original !== Object.prototype && original !== Function.prototype; ) {
    let ownProperties = [
      ...Object.getOwnPropertyNames(original),
      ...Object.getOwnPropertySymbols(original)
    ];
    for (let prop of ownProperties)
      descriptors2[prop] || ignoreProperties.has(prop) || (properties.add(prop), descriptors2[prop] = Object.getOwnPropertyDescriptor(original, prop));
    original = Object.getPrototypeOf(original);
  }
  return {
    properties,
    descriptors: descriptors2
  };
}
function wrap(mock, original) {
  if (!original || // the original is already a spy, so it has all the properties
  SYMBOL_STATE in original)
    return mock;
  let { properties, descriptors: descriptors2 } = getAllProperties(original);
  for (let key of properties) {
    let descriptor = descriptors2[key];
    getDescriptor(mock, key) || define(mock, key, descriptor);
  }
  return mock;
}
function isSpyFunction(obj) {
  return isMockFunction(obj) && "getOriginal" in obj[SYMBOL_STATE];
}

// ../../node_modules/.pnpm/@vitest+spy@3.2.1/node_modules/@vitest/spy/dist/index.js
var mocks = /* @__PURE__ */ new Set();
function isMockFunction2(fn2) {
  return typeof fn2 == "function" && "_isMockFunction" in fn2 && fn2._isMockFunction;
}
function spyOn(obj, method, accessType) {
  let objMethod = accessType ? { [{
    get: "getter",
    set: "setter"
  }[accessType]]: method } : method, state, descriptor = getDescriptor2(obj, method), fn2 = descriptor && descriptor[accessType || "value"];
  isMockFunction2(fn2) && (state = fn2.mock._state());
  let stub = internalSpyOn(obj, objMethod), spy = enhanceSpy(stub);
  return state && spy.mock._state(state), spy;
}
var callOrder = 0;
function enhanceSpy(spy) {
  let stub = spy, implementation, onceImplementations = [], implementationChangedTemporarily = !1, instances = [], contexts = [], invocations = [], state = getInternalState(spy), mockContext = {
    get calls() {
      return state.calls;
    },
    get contexts() {
      return contexts;
    },
    get instances() {
      return instances;
    },
    get invocationCallOrder() {
      return invocations;
    },
    get results() {
      return state.results.map(([callType, value]) => ({
        type: callType === "error" ? "throw" : "return",
        value
      }));
    },
    get settledResults() {
      return state.resolves.map(([callType, value]) => ({
        type: callType === "error" ? "rejected" : "fulfilled",
        value
      }));
    },
    get lastCall() {
      return state.calls[state.calls.length - 1];
    },
    _state(state2) {
      return state2 && (implementation = state2.implementation, onceImplementations = state2.onceImplementations, implementationChangedTemporarily = state2.implementationChangedTemporarily), {
        implementation,
        onceImplementations,
        implementationChangedTemporarily
      };
    }
  };
  function mockCall(...args) {
    return instances.push(this), contexts.push(this), invocations.push(++callOrder), (implementationChangedTemporarily ? implementation : onceImplementations.shift() || implementation || state.getOriginal() || (() => {
    })).apply(this, args);
  }
  let name = stub.name;
  stub.getMockName = () => name || "vi.fn()", stub.mockName = (n) => (name = n, stub), stub.mockClear = () => (state.reset(), instances = [], contexts = [], invocations = [], stub), stub.mockReset = () => (stub.mockClear(), implementation = void 0, onceImplementations = [], stub), stub.mockRestore = () => (stub.mockReset(), state.restore(), stub), Symbol.dispose && (stub[Symbol.dispose] = () => stub.mockRestore()), stub.getMockImplementation = () => implementationChangedTemporarily ? implementation : onceImplementations.at(0) || implementation, stub.mockImplementation = (fn2) => (implementation = fn2, state.willCall(mockCall), stub), stub.mockImplementationOnce = (fn2) => (onceImplementations.push(fn2), stub);
  function withImplementation(fn2, cb) {
    let originalImplementation = implementation;
    implementation = fn2, state.willCall(mockCall), implementationChangedTemporarily = !0;
    let reset2 = () => {
      implementation = originalImplementation, implementationChangedTemporarily = !1;
    }, result = cb();
    return typeof result == "object" && result && typeof result.then == "function" ? result.then(() => (reset2(), stub)) : (reset2(), stub);
  }
  return stub.withImplementation = withImplementation, stub.mockReturnThis = () => stub.mockImplementation(function() {
    return this;
  }), stub.mockReturnValue = (val) => stub.mockImplementation(() => val), stub.mockReturnValueOnce = (val) => stub.mockImplementationOnce(() => val), stub.mockResolvedValue = (val) => stub.mockImplementation(() => Promise.resolve(val)), stub.mockResolvedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.resolve(val)), stub.mockRejectedValue = (val) => stub.mockImplementation(() => Promise.reject(val)), stub.mockRejectedValueOnce = (val) => stub.mockImplementationOnce(() => Promise.reject(val)), Object.defineProperty(stub, "mock", { get: () => mockContext }), state.willCall(mockCall), mocks.add(stub), stub;
}
function fn(implementation) {
  let enhancedSpy = enhanceSpy(internalSpyOn({ spy: implementation || function() {
  } }, "spy"));
  return implementation && enhancedSpy.mockImplementation(implementation), enhancedSpy;
}
function getDescriptor2(obj, method) {
  let objDescriptor = Object.getOwnPropertyDescriptor(obj, method);
  if (objDescriptor)
    return objDescriptor;
  let currentProto = Object.getPrototypeOf(obj);
  for (; currentProto !== null; ) {
    let descriptor = Object.getOwnPropertyDescriptor(currentProto, method);
    if (descriptor)
      return descriptor;
    currentProto = Object.getPrototypeOf(currentProto);
  }
}

// ../../node_modules/.pnpm/chai@5.2.0/node_modules/chai/chai.js
init_cjs_shims();
var __defProp = Object.defineProperty, __getOwnPropNames = Object.getOwnPropertyNames, __name = (target, value) => __defProp(target, "name", { value, configurable: !0 }), __commonJS2 = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
}, __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, require_util = __commonJS2({
  "(disabled):util"() {
  }
}), utils_exports = {};
__export(utils_exports, {
  addChainableMethod: () => addChainableMethod,
  addLengthGuard: () => addLengthGuard,
  addMethod: () => addMethod,
  addProperty: () => addProperty,
  checkError: () => check_error_exports,
  compareByInspect: () => compareByInspect,
  eql: () => deep_eql_default,
  expectTypes: () => expectTypes,
  flag: () => flag,
  getActual: () => getActual,
  getMessage: () => getMessage2,
  getName: () => getName,
  getOperator: () => getOperator,
  getOwnEnumerableProperties: () => getOwnEnumerableProperties,
  getOwnEnumerablePropertySymbols: () => getOwnEnumerablePropertySymbols,
  getPathInfo: () => getPathInfo,
  hasProperty: () => hasProperty,
  inspect: () => inspect22,
  isNaN: () => isNaN22,
  isNumeric: () => isNumeric,
  isProxyEnabled: () => isProxyEnabled,
  isRegExp: () => isRegExp2,
  objDisplay: () => objDisplay2,
  overwriteChainableMethod: () => overwriteChainableMethod,
  overwriteMethod: () => overwriteMethod,
  overwriteProperty: () => overwriteProperty,
  proxify: () => proxify,
  test: () => test3,
  transferFlags: () => transferFlags,
  type: () => type
});
var check_error_exports = {};
__export(check_error_exports, {
  compatibleConstructor: () => compatibleConstructor,
  compatibleInstance: () => compatibleInstance,
  compatibleMessage: () => compatibleMessage,
  getConstructorName: () => getConstructorName2,
  getMessage: () => getMessage
});
function isErrorInstance(obj) {
  return obj instanceof Error || Object.prototype.toString.call(obj) === "[object Error]";
}
__name(isErrorInstance, "isErrorInstance");
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function compatibleInstance(thrown, errorLike) {
  return isErrorInstance(errorLike) && thrown === errorLike;
}
__name(compatibleInstance, "compatibleInstance");
function compatibleConstructor(thrown, errorLike) {
  return isErrorInstance(errorLike) ? thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor : (typeof errorLike == "object" || typeof errorLike == "function") && errorLike.prototype ? thrown.constructor === errorLike || thrown instanceof errorLike : !1;
}
__name(compatibleConstructor, "compatibleConstructor");
function compatibleMessage(thrown, errMatcher) {
  let comparisonString = typeof thrown == "string" ? thrown : thrown.message;
  return isRegExp(errMatcher) ? errMatcher.test(comparisonString) : typeof errMatcher == "string" ? comparisonString.indexOf(errMatcher) !== -1 : !1;
}
__name(compatibleMessage, "compatibleMessage");
function getConstructorName2(errorLike) {
  let constructorName = errorLike;
  return isErrorInstance(errorLike) ? constructorName = errorLike.constructor.name : typeof errorLike == "function" && (constructorName = errorLike.name, constructorName === "" && (constructorName = new errorLike().name || constructorName)), constructorName;
}
__name(getConstructorName2, "getConstructorName");
function getMessage(errorLike) {
  let msg = "";
  return errorLike && errorLike.message ? msg = errorLike.message : typeof errorLike == "string" && (msg = errorLike), msg;
}
__name(getMessage, "getMessage");
function flag(obj, key, value) {
  var flags = obj.__flags || (obj.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    flags[key] = value;
  else
    return flags[key];
}
__name(flag, "flag");
function test3(obj, args) {
  var negate = flag(obj, "negate"), expr = args[0];
  return negate ? !expr : expr;
}
__name(test3, "test");
function type(obj) {
  if (typeof obj > "u")
    return "undefined";
  if (obj === null)
    return "null";
  let stringTag = obj[Symbol.toStringTag];
  return typeof stringTag == "string" ? stringTag : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type, "type");
var canElideFrames = "captureStackTrace" in Error, AssertionError = class _AssertionError extends Error {
  static {
    __name(this, "AssertionError");
  }
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(message = "Unspecified AssertionError", props, ssf) {
    super(message), this.message = message, canElideFrames && Error.captureStackTrace(this, ssf || _AssertionError);
    for (let key in props)
      key in this || (this[key] = props[key]);
  }
  toJSON(stack) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: stack !== !1 ? this.stack : void 0
    };
  }
};
function expectTypes(obj, types) {
  var flagMsg = flag(obj, "message"), ssfi = flag(obj, "ssfi");
  flagMsg = flagMsg ? flagMsg + ": " : "", obj = flag(obj, "object"), types = types.map(function(t) {
    return t.toLowerCase();
  }), types.sort();
  var str = types.map(function(t, index2) {
    var art = ~["a", "e", "i", "o", "u"].indexOf(t.charAt(0)) ? "an" : "a", or = types.length > 1 && index2 === types.length - 1 ? "or " : "";
    return or + art + " " + t;
  }).join(", "), objType = type(obj).toLowerCase();
  if (!types.some(function(expected) {
    return objType === expected;
  }))
    throw new AssertionError(
      flagMsg + "object tested must be " + str + ", but " + objType + " given",
      void 0,
      ssfi
    );
}
__name(expectTypes, "expectTypes");
function getActual(obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
}
__name(getActual, "getActual");
var ansiColors2 = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, styles2 = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, truncator2 = "\u2026";
function colorise2(value, styleType) {
  let color = ansiColors2[styles2[styleType]] || ansiColors2[styleType] || "";
  return color ? `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m` : String(value);
}
__name(colorise2, "colorise");
function normaliseOptions2({
  showHidden = !1,
  depth = 2,
  colors = !1,
  customInspect = !0,
  showProxy = !1,
  maxArrayLength = 1 / 0,
  breakLength = 1 / 0,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate22 = 1 / 0,
  stylize = String
} = {}, inspect32) {
  let options = {
    showHidden: !!showHidden,
    depth: Number(depth),
    colors: !!colors,
    customInspect: !!customInspect,
    showProxy: !!showProxy,
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate22),
    seen,
    inspect: inspect32,
    stylize
  };
  return options.colors && (options.stylize = colorise2), options;
}
__name(normaliseOptions2, "normaliseOptions");
function isHighSurrogate2(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
__name(isHighSurrogate2, "isHighSurrogate");
function truncate2(string2, length, tail = truncator2) {
  string2 = String(string2);
  let tailLength = tail.length, stringLength = string2.length;
  if (tailLength > length && stringLength > tailLength)
    return tail;
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    return end > 0 && isHighSurrogate2(string2[end - 1]) && (end = end - 1), `${string2.slice(0, end)}${tail}`;
  }
  return string2;
}
__name(truncate2, "truncate");
function inspectList2(list, options, inspectItem, separator = ", ") {
  inspectItem = inspectItem || options.inspect;
  let size = list.length;
  if (size === 0)
    return "";
  let originalLength = options.truncate, output = "", peek = "", truncated = "";
  for (let i = 0; i < size; i += 1) {
    let last = i + 1 === list.length, secondToLast = i + 2 === list.length;
    truncated = `${truncator2}(${list.length - i})`;
    let value = list[i];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    let string2 = peek || inspectItem(value, options) + (last ? "" : separator), nextLength = output.length + string2.length, truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength || !last && !secondToLast && truncatedLength > originalLength || (peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator), !last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength))
      break;
    if (output += string2, !last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator2}(${list.length - i - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
__name(inspectList2, "inspectList");
function quoteComplexKey2(key) {
  return key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? key : JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
__name(quoteComplexKey2, "quoteComplexKey");
function inspectProperty2([key, value], options) {
  return options.truncate -= 2, typeof key == "string" ? key = quoteComplexKey2(key) : typeof key != "number" && (key = `[${options.inspect(key, options)}]`), options.truncate -= key.length, value = options.inspect(value, options), `${key}: ${value}`;
}
__name(inspectProperty2, "inspectProperty");
function inspectArray2(array2, options) {
  let nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  let listContents = inspectList2(array2, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty2)), `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectArray2, "inspectArray");
var getArrayName2 = /* @__PURE__ */ __name((array2) => typeof Buffer == "function" && array2 instanceof Buffer ? "Buffer" : array2[Symbol.toStringTag] ? array2[Symbol.toStringTag] : array2.constructor.name, "getArrayName");
function inspectTypedArray2(array2, options) {
  let name = getArrayName2(array2);
  options.truncate -= name.length + 4;
  let nonIndexProperties = Object.keys(array2).slice(array2.length);
  if (!array2.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i = 0; i < array2.length; i++) {
    let string2 = `${options.stylize(truncate2(array2[i], options.truncate), "number")}${i === array2.length - 1 ? "" : ", "}`;
    if (options.truncate -= string2.length, array2[i] !== array2.length && options.truncate <= 3) {
      output += `${truncator2}(${array2.length - array2[i] + 1})`;
      break;
    }
    output += string2;
  }
  let propertyContents = "";
  return nonIndexProperties.length && (propertyContents = inspectList2(nonIndexProperties.map((key) => [key, array2[key]]), options, inspectProperty2)), `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
__name(inspectTypedArray2, "inspectTypedArray");
function inspectDate2(dateObject, options) {
  let stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null)
    return "Invalid Date";
  let split = stringRepresentation.split("T"), date = split[0];
  return options.stylize(`${date}T${truncate2(split[1], options.truncate - date.length - 1)}`, "date");
}
__name(inspectDate2, "inspectDate");
function inspectFunction2(func, options) {
  let functionType = func[Symbol.toStringTag] || "Function", name = func.name;
  return name ? options.stylize(`[${functionType} ${truncate2(name, options.truncate - 11)}]`, "special") : options.stylize(`[${functionType}]`, "special");
}
__name(inspectFunction2, "inspectFunction");
function inspectMapEntry2([key, value], options) {
  return options.truncate -= 4, key = options.inspect(key, options), options.truncate -= key.length, value = options.inspect(value, options), `${key} => ${value}`;
}
__name(inspectMapEntry2, "inspectMapEntry");
function mapToEntries2(map2) {
  let entries = [];
  return map2.forEach((value, key) => {
    entries.push([key, value]);
  }), entries;
}
__name(mapToEntries2, "mapToEntries");
function inspectMap2(map2, options) {
  return map2.size - 1 <= 0 ? "Map{}" : (options.truncate -= 7, `Map{ ${inspectList2(mapToEntries2(map2), options, inspectMapEntry2)} }`);
}
__name(inspectMap2, "inspectMap");
var isNaN2 = Number.isNaN || ((i) => i !== i);
function inspectNumber2(number, options) {
  return isNaN2(number) ? options.stylize("NaN", "number") : number === 1 / 0 ? options.stylize("Infinity", "number") : number === -1 / 0 ? options.stylize("-Infinity", "number") : number === 0 ? options.stylize(1 / number === 1 / 0 ? "+0" : "-0", "number") : options.stylize(truncate2(String(number), options.truncate), "number");
}
__name(inspectNumber2, "inspectNumber");
function inspectBigInt2(number, options) {
  let nums = truncate2(number.toString(), options.truncate - 1);
  return nums !== truncator2 && (nums += "n"), options.stylize(nums, "bigint");
}
__name(inspectBigInt2, "inspectBigInt");
function inspectRegExp2(value, options) {
  let flags = value.toString().split("/")[2], sourceLength = options.truncate - (2 + flags.length), source = value.source;
  return options.stylize(`/${truncate2(source, sourceLength)}/${flags}`, "regexp");
}
__name(inspectRegExp2, "inspectRegExp");
function arrayFromSet2(set22) {
  let values = [];
  return set22.forEach((value) => {
    values.push(value);
  }), values;
}
__name(arrayFromSet2, "arrayFromSet");
function inspectSet2(set22, options) {
  return set22.size === 0 ? "Set{}" : (options.truncate -= 7, `Set{ ${inspectList2(arrayFromSet2(set22), options)} }`);
}
__name(inspectSet2, "inspectSet");
var stringEscapeChars2 = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), escapeCharacters2 = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, hex2 = 16, unicodeLength2 = 4;
function escape2(char) {
  return escapeCharacters2[char] || `\\u${`0000${char.charCodeAt(0).toString(hex2)}`.slice(-unicodeLength2)}`;
}
__name(escape2, "escape");
function inspectString2(string2, options) {
  return stringEscapeChars2.test(string2) && (string2 = string2.replace(stringEscapeChars2, escape2)), options.stylize(`'${truncate2(string2, options.truncate - 2)}'`, "string");
}
__name(inspectString2, "inspectString");
function inspectSymbol2(value) {
  return "description" in Symbol.prototype ? value.description ? `Symbol(${value.description})` : "Symbol()" : value.toString();
}
__name(inspectSymbol2, "inspectSymbol");
var getPromiseValue2 = /* @__PURE__ */ __name(() => "Promise{\u2026}", "getPromiseValue");
try {
  let { getPromiseDetails, kPending, kRejected } = process.binding("util");
  Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue2 = /* @__PURE__ */ __name((value, options) => {
    let [state, innerValue] = getPromiseDetails(value);
    return state === kPending ? "Promise{<pending>}" : `Promise${state === kRejected ? "!" : ""}{${options.inspect(innerValue, options)}}`;
  }, "getPromiseValue"));
} catch {
}
var promise_default2 = getPromiseValue2;
function inspectObject3(object2, options) {
  let properties = Object.getOwnPropertyNames(object2), symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
  if (properties.length === 0 && symbols.length === 0)
    return "{}";
  if (options.truncate -= 4, options.seen = options.seen || [], options.seen.includes(object2))
    return "[Circular]";
  options.seen.push(object2);
  let propertyContents = inspectList2(properties.map((key) => [key, object2[key]]), options, inspectProperty2), symbolContents = inspectList2(symbols.map((key) => [key, object2[key]]), options, inspectProperty2);
  options.seen.pop();
  let sep2 = "";
  return propertyContents && symbolContents && (sep2 = ", "), `{ ${propertyContents}${sep2}${symbolContents} }`;
}
__name(inspectObject3, "inspectObject");
var toStringTag2 = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function inspectClass2(value, options) {
  let name = "";
  return toStringTag2 && toStringTag2 in value && (name = value[toStringTag2]), name = name || value.constructor.name, (!name || name === "_class") && (name = "<Anonymous Class>"), options.truncate -= name.length, `${name}${inspectObject3(value, options)}`;
}
__name(inspectClass2, "inspectClass");
function inspectArguments2(args, options) {
  return args.length === 0 ? "Arguments[]" : (options.truncate -= 13, `Arguments[ ${inspectList2(args, options)} ]`);
}
__name(inspectArguments2, "inspectArguments");
var errorKeys2 = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject22(error, options) {
  let properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys2.indexOf(key) === -1), name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message == "string" ? message = truncate2(error.message, options.truncate) : properties.unshift("message"), message = message ? `: ${message}` : "", options.truncate -= message.length + 5, options.seen = options.seen || [], options.seen.includes(error))
    return "[Circular]";
  options.seen.push(error);
  let propertyContents = inspectList2(properties.map((key) => [key, error[key]]), options, inspectProperty2);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
__name(inspectObject22, "inspectObject");
function inspectAttribute2([key, value], options) {
  return options.truncate -= 3, value ? `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}` : `${options.stylize(String(key), "yellow")}`;
}
__name(inspectAttribute2, "inspectAttribute");
function inspectHTMLCollection2(collection, options) {
  return inspectList2(collection, options, inspectHTML2, `
`);
}
__name(inspectHTMLCollection2, "inspectHTMLCollection");
function inspectHTML2(element, options) {
  let properties = element.getAttributeNames(), name = element.tagName.toLowerCase(), head = options.stylize(`<${name}`, "special"), headClose = options.stylize(">", "special"), tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  properties.length > 0 && (propertyContents += " ", propertyContents += inspectList2(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute2, " ")), options.truncate -= propertyContents.length;
  let truncate22 = options.truncate, children = inspectHTMLCollection2(element.children, options);
  return children && children.length > truncate22 && (children = `${truncator2}(${element.children.length})`), `${head}${propertyContents}${headClose}${children}${tail}`;
}
__name(inspectHTML2, "inspectHTML");
var symbolsSupported2 = typeof Symbol == "function" && typeof Symbol.for == "function", chaiInspect2 = symbolsSupported2 ? Symbol.for("chai/inspect") : "@@chai/inspect", nodeInspect2 = !1;
try {
  let nodeUtil = require_util();
  nodeInspect2 = nodeUtil.inspect ? nodeUtil.inspect.custom : !1;
} catch {
  nodeInspect2 = !1;
}
var constructorMap2 = /* @__PURE__ */ new WeakMap(), stringTagMap2 = {}, baseTypesMap2 = {
  undefined: (value, options) => options.stylize("undefined", "undefined"),
  null: (value, options) => options.stylize("null", "null"),
  boolean: (value, options) => options.stylize(String(value), "boolean"),
  Boolean: (value, options) => options.stylize(String(value), "boolean"),
  number: inspectNumber2,
  Number: inspectNumber2,
  bigint: inspectBigInt2,
  BigInt: inspectBigInt2,
  string: inspectString2,
  String: inspectString2,
  function: inspectFunction2,
  Function: inspectFunction2,
  symbol: inspectSymbol2,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol2,
  Array: inspectArray2,
  Date: inspectDate2,
  Map: inspectMap2,
  Set: inspectSet2,
  RegExp: inspectRegExp2,
  Promise: promise_default2,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value, options) => options.stylize("WeakSet{\u2026}", "special"),
  WeakMap: (value, options) => options.stylize("WeakMap{\u2026}", "special"),
  Arguments: inspectArguments2,
  Int8Array: inspectTypedArray2,
  Uint8Array: inspectTypedArray2,
  Uint8ClampedArray: inspectTypedArray2,
  Int16Array: inspectTypedArray2,
  Uint16Array: inspectTypedArray2,
  Int32Array: inspectTypedArray2,
  Uint32Array: inspectTypedArray2,
  Float32Array: inspectTypedArray2,
  Float64Array: inspectTypedArray2,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject22,
  HTMLCollection: inspectHTMLCollection2,
  NodeList: inspectHTMLCollection2
}, inspectCustom2 = /* @__PURE__ */ __name((value, options, type3) => chaiInspect2 in value && typeof value[chaiInspect2] == "function" ? value[chaiInspect2](options) : nodeInspect2 && nodeInspect2 in value && typeof value[nodeInspect2] == "function" ? value[nodeInspect2](options.depth, options) : "inspect" in value && typeof value.inspect == "function" ? value.inspect(options.depth, options) : "constructor" in value && constructorMap2.has(value.constructor) ? constructorMap2.get(value.constructor)(value, options) : stringTagMap2[type3] ? stringTagMap2[type3](value, options) : "", "inspectCustom"), toString3 = Object.prototype.toString;
function inspect3(value, opts = {}) {
  let options = normaliseOptions2(opts, inspect3), { customInspect } = options, type3 = value === null ? "null" : typeof value;
  if (type3 === "object" && (type3 = toString3.call(value).slice(8, -1)), type3 in baseTypesMap2)
    return baseTypesMap2[type3](value, options);
  if (customInspect && value) {
    let output = inspectCustom2(value, options, type3);
    if (output)
      return typeof output == "string" ? output : inspect3(output, options);
  }
  let proto = value ? Object.getPrototypeOf(value) : !1;
  return proto === Object.prototype || proto === null ? inspectObject3(value, options) : value && typeof HTMLElement == "function" && value instanceof HTMLElement ? inspectHTML2(value, options) : "constructor" in value ? value.constructor !== Object ? inspectClass2(value, options) : inspectObject3(value, options) : value === Object(value) ? inspectObject3(value, options) : options.stylize(String(value), type3);
}
__name(inspect3, "inspect");
var config = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function inspect22(obj, showHidden, depth, colors) {
  var options = {
    colors,
    depth: typeof depth > "u" ? 2 : depth,
    showHidden,
    truncate: config.truncateThreshold ? config.truncateThreshold : 1 / 0
  };
  return inspect3(obj, options);
}
__name(inspect22, "inspect");
function objDisplay2(obj) {
  var str = inspect22(obj), type3 = Object.prototype.toString.call(obj);
  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type3 === "[object Function]")
      return !obj.name || obj.name === "" ? "[Function]" : "[Function: " + obj.name + "]";
    if (type3 === "[object Array]")
      return "[ Array(" + obj.length + ") ]";
    if (type3 === "[object Object]") {
      var keys2 = Object.keys(obj), kstr = keys2.length > 2 ? keys2.splice(0, 2).join(", ") + ", ..." : keys2.join(", ");
      return "{ Object (" + kstr + ") }";
    } else
      return str;
  } else
    return str;
}
__name(objDisplay2, "objDisplay");
function getMessage2(obj, args) {
  var negate = flag(obj, "negate"), val = flag(obj, "object"), expected = args[3], actual = getActual(obj, args), msg = negate ? args[2] : args[1], flagMsg = flag(obj, "message");
  return typeof msg == "function" && (msg = msg()), msg = msg || "", msg = msg.replace(/#\{this\}/g, function() {
    return objDisplay2(val);
  }).replace(/#\{act\}/g, function() {
    return objDisplay2(actual);
  }).replace(/#\{exp\}/g, function() {
    return objDisplay2(expected);
  }), flagMsg ? flagMsg + ": " + msg : msg;
}
__name(getMessage2, "getMessage");
function transferFlags(assertion, object2, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = /* @__PURE__ */ Object.create(null));
  object2.__flags || (object2.__flags = /* @__PURE__ */ Object.create(null)), includeAll = arguments.length === 3 ? includeAll : !0;
  for (var flag3 in flags)
    (includeAll || flag3 !== "object" && flag3 !== "ssfi" && flag3 !== "lockSsfi" && flag3 != "message") && (object2.__flags[flag3] = flags[flag3]);
}
__name(transferFlags, "transferFlags");
function type2(obj) {
  if (typeof obj > "u")
    return "undefined";
  if (obj === null)
    return "null";
  let stringTag = obj[Symbol.toStringTag];
  return typeof stringTag == "string" ? stringTag : Object.prototype.toString.call(obj).slice(8, -1);
}
__name(type2, "type");
function FakeMap() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
__name(FakeMap, "FakeMap");
FakeMap.prototype = {
  get: /* @__PURE__ */ __name(function(key) {
    return key[this._key];
  }, "get"),
  set: /* @__PURE__ */ __name(function(key, value) {
    Object.isExtensible(key) && Object.defineProperty(key, this._key, {
      value,
      configurable: !0
    });
  }, "set")
};
var MemoizeMap = typeof WeakMap == "function" ? WeakMap : FakeMap;
function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
  if (!memoizeMap || isPrimitive2(leftHandOperand) || isPrimitive2(rightHandOperand))
    return null;
  var leftHandMap = memoizeMap.get(leftHandOperand);
  if (leftHandMap) {
    var result = leftHandMap.get(rightHandOperand);
    if (typeof result == "boolean")
      return result;
  }
  return null;
}
__name(memoizeCompare, "memoizeCompare");
function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
  if (!(!memoizeMap || isPrimitive2(leftHandOperand) || isPrimitive2(rightHandOperand))) {
    var leftHandMap = memoizeMap.get(leftHandOperand);
    leftHandMap ? leftHandMap.set(rightHandOperand, result) : (leftHandMap = new MemoizeMap(), leftHandMap.set(rightHandOperand, result), memoizeMap.set(leftHandOperand, leftHandMap));
  }
}
__name(memoizeSet, "memoizeSet");
var deep_eql_default = deepEqual;
function deepEqual(leftHandOperand, rightHandOperand, options) {
  if (options && options.comparator)
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
  var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
  return simpleResult !== null ? simpleResult : extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
__name(deepEqual, "deepEqual");
function simpleEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand === rightHandOperand ? leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand : leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
  rightHandOperand !== rightHandOperand ? !0 : isPrimitive2(leftHandOperand) || isPrimitive2(rightHandOperand) ? !1 : null;
}
__name(simpleEqual, "simpleEqual");
function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
  options = options || {}, options.memoize = options.memoize === !1 ? !1 : options.memoize || new MemoizeMap();
  var comparator = options && options.comparator, memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
  if (memoizeResultLeft !== null)
    return memoizeResultLeft;
  var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
  if (memoizeResultRight !== null)
    return memoizeResultRight;
  if (comparator) {
    var comparatorResult = comparator(leftHandOperand, rightHandOperand);
    if (comparatorResult === !1 || comparatorResult === !0)
      return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult), comparatorResult;
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null)
      return simpleResult;
  }
  var leftHandType = type2(leftHandOperand);
  if (leftHandType !== type2(rightHandOperand))
    return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, !1), !1;
  memoizeSet(leftHandOperand, rightHandOperand, options.memoize, !0);
  var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
  return memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result), result;
}
__name(extensiveDeepEqual, "extensiveDeepEqual");
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
  switch (leftHandType) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return leftHandOperand === rightHandOperand;
    case "Error":
      return keysEqual(leftHandOperand, rightHandOperand, ["name", "message", "code"], options);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return iterableEqual(leftHandOperand, rightHandOperand, options);
    case "RegExp":
      return regexpEqual(leftHandOperand, rightHandOperand);
    case "Generator":
      return generatorEqual(leftHandOperand, rightHandOperand, options);
    case "DataView":
      return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
    case "ArrayBuffer":
      return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
    case "Set":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Map":
      return entriesEqual(leftHandOperand, rightHandOperand, options);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return leftHandOperand.equals(rightHandOperand);
    case "Temporal.Duration":
      return leftHandOperand.total("nanoseconds") === rightHandOperand.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return leftHandOperand.toString() === rightHandOperand.toString();
    default:
      return objectEqual(leftHandOperand, rightHandOperand, options);
  }
}
__name(extensiveDeepEqualByType, "extensiveDeepEqualByType");
function regexpEqual(leftHandOperand, rightHandOperand) {
  return leftHandOperand.toString() === rightHandOperand.toString();
}
__name(regexpEqual, "regexpEqual");
function entriesEqual(leftHandOperand, rightHandOperand, options) {
  try {
    if (leftHandOperand.size !== rightHandOperand.size)
      return !1;
    if (leftHandOperand.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var leftHandItems = [], rightHandItems = [];
  return leftHandOperand.forEach(/* @__PURE__ */ __name(function(key, value) {
    leftHandItems.push([key, value]);
  }, "gatherEntries")), rightHandOperand.forEach(/* @__PURE__ */ __name(function(key, value) {
    rightHandItems.push([key, value]);
  }, "gatherEntries")), iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
__name(entriesEqual, "entriesEqual");
function iterableEqual(leftHandOperand, rightHandOperand, options) {
  var length = leftHandOperand.length;
  if (length !== rightHandOperand.length)
    return !1;
  if (length === 0)
    return !0;
  for (var index2 = -1; ++index2 < length; )
    if (deepEqual(leftHandOperand[index2], rightHandOperand[index2], options) === !1)
      return !1;
  return !0;
}
__name(iterableEqual, "iterableEqual");
function generatorEqual(leftHandOperand, rightHandOperand, options) {
  return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
__name(generatorEqual, "generatorEqual");
function hasIteratorFunction(target) {
  return typeof Symbol < "u" && typeof target == "object" && typeof Symbol.iterator < "u" && typeof target[Symbol.iterator] == "function";
}
__name(hasIteratorFunction, "hasIteratorFunction");
function getIteratorEntries(target) {
  if (hasIteratorFunction(target))
    try {
      return getGeneratorEntries(target[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
__name(getIteratorEntries, "getIteratorEntries");
function getGeneratorEntries(generator) {
  for (var generatorResult = generator.next(), accumulator = [generatorResult.value]; generatorResult.done === !1; )
    generatorResult = generator.next(), accumulator.push(generatorResult.value);
  return accumulator;
}
__name(getGeneratorEntries, "getGeneratorEntries");
function getEnumerableKeys(target) {
  var keys2 = [];
  for (var key in target)
    keys2.push(key);
  return keys2;
}
__name(getEnumerableKeys, "getEnumerableKeys");
function getEnumerableSymbols(target) {
  for (var keys2 = [], allKeys = Object.getOwnPropertySymbols(target), i = 0; i < allKeys.length; i += 1) {
    var key = allKeys[i];
    Object.getOwnPropertyDescriptor(target, key).enumerable && keys2.push(key);
  }
  return keys2;
}
__name(getEnumerableSymbols, "getEnumerableSymbols");
function keysEqual(leftHandOperand, rightHandOperand, keys2, options) {
  var length = keys2.length;
  if (length === 0)
    return !0;
  for (var i = 0; i < length; i += 1)
    if (deepEqual(leftHandOperand[keys2[i]], rightHandOperand[keys2[i]], options) === !1)
      return !1;
  return !0;
}
__name(keysEqual, "keysEqual");
function objectEqual(leftHandOperand, rightHandOperand, options) {
  var leftHandKeys = getEnumerableKeys(leftHandOperand), rightHandKeys = getEnumerableKeys(rightHandOperand), leftHandSymbols = getEnumerableSymbols(leftHandOperand), rightHandSymbols = getEnumerableSymbols(rightHandOperand);
  if (leftHandKeys = leftHandKeys.concat(leftHandSymbols), rightHandKeys = rightHandKeys.concat(rightHandSymbols), leftHandKeys.length && leftHandKeys.length === rightHandKeys.length)
    return iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === !1 ? !1 : keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
  var leftHandEntries = getIteratorEntries(leftHandOperand), rightHandEntries = getIteratorEntries(rightHandOperand);
  return leftHandEntries.length && leftHandEntries.length === rightHandEntries.length ? (leftHandEntries.sort(), rightHandEntries.sort(), iterableEqual(leftHandEntries, rightHandEntries, options)) : leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0;
}
__name(objectEqual, "objectEqual");
function isPrimitive2(value) {
  return value === null || typeof value != "object";
}
__name(isPrimitive2, "isPrimitive");
function mapSymbols(arr) {
  return arr.map(/* @__PURE__ */ __name(function(entry) {
    return typeof entry == "symbol" ? entry.toString() : entry;
  }, "mapSymbol"));
}
__name(mapSymbols, "mapSymbols");
function hasProperty(obj, name) {
  return typeof obj > "u" || obj === null ? !1 : name in Object(obj);
}
__name(hasProperty, "hasProperty");
function parsePath(path) {
  return path.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((value) => {
    if (value === "constructor" || value === "__proto__" || value === "prototype")
      return {};
    let mArr = /^\[(\d+)\]$/.exec(value), parsed = null;
    return mArr ? parsed = { i: parseFloat(mArr[1]) } : parsed = { p: value.replace(/\\([.[\]])/g, "$1") }, parsed;
  });
}
__name(parsePath, "parsePath");
function internalGetPathValue(obj, parsed, pathDepth) {
  let temporaryValue = obj, res = null;
  pathDepth = typeof pathDepth > "u" ? parsed.length : pathDepth;
  for (let i = 0; i < pathDepth; i++) {
    let part = parsed[i];
    temporaryValue && (typeof part.p > "u" ? temporaryValue = temporaryValue[part.i] : temporaryValue = temporaryValue[part.p], i === pathDepth - 1 && (res = temporaryValue));
  }
  return res;
}
__name(internalGetPathValue, "internalGetPathValue");
function getPathInfo(obj, path) {
  let parsed = parsePath(path), last = parsed[parsed.length - 1], info = {
    parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
    name: last.p || last.i,
    value: internalGetPathValue(obj, parsed)
  };
  return info.exists = hasProperty(info.parent, info.name), info;
}
__name(getPathInfo, "getPathInfo");
function Assertion(obj, msg, ssfi, lockSsfi) {
  return flag(this, "ssfi", ssfi || Assertion), flag(this, "lockSsfi", lockSsfi), flag(this, "object", obj), flag(this, "message", msg), flag(this, "eql", config.deepEqual || deep_eql_default), proxify(this);
}
__name(Assertion, "Assertion");
Object.defineProperty(Assertion, "includeStack", {
  get: function() {
    return console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), config.includeStack;
  },
  set: function(value) {
    console.warn(
      "Assertion.includeStack is deprecated, use chai.config.includeStack instead."
    ), config.includeStack = value;
  }
});
Object.defineProperty(Assertion, "showDiff", {
  get: function() {
    return console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), config.showDiff;
  },
  set: function(value) {
    console.warn(
      "Assertion.showDiff is deprecated, use chai.config.showDiff instead."
    ), config.showDiff = value;
  }
});
Assertion.addProperty = function(name, fn2) {
  addProperty(this.prototype, name, fn2);
};
Assertion.addMethod = function(name, fn2) {
  addMethod(this.prototype, name, fn2);
};
Assertion.addChainableMethod = function(name, fn2, chainingBehavior) {
  addChainableMethod(this.prototype, name, fn2, chainingBehavior);
};
Assertion.overwriteProperty = function(name, fn2) {
  overwriteProperty(this.prototype, name, fn2);
};
Assertion.overwriteMethod = function(name, fn2) {
  overwriteMethod(this.prototype, name, fn2);
};
Assertion.overwriteChainableMethod = function(name, fn2, chainingBehavior) {
  overwriteChainableMethod(this.prototype, name, fn2, chainingBehavior);
};
Assertion.prototype.assert = function(expr, msg, negateMsg, expected, _actual, showDiff) {
  var ok = test3(this, arguments);
  if (showDiff !== !1 && (showDiff = !0), expected === void 0 && _actual === void 0 && (showDiff = !1), config.showDiff !== !0 && (showDiff = !1), !ok) {
    msg = getMessage2(this, arguments);
    var actual = getActual(this, arguments), assertionErrorObjectProperties = {
      actual,
      expected,
      showDiff
    }, operator = getOperator(this, arguments);
    throw operator && (assertionErrorObjectProperties.operator = operator), new AssertionError(
      msg,
      assertionErrorObjectProperties,
      config.includeStack ? this.assert : flag(this, "ssfi")
    );
  }
};
Object.defineProperty(Assertion.prototype, "_obj", {
  get: function() {
    return flag(this, "object");
  },
  set: function(val) {
    flag(this, "object", val);
  }
});
function isProxyEnabled() {
  return config.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
__name(isProxyEnabled, "isProxyEnabled");
function addProperty(ctx, name, getter) {
  getter = getter === void 0 ? function() {
  } : getter, Object.defineProperty(ctx, name, {
    get: /* @__PURE__ */ __name(function propertyGetter() {
      !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", propertyGetter);
      var result = getter.call(this);
      if (result !== void 0)
        return result;
      var newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "propertyGetter"),
    configurable: !0
  });
}
__name(addProperty, "addProperty");
var fnLengthDesc = Object.getOwnPropertyDescriptor(function() {
}, "length");
function addLengthGuard(fn2, assertionName, isChainable) {
  return fnLengthDesc.configurable && Object.defineProperty(fn2, "length", {
    get: function() {
      throw Error(
        isChainable ? "Invalid Chai property: " + assertionName + '.length. Due to a compatibility issue, "length" cannot directly follow "' + assertionName + '". Use "' + assertionName + '.lengthOf" instead.' : "Invalid Chai property: " + assertionName + '.length. See docs for proper usage of "' + assertionName + '".'
      );
    }
  }), fn2;
}
__name(addLengthGuard, "addLengthGuard");
function getProperties(object2) {
  var result = Object.getOwnPropertyNames(object2);
  function addProperty2(property) {
    result.indexOf(property) === -1 && result.push(property);
  }
  __name(addProperty2, "addProperty");
  for (var proto = Object.getPrototypeOf(object2); proto !== null; )
    Object.getOwnPropertyNames(proto).forEach(addProperty2), proto = Object.getPrototypeOf(proto);
  return result;
}
__name(getProperties, "getProperties");
var builtins = ["__flags", "__methods", "_obj", "assert"];
function proxify(obj, nonChainableMethodName) {
  return isProxyEnabled() ? new Proxy(obj, {
    get: /* @__PURE__ */ __name(function proxyGetter(target, property) {
      if (typeof property == "string" && config.proxyExcludedKeys.indexOf(property) === -1 && !Reflect.has(target, property)) {
        if (nonChainableMethodName)
          throw Error(
            "Invalid Chai property: " + nonChainableMethodName + "." + property + '. See docs for proper usage of "' + nonChainableMethodName + '".'
          );
        var suggestion = null, suggestionDistance = 4;
        throw getProperties(target).forEach(function(prop) {
          if (
            // we actually mean to check `Object.prototype` here
            // eslint-disable-next-line no-prototype-builtins
            !Object.prototype.hasOwnProperty(prop) && builtins.indexOf(prop) === -1
          ) {
            var dist = stringDistanceCapped(property, prop, suggestionDistance);
            dist < suggestionDistance && (suggestion = prop, suggestionDistance = dist);
          }
        }), Error(
          suggestion !== null ? "Invalid Chai property: " + property + '. Did you mean "' + suggestion + '"?' : "Invalid Chai property: " + property
        );
      }
      return builtins.indexOf(property) === -1 && !flag(target, "lockSsfi") && flag(target, "ssfi", proxyGetter), Reflect.get(target, property);
    }, "proxyGetter")
  }) : obj;
}
__name(proxify, "proxify");
function stringDistanceCapped(strA, strB, cap) {
  if (Math.abs(strA.length - strB.length) >= cap)
    return cap;
  var memo = [];
  for (let i = 0; i <= strA.length; i++)
    memo[i] = Array(strB.length + 1).fill(0), memo[i][0] = i;
  for (let j = 0; j < strB.length; j++)
    memo[0][j] = j;
  for (let i = 1; i <= strA.length; i++) {
    var ch = strA.charCodeAt(i - 1);
    for (let j = 1; j <= strB.length; j++) {
      if (Math.abs(i - j) >= cap) {
        memo[i][j] = cap;
        continue;
      }
      memo[i][j] = Math.min(
        memo[i - 1][j] + 1,
        memo[i][j - 1] + 1,
        memo[i - 1][j - 1] + (ch === strB.charCodeAt(j - 1) ? 0 : 1)
      );
    }
  }
  return memo[strA.length][strB.length];
}
__name(stringDistanceCapped, "stringDistanceCapped");
function addMethod(ctx, name, method) {
  var methodWrapper = /* @__PURE__ */ __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", methodWrapper);
    var result = method.apply(this, arguments);
    if (result !== void 0)
      return result;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "methodWrapper");
  addLengthGuard(methodWrapper, name, !1), ctx[name] = proxify(methodWrapper, name);
}
__name(addMethod, "addMethod");
function overwriteProperty(ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name), _super = /* @__PURE__ */ __name(function() {
  }, "_super");
  _get && typeof _get.get == "function" && (_super = _get.get), Object.defineProperty(ctx, name, {
    get: /* @__PURE__ */ __name(function overwritingPropertyGetter() {
      !isProxyEnabled() && !flag(this, "lockSsfi") && flag(this, "ssfi", overwritingPropertyGetter);
      var origLockSsfi = flag(this, "lockSsfi");
      flag(this, "lockSsfi", !0);
      var result = getter(_super).call(this);
      if (flag(this, "lockSsfi", origLockSsfi), result !== void 0)
        return result;
      var newAssertion = new Assertion();
      return transferFlags(this, newAssertion), newAssertion;
    }, "overwritingPropertyGetter"),
    configurable: !0
  });
}
__name(overwriteProperty, "overwriteProperty");
function overwriteMethod(ctx, name, method) {
  var _method = ctx[name], _super = /* @__PURE__ */ __name(function() {
    throw new Error(name + " is not a function");
  }, "_super");
  _method && typeof _method == "function" && (_super = _method);
  var overwritingMethodWrapper = /* @__PURE__ */ __name(function() {
    flag(this, "lockSsfi") || flag(this, "ssfi", overwritingMethodWrapper);
    var origLockSsfi = flag(this, "lockSsfi");
    flag(this, "lockSsfi", !0);
    var result = method(_super).apply(this, arguments);
    if (flag(this, "lockSsfi", origLockSsfi), result !== void 0)
      return result;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingMethodWrapper");
  addLengthGuard(overwritingMethodWrapper, name, !1), ctx[name] = proxify(overwritingMethodWrapper, name);
}
__name(overwriteMethod, "overwriteMethod");
var canSetPrototype = typeof Object.setPrototypeOf == "function", testFn = /* @__PURE__ */ __name(function() {
}, "testFn"), excludeNames = Object.getOwnPropertyNames(testFn).filter(function(name) {
  var propDesc = Object.getOwnPropertyDescriptor(testFn, name);
  return typeof propDesc != "object" ? !0 : !propDesc.configurable;
}), call = Function.prototype.call, apply = Function.prototype.apply;
function addChainableMethod(ctx, name, method, chainingBehavior) {
  typeof chainingBehavior != "function" && (chainingBehavior = /* @__PURE__ */ __name(function() {
  }, "chainingBehavior"));
  var chainableBehavior = {
    method,
    chainingBehavior
  };
  ctx.__methods || (ctx.__methods = {}), ctx.__methods[name] = chainableBehavior, Object.defineProperty(ctx, name, {
    get: /* @__PURE__ */ __name(function() {
      chainableBehavior.chainingBehavior.call(this);
      var chainableMethodWrapper = /* @__PURE__ */ __name(function() {
        flag(this, "lockSsfi") || flag(this, "ssfi", chainableMethodWrapper);
        var result = chainableBehavior.method.apply(this, arguments);
        if (result !== void 0)
          return result;
        var newAssertion = new Assertion();
        return transferFlags(this, newAssertion), newAssertion;
      }, "chainableMethodWrapper");
      if (addLengthGuard(chainableMethodWrapper, name, !0), canSetPrototype) {
        var prototype = Object.create(this);
        prototype.call = call, prototype.apply = apply, Object.setPrototypeOf(chainableMethodWrapper, prototype);
      } else {
        var asserterNames = Object.getOwnPropertyNames(ctx);
        asserterNames.forEach(function(asserterName) {
          if (excludeNames.indexOf(asserterName) === -1) {
            var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
            Object.defineProperty(chainableMethodWrapper, asserterName, pd);
          }
        });
      }
      return transferFlags(this, chainableMethodWrapper), proxify(chainableMethodWrapper);
    }, "chainableMethodGetter"),
    configurable: !0
  });
}
__name(addChainableMethod, "addChainableMethod");
function overwriteChainableMethod(ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name], _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = /* @__PURE__ */ __name(function() {
    var result = chainingBehavior(_chainingBehavior).call(this);
    if (result !== void 0)
      return result;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodGetter");
  var _method = chainableBehavior.method;
  chainableBehavior.method = /* @__PURE__ */ __name(function() {
    var result = method(_method).apply(this, arguments);
    if (result !== void 0)
      return result;
    var newAssertion = new Assertion();
    return transferFlags(this, newAssertion), newAssertion;
  }, "overwritingChainableMethodWrapper");
}
__name(overwriteChainableMethod, "overwriteChainableMethod");
function compareByInspect(a3, b) {
  return inspect22(a3) < inspect22(b) ? -1 : 1;
}
__name(compareByInspect, "compareByInspect");
function getOwnEnumerablePropertySymbols(obj) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(obj).filter(function(sym) {
    return Object.getOwnPropertyDescriptor(obj, sym).enumerable;
  });
}
__name(getOwnEnumerablePropertySymbols, "getOwnEnumerablePropertySymbols");
function getOwnEnumerableProperties(obj) {
  return Object.keys(obj).concat(getOwnEnumerablePropertySymbols(obj));
}
__name(getOwnEnumerableProperties, "getOwnEnumerableProperties");
var isNaN22 = Number.isNaN;
function isObjectType(obj) {
  var objectType = type(obj), objectTypes = ["Array", "Object", "Function"];
  return objectTypes.indexOf(objectType) !== -1;
}
__name(isObjectType, "isObjectType");
function getOperator(obj, args) {
  var operator = flag(obj, "operator"), negate = flag(obj, "negate"), expected = args[3], msg = negate ? args[2] : args[1];
  if (operator)
    return operator;
  if (typeof msg == "function" && (msg = msg()), msg = msg || "", !!msg && !/\shave\s/.test(msg)) {
    var isObject3 = isObjectType(expected);
    return /\snot\s/.test(msg) ? isObject3 ? "notDeepStrictEqual" : "notStrictEqual" : isObject3 ? "deepStrictEqual" : "strictEqual";
  }
}
__name(getOperator, "getOperator");
function getName(fn2) {
  return fn2.name;
}
__name(getName, "getName");
function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
}
__name(isRegExp2, "isRegExp");
function isNumeric(obj) {
  return ["Number", "BigInt"].includes(type(obj));
}
__name(isNumeric, "isNumeric");
var { flag: flag2 } = utils_exports;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(chain) {
  Assertion.addProperty(chain);
});
Assertion.addProperty("not", function() {
  flag2(this, "negate", !0);
});
Assertion.addProperty("deep", function() {
  flag2(this, "deep", !0);
});
Assertion.addProperty("nested", function() {
  flag2(this, "nested", !0);
});
Assertion.addProperty("own", function() {
  flag2(this, "own", !0);
});
Assertion.addProperty("ordered", function() {
  flag2(this, "ordered", !0);
});
Assertion.addProperty("any", function() {
  flag2(this, "any", !0), flag2(this, "all", !1);
});
Assertion.addProperty("all", function() {
  flag2(this, "all", !0), flag2(this, "any", !1);
});
var functionTypes = {
  function: [
    "function",
    "asyncfunction",
    "generatorfunction",
    "asyncgeneratorfunction"
  ],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function an(type3, msg) {
  msg && flag2(this, "message", msg), type3 = type3.toLowerCase();
  var obj = flag2(this, "object"), article = ~["a", "e", "i", "o", "u"].indexOf(type3.charAt(0)) ? "an " : "a ";
  let detectedType = type(obj).toLowerCase();
  functionTypes.function.includes(type3) ? this.assert(
    functionTypes[type3].includes(detectedType),
    "expected #{this} to be " + article + type3,
    "expected #{this} not to be " + article + type3
  ) : this.assert(
    type3 === detectedType,
    "expected #{this} to be " + article + type3,
    "expected #{this} not to be " + article + type3
  );
}
__name(an, "an");
Assertion.addChainableMethod("an", an);
Assertion.addChainableMethod("a", an);
function SameValueZero(a3, b) {
  return isNaN22(a3) && isNaN22(b) || a3 === b;
}
__name(SameValueZero, "SameValueZero");
function includeChainingBehavior() {
  flag2(this, "contains", !0);
}
__name(includeChainingBehavior, "includeChainingBehavior");
function include(val, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), negate = flag2(this, "negate"), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), descriptor = isDeep ? "deep " : "", isEql = isDeep ? flag2(this, "eql") : SameValueZero;
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var included = !1;
  switch (objType) {
    case "string":
      included = obj.indexOf(val) !== -1;
      break;
    case "weakset":
      if (isDeep)
        throw new AssertionError(
          flagMsg + "unable to use .deep.include with WeakSet",
          void 0,
          ssfi
        );
      included = obj.has(val);
      break;
    case "map":
      obj.forEach(function(item) {
        included = included || isEql(item, val);
      });
      break;
    case "set":
      isDeep ? obj.forEach(function(item) {
        included = included || isEql(item, val);
      }) : included = obj.has(val);
      break;
    case "array":
      isDeep ? included = obj.some(function(item) {
        return isEql(item, val);
      }) : included = obj.indexOf(val) !== -1;
      break;
    default:
      if (val !== Object(val))
        throw new AssertionError(
          flagMsg + "the given combination of arguments (" + objType + " and " + type(val).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + type(val).toLowerCase(),
          void 0,
          ssfi
        );
      var props = Object.keys(val), firstErr = null, numErrs = 0;
      if (props.forEach(function(prop) {
        var propAssertion = new Assertion(obj);
        if (transferFlags(this, propAssertion, !0), flag2(propAssertion, "lockSsfi", !0), !negate || props.length === 1) {
          propAssertion.property(prop, val[prop]);
          return;
        }
        try {
          propAssertion.property(prop, val[prop]);
        } catch (err) {
          if (!check_error_exports.compatibleConstructor(err, AssertionError))
            throw err;
          firstErr === null && (firstErr = err), numErrs++;
        }
      }, this), negate && props.length > 1 && numErrs === props.length)
        throw firstErr;
      return;
  }
  this.assert(
    included,
    "expected #{this} to " + descriptor + "include " + inspect22(val),
    "expected #{this} to not " + descriptor + "include " + inspect22(val)
  );
}
__name(include, "include");
Assertion.addChainableMethod("include", include, includeChainingBehavior);
Assertion.addChainableMethod("contain", include, includeChainingBehavior);
Assertion.addChainableMethod("contains", include, includeChainingBehavior);
Assertion.addChainableMethod("includes", include, includeChainingBehavior);
Assertion.addProperty("ok", function() {
  this.assert(
    flag2(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
Assertion.addProperty("true", function() {
  this.assert(
    flag2(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !flag2(this, "negate")
  );
});
Assertion.addProperty("numeric", function() {
  let object2 = flag2(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(type(object2)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !flag2(this, "negate")
  );
});
Assertion.addProperty("callable", function() {
  let val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), message = flag2(this, "message"), msg = message ? `${message}: ` : "", negate = flag2(this, "negate"), assertionMessage = negate ? `${msg}expected ${inspect22(val)} not to be a callable function` : `${msg}expected ${inspect22(val)} to be a callable function`, isCallable = [
    "Function",
    "AsyncFunction",
    "GeneratorFunction",
    "AsyncGeneratorFunction"
  ].includes(type(val));
  if (isCallable && negate || !isCallable && !negate)
    throw new AssertionError(assertionMessage, void 0, ssfi);
});
Assertion.addProperty("false", function() {
  this.assert(
    flag2(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!flag2(this, "negate")
  );
});
Assertion.addProperty("null", function() {
  this.assert(
    flag2(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
Assertion.addProperty("undefined", function() {
  this.assert(
    flag2(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
Assertion.addProperty("NaN", function() {
  this.assert(
    isNaN22(flag2(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function assertExist() {
  var val = flag2(this, "object");
  this.assert(
    val != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
__name(assertExist, "assertExist");
Assertion.addProperty("exist", assertExist);
Assertion.addProperty("exists", assertExist);
Assertion.addProperty("empty", function() {
  var val = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), itemsCount;
  switch (flagMsg = flagMsg ? flagMsg + ": " : "", type(val).toLowerCase()) {
    case "array":
    case "string":
      itemsCount = val.length;
      break;
    case "map":
    case "set":
      itemsCount = val.size;
      break;
    case "weakmap":
    case "weakset":
      throw new AssertionError(
        flagMsg + ".empty was passed a weak collection",
        void 0,
        ssfi
      );
    case "function":
      var msg = flagMsg + ".empty was passed a function " + getName(val);
      throw new AssertionError(msg.trim(), void 0, ssfi);
    default:
      if (val !== Object(val))
        throw new AssertionError(
          flagMsg + ".empty was passed non-string primitive " + inspect22(val),
          void 0,
          ssfi
        );
      itemsCount = Object.keys(val).length;
  }
  this.assert(
    itemsCount === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function checkArguments() {
  var obj = flag2(this, "object"), type3 = type(obj);
  this.assert(
    type3 === "Arguments",
    "expected #{this} to be arguments but got " + type3,
    "expected #{this} to not be arguments"
  );
}
__name(checkArguments, "checkArguments");
Assertion.addProperty("arguments", checkArguments);
Assertion.addProperty("Arguments", checkArguments);
function assertEqual(val, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object");
  if (flag2(this, "deep")) {
    var prevLockSsfi = flag2(this, "lockSsfi");
    flag2(this, "lockSsfi", !0), this.eql(val), flag2(this, "lockSsfi", prevLockSsfi);
  } else
    this.assert(
      val === obj,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      val,
      this._obj,
      !0
    );
}
__name(assertEqual, "assertEqual");
Assertion.addMethod("equal", assertEqual);
Assertion.addMethod("equals", assertEqual);
Assertion.addMethod("eq", assertEqual);
function assertEql(obj, msg) {
  msg && flag2(this, "message", msg);
  var eql = flag2(this, "eql");
  this.assert(
    eql(obj, flag2(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    obj,
    this._obj,
    !0
  );
}
__name(assertEql, "assertEql");
Assertion.addMethod("eql", assertEql);
Assertion.addMethod("eqls", assertEql);
function assertAbove(n, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase();
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    throw new AssertionError(
      msgPrefix + "the argument to above must be a date",
      void 0,
      ssfi
    );
  if (!isNumeric(n) && (doLength || isNumeric(obj)))
    throw new AssertionError(
      msgPrefix + "the argument to above must be a number",
      void 0,
      ssfi
    );
  if (!doLength && objType !== "date" && !isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    throw new AssertionError(
      msgPrefix + "expected " + printObj + " to be a number or a date",
      void 0,
      ssfi
    );
  }
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount > n,
      "expected #{this} to have a " + descriptor + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " above #{exp}",
      n,
      itemsCount
    );
  } else
    this.assert(
      obj > n,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      n
    );
}
__name(assertAbove, "assertAbove");
Assertion.addMethod("above", assertAbove);
Assertion.addMethod("gt", assertAbove);
Assertion.addMethod("greaterThan", assertAbove);
function assertLeast(n, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = !0;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to least must be a date";
  else if (!isNumeric(n) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to least must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount >= n,
      "expected #{this} to have a " + descriptor + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " below #{exp}",
      n,
      itemsCount
    );
  } else
    this.assert(
      obj >= n,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      n
    );
}
__name(assertLeast, "assertLeast");
Assertion.addMethod("least", assertLeast);
Assertion.addMethod("gte", assertLeast);
Assertion.addMethod("greaterThanOrEqual", assertLeast);
function assertBelow(n, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = !0;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to below must be a date";
  else if (!isNumeric(n) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to below must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount < n,
      "expected #{this} to have a " + descriptor + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + descriptor + " below #{exp}",
      n,
      itemsCount
    );
  } else
    this.assert(
      obj < n,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      n
    );
}
__name(assertBelow, "assertBelow");
Assertion.addMethod("below", assertBelow);
Assertion.addMethod("lt", assertBelow);
Assertion.addMethod("lessThan", assertBelow);
function assertMost(n, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), nType = type(n).toLowerCase(), errorMessage, shouldThrow = !0;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && nType !== "date")
    errorMessage = msgPrefix + "the argument to most must be a date";
  else if (!isNumeric(n) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the argument to most must be a number";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount <= n,
      "expected #{this} to have a " + descriptor + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + descriptor + " above #{exp}",
      n,
      itemsCount
    );
  } else
    this.assert(
      obj <= n,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      n
    );
}
__name(assertMost, "assertMost");
Assertion.addMethod("most", assertMost);
Assertion.addMethod("lte", assertMost);
Assertion.addMethod("lessThanOrEqual", assertMost);
Assertion.addMethod("within", function(start, finish, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), doLength = flag2(this, "doLength"), flagMsg = flag2(this, "message"), msgPrefix = flagMsg ? flagMsg + ": " : "", ssfi = flag2(this, "ssfi"), objType = type(obj).toLowerCase(), startType = type(start).toLowerCase(), finishType = type(finish).toLowerCase(), errorMessage, shouldThrow = !0, range = startType === "date" && finishType === "date" ? start.toISOString() + ".." + finish.toISOString() : start + ".." + finish;
  if (doLength && objType !== "map" && objType !== "set" && new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), !doLength && objType === "date" && (startType !== "date" || finishType !== "date"))
    errorMessage = msgPrefix + "the arguments to within must be dates";
  else if ((!isNumeric(start) || !isNumeric(finish)) && (doLength || isNumeric(obj)))
    errorMessage = msgPrefix + "the arguments to within must be numbers";
  else if (!doLength && objType !== "date" && !isNumeric(obj)) {
    var printObj = objType === "string" ? "'" + obj + "'" : obj;
    errorMessage = msgPrefix + "expected " + printObj + " to be a number or a date";
  } else
    shouldThrow = !1;
  if (shouldThrow)
    throw new AssertionError(errorMessage, void 0, ssfi);
  if (doLength) {
    var descriptor = "length", itemsCount;
    objType === "map" || objType === "set" ? (descriptor = "size", itemsCount = obj.size) : itemsCount = obj.length, this.assert(
      itemsCount >= start && itemsCount <= finish,
      "expected #{this} to have a " + descriptor + " within " + range,
      "expected #{this} to not have a " + descriptor + " within " + range
    );
  } else
    this.assert(
      obj >= start && obj <= finish,
      "expected #{this} to be within " + range,
      "expected #{this} to not be within " + range
    );
});
function assertInstanceOf(constructor, msg) {
  msg && flag2(this, "message", msg);
  var target = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message");
  try {
    var isInstanceOf = target instanceof constructor;
  } catch (err) {
    throw err instanceof TypeError ? (flagMsg = flagMsg ? flagMsg + ": " : "", new AssertionError(
      flagMsg + "The instanceof assertion needs a constructor but " + type(constructor) + " was given.",
      void 0,
      ssfi
    )) : err;
  }
  var name = getName(constructor);
  name == null && (name = "an unnamed constructor"), this.assert(
    isInstanceOf,
    "expected #{this} to be an instance of " + name,
    "expected #{this} to not be an instance of " + name
  );
}
__name(assertInstanceOf, "assertInstanceOf");
Assertion.addMethod("instanceof", assertInstanceOf);
Assertion.addMethod("instanceOf", assertInstanceOf);
function assertProperty(name, val, msg) {
  msg && flag2(this, "message", msg);
  var isNested = flag2(this, "nested"), isOwn = flag2(this, "own"), flagMsg = flag2(this, "message"), obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), nameType = typeof name;
  if (flagMsg = flagMsg ? flagMsg + ": " : "", isNested) {
    if (nameType !== "string")
      throw new AssertionError(
        flagMsg + "the argument to property must be a string when using nested syntax",
        void 0,
        ssfi
      );
  } else if (nameType !== "string" && nameType !== "number" && nameType !== "symbol")
    throw new AssertionError(
      flagMsg + "the argument to property must be a string, number, or symbol",
      void 0,
      ssfi
    );
  if (isNested && isOwn)
    throw new AssertionError(
      flagMsg + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      ssfi
    );
  if (obj == null)
    throw new AssertionError(
      flagMsg + "Target cannot be null or undefined.",
      void 0,
      ssfi
    );
  var isDeep = flag2(this, "deep"), negate = flag2(this, "negate"), pathInfo = isNested ? getPathInfo(obj, name) : null, value = isNested ? pathInfo.value : obj[name], isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2, descriptor = "";
  isDeep && (descriptor += "deep "), isOwn && (descriptor += "own "), isNested && (descriptor += "nested "), descriptor += "property ";
  var hasProperty2;
  isOwn ? hasProperty2 = Object.prototype.hasOwnProperty.call(obj, name) : isNested ? hasProperty2 = pathInfo.exists : hasProperty2 = hasProperty(obj, name), (!negate || arguments.length === 1) && this.assert(
    hasProperty2,
    "expected #{this} to have " + descriptor + inspect22(name),
    "expected #{this} to not have " + descriptor + inspect22(name)
  ), arguments.length > 1 && this.assert(
    hasProperty2 && isEql(val, value),
    "expected #{this} to have " + descriptor + inspect22(name) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + descriptor + inspect22(name) + " of #{act}",
    val,
    value
  ), flag2(this, "object", value);
}
__name(assertProperty, "assertProperty");
Assertion.addMethod("property", assertProperty);
function assertOwnProperty(_name, _value, _msg) {
  flag2(this, "own", !0), assertProperty.apply(this, arguments);
}
__name(assertOwnProperty, "assertOwnProperty");
Assertion.addMethod("ownProperty", assertOwnProperty);
Assertion.addMethod("haveOwnProperty", assertOwnProperty);
function assertOwnPropertyDescriptor(name, descriptor, msg) {
  typeof descriptor == "string" && (msg = descriptor, descriptor = null), msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name), eql = flag2(this, "eql");
  actualDescriptor && descriptor ? this.assert(
    eql(descriptor, actualDescriptor),
    "expected the own property descriptor for " + inspect22(name) + " on #{this} to match " + inspect22(descriptor) + ", got " + inspect22(actualDescriptor),
    "expected the own property descriptor for " + inspect22(name) + " on #{this} to not match " + inspect22(descriptor),
    descriptor,
    actualDescriptor,
    !0
  ) : this.assert(
    actualDescriptor,
    "expected #{this} to have an own property descriptor for " + inspect22(name),
    "expected #{this} to not have an own property descriptor for " + inspect22(name)
  ), flag2(this, "object", actualDescriptor);
}
__name(assertOwnPropertyDescriptor, "assertOwnPropertyDescriptor");
Assertion.addMethod("ownPropertyDescriptor", assertOwnPropertyDescriptor);
Assertion.addMethod("haveOwnPropertyDescriptor", assertOwnPropertyDescriptor);
function assertLengthChain() {
  flag2(this, "doLength", !0);
}
__name(assertLengthChain, "assertLengthChain");
function assertLength(n, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), objType = type(obj).toLowerCase(), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), descriptor = "length", itemsCount;
  switch (objType) {
    case "map":
    case "set":
      descriptor = "size", itemsCount = obj.size;
      break;
    default:
      new Assertion(obj, flagMsg, ssfi, !0).to.have.property("length"), itemsCount = obj.length;
  }
  this.assert(
    itemsCount == n,
    "expected #{this} to have a " + descriptor + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + descriptor + " of #{act}",
    n,
    itemsCount
  );
}
__name(assertLength, "assertLength");
Assertion.addChainableMethod("length", assertLength, assertLengthChain);
Assertion.addChainableMethod("lengthOf", assertLength, assertLengthChain);
function assertMatch(re, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(
    re.exec(obj),
    "expected #{this} to match " + re,
    "expected #{this} not to match " + re
  );
}
__name(assertMatch, "assertMatch");
Assertion.addMethod("match", assertMatch);
Assertion.addMethod("matches", assertMatch);
Assertion.addMethod("string", function(str, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, !0).is.a("string"), this.assert(
    ~obj.indexOf(str),
    "expected #{this} to contain " + inspect22(str),
    "expected #{this} to not contain " + inspect22(str)
  );
});
function assertKeys(keys2) {
  var obj = flag2(this, "object"), objType = type(obj), keysType = type(keys2), ssfi = flag2(this, "ssfi"), isDeep = flag2(this, "deep"), str, deepStr = "", actual, ok = !0, flagMsg = flag2(this, "message");
  flagMsg = flagMsg ? flagMsg + ": " : "";
  var mixedArgsMsg = flagMsg + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (objType === "Map" || objType === "Set")
    deepStr = isDeep ? "deeply " : "", actual = [], obj.forEach(function(val, key) {
      actual.push(key);
    }), keysType !== "Array" && (keys2 = Array.prototype.slice.call(arguments));
  else {
    switch (actual = getOwnEnumerableProperties(obj), keysType) {
      case "Array":
        if (arguments.length > 1)
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new AssertionError(mixedArgsMsg, void 0, ssfi);
        keys2 = Object.keys(keys2);
        break;
      default:
        keys2 = Array.prototype.slice.call(arguments);
    }
    keys2 = keys2.map(function(val) {
      return typeof val == "symbol" ? val : String(val);
    });
  }
  if (!keys2.length)
    throw new AssertionError(flagMsg + "keys required", void 0, ssfi);
  var len = keys2.length, any = flag2(this, "any"), all = flag2(this, "all"), expected = keys2, isEql = isDeep ? flag2(this, "eql") : (val1, val2) => val1 === val2;
  if (!any && !all && (all = !0), any && (ok = expected.some(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  })), all && (ok = expected.every(function(expectedKey) {
    return actual.some(function(actualKey) {
      return isEql(expectedKey, actualKey);
    });
  }), flag2(this, "contains") || (ok = ok && keys2.length == actual.length)), len > 1) {
    keys2 = keys2.map(function(key) {
      return inspect22(key);
    });
    var last = keys2.pop();
    all && (str = keys2.join(", ") + ", and " + last), any && (str = keys2.join(", ") + ", or " + last);
  } else
    str = inspect22(keys2[0]);
  str = (len > 1 ? "keys " : "key ") + str, str = (flag2(this, "contains") ? "contain " : "have ") + str, this.assert(
    ok,
    "expected #{this} to " + deepStr + str,
    "expected #{this} to not " + deepStr + str,
    expected.slice(0).sort(compareByInspect),
    actual.sort(compareByInspect),
    !0
  );
}
__name(assertKeys, "assertKeys");
Assertion.addMethod("keys", assertKeys);
Assertion.addMethod("key", assertKeys);
function assertThrows(errorLike, errMsgMatcher, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), ssfi = flag2(this, "ssfi"), flagMsg = flag2(this, "message"), negate = flag2(this, "negate") || !1;
  new Assertion(obj, flagMsg, ssfi, !0).is.a("function"), (isRegExp2(errorLike) || typeof errorLike == "string") && (errMsgMatcher = errorLike, errorLike = null);
  let caughtErr, errorWasThrown = !1;
  try {
    obj();
  } catch (err) {
    errorWasThrown = !0, caughtErr = err;
  }
  var everyArgIsUndefined = errorLike === void 0 && errMsgMatcher === void 0, everyArgIsDefined = !!(errorLike && errMsgMatcher), errorLikeFail = !1, errMsgMatcherFail = !1;
  if (everyArgIsUndefined || !everyArgIsUndefined && !negate) {
    var errorLikeString = "an error";
    errorLike instanceof Error ? errorLikeString = "#{exp}" : errorLike && (errorLikeString = check_error_exports.getConstructorName(errorLike));
    let actual = caughtErr;
    if (caughtErr instanceof Error)
      actual = caughtErr.toString();
    else if (typeof caughtErr == "string")
      actual = caughtErr;
    else if (caughtErr && (typeof caughtErr == "object" || typeof caughtErr == "function"))
      try {
        actual = check_error_exports.getConstructorName(caughtErr);
      } catch {
      }
    this.assert(
      errorWasThrown,
      "expected #{this} to throw " + errorLikeString,
      "expected #{this} to not throw an error but #{act} was thrown",
      errorLike && errorLike.toString(),
      actual
    );
  }
  if (errorLike && caughtErr) {
    if (errorLike instanceof Error) {
      var isCompatibleInstance = check_error_exports.compatibleInstance(
        caughtErr,
        errorLike
      );
      isCompatibleInstance === negate && (everyArgIsDefined && negate ? errorLikeFail = !0 : this.assert(
        negate,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (caughtErr && !negate ? " but #{act} was thrown" : ""),
        errorLike.toString(),
        caughtErr.toString()
      ));
    }
    var isCompatibleConstructor = check_error_exports.compatibleConstructor(
      caughtErr,
      errorLike
    );
    isCompatibleConstructor === negate && (everyArgIsDefined && negate ? errorLikeFail = !0 : this.assert(
      negate,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
      errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
      caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
    ));
  }
  if (caughtErr && errMsgMatcher !== void 0 && errMsgMatcher !== null) {
    var placeholder = "including";
    isRegExp2(errMsgMatcher) && (placeholder = "matching");
    var isCompatibleMessage = check_error_exports.compatibleMessage(
      caughtErr,
      errMsgMatcher
    );
    isCompatibleMessage === negate && (everyArgIsDefined && negate ? errMsgMatcherFail = !0 : this.assert(
      negate,
      "expected #{this} to throw error " + placeholder + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + placeholder + " #{exp}",
      errMsgMatcher,
      check_error_exports.getMessage(caughtErr)
    ));
  }
  errorLikeFail && errMsgMatcherFail && this.assert(
    negate,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (caughtErr ? " but #{act} was thrown" : ""),
    errorLike instanceof Error ? errorLike.toString() : errorLike && check_error_exports.getConstructorName(errorLike),
    caughtErr instanceof Error ? caughtErr.toString() : caughtErr && check_error_exports.getConstructorName(caughtErr)
  ), flag2(this, "object", caughtErr);
}
__name(assertThrows, "assertThrows");
Assertion.addMethod("throw", assertThrows);
Assertion.addMethod("throws", assertThrows);
Assertion.addMethod("Throw", assertThrows);
function respondTo(method, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), itself = flag2(this, "itself"), context = typeof obj == "function" && !itself ? obj.prototype[method] : obj[method];
  this.assert(
    typeof context == "function",
    "expected #{this} to respond to " + inspect22(method),
    "expected #{this} to not respond to " + inspect22(method)
  );
}
__name(respondTo, "respondTo");
Assertion.addMethod("respondTo", respondTo);
Assertion.addMethod("respondsTo", respondTo);
Assertion.addProperty("itself", function() {
  flag2(this, "itself", !0);
});
function satisfy(matcher, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), result = matcher(obj);
  this.assert(
    result,
    "expected #{this} to satisfy " + objDisplay2(matcher),
    "expected #{this} to not satisfy" + objDisplay2(matcher),
    !flag2(this, "negate"),
    result
  );
}
__name(satisfy, "satisfy");
Assertion.addMethod("satisfy", satisfy);
Assertion.addMethod("satisfies", satisfy);
function closeTo(expected, delta, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, !0).is.numeric;
  let message = "A `delta` value is required for `closeTo`";
  if (delta == null)
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  if (new Assertion(delta, flagMsg, ssfi, !0).is.numeric, message = "A `expected` value is required for `closeTo`", expected == null)
    throw new AssertionError(
      flagMsg ? `${flagMsg}: ${message}` : message,
      void 0,
      ssfi
    );
  new Assertion(expected, flagMsg, ssfi, !0).is.numeric;
  let abs = /* @__PURE__ */ __name((x) => x < 0n ? -x : x, "abs"), strip = /* @__PURE__ */ __name((number) => parseFloat(parseFloat(number).toPrecision(12)), "strip");
  this.assert(
    strip(abs(obj - expected)) <= delta,
    "expected #{this} to be close to " + expected + " +/- " + delta,
    "expected #{this} not to be close to " + expected + " +/- " + delta
  );
}
__name(closeTo, "closeTo");
Assertion.addMethod("closeTo", closeTo);
Assertion.addMethod("approximately", closeTo);
function isSubsetOf(_subset, _superset, cmp, contains, ordered) {
  let superset = Array.from(_superset), subset = Array.from(_subset);
  if (!contains) {
    if (subset.length !== superset.length)
      return !1;
    superset = superset.slice();
  }
  return subset.every(function(elem, idx) {
    if (ordered)
      return cmp ? cmp(elem, superset[idx]) : elem === superset[idx];
    if (!cmp) {
      var matchIdx = superset.indexOf(elem);
      return matchIdx === -1 ? !1 : (contains || superset.splice(matchIdx, 1), !0);
    }
    return superset.some(function(elem2, matchIdx2) {
      return cmp(elem, elem2) ? (contains || superset.splice(matchIdx2, 1), !0) : !1;
    });
  });
}
__name(isSubsetOf, "isSubsetOf");
Assertion.addMethod("members", function(subset, msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(obj, flagMsg, ssfi, !0).to.be.iterable, new Assertion(subset, flagMsg, ssfi, !0).to.be.iterable;
  var contains = flag2(this, "contains"), ordered = flag2(this, "ordered"), subject, failMsg, failNegateMsg;
  contains ? (subject = ordered ? "an ordered superset" : "a superset", failMsg = "expected #{this} to be " + subject + " of #{exp}", failNegateMsg = "expected #{this} to not be " + subject + " of #{exp}") : (subject = ordered ? "ordered members" : "members", failMsg = "expected #{this} to have the same " + subject + " as #{exp}", failNegateMsg = "expected #{this} to not have the same " + subject + " as #{exp}");
  var cmp = flag2(this, "deep") ? flag2(this, "eql") : void 0;
  this.assert(
    isSubsetOf(subset, obj, cmp, contains, ordered),
    failMsg,
    failNegateMsg,
    subset,
    obj,
    !0
  );
});
Assertion.addProperty("iterable", function(msg) {
  msg && flag2(this, "message", msg);
  var obj = flag2(this, "object");
  this.assert(
    obj != null && obj[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    obj
  );
});
function oneOf(list, msg) {
  msg && flag2(this, "message", msg);
  var expected = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi"), contains = flag2(this, "contains"), isDeep = flag2(this, "deep"), eql = flag2(this, "eql");
  new Assertion(list, flagMsg, ssfi, !0).to.be.an("array"), contains ? this.assert(
    list.some(function(possibility) {
      return expected.indexOf(possibility) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    list,
    expected
  ) : isDeep ? this.assert(
    list.some(function(possibility) {
      return eql(expected, possibility);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    list,
    expected
  ) : this.assert(
    list.indexOf(expected) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    list,
    expected
  );
}
__name(oneOf, "oneOf");
Assertion.addMethod("oneOf", oneOf);
function assertChanges(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  var fn2 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn2, flagMsg, ssfi, !0).is.a("function");
  var initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, !0).is.a("function"), initial = subject()), fn2();
  var final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "change"), flag2(this, "realDelta", final !== initial), this.assert(
    initial !== final,
    "expected " + msgObj + " to change",
    "expected " + msgObj + " to not change"
  );
}
__name(assertChanges, "assertChanges");
Assertion.addMethod("change", assertChanges);
Assertion.addMethod("changes", assertChanges);
function assertIncreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  var fn2 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn2, flagMsg, ssfi, !0).is.a("function");
  var initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, !0).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, !0).is.a("number"), fn2();
  var final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "increase"), flag2(this, "realDelta", final - initial), this.assert(
    final - initial > 0,
    "expected " + msgObj + " to increase",
    "expected " + msgObj + " to not increase"
  );
}
__name(assertIncreases, "assertIncreases");
Assertion.addMethod("increase", assertIncreases);
Assertion.addMethod("increases", assertIncreases);
function assertDecreases(subject, prop, msg) {
  msg && flag2(this, "message", msg);
  var fn2 = flag2(this, "object"), flagMsg = flag2(this, "message"), ssfi = flag2(this, "ssfi");
  new Assertion(fn2, flagMsg, ssfi, !0).is.a("function");
  var initial;
  prop ? (new Assertion(subject, flagMsg, ssfi, !0).to.have.property(prop), initial = subject[prop]) : (new Assertion(subject, flagMsg, ssfi, !0).is.a("function"), initial = subject()), new Assertion(initial, flagMsg, ssfi, !0).is.a("number"), fn2();
  var final = prop == null ? subject() : subject[prop], msgObj = prop == null ? initial : "." + prop;
  flag2(this, "deltaMsgObj", msgObj), flag2(this, "initialDeltaValue", initial), flag2(this, "finalDeltaValue", final), flag2(this, "deltaBehavior", "decrease"), flag2(this, "realDelta", initial - final), this.assert(
    final - initial < 0,
    "expected " + msgObj + " to decrease",
    "expected " + msgObj + " to not decrease"
  );
}
__name(assertDecreases, "assertDecreases");
Assertion.addMethod("decrease", assertDecreases);
Assertion.addMethod("decreases", assertDecreases);
function assertDelta(delta, msg) {
  msg && flag2(this, "message", msg);
  var msgObj = flag2(this, "deltaMsgObj"), initial = flag2(this, "initialDeltaValue"), final = flag2(this, "finalDeltaValue"), behavior = flag2(this, "deltaBehavior"), realDelta = flag2(this, "realDelta"), expression;
  behavior === "change" ? expression = Math.abs(final - initial) === Math.abs(delta) : expression = realDelta === Math.abs(delta), this.assert(
    expression,
    "expected " + msgObj + " to " + behavior + " by " + delta,
    "expected " + msgObj + " to not " + behavior + " by " + delta
  );
}
__name(assertDelta, "assertDelta");
Assertion.addMethod("by", assertDelta);
Assertion.addProperty("extensible", function() {
  var obj = flag2(this, "object"), isExtensible = obj === Object(obj) && Object.isExtensible(obj);
  this.assert(
    isExtensible,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
Assertion.addProperty("sealed", function() {
  var obj = flag2(this, "object"), isSealed = obj === Object(obj) ? Object.isSealed(obj) : !0;
  this.assert(
    isSealed,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
Assertion.addProperty("frozen", function() {
  var obj = flag2(this, "object"), isFrozen = obj === Object(obj) ? Object.isFrozen(obj) : !0;
  this.assert(
    isFrozen,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
Assertion.addProperty("finite", function(_msg) {
  var obj = flag2(this, "object");
  this.assert(
    typeof obj == "number" && isFinite(obj),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function compareSubset(expected, actual) {
  return expected === actual ? !0 : typeof actual != typeof expected ? !1 : typeof expected != "object" || expected === null ? expected === actual : actual ? Array.isArray(expected) ? Array.isArray(actual) ? expected.every(function(exp) {
    return actual.some(function(act) {
      return compareSubset(exp, act);
    });
  }) : !1 : expected instanceof Date ? actual instanceof Date ? expected.getTime() === actual.getTime() : !1 : Object.keys(expected).every(function(key) {
    var expectedValue = expected[key], actualValue = actual[key];
    return typeof expectedValue == "object" && expectedValue !== null && actualValue !== null ? compareSubset(expectedValue, actualValue) : typeof expectedValue == "function" ? expectedValue(actualValue) : actualValue === expectedValue;
  }) : !1;
}
__name(compareSubset, "compareSubset");
Assertion.addMethod("containSubset", function(expected) {
  let actual = flag(this, "object"), showDiff = config.showDiff;
  this.assert(
    compareSubset(expected, actual),
    "expected #{act} to contain subset #{exp}",
    "expected #{act} to not contain subset #{exp}",
    expected,
    actual,
    showDiff
  );
});
function expect(val, message) {
  return new Assertion(val, message);
}
__name(expect, "expect");
expect.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "expect.fail()", new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    expect.fail
  );
};
var should_exports = {};
__export(should_exports, {
  Should: () => Should,
  should: () => should
});
function loadShould() {
  function shouldGetter() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new Assertion(this.valueOf(), null, shouldGetter) : new Assertion(this, null, shouldGetter);
  }
  __name(shouldGetter, "shouldGetter");
  function shouldSetter(value) {
    Object.defineProperty(this, "should", {
      value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  __name(shouldSetter, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: shouldSetter,
    get: shouldGetter,
    configurable: !0
  });
  var should2 = {};
  return should2.fail = function(actual, expected, message, operator) {
    throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "should.fail()", new AssertionError(
      message,
      {
        actual,
        expected,
        operator
      },
      should2.fail
    );
  }, should2.equal = function(actual, expected, message) {
    new Assertion(actual, message).to.equal(expected);
  }, should2.Throw = function(fn2, errt, errs, msg) {
    new Assertion(fn2, msg).to.Throw(errt, errs);
  }, should2.exist = function(val, msg) {
    new Assertion(val, msg).to.exist;
  }, should2.not = {}, should2.not.equal = function(actual, expected, msg) {
    new Assertion(actual, msg).to.not.equal(expected);
  }, should2.not.Throw = function(fn2, errt, errs, msg) {
    new Assertion(fn2, msg).to.not.Throw(errt, errs);
  }, should2.not.exist = function(val, msg) {
    new Assertion(val, msg).to.not.exist;
  }, should2.throw = should2.Throw, should2.not.throw = should2.not.Throw, should2;
}
__name(loadShould, "loadShould");
var should = loadShould, Should = loadShould;
function assert3(express, errmsg) {
  var test22 = new Assertion(null, null, assert3, !0);
  test22.assert(express, errmsg, "[ negation message unavailable ]");
}
__name(assert3, "assert");
assert3.fail = function(actual, expected, message, operator) {
  throw arguments.length < 2 && (message = actual, actual = void 0), message = message || "assert.fail()", new AssertionError(
    message,
    {
      actual,
      expected,
      operator
    },
    assert3.fail
  );
};
assert3.isOk = function(val, msg) {
  new Assertion(val, msg, assert3.isOk, !0).is.ok;
};
assert3.isNotOk = function(val, msg) {
  new Assertion(val, msg, assert3.isNotOk, !0).is.not.ok;
};
assert3.equal = function(act, exp, msg) {
  var test22 = new Assertion(act, msg, assert3.equal, !0);
  test22.assert(
    exp == flag(test22, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    exp,
    act,
    !0
  );
};
assert3.notEqual = function(act, exp, msg) {
  var test22 = new Assertion(act, msg, assert3.notEqual, !0);
  test22.assert(
    exp != flag(test22, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    exp,
    act,
    !0
  );
};
assert3.strictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert3.strictEqual, !0).to.equal(exp);
};
assert3.notStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert3.notStrictEqual, !0).to.not.equal(exp);
};
assert3.deepEqual = assert3.deepStrictEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert3.deepEqual, !0).to.eql(exp);
};
assert3.notDeepEqual = function(act, exp, msg) {
  new Assertion(act, msg, assert3.notDeepEqual, !0).to.not.eql(exp);
};
assert3.isAbove = function(val, abv, msg) {
  new Assertion(val, msg, assert3.isAbove, !0).to.be.above(abv);
};
assert3.isAtLeast = function(val, atlst, msg) {
  new Assertion(val, msg, assert3.isAtLeast, !0).to.be.least(atlst);
};
assert3.isBelow = function(val, blw, msg) {
  new Assertion(val, msg, assert3.isBelow, !0).to.be.below(blw);
};
assert3.isAtMost = function(val, atmst, msg) {
  new Assertion(val, msg, assert3.isAtMost, !0).to.be.most(atmst);
};
assert3.isTrue = function(val, msg) {
  new Assertion(val, msg, assert3.isTrue, !0).is.true;
};
assert3.isNotTrue = function(val, msg) {
  new Assertion(val, msg, assert3.isNotTrue, !0).to.not.equal(!0);
};
assert3.isFalse = function(val, msg) {
  new Assertion(val, msg, assert3.isFalse, !0).is.false;
};
assert3.isNotFalse = function(val, msg) {
  new Assertion(val, msg, assert3.isNotFalse, !0).to.not.equal(!1);
};
assert3.isNull = function(val, msg) {
  new Assertion(val, msg, assert3.isNull, !0).to.equal(null);
};
assert3.isNotNull = function(val, msg) {
  new Assertion(val, msg, assert3.isNotNull, !0).to.not.equal(null);
};
assert3.isNaN = function(val, msg) {
  new Assertion(val, msg, assert3.isNaN, !0).to.be.NaN;
};
assert3.isNotNaN = function(value, message) {
  new Assertion(value, message, assert3.isNotNaN, !0).not.to.be.NaN;
};
assert3.exists = function(val, msg) {
  new Assertion(val, msg, assert3.exists, !0).to.exist;
};
assert3.notExists = function(val, msg) {
  new Assertion(val, msg, assert3.notExists, !0).to.not.exist;
};
assert3.isUndefined = function(val, msg) {
  new Assertion(val, msg, assert3.isUndefined, !0).to.equal(void 0);
};
assert3.isDefined = function(val, msg) {
  new Assertion(val, msg, assert3.isDefined, !0).to.not.equal(void 0);
};
assert3.isCallable = function(value, message) {
  new Assertion(value, message, assert3.isCallable, !0).is.callable;
};
assert3.isNotCallable = function(value, message) {
  new Assertion(value, message, assert3.isNotCallable, !0).is.not.callable;
};
assert3.isObject = function(val, msg) {
  new Assertion(val, msg, assert3.isObject, !0).to.be.a("object");
};
assert3.isNotObject = function(val, msg) {
  new Assertion(val, msg, assert3.isNotObject, !0).to.not.be.a("object");
};
assert3.isArray = function(val, msg) {
  new Assertion(val, msg, assert3.isArray, !0).to.be.an("array");
};
assert3.isNotArray = function(val, msg) {
  new Assertion(val, msg, assert3.isNotArray, !0).to.not.be.an("array");
};
assert3.isString = function(val, msg) {
  new Assertion(val, msg, assert3.isString, !0).to.be.a("string");
};
assert3.isNotString = function(val, msg) {
  new Assertion(val, msg, assert3.isNotString, !0).to.not.be.a("string");
};
assert3.isNumber = function(val, msg) {
  new Assertion(val, msg, assert3.isNumber, !0).to.be.a("number");
};
assert3.isNotNumber = function(val, msg) {
  new Assertion(val, msg, assert3.isNotNumber, !0).to.not.be.a("number");
};
assert3.isNumeric = function(val, msg) {
  new Assertion(val, msg, assert3.isNumeric, !0).is.numeric;
};
assert3.isNotNumeric = function(val, msg) {
  new Assertion(val, msg, assert3.isNotNumeric, !0).is.not.numeric;
};
assert3.isFinite = function(val, msg) {
  new Assertion(val, msg, assert3.isFinite, !0).to.be.finite;
};
assert3.isBoolean = function(val, msg) {
  new Assertion(val, msg, assert3.isBoolean, !0).to.be.a("boolean");
};
assert3.isNotBoolean = function(val, msg) {
  new Assertion(val, msg, assert3.isNotBoolean, !0).to.not.be.a("boolean");
};
assert3.typeOf = function(val, type3, msg) {
  new Assertion(val, msg, assert3.typeOf, !0).to.be.a(type3);
};
assert3.notTypeOf = function(value, type3, message) {
  new Assertion(value, message, assert3.notTypeOf, !0).to.not.be.a(type3);
};
assert3.instanceOf = function(val, type3, msg) {
  new Assertion(val, msg, assert3.instanceOf, !0).to.be.instanceOf(type3);
};
assert3.notInstanceOf = function(val, type3, msg) {
  new Assertion(val, msg, assert3.notInstanceOf, !0).to.not.be.instanceOf(
    type3
  );
};
assert3.include = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.include, !0).include(inc);
};
assert3.notInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.notInclude, !0).not.include(inc);
};
assert3.deepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.deepInclude, !0).deep.include(inc);
};
assert3.notDeepInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.notDeepInclude, !0).not.deep.include(inc);
};
assert3.nestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.nestedInclude, !0).nested.include(inc);
};
assert3.notNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.notNestedInclude, !0).not.nested.include(
    inc
  );
};
assert3.deepNestedInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.deepNestedInclude, !0).deep.nested.include(
    inc
  );
};
assert3.notDeepNestedInclude = function(exp, inc, msg) {
  new Assertion(
    exp,
    msg,
    assert3.notDeepNestedInclude,
    !0
  ).not.deep.nested.include(inc);
};
assert3.ownInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.ownInclude, !0).own.include(inc);
};
assert3.notOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.notOwnInclude, !0).not.own.include(inc);
};
assert3.deepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.deepOwnInclude, !0).deep.own.include(inc);
};
assert3.notDeepOwnInclude = function(exp, inc, msg) {
  new Assertion(exp, msg, assert3.notDeepOwnInclude, !0).not.deep.own.include(
    inc
  );
};
assert3.match = function(exp, re, msg) {
  new Assertion(exp, msg, assert3.match, !0).to.match(re);
};
assert3.notMatch = function(exp, re, msg) {
  new Assertion(exp, msg, assert3.notMatch, !0).to.not.match(re);
};
assert3.property = function(obj, prop, msg) {
  new Assertion(obj, msg, assert3.property, !0).to.have.property(prop);
};
assert3.notProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert3.notProperty, !0).to.not.have.property(prop);
};
assert3.propertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert3.propertyVal, !0).to.have.property(prop, val);
};
assert3.notPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert3.notPropertyVal, !0).to.not.have.property(
    prop,
    val
  );
};
assert3.deepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(obj, msg, assert3.deepPropertyVal, !0).to.have.deep.property(
    prop,
    val
  );
};
assert3.notDeepPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert3.notDeepPropertyVal,
    !0
  ).to.not.have.deep.property(prop, val);
};
assert3.ownProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert3.ownProperty, !0).to.have.own.property(prop);
};
assert3.notOwnProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert3.notOwnProperty, !0).to.not.have.own.property(
    prop
  );
};
assert3.ownPropertyVal = function(obj, prop, value, msg) {
  new Assertion(obj, msg, assert3.ownPropertyVal, !0).to.have.own.property(
    prop,
    value
  );
};
assert3.notOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert3.notOwnPropertyVal,
    !0
  ).to.not.have.own.property(prop, value);
};
assert3.deepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert3.deepOwnPropertyVal,
    !0
  ).to.have.deep.own.property(prop, value);
};
assert3.notDeepOwnPropertyVal = function(obj, prop, value, msg) {
  new Assertion(
    obj,
    msg,
    assert3.notDeepOwnPropertyVal,
    !0
  ).to.not.have.deep.own.property(prop, value);
};
assert3.nestedProperty = function(obj, prop, msg) {
  new Assertion(obj, msg, assert3.nestedProperty, !0).to.have.nested.property(
    prop
  );
};
assert3.notNestedProperty = function(obj, prop, msg) {
  new Assertion(
    obj,
    msg,
    assert3.notNestedProperty,
    !0
  ).to.not.have.nested.property(prop);
};
assert3.nestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert3.nestedPropertyVal,
    !0
  ).to.have.nested.property(prop, val);
};
assert3.notNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert3.notNestedPropertyVal,
    !0
  ).to.not.have.nested.property(prop, val);
};
assert3.deepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert3.deepNestedPropertyVal,
    !0
  ).to.have.deep.nested.property(prop, val);
};
assert3.notDeepNestedPropertyVal = function(obj, prop, val, msg) {
  new Assertion(
    obj,
    msg,
    assert3.notDeepNestedPropertyVal,
    !0
  ).to.not.have.deep.nested.property(prop, val);
};
assert3.lengthOf = function(exp, len, msg) {
  new Assertion(exp, msg, assert3.lengthOf, !0).to.have.lengthOf(len);
};
assert3.hasAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.hasAnyKeys, !0).to.have.any.keys(keys2);
};
assert3.hasAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.hasAllKeys, !0).to.have.all.keys(keys2);
};
assert3.containsAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.containsAllKeys, !0).to.contain.all.keys(
    keys2
  );
};
assert3.doesNotHaveAnyKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.doesNotHaveAnyKeys, !0).to.not.have.any.keys(
    keys2
  );
};
assert3.doesNotHaveAllKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.doesNotHaveAllKeys, !0).to.not.have.all.keys(
    keys2
  );
};
assert3.hasAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.hasAnyDeepKeys, !0).to.have.any.deep.keys(
    keys2
  );
};
assert3.hasAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(obj, msg, assert3.hasAllDeepKeys, !0).to.have.all.deep.keys(
    keys2
  );
};
assert3.containsAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert3.containsAllDeepKeys,
    !0
  ).to.contain.all.deep.keys(keys2);
};
assert3.doesNotHaveAnyDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert3.doesNotHaveAnyDeepKeys,
    !0
  ).to.not.have.any.deep.keys(keys2);
};
assert3.doesNotHaveAllDeepKeys = function(obj, keys2, msg) {
  new Assertion(
    obj,
    msg,
    assert3.doesNotHaveAllDeepKeys,
    !0
  ).to.not.have.all.deep.keys(keys2);
};
assert3.throws = function(fn2, errorLike, errMsgMatcher, msg) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null);
  var assertErr = new Assertion(fn2, msg, assert3.throws, !0).to.throw(
    errorLike,
    errMsgMatcher
  );
  return flag(assertErr, "object");
};
assert3.doesNotThrow = function(fn2, errorLike, errMsgMatcher, message) {
  (typeof errorLike == "string" || errorLike instanceof RegExp) && (errMsgMatcher = errorLike, errorLike = null), new Assertion(fn2, message, assert3.doesNotThrow, !0).to.not.throw(
    errorLike,
    errMsgMatcher
  );
};
assert3.operator = function(val, operator, val2, msg) {
  var ok;
  switch (operator) {
    case "==":
      ok = val == val2;
      break;
    case "===":
      ok = val === val2;
      break;
    case ">":
      ok = val > val2;
      break;
    case ">=":
      ok = val >= val2;
      break;
    case "<":
      ok = val < val2;
      break;
    case "<=":
      ok = val <= val2;
      break;
    case "!=":
      ok = val != val2;
      break;
    case "!==":
      ok = val !== val2;
      break;
    default:
      throw msg = msg && msg + ": ", new AssertionError(
        msg + 'Invalid operator "' + operator + '"',
        void 0,
        assert3.operator
      );
  }
  var test22 = new Assertion(ok, msg, assert3.operator, !0);
  test22.assert(
    flag(test22, "object") === !0,
    "expected " + inspect22(val) + " to be " + operator + " " + inspect22(val2),
    "expected " + inspect22(val) + " to not be " + operator + " " + inspect22(val2)
  );
};
assert3.closeTo = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert3.closeTo, !0).to.be.closeTo(exp, delta);
};
assert3.approximately = function(act, exp, delta, msg) {
  new Assertion(act, msg, assert3.approximately, !0).to.be.approximately(
    exp,
    delta
  );
};
assert3.sameMembers = function(set1, set22, msg) {
  new Assertion(set1, msg, assert3.sameMembers, !0).to.have.same.members(set22);
};
assert3.notSameMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.notSameMembers,
    !0
  ).to.not.have.same.members(set22);
};
assert3.sameDeepMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.sameDeepMembers,
    !0
  ).to.have.same.deep.members(set22);
};
assert3.notSameDeepMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.notSameDeepMembers,
    !0
  ).to.not.have.same.deep.members(set22);
};
assert3.sameOrderedMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.sameOrderedMembers,
    !0
  ).to.have.same.ordered.members(set22);
};
assert3.notSameOrderedMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.notSameOrderedMembers,
    !0
  ).to.not.have.same.ordered.members(set22);
};
assert3.sameDeepOrderedMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.sameDeepOrderedMembers,
    !0
  ).to.have.same.deep.ordered.members(set22);
};
assert3.notSameDeepOrderedMembers = function(set1, set22, msg) {
  new Assertion(
    set1,
    msg,
    assert3.notSameDeepOrderedMembers,
    !0
  ).to.not.have.same.deep.ordered.members(set22);
};
assert3.includeMembers = function(superset, subset, msg) {
  new Assertion(superset, msg, assert3.includeMembers, !0).to.include.members(
    subset
  );
};
assert3.notIncludeMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.notIncludeMembers,
    !0
  ).to.not.include.members(subset);
};
assert3.includeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.includeDeepMembers,
    !0
  ).to.include.deep.members(subset);
};
assert3.notIncludeDeepMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.notIncludeDeepMembers,
    !0
  ).to.not.include.deep.members(subset);
};
assert3.includeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.includeOrderedMembers,
    !0
  ).to.include.ordered.members(subset);
};
assert3.notIncludeOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.notIncludeOrderedMembers,
    !0
  ).to.not.include.ordered.members(subset);
};
assert3.includeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.includeDeepOrderedMembers,
    !0
  ).to.include.deep.ordered.members(subset);
};
assert3.notIncludeDeepOrderedMembers = function(superset, subset, msg) {
  new Assertion(
    superset,
    msg,
    assert3.notIncludeDeepOrderedMembers,
    !0
  ).to.not.include.deep.ordered.members(subset);
};
assert3.oneOf = function(inList, list, msg) {
  new Assertion(inList, msg, assert3.oneOf, !0).to.be.oneOf(list);
};
assert3.isIterable = function(obj, msg) {
  if (obj == null || !obj[Symbol.iterator])
    throw msg = msg ? `${msg} expected ${inspect22(obj)} to be an iterable` : `expected ${inspect22(obj)} to be an iterable`, new AssertionError(msg, void 0, assert3.isIterable);
};
assert3.changes = function(fn2, obj, prop, msg) {
  arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn2, msg, assert3.changes, !0).to.change(obj, prop);
};
assert3.changesBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn2, msg, assert3.changesBy, !0).to.change(obj, prop).by(delta);
};
assert3.doesNotChange = function(fn2, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn2, msg, assert3.doesNotChange, !0).to.not.change(
    obj,
    prop
  );
};
assert3.changesButNotBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn2, msg, assert3.changesButNotBy, !0).to.change(obj, prop).but.not.by(delta);
};
assert3.increases = function(fn2, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn2, msg, assert3.increases, !0).to.increase(obj, prop);
};
assert3.increasesBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn2, msg, assert3.increasesBy, !0).to.increase(obj, prop).by(delta);
};
assert3.doesNotIncrease = function(fn2, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn2, msg, assert3.doesNotIncrease, !0).to.not.increase(
    obj,
    prop
  );
};
assert3.increasesButNotBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn2, msg, assert3.increasesButNotBy, !0).to.increase(obj, prop).but.not.by(delta);
};
assert3.decreases = function(fn2, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn2, msg, assert3.decreases, !0).to.decrease(obj, prop);
};
assert3.decreasesBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn2, msg, assert3.decreasesBy, !0).to.decrease(obj, prop).by(delta);
};
assert3.doesNotDecrease = function(fn2, obj, prop, msg) {
  return arguments.length === 3 && typeof obj == "function" && (msg = prop, prop = null), new Assertion(fn2, msg, assert3.doesNotDecrease, !0).to.not.decrease(
    obj,
    prop
  );
};
assert3.doesNotDecreaseBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  return new Assertion(fn2, msg, assert3.doesNotDecreaseBy, !0).to.not.decrease(obj, prop).by(delta);
};
assert3.decreasesButNotBy = function(fn2, obj, prop, delta, msg) {
  if (arguments.length === 4 && typeof obj == "function") {
    var tmpMsg = delta;
    delta = prop, msg = tmpMsg;
  } else arguments.length === 3 && (delta = prop, prop = null);
  new Assertion(fn2, msg, assert3.decreasesButNotBy, !0).to.decrease(obj, prop).but.not.by(delta);
};
assert3.ifError = function(val) {
  if (val)
    throw val;
};
assert3.isExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert3.isExtensible, !0).to.be.extensible;
};
assert3.isNotExtensible = function(obj, msg) {
  new Assertion(obj, msg, assert3.isNotExtensible, !0).to.not.be.extensible;
};
assert3.isSealed = function(obj, msg) {
  new Assertion(obj, msg, assert3.isSealed, !0).to.be.sealed;
};
assert3.isNotSealed = function(obj, msg) {
  new Assertion(obj, msg, assert3.isNotSealed, !0).to.not.be.sealed;
};
assert3.isFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert3.isFrozen, !0).to.be.frozen;
};
assert3.isNotFrozen = function(obj, msg) {
  new Assertion(obj, msg, assert3.isNotFrozen, !0).to.not.be.frozen;
};
assert3.isEmpty = function(val, msg) {
  new Assertion(val, msg, assert3.isEmpty, !0).to.be.empty;
};
assert3.isNotEmpty = function(val, msg) {
  new Assertion(val, msg, assert3.isNotEmpty, !0).to.not.be.empty;
};
assert3.containsSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.containSubset(exp);
};
assert3.doesNotContainSubset = function(val, exp, msg) {
  new Assertion(val, msg).to.not.containSubset(exp);
};
var aliases = [
  ["isOk", "ok"],
  ["isNotOk", "notOk"],
  ["throws", "throw"],
  ["throws", "Throw"],
  ["isExtensible", "extensible"],
  ["isNotExtensible", "notExtensible"],
  ["isSealed", "sealed"],
  ["isNotSealed", "notSealed"],
  ["isFrozen", "frozen"],
  ["isNotFrozen", "notFrozen"],
  ["isEmpty", "empty"],
  ["isNotEmpty", "notEmpty"],
  ["isCallable", "isFunction"],
  ["isNotCallable", "isNotFunction"],
  ["containsSubset", "containSubset"]
];
for (let [name, as] of aliases)
  assert3[as] = assert3[name];
var used = [];
function use(fn2) {
  let exports = {
    use,
    AssertionError,
    util: utils_exports,
    config,
    expect,
    assert: assert3,
    Assertion,
    ...should_exports
  };
  return ~used.indexOf(fn2) || (fn2(exports, utils_exports), used.push(fn2)), exports;
}
__name(use, "use");

// ../../node_modules/.pnpm/@vitest+expect@3.2.1/node_modules/@vitest/expect/dist/index.js
var MATCHERS_OBJECT = Symbol.for("matchers-object"), JEST_MATCHERS_OBJECT = Symbol.for("$$jest-matchers-object"), GLOBAL_EXPECT = Symbol.for("expect-global"), ASYMMETRIC_MATCHERS_OBJECT = Symbol.for("asymmetric-matchers-object"), customMatchers = {
  toSatisfy(actual, expected, message) {
    let { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils, pass = expected(actual);
    return {
      pass,
      message: () => pass ? `${matcherHint2(".not.toSatisfy", "received", "")}

Expected value to not satisfy:
${message || printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toSatisfy", "received", "")}

Expected value to satisfy:
${message || printExpected3(expected)}

Received:
${printReceived3(actual)}`
    };
  },
  toBeOneOf(actual, expected) {
    let { equals: equals2, customTesters } = this, { printReceived: printReceived3, printExpected: printExpected3, matcherHint: matcherHint2 } = this.utils;
    if (!Array.isArray(expected))
      throw new TypeError(`You must provide an array to ${matcherHint2(".toBeOneOf")}, not '${typeof expected}'.`);
    let pass = expected.length === 0 || expected.some((item) => equals2(item, actual, customTesters));
    return {
      pass,
      message: () => pass ? `${matcherHint2(".not.toBeOneOf", "received", "")}

Expected value to not be one of:
${printExpected3(expected)}
Received:
${printReceived3(actual)}` : `${matcherHint2(".toBeOneOf", "received", "")}

Expected value to be one of:
${printExpected3(expected)}

Received:
${printReceived3(actual)}`
    };
  }
}, EXPECTED_COLOR = u.green, RECEIVED_COLOR = u.red, INVERTED_COLOR = u.inverse, BOLD_WEIGHT = u.bold, DIM_COLOR = u.dim;
function matcherHint(matcherName, received = "received", expected = "expected", options = {}) {
  let { comment = "", isDirectExpectCall = !1, isNot = !1, promise = "", secondArgument = "", expectedColor = EXPECTED_COLOR, receivedColor = RECEIVED_COLOR, secondArgumentColor = EXPECTED_COLOR } = options, hint = "", dimString = "expect";
  return !isDirectExpectCall && received !== "" && (hint += DIM_COLOR(`${dimString}(`) + receivedColor(received), dimString = ")"), promise !== "" && (hint += DIM_COLOR(`${dimString}.`) + promise, dimString = ""), isNot && (hint += `${DIM_COLOR(`${dimString}.`)}not`, dimString = ""), matcherName.includes(".") ? dimString += matcherName : (hint += DIM_COLOR(`${dimString}.`) + matcherName, dimString = ""), expected === "" ? dimString += "()" : (hint += DIM_COLOR(`${dimString}(`) + expectedColor(expected), secondArgument && (hint += DIM_COLOR(", ") + secondArgumentColor(secondArgument)), dimString = ")"), comment !== "" && (dimString += ` // ${comment}`), dimString !== "" && (hint += DIM_COLOR(dimString)), hint;
}
var SPACE_SYMBOL2 = "\xB7";
function replaceTrailingSpaces2(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL2.repeat(spaces.length));
}
function printReceived2(object2) {
  return RECEIVED_COLOR(replaceTrailingSpaces2(stringify(object2)));
}
function printExpected2(value) {
  return EXPECTED_COLOR(replaceTrailingSpaces2(stringify(value)));
}
function getMatcherUtils() {
  return {
    EXPECTED_COLOR,
    RECEIVED_COLOR,
    INVERTED_COLOR,
    BOLD_WEIGHT,
    DIM_COLOR,
    diff,
    matcherHint,
    printReceived: printReceived2,
    printExpected: printExpected2,
    printDiffOrStringify,
    printWithType
  };
}
function printWithType(name, value, print) {
  let type3 = getType2(value), hasType = type3 !== "null" && type3 !== "undefined" ? `${name} has type:  ${type3}
` : "", hasValue = `${name} has value: ${print(value)}`;
  return hasType + hasValue;
}
function addCustomEqualityTesters(newTesters) {
  if (!Array.isArray(newTesters))
    throw new TypeError(`expect.customEqualityTesters: Must be set to an array of Testers. Was given "${getType2(newTesters)}"`);
  globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters.push(...newTesters);
}
function getCustomEqualityTesters() {
  return globalThis[JEST_MATCHERS_OBJECT].customEqualityTesters;
}
function equals(a3, b, customTesters, strictCheck) {
  return customTesters = customTesters || [], eq(a3, b, [], [], customTesters, strictCheck ? hasKey : hasDefinedKey);
}
var functionToString = Function.prototype.toString;
function isAsymmetric(obj) {
  return !!obj && typeof obj == "object" && "asymmetricMatch" in obj && isA("Function", obj.asymmetricMatch);
}
function asymmetricMatch(a3, b) {
  let asymmetricA = isAsymmetric(a3), asymmetricB = isAsymmetric(b);
  if (!(asymmetricA && asymmetricB)) {
    if (asymmetricA)
      return a3.asymmetricMatch(b);
    if (asymmetricB)
      return b.asymmetricMatch(a3);
  }
}
function eq(a3, b, aStack, bStack, customTesters, hasKey2) {
  let result = !0, asymmetricResult = asymmetricMatch(a3, b);
  if (asymmetricResult !== void 0)
    return asymmetricResult;
  let testerContext = { equals };
  for (let i = 0; i < customTesters.length; i++) {
    let customTesterResult = customTesters[i].call(testerContext, a3, b, customTesters);
    if (customTesterResult !== void 0)
      return customTesterResult;
  }
  if (typeof URL == "function" && a3 instanceof URL && b instanceof URL)
    return a3.href === b.href;
  if (Object.is(a3, b))
    return !0;
  if (a3 === null || b === null)
    return a3 === b;
  let className = Object.prototype.toString.call(a3);
  if (className !== Object.prototype.toString.call(b))
    return !1;
  switch (className) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof a3 != typeof b ? !1 : typeof a3 != "object" && typeof b != "object" ? Object.is(a3, b) : Object.is(a3.valueOf(), b.valueOf());
    case "[object Date]": {
      let numA = +a3, numB = +b;
      return numA === numB || Number.isNaN(numA) && Number.isNaN(numB);
    }
    case "[object RegExp]":
      return a3.source === b.source && a3.flags === b.flags;
    case "[object Temporal.Instant]":
    case "[object Temporal.ZonedDateTime]":
    case "[object Temporal.PlainDateTime]":
    case "[object Temporal.PlainDate]":
    case "[object Temporal.PlainTime]":
    case "[object Temporal.PlainYearMonth]":
    case "[object Temporal.PlainMonthDay]":
      return a3.equals(b);
    case "[object Temporal.Duration]":
      return a3.toString() === b.toString();
  }
  if (typeof a3 != "object" || typeof b != "object")
    return !1;
  if (isDomNode(a3) && isDomNode(b))
    return a3.isEqualNode(b);
  let length = aStack.length;
  for (; length--; ) {
    if (aStack[length] === a3)
      return bStack[length] === b;
    if (bStack[length] === b)
      return !1;
  }
  if (aStack.push(a3), bStack.push(b), className === "[object Array]" && a3.length !== b.length)
    return !1;
  if (a3 instanceof Error && b instanceof Error)
    try {
      return isErrorEqual(a3, b, aStack, bStack, customTesters, hasKey2);
    } finally {
      aStack.pop(), bStack.pop();
    }
  let aKeys = keys(a3, hasKey2), key, size = aKeys.length;
  if (keys(b, hasKey2).length !== size)
    return !1;
  for (; size--; )
    if (key = aKeys[size], result = hasKey2(b, key) && eq(a3[key], b[key], aStack, bStack, customTesters, hasKey2), !result)
      return !1;
  return aStack.pop(), bStack.pop(), result;
}
function isErrorEqual(a3, b, aStack, bStack, customTesters, hasKey2) {
  let result = Object.getPrototypeOf(a3) === Object.getPrototypeOf(b) && a3.name === b.name && a3.message === b.message;
  return typeof b.cause < "u" && result && (result = eq(a3.cause, b.cause, aStack, bStack, customTesters, hasKey2)), a3 instanceof AggregateError && b instanceof AggregateError && result && (result = eq(a3.errors, b.errors, aStack, bStack, customTesters, hasKey2)), result && (result = eq({ ...a3 }, { ...b }, aStack, bStack, customTesters, hasKey2)), result;
}
function keys(obj, hasKey2) {
  let keys2 = [];
  for (let key in obj)
    hasKey2(obj, key) && keys2.push(key);
  return keys2.concat(Object.getOwnPropertySymbols(obj).filter((symbol) => Object.getOwnPropertyDescriptor(obj, symbol).enumerable));
}
function hasDefinedKey(obj, key) {
  return hasKey(obj, key) && obj[key] !== void 0;
}
function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === `[object ${typeName}]`;
}
function isDomNode(obj) {
  return obj !== null && typeof obj == "object" && "nodeType" in obj && typeof obj.nodeType == "number" && "nodeName" in obj && typeof obj.nodeName == "string" && "isEqualNode" in obj && typeof obj.isEqualNode == "function";
}
var IS_KEYED_SENTINEL2 = "@@__IMMUTABLE_KEYED__@@", IS_SET_SENTINEL2 = "@@__IMMUTABLE_SET__@@", IS_LIST_SENTINEL2 = "@@__IMMUTABLE_LIST__@@", IS_ORDERED_SENTINEL2 = "@@__IMMUTABLE_ORDERED__@@", IS_RECORD_SYMBOL2 = "@@__IMMUTABLE_RECORD__@@";
function isImmutableUnorderedKeyed(maybeKeyed) {
  return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL2] && !maybeKeyed[IS_ORDERED_SENTINEL2]);
}
function isImmutableUnorderedSet(maybeSet) {
  return !!(maybeSet && maybeSet[IS_SET_SENTINEL2] && !maybeSet[IS_ORDERED_SENTINEL2]);
}
function isObjectLiteral(source) {
  return source != null && typeof source == "object" && !Array.isArray(source);
}
function isImmutableList(source) {
  return !!(source && isObjectLiteral(source) && source[IS_LIST_SENTINEL2]);
}
function isImmutableOrderedKeyed(source) {
  return !!(source && isObjectLiteral(source) && source[IS_KEYED_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
function isImmutableOrderedSet(source) {
  return !!(source && isObjectLiteral(source) && source[IS_SET_SENTINEL2] && source[IS_ORDERED_SENTINEL2]);
}
function isImmutableRecord(source) {
  return !!(source && isObjectLiteral(source) && source[IS_RECORD_SYMBOL2]);
}
var IteratorSymbol = Symbol.iterator;
function hasIterator(object2) {
  return !!(object2 != null && object2[IteratorSymbol]);
}
function iterableEquality(a3, b, customTesters = [], aStack = [], bStack = []) {
  if (typeof a3 != "object" || typeof b != "object" || Array.isArray(a3) || Array.isArray(b) || !hasIterator(a3) || !hasIterator(b))
    return;
  if (a3.constructor !== b.constructor)
    return !1;
  let length = aStack.length;
  for (; length--; )
    if (aStack[length] === a3)
      return bStack[length] === b;
  aStack.push(a3), bStack.push(b);
  let filteredCustomTesters = [...customTesters.filter((t) => t !== iterableEquality), iterableEqualityWithStack];
  function iterableEqualityWithStack(a4, b2) {
    return iterableEquality(a4, b2, [...customTesters], [...aStack], [...bStack]);
  }
  if (a3.size !== void 0) {
    if (a3.size !== b.size)
      return !1;
    if (isA("Set", a3) || isImmutableUnorderedSet(a3)) {
      let allFound = !0;
      for (let aValue of a3)
        if (!b.has(aValue)) {
          let has = !1;
          for (let bValue of b)
            equals(aValue, bValue, filteredCustomTesters) === !0 && (has = !0);
          if (has === !1) {
            allFound = !1;
            break;
          }
        }
      return aStack.pop(), bStack.pop(), allFound;
    } else if (isA("Map", a3) || isImmutableUnorderedKeyed(a3)) {
      let allFound = !0;
      for (let aEntry of a3)
        if (!b.has(aEntry[0]) || !equals(aEntry[1], b.get(aEntry[0]), filteredCustomTesters)) {
          let has = !1;
          for (let bEntry of b) {
            let matchedKey = equals(aEntry[0], bEntry[0], filteredCustomTesters), matchedValue = !1;
            matchedKey === !0 && (matchedValue = equals(aEntry[1], bEntry[1], filteredCustomTesters)), matchedValue === !0 && (has = !0);
          }
          if (has === !1) {
            allFound = !1;
            break;
          }
        }
      return aStack.pop(), bStack.pop(), allFound;
    }
  }
  let bIterator = b[IteratorSymbol]();
  for (let aValue of a3) {
    let nextB = bIterator.next();
    if (nextB.done || !equals(aValue, nextB.value, filteredCustomTesters))
      return !1;
  }
  if (!bIterator.next().done)
    return !1;
  if (!isImmutableList(a3) && !isImmutableOrderedKeyed(a3) && !isImmutableOrderedSet(a3) && !isImmutableRecord(a3)) {
    let aEntries = Object.entries(a3), bEntries = Object.entries(b);
    if (!equals(aEntries, bEntries, filteredCustomTesters))
      return !1;
  }
  return aStack.pop(), bStack.pop(), !0;
}
function hasPropertyInObject(object2, key) {
  return !object2 || typeof object2 != "object" || object2 === Object.prototype ? !1 : Object.prototype.hasOwnProperty.call(object2, key) || hasPropertyInObject(Object.getPrototypeOf(object2), key);
}
function isObjectWithKeys(a3) {
  return isObject(a3) && !(a3 instanceof Error) && !Array.isArray(a3) && !(a3 instanceof Date);
}
function subsetEquality(object2, subset, customTesters = []) {
  let filteredCustomTesters = customTesters.filter((t) => t !== subsetEquality), subsetEqualityWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object3, subset2) => {
    if (isObjectWithKeys(subset2))
      return Object.keys(subset2).every((key) => {
        if (subset2[key] != null && typeof subset2[key] == "object") {
          if (seenReferences.has(subset2[key]))
            return equals(object3[key], subset2[key], filteredCustomTesters);
          seenReferences.set(subset2[key], !0);
        }
        let result = object3 != null && hasPropertyInObject(object3, key) && equals(object3[key], subset2[key], [...filteredCustomTesters, subsetEqualityWithContext(seenReferences)]);
        return seenReferences.delete(subset2[key]), result;
      });
  };
  return subsetEqualityWithContext()(object2, subset);
}
function typeEquality(a3, b) {
  if (!(a3 == null || b == null || a3.constructor === b.constructor))
    return !1;
}
function arrayBufferEquality(a3, b) {
  let dataViewA = a3, dataViewB = b;
  if (!(a3 instanceof DataView && b instanceof DataView)) {
    if (!(a3 instanceof ArrayBuffer) || !(b instanceof ArrayBuffer))
      return;
    try {
      dataViewA = new DataView(a3), dataViewB = new DataView(b);
    } catch {
      return;
    }
  }
  if (dataViewA.byteLength !== dataViewB.byteLength)
    return !1;
  for (let i = 0; i < dataViewA.byteLength; i++)
    if (dataViewA.getUint8(i) !== dataViewB.getUint8(i))
      return !1;
  return !0;
}
function sparseArrayEquality(a3, b, customTesters = []) {
  if (!Array.isArray(a3) || !Array.isArray(b))
    return;
  let aKeys = Object.keys(a3), bKeys = Object.keys(b), filteredCustomTesters = customTesters.filter((t) => t !== sparseArrayEquality);
  return equals(a3, b, filteredCustomTesters, !0) && equals(aKeys, bKeys);
}
function generateToBeMessage(deepEqualityName, expected = "#{this}", actual = "#{exp}") {
  let toBeMessage = `expected ${expected} to be ${actual} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(deepEqualityName) ? `${toBeMessage}

If it should pass with deep equality, replace "toBe" with "${deepEqualityName}"

Expected: ${expected}
Received: serializes to the same string
` : toBeMessage;
}
function pluralize(word, count) {
  return `${count} ${word}${count === 1 ? "" : "s"}`;
}
function getObjectKeys(object2) {
  return [...Object.keys(object2), ...Object.getOwnPropertySymbols(object2).filter((s2) => {
    var _Object$getOwnPropert;
    return (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(object2, s2)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.enumerable;
  })];
}
function getObjectSubset(object2, subset, customTesters) {
  let stripped = 0, getObjectSubsetWithContext = (seenReferences = /* @__PURE__ */ new WeakMap()) => (object3, subset2) => {
    if (Array.isArray(object3)) {
      if (Array.isArray(subset2) && subset2.length === object3.length)
        return subset2.map((sub, i) => getObjectSubsetWithContext(seenReferences)(object3[i], sub));
    } else {
      if (object3 instanceof Date)
        return object3;
      if (isObject(object3) && isObject(subset2)) {
        if (equals(object3, subset2, [
          ...customTesters,
          iterableEquality,
          subsetEquality
        ]))
          return subset2;
        let trimmed = {};
        seenReferences.set(object3, trimmed), typeof object3.constructor == "function" && typeof object3.constructor.name == "string" && Object.defineProperty(trimmed, "constructor", {
          enumerable: !1,
          value: object3.constructor
        });
        for (let key of getObjectKeys(object3))
          hasPropertyInObject(subset2, key) ? trimmed[key] = seenReferences.has(object3[key]) ? seenReferences.get(object3[key]) : getObjectSubsetWithContext(seenReferences)(object3[key], subset2[key]) : seenReferences.has(object3[key]) || (stripped += 1, isObject(object3[key]) && (stripped += getObjectKeys(object3[key]).length), getObjectSubsetWithContext(seenReferences)(object3[key], subset2[key]));
        if (getObjectKeys(trimmed).length > 0)
          return trimmed;
      }
    }
    return object3;
  };
  return {
    subset: getObjectSubsetWithContext()(object2, subset),
    stripped
  };
}
if (!Object.prototype.hasOwnProperty.call(globalThis, MATCHERS_OBJECT)) {
  let globalState = /* @__PURE__ */ new WeakMap(), matchers = /* @__PURE__ */ Object.create(null), customEqualityTesters = [], asymmetricMatchers = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, MATCHERS_OBJECT, { get: () => globalState }), Object.defineProperty(globalThis, JEST_MATCHERS_OBJECT, {
    configurable: !0,
    get: () => ({
      state: globalState.get(globalThis[GLOBAL_EXPECT]),
      matchers,
      customEqualityTesters
    })
  }), Object.defineProperty(globalThis, ASYMMETRIC_MATCHERS_OBJECT, { get: () => asymmetricMatchers });
}
function getState(expect2) {
  return globalThis[MATCHERS_OBJECT].get(expect2);
}
function setState(state, expect2) {
  let map2 = globalThis[MATCHERS_OBJECT], current = map2.get(expect2) || {}, results = Object.defineProperties(current, {
    ...Object.getOwnPropertyDescriptors(current),
    ...Object.getOwnPropertyDescriptors(state)
  });
  map2.set(expect2, results);
}
var AsymmetricMatcher3 = class {
  // should have "jest" to be compatible with its ecosystem
  $$typeof = Symbol.for("jest.asymmetricMatcher");
  constructor(sample, inverse = !1) {
    this.sample = sample, this.inverse = inverse;
  }
  getMatcherContext(expect2) {
    return {
      ...getState(expect2 || globalThis[GLOBAL_EXPECT]),
      equals,
      isNot: this.inverse,
      customTesters: getCustomEqualityTesters(),
      utils: {
        ...getMatcherUtils(),
        diff,
        stringify,
        iterableEquality,
        subsetEquality
      }
    };
  }
};
AsymmetricMatcher3.prototype[Symbol.for("chai/inspect")] = function(options) {
  let result = stringify(this, options.depth, { min: !0 });
  return result.length <= options.truncate ? result : `${this.toString()}{\u2026}`;
};
var StringContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    if (!isA("String", sample))
      throw new Error("Expected is not a string");
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    let result = isA("String", other) && other.includes(this.sample);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
}, Anything = class extends AsymmetricMatcher3 {
  asymmetricMatch(other) {
    return other != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
}, ObjectContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    super(sample, inverse);
  }
  getPrototype(obj) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(obj) : obj.constructor.prototype === obj ? null : obj.constructor.prototype;
  }
  hasProperty(obj, property) {
    return obj ? Object.prototype.hasOwnProperty.call(obj, property) ? !0 : this.hasProperty(this.getPrototype(obj), property) : !1;
  }
  asymmetricMatch(other) {
    if (typeof this.sample != "object")
      throw new TypeError(`You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`);
    let result = !0, matcherContext = this.getMatcherContext();
    for (let property in this.sample)
      if (!this.hasProperty(other, property) || !equals(this.sample[property], other[property], matcherContext.customTesters)) {
        result = !1;
        break;
      }
    return this.inverse ? !result : result;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
}, ArrayContaining = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    super(sample, inverse);
  }
  asymmetricMatch(other) {
    if (!Array.isArray(this.sample))
      throw new TypeError(`You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`);
    let matcherContext = this.getMatcherContext(), result = this.sample.length === 0 || Array.isArray(other) && this.sample.every((item) => other.some((another) => equals(item, another, matcherContext.customTesters)));
    return this.inverse ? !result : result;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
}, Any = class extends AsymmetricMatcher3 {
  constructor(sample) {
    if (typeof sample > "u")
      throw new TypeError("any() expects to be passed a constructor function. Please pass one or use anything() to match any object.");
    super(sample);
  }
  fnNameFor(func) {
    if (func.name)
      return func.name;
    let matches = Function.prototype.toString.call(func).match(/^(?:async)?\s*function\s*(?:\*\s*)?([\w$]+)\s*\(/);
    return matches ? matches[1] : "<anonymous>";
  }
  asymmetricMatch(other) {
    return this.sample === String ? typeof other == "string" || other instanceof String : this.sample === Number ? typeof other == "number" || other instanceof Number : this.sample === Function ? typeof other == "function" || typeof other == "function" : this.sample === Boolean ? typeof other == "boolean" || other instanceof Boolean : this.sample === BigInt ? typeof other == "bigint" || other instanceof BigInt : this.sample === Symbol ? typeof other == "symbol" || other instanceof Symbol : this.sample === Object ? typeof other == "object" : other instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
}, StringMatching = class extends AsymmetricMatcher3 {
  constructor(sample, inverse = !1) {
    if (!isA("String", sample) && !isA("RegExp", sample))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(sample), inverse);
  }
  asymmetricMatch(other) {
    let result = isA("String", other) && this.sample.test(other);
    return this.inverse ? !result : result;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
}, CloseTo = class extends AsymmetricMatcher3 {
  precision;
  constructor(sample, precision = 2, inverse = !1) {
    if (!isA("Number", sample))
      throw new Error("Expected is not a Number");
    if (!isA("Number", precision))
      throw new Error("Precision is not a Number");
    super(sample), this.inverse = inverse, this.precision = precision;
  }
  asymmetricMatch(other) {
    if (!isA("Number", other))
      return !1;
    let result = !1;
    return other === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || other === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? result = !0 : result = Math.abs(this.sample - other) < 10 ** -this.precision / 2, this.inverse ? !result : result;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${pluralize("digit", this.precision)})`
    ].join(" ");
  }
}, JestAsymmetricMatchers = (chai2, utils) => {
  utils.addMethod(chai2.expect, "anything", () => new Anything()), utils.addMethod(chai2.expect, "any", (expected) => new Any(expected)), utils.addMethod(chai2.expect, "stringContaining", (expected) => new StringContaining(expected)), utils.addMethod(chai2.expect, "objectContaining", (expected) => new ObjectContaining(expected)), utils.addMethod(chai2.expect, "arrayContaining", (expected) => new ArrayContaining(expected)), utils.addMethod(chai2.expect, "stringMatching", (expected) => new StringMatching(expected)), utils.addMethod(chai2.expect, "closeTo", (expected, precision) => new CloseTo(expected, precision)), chai2.expect.not = {
    stringContaining: (expected) => new StringContaining(expected, !0),
    objectContaining: (expected) => new ObjectContaining(expected, !0),
    arrayContaining: (expected) => new ArrayContaining(expected, !0),
    stringMatching: (expected) => new StringMatching(expected, !0),
    closeTo: (expected, precision) => new CloseTo(expected, precision, !0)
  };
};
function createAssertionMessage(util, assertion, hasArgs) {
  let not = util.flag(assertion, "negate") ? "not." : "", name = `${util.flag(assertion, "_name")}(${hasArgs ? "expected" : ""})`, promiseName = util.flag(assertion, "promise");
  return `expect(actual)${promiseName ? `.${promiseName}` : ""}.${not}${name}`;
}
function recordAsyncExpect(_test2, promise, assertion, error) {
  let test5 = _test2;
  if (test5 && promise instanceof Promise) {
    promise = promise.finally(() => {
      if (!test5.promises)
        return;
      let index2 = test5.promises.indexOf(promise);
      index2 !== -1 && test5.promises.splice(index2, 1);
    }), test5.promises || (test5.promises = []), test5.promises.push(promise);
    let resolved = !1;
    return test5.onFinished ?? (test5.onFinished = []), test5.onFinished.push(() => {
      if (!resolved) {
        var _vitest_worker__;
        let stack = (((_vitest_worker__ = globalThis.__vitest_worker__) === null || _vitest_worker__ === void 0 ? void 0 : _vitest_worker__.onFilterStackTrace) || ((s2) => s2 || ""))(error.stack);
        console.warn([
          `Promise returned by \`${assertion}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          stack
        ].join(""));
      }
    }), {
      then(onFulfilled, onRejected) {
        return resolved = !0, promise.then(onFulfilled, onRejected);
      },
      catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally(onFinally) {
        return promise.finally(onFinally);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return promise;
}
function wrapAssertion(utils, name, fn2) {
  return function(...args) {
    if (name !== "withTest" && utils.flag(this, "_name", name), !utils.flag(this, "soft"))
      return fn2.apply(this, args);
    let test5 = utils.flag(this, "vitest-test");
    if (!test5)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      return fn2.apply(this, args);
    } catch (err) {
      var _test$result;
      test5.result || (test5.result = { state: "fail" }), test5.result.state = "fail", (_test$result = test5.result).errors || (_test$result.errors = []), test5.result.errors.push(processError(err));
    }
  };
}
var JestChaiExpect = (chai2, utils) => {
  let { AssertionError: AssertionError2 } = chai2, customTesters = getCustomEqualityTesters();
  function def(name, fn2) {
    let addMethod2 = (n) => {
      let softWrapper = wrapAssertion(utils, n, fn2);
      utils.addMethod(chai2.Assertion.prototype, n, softWrapper), utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, n, softWrapper);
    };
    Array.isArray(name) ? name.forEach((n) => addMethod2(n)) : addMethod2(name);
  }
  [
    "throw",
    "throws",
    "Throw"
  ].forEach((m2) => {
    utils.overwriteMethod(chai2.Assertion.prototype, m2, (_super) => function(...args) {
      let promise = utils.flag(this, "promise"), object2 = utils.flag(this, "object"), isNot = utils.flag(this, "negate");
      if (promise === "rejects")
        utils.flag(this, "object", () => {
          throw object2;
        });
      else if (promise === "resolves" && typeof object2 != "function") {
        if (isNot)
          return;
        {
          let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: !1 };
          throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
        }
      }
      _super.apply(this, args);
    });
  }), def("withTest", function(test5) {
    return utils.flag(this, "vitest-test", test5), this;
  }), def("toEqual", function(expected) {
    let actual = utils.flag(this, "object"), equal = equals(actual, expected, [...customTesters, iterableEquality]);
    return this.assert(equal, "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", expected, actual);
  }), def("toStrictEqual", function(expected) {
    let obj = utils.flag(this, "object"), equal = equals(obj, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], !0);
    return this.assert(equal, "expected #{this} to strictly equal #{exp}", "expected #{this} to not strictly equal #{exp}", expected, obj);
  }), def("toBe", function(expected) {
    let actual = this._obj, pass = Object.is(actual, expected), deepEqualityName = "";
    return pass || (equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      typeEquality,
      sparseArrayEquality,
      arrayBufferEquality
    ], !0) ? deepEqualityName = "toStrictEqual" : equals(actual, expected, [...customTesters, iterableEquality]) && (deepEqualityName = "toEqual")), this.assert(pass, generateToBeMessage(deepEqualityName), "expected #{this} not to be #{exp} // Object.is equality", expected, actual);
  }), def("toMatchObject", function(expected) {
    let actual = this._obj, pass = equals(actual, expected, [
      ...customTesters,
      iterableEquality,
      subsetEquality
    ]), isNot = utils.flag(this, "negate"), { subset: actualSubset, stripped } = getObjectSubset(actual, expected, customTesters);
    if (pass && isNot || !pass && !isNot) {
      let msg = utils.getMessage(this, [
        pass,
        "expected #{this} to match object #{exp}",
        "expected #{this} to not match object #{exp}",
        expected,
        actualSubset,
        !1
      ]), message = stripped === 0 ? msg : `${msg}
(${stripped} matching ${stripped === 1 ? "property" : "properties"} omitted from actual)`;
      throw new AssertionError2(message, {
        showDiff: !0,
        expected,
        actual: actualSubset
      });
    }
  }), def("toMatch", function(expected) {
    let actual = this._obj;
    if (typeof actual != "string")
      throw new TypeError(`.toMatch() expects to receive a string, but got ${typeof actual}`);
    return this.assert(typeof expected == "string" ? actual.includes(expected) : actual.match(expected), "expected #{this} to match #{exp}", "expected #{this} not to match #{exp}", expected, actual);
  }), def("toContain", function(item) {
    let actual = this._obj;
    if (typeof Node < "u" && actual instanceof Node) {
      if (!(item instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof item}`);
      return this.assert(actual.contains(item), "expected #{this} to contain element #{exp}", "expected #{this} not to contain element #{exp}", item, actual);
    }
    if (typeof DOMTokenList < "u" && actual instanceof DOMTokenList) {
      assertTypes(item, "class name", ["string"]);
      let expectedClassList = utils.flag(this, "negate") ? actual.value.replace(item, "").trim() : `${actual.value} ${item}`;
      return this.assert(actual.contains(item), `expected "${actual.value}" to contain "${item}"`, `expected "${actual.value}" not to contain "${item}"`, expectedClassList, actual.value);
    }
    return typeof actual == "string" && typeof item == "string" ? this.assert(actual.includes(item), "expected #{this} to contain #{exp}", "expected #{this} not to contain #{exp}", item, actual) : (actual != null && typeof actual != "string" && utils.flag(this, "object", Array.from(actual)), this.contain(item));
  }), def("toContainEqual", function(expected) {
    let obj = utils.flag(this, "object"), index2 = Array.from(obj).findIndex((item) => equals(item, expected, customTesters));
    this.assert(index2 !== -1, "expected #{this} to deep equally contain #{exp}", "expected #{this} to not deep equally contain #{exp}", expected);
  }), def("toBeTruthy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!!obj, "expected #{this} to be truthy", "expected #{this} to not be truthy", !0, obj);
  }), def("toBeFalsy", function() {
    let obj = utils.flag(this, "object");
    this.assert(!obj, "expected #{this} to be falsy", "expected #{this} to not be falsy", !1, obj);
  }), def("toBeGreaterThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual > expected, `expected ${actual} to be greater than ${expected}`, `expected ${actual} to be not greater than ${expected}`, expected, actual, !1);
  }), def("toBeGreaterThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual >= expected, `expected ${actual} to be greater than or equal to ${expected}`, `expected ${actual} to be not greater than or equal to ${expected}`, expected, actual, !1);
  }), def("toBeLessThan", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual < expected, `expected ${actual} to be less than ${expected}`, `expected ${actual} to be not less than ${expected}`, expected, actual, !1);
  }), def("toBeLessThanOrEqual", function(expected) {
    let actual = this._obj;
    return assertTypes(actual, "actual", ["number", "bigint"]), assertTypes(expected, "expected", ["number", "bigint"]), this.assert(actual <= expected, `expected ${actual} to be less than or equal to ${expected}`, `expected ${actual} to be not less than or equal to ${expected}`, expected, actual, !1);
  }), def("toBeNaN", function() {
    let obj = utils.flag(this, "object");
    this.assert(Number.isNaN(obj), "expected #{this} to be NaN", "expected #{this} not to be NaN", Number.NaN, obj);
  }), def("toBeUndefined", function() {
    let obj = utils.flag(this, "object");
    this.assert(obj === void 0, "expected #{this} to be undefined", "expected #{this} not to be undefined", void 0, obj);
  }), def("toBeNull", function() {
    let obj = utils.flag(this, "object");
    this.assert(obj === null, "expected #{this} to be null", "expected #{this} not to be null", null, obj);
  }), def("toBeDefined", function() {
    let obj = utils.flag(this, "object");
    this.assert(typeof obj < "u", "expected #{this} to be defined", "expected #{this} to be undefined", obj);
  }), def("toBeTypeOf", function(expected) {
    let actual = typeof this._obj, equal = expected === actual;
    return this.assert(equal, "expected #{this} to be type of #{exp}", "expected #{this} not to be type of #{exp}", expected, actual);
  }), def("toBeInstanceOf", function(obj) {
    return this.instanceOf(obj);
  }), def("toHaveLength", function(length) {
    return this.have.length(length);
  }), def("toHaveProperty", function(...args) {
    Array.isArray(args[0]) && (args[0] = args[0].map((key) => String(key).replace(/([.[\]])/g, "\\$1")).join("."));
    let actual = this._obj, [propertyName, expected] = args, getValue = () => Object.prototype.hasOwnProperty.call(actual, propertyName) ? {
      value: actual[propertyName],
      exists: !0
    } : utils.getPathInfo(actual, propertyName), { value, exists } = getValue(), pass = exists && (args.length === 1 || equals(expected, value, customTesters)), valueString = args.length === 1 ? "" : ` with value ${utils.objDisplay(expected)}`;
    return this.assert(pass, `expected #{this} to have property "${propertyName}"${valueString}`, `expected #{this} to not have property "${propertyName}"${valueString}`, expected, exists ? value : void 0);
  }), def("toBeCloseTo", function(received, precision = 2) {
    let expected = this._obj, pass = !1, expectedDiff = 0, receivedDiff = 0;
    return received === Number.POSITIVE_INFINITY && expected === Number.POSITIVE_INFINITY || received === Number.NEGATIVE_INFINITY && expected === Number.NEGATIVE_INFINITY ? pass = !0 : (expectedDiff = 10 ** -precision / 2, receivedDiff = Math.abs(expected - received), pass = receivedDiff < expectedDiff), this.assert(pass, `expected #{this} to be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff}`, `expected #{this} to not be close to #{exp}, received difference is ${receivedDiff}, but expected ${expectedDiff}`, received, expected, !1);
  });
  function assertIsMock(assertion) {
    if (!isMockFunction2(assertion._obj))
      throw new TypeError(`${utils.inspect(assertion._obj)} is not a spy or a call to a spy!`);
  }
  function getSpy(assertion) {
    return assertIsMock(assertion), assertion._obj;
  }
  def(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(number) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === number, `expected "${spyName}" to be called #{exp} times, but got ${callCount} times`, `expected "${spyName}" to not be called #{exp} times`, number, callCount, !1);
  }), def("toHaveBeenCalledOnce", function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length;
    return this.assert(callCount === 1, `expected "${spyName}" to be called once, but got ${callCount} times`, `expected "${spyName}" to not be called once`, 1, callCount, !1);
  }), def(["toHaveBeenCalled", "toBeCalled"], function() {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, called = callCount > 0, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      called,
      `expected "${spyName}" to be called at least once`,
      `expected "${spyName}" to not be called at all, but actually been called ${callCount} times`,
      !0,
      called
    ]);
    if (called && isNot && (msg = formatCalls(spy, msg)), called && isNot || !called && !isNot)
      throw new AssertionError2(msg);
  });
  function equalsArgumentArray(a3, b) {
    return a3.length === b.length && a3.every((aItem, i) => equals(aItem, b[i], [...customTesters, iterableEquality]));
  }
  def(["toHaveBeenCalledWith", "toBeCalledWith"], function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)), isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called with arguments: #{exp}`,
      `expected "${spyName}" to not be called with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot)
      throw new AssertionError2(formatCalls(spy, msg, args));
  }), def("toHaveBeenCalledExactlyOnceWith", function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), callCount = spy.mock.calls.length, pass = spy.mock.calls.some((callArg) => equalsArgumentArray(callArg, args)) && callCount === 1, isNot = utils.flag(this, "negate"), msg = utils.getMessage(this, [
      pass,
      `expected "${spyName}" to be called once with arguments: #{exp}`,
      `expected "${spyName}" to not be called once with arguments: #{exp}`,
      args
    ]);
    if (pass && isNot || !pass && !isNot)
      throw new AssertionError2(formatCalls(spy, msg, args));
  }), def(["toHaveBeenNthCalledWith", "nthCalledWith"], function(times, ...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), nthCall = spy.mock.calls[times - 1], callCount = spy.mock.calls.length, isCalled = times <= callCount;
    this.assert(nthCall && equalsArgumentArray(nthCall, args), `expected ${ordinalOf(times)} "${spyName}" call to have been called with #{exp}${isCalled ? "" : `, but called only ${callCount} times`}`, `expected ${ordinalOf(times)} "${spyName}" call to not have been called with #{exp}`, args, nthCall, isCalled);
  }), def(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...args) {
    let spy = getSpy(this), spyName = spy.getMockName(), lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    this.assert(lastCall && equalsArgumentArray(lastCall, args), `expected last "${spyName}" call to have been called with #{exp}`, `expected last "${spyName}" call to not have been called with #{exp}`, args, lastCall);
  });
  function isSpyCalledBeforeAnotherSpy(beforeSpy, afterSpy, failIfNoFirstInvocation) {
    let beforeInvocationCallOrder = beforeSpy.mock.invocationCallOrder, afterInvocationCallOrder = afterSpy.mock.invocationCallOrder;
    return beforeInvocationCallOrder.length === 0 ? !failIfNoFirstInvocation : afterInvocationCallOrder.length === 0 ? !1 : beforeInvocationCallOrder[0] < afterInvocationCallOrder[0];
  }
  def(["toHaveBeenCalledBefore"], function(resultSpy, failIfNoFirstInvocation = !0) {
    let expectSpy = getSpy(this);
    if (!isMockFunction2(resultSpy))
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    this.assert(isSpyCalledBeforeAnotherSpy(expectSpy, resultSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called before "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called before "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  }), def(["toHaveBeenCalledAfter"], function(resultSpy, failIfNoFirstInvocation = !0) {
    let expectSpy = getSpy(this);
    if (!isMockFunction2(resultSpy))
      throw new TypeError(`${utils.inspect(resultSpy)} is not a spy or a call to a spy`);
    this.assert(isSpyCalledBeforeAnotherSpy(resultSpy, expectSpy, failIfNoFirstInvocation), `expected "${expectSpy.getMockName()}" to have been called after "${resultSpy.getMockName()}"`, `expected "${expectSpy.getMockName()}" to not have been called after "${resultSpy.getMockName()}"`, resultSpy, expectSpy);
  }), def(["toThrow", "toThrowError"], function(expected) {
    if (typeof expected == "string" || typeof expected > "u" || expected instanceof RegExp)
      return this.throws(expected === "" ? /^$/ : expected);
    let obj = this._obj, promise = utils.flag(this, "promise"), isNot = utils.flag(this, "negate"), thrown = null;
    if (promise === "rejects")
      thrown = obj;
    else if (promise === "resolves" && typeof obj != "function") {
      if (isNot)
        return;
      {
        let message = utils.flag(this, "message") || "expected promise to throw an error, but it didn't", error = { showDiff: !1 };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    } else {
      let isThrow = !1;
      try {
        obj();
      } catch (err) {
        isThrow = !0, thrown = err;
      }
      if (!isThrow && !isNot) {
        let message = utils.flag(this, "message") || "expected function to throw an error, but it didn't", error = { showDiff: !1 };
        throw new AssertionError2(message, error, utils.flag(this, "ssfi"));
      }
    }
    if (typeof expected == "function") {
      let name = expected.name || expected.prototype.constructor.name;
      return this.assert(thrown && thrown instanceof expected, `expected error to be instance of ${name}`, `expected error not to be instance of ${name}`, expected, thrown);
    }
    if (expected instanceof Error) {
      let equal = equals(thrown, expected, [...customTesters, iterableEquality]);
      return this.assert(equal, "expected a thrown error to be #{exp}", "expected a thrown error not to be #{exp}", expected, thrown);
    }
    if (typeof expected == "object" && "asymmetricMatch" in expected && typeof expected.asymmetricMatch == "function") {
      let matcher = expected;
      return this.assert(thrown && matcher.asymmetricMatch(thrown), "expected error to match asymmetric matcher", "expected error not to match asymmetric matcher", matcher, thrown);
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof expected}"`);
  }), [{
    name: "toHaveResolved",
    condition: (spy) => spy.mock.settledResults.length > 0 && spy.mock.settledResults.some(({ type: type3 }) => type3 === "fulfilled"),
    action: "resolved"
  }, {
    name: ["toHaveReturned", "toReturn"],
    condition: (spy) => spy.mock.calls.length > 0 && spy.mock.results.some(({ type: type3 }) => type3 !== "throw"),
    action: "called"
  }].forEach(({ name, condition, action }) => {
    def(name, function() {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy);
      this.assert(pass, `expected "${spyName}" to be successfully ${action} at least once`, `expected "${spyName}" to not be successfully ${action}`, pass, !pass, !1);
    });
  }), [{
    name: "toHaveResolvedTimes",
    condition: (spy, times) => spy.mock.settledResults.reduce((s2, { type: type3 }) => type3 === "fulfilled" ? ++s2 : s2, 0) === times,
    action: "resolved"
  }, {
    name: ["toHaveReturnedTimes", "toReturnTimes"],
    condition: (spy, times) => spy.mock.results.reduce((s2, { type: type3 }) => type3 === "throw" ? s2 : ++s2, 0) === times,
    action: "called"
  }].forEach(({ name, condition, action }) => {
    def(name, function(times) {
      let spy = getSpy(this), spyName = spy.getMockName(), pass = condition(spy, times);
      this.assert(pass, `expected "${spyName}" to be successfully ${action} ${times} times`, `expected "${spyName}" to not be successfully ${action} ${times} times`, `expected resolved times: ${times}`, `received resolved times: ${pass}`, !1);
    });
  }), [{
    name: "toHaveResolvedWith",
    condition: (spy, value) => spy.mock.settledResults.some(({ type: type3, value: result }) => type3 === "fulfilled" && equals(value, result)),
    action: "resolve"
  }, {
    name: ["toHaveReturnedWith", "toReturnWith"],
    condition: (spy, value) => spy.mock.results.some(({ type: type3, value: result }) => type3 === "return" && equals(value, result)),
    action: "return"
  }].forEach(({ name, condition, action }) => {
    def(name, function(value) {
      let spy = getSpy(this), pass = condition(spy, value), isNot = utils.flag(this, "negate");
      if (pass && isNot || !pass && !isNot) {
        let spyName = spy.getMockName(), msg = utils.getMessage(this, [
          pass,
          `expected "${spyName}" to ${action} with: #{exp} at least once`,
          `expected "${spyName}" to not ${action} with: #{exp}`,
          value
        ]), results = action === "return" ? spy.mock.results : spy.mock.settledResults;
        throw new AssertionError2(formatReturns(spy, results, msg, value));
      }
    });
  }), [{
    name: "toHaveLastResolvedWith",
    condition: (spy, value) => {
      let result = spy.mock.settledResults[spy.mock.settledResults.length - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveLastReturnedWith", "lastReturnedWith"],
    condition: (spy, value) => {
      let result = spy.mock.results[spy.mock.results.length - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(({ name, condition, action }) => {
    def(name, function(value) {
      let spy = getSpy(this), results = action === "return" ? spy.mock.results : spy.mock.settledResults, result = results[results.length - 1], spyName = spy.getMockName();
      this.assert(condition(spy, value), `expected last "${spyName}" call to ${action} #{exp}`, `expected last "${spyName}" call to not ${action} #{exp}`, value, result?.value);
    });
  }), [{
    name: "toHaveNthResolvedWith",
    condition: (spy, index2, value) => {
      let result = spy.mock.settledResults[index2 - 1];
      return result && result.type === "fulfilled" && equals(result.value, value);
    },
    action: "resolve"
  }, {
    name: ["toHaveNthReturnedWith", "nthReturnedWith"],
    condition: (spy, index2, value) => {
      let result = spy.mock.results[index2 - 1];
      return result && result.type === "return" && equals(result.value, value);
    },
    action: "return"
  }].forEach(({ name, condition, action }) => {
    def(name, function(nthCall, value) {
      let spy = getSpy(this), spyName = spy.getMockName(), result = (action === "return" ? spy.mock.results : spy.mock.settledResults)[nthCall - 1], ordinalCall = `${ordinalOf(nthCall)} call`;
      this.assert(condition(spy, nthCall, value), `expected ${ordinalCall} "${spyName}" call to ${action} #{exp}`, `expected ${ordinalCall} "${spyName}" call to not ${action} #{exp}`, value, result?.value);
    });
  }), def("withContext", function(context) {
    for (let key in context)
      utils.flag(this, key, context[key]);
    return this;
  }), utils.addProperty(chai2.Assertion.prototype, "resolves", function() {
    let error = new Error("resolves");
    utils.flag(this, "promise", "resolves"), utils.flag(this, "error", error);
    let test5 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object");
    if (utils.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .resolves");
    if (typeof obj?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof obj}'.`);
    let proxy = new Proxy(this, { get: (target, key, receiver) => {
      let result = Reflect.get(target, key, receiver);
      return typeof result != "function" ? result instanceof chai2.Assertion ? proxy : result : (...args) => {
        utils.flag(this, "_name", key);
        let promise = obj.then((value) => (utils.flag(this, "object", value), result.call(this, ...args)), (err) => {
          let _error = new AssertionError2(`promise rejected "${utils.inspect(err)}" instead of resolving`, { showDiff: !1 });
          throw _error.cause = err, _error.stack = error.stack.replace(error.message, _error.message), _error;
        });
        return recordAsyncExpect(test5, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    } });
    return proxy;
  }), utils.addProperty(chai2.Assertion.prototype, "rejects", function() {
    let error = new Error("rejects");
    utils.flag(this, "promise", "rejects"), utils.flag(this, "error", error);
    let test5 = utils.flag(this, "vitest-test"), obj = utils.flag(this, "object"), wrapper = typeof obj == "function" ? obj() : obj;
    if (utils.flag(this, "poll"))
      throw new SyntaxError("expect.poll() is not supported in combination with .rejects");
    if (typeof wrapper?.then != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof wrapper}'.`);
    let proxy = new Proxy(this, { get: (target, key, receiver) => {
      let result = Reflect.get(target, key, receiver);
      return typeof result != "function" ? result instanceof chai2.Assertion ? proxy : result : (...args) => {
        utils.flag(this, "_name", key);
        let promise = wrapper.then((value) => {
          let _error = new AssertionError2(`promise resolved "${utils.inspect(value)}" instead of rejecting`, {
            showDiff: !0,
            expected: new Error("rejected promise"),
            actual: value
          });
          throw _error.stack = error.stack.replace(error.message, _error.message), _error;
        }, (err) => (utils.flag(this, "object", err), result.call(this, ...args)));
        return recordAsyncExpect(test5, promise, createAssertionMessage(utils, this, !!args.length), error);
      };
    } });
    return proxy;
  });
};
function ordinalOf(i) {
  let j = i % 10, k = i % 100;
  return j === 1 && k !== 11 ? `${i}st` : j === 2 && k !== 12 ? `${i}nd` : j === 3 && k !== 13 ? `${i}rd` : `${i}th`;
}
function formatCalls(spy, msg, showActualCall) {
  return spy.mock.calls.length && (msg += u.gray(`

Received: 

${spy.mock.calls.map((callArg, i) => {
    let methodCall = u.bold(`  ${ordinalOf(i + 1)} ${spy.getMockName()} call:

`);
    return showActualCall ? methodCall += diff(showActualCall, callArg, { omitAnnotationLines: !0 }) : methodCall += stringify(callArg).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += u.gray(`

Number of calls: ${u.bold(spy.mock.calls.length)}
`), msg;
}
function formatReturns(spy, results, msg, showActualReturn) {
  return results.length && (msg += u.gray(`

Received: 

${results.map((callReturn, i) => {
    let methodCall = u.bold(`  ${ordinalOf(i + 1)} ${spy.getMockName()} call return:

`);
    return showActualReturn ? methodCall += diff(showActualReturn, callReturn.value, { omitAnnotationLines: !0 }) : methodCall += stringify(callReturn).split(`
`).map((line) => `    ${line}`).join(`
`), methodCall += `
`, methodCall;
  }).join(`
`)}`)), msg += u.gray(`

Number of calls: ${u.bold(spy.mock.calls.length)}
`), msg;
}
function getMatcherState(assertion, expect2) {
  let obj = assertion._obj, isNot = utils_exports.flag(assertion, "negate"), promise = utils_exports.flag(assertion, "promise") || "", jestUtils = {
    ...getMatcherUtils(),
    diff,
    stringify,
    iterableEquality,
    subsetEquality
  };
  return {
    state: {
      ...getState(expect2),
      customTesters: getCustomEqualityTesters(),
      isNot,
      utils: jestUtils,
      promise,
      equals,
      suppressedErrors: [],
      soft: utils_exports.flag(assertion, "soft"),
      poll: utils_exports.flag(assertion, "poll")
    },
    isNot,
    obj
  };
}
var JestExtendError = class extends Error {
  constructor(message, actual, expected) {
    super(message), this.actual = actual, this.expected = expected;
  }
};
function JestExtendPlugin(c, expect2, matchers) {
  return (_, utils) => {
    Object.entries(matchers).forEach(([expectAssertionName, expectAssertion]) => {
      function expectWrapper(...args) {
        let { state, isNot, obj } = getMatcherState(this, expect2), result = expectAssertion.call(state, obj, ...args);
        if (result && typeof result == "object" && result instanceof Promise)
          return result.then(({ pass: pass2, message: message2, actual: actual2, expected: expected2 }) => {
            if (pass2 && isNot || !pass2 && !isNot)
              throw new JestExtendError(message2(), actual2, expected2);
          });
        let { pass, message, actual, expected } = result;
        if (pass && isNot || !pass && !isNot)
          throw new JestExtendError(message(), actual, expected);
      }
      let softWrapper = wrapAssertion(utils, expectAssertionName, expectWrapper);
      utils.addMethod(globalThis[JEST_MATCHERS_OBJECT].matchers, expectAssertionName, softWrapper), utils.addMethod(c.Assertion.prototype, expectAssertionName, softWrapper);
      class CustomMatcher extends AsymmetricMatcher3 {
        constructor(inverse = !1, ...sample) {
          super(sample, inverse);
        }
        asymmetricMatch(other) {
          let { pass } = expectAssertion.call(this.getMatcherContext(expect2), other, ...this.sample);
          return this.inverse ? !pass : pass;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${expectAssertionName}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map((item) => stringify(item)).join(", ")}>`;
        }
      }
      let customMatcher = (...sample) => new CustomMatcher(!1, ...sample);
      Object.defineProperty(expect2, expectAssertionName, {
        configurable: !0,
        enumerable: !0,
        value: customMatcher,
        writable: !0
      }), Object.defineProperty(expect2.not, expectAssertionName, {
        configurable: !0,
        enumerable: !0,
        value: (...sample) => new CustomMatcher(!0, ...sample),
        writable: !0
      }), Object.defineProperty(globalThis[ASYMMETRIC_MATCHERS_OBJECT], expectAssertionName, {
        configurable: !0,
        enumerable: !0,
        value: customMatcher,
        writable: !0
      });
    });
  };
}
var JestExtend = (chai2, utils) => {
  utils.addMethod(chai2.expect, "extend", (expect2, expects) => {
    use(JestExtendPlugin(chai2, expect2, expects));
  });
};

// ../../node_modules/.pnpm/@vitest+runner@3.2.1/node_modules/@vitest/runner/dist/utils.js
init_cjs_shims();

// ../../node_modules/.pnpm/vitest@3.2.1_@types+node@18.19.70_jiti@2.4.2_jsdom@20.0.3_msw@2.8.7_@types+node@18.19.7_59b23bdad58d2b08cdc86d448ade34f5/node_modules/vitest/dist/chunks/utils.XdZDrNZV.js
init_cjs_shims();
var NAME_WORKER_STATE = "__vitest_worker__";
function getWorkerState() {
  let workerState = globalThis[NAME_WORKER_STATE];
  if (!workerState) {
    let errorMsg = `Vitest failed to access its internal state.

One of the following is possible:
- "vitest" is imported directly without running "vitest" command
- "vitest" is imported inside "globalSetup" (to fix this, use "setupFiles" instead, because "globalSetup" runs in a different context)
- "vitest" is imported inside Vite / Vitest config file
- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues
`;
    throw new Error(errorMsg);
  }
  return workerState;
}
function getCurrentEnvironment() {
  return getWorkerState()?.environment.name;
}
function isChildProcess() {
  return typeof process < "u" && !!process.send;
}
function resetModules(modules, resetMocks = !1) {
  let skipPaths = [
    /\/vitest\/dist\//,
    /\/vite-node\/dist\//,
    /vitest-virtual-\w+\/dist/,
    /@vitest\/dist/,
    ...resetMocks ? [] : [/^mock:/]
  ];
  modules.forEach((mod, path) => {
    skipPaths.some((re) => re.test(path)) || modules.invalidateModule(mod);
  });
}
function waitNextTick() {
  let { setTimeout } = getSafeTimers();
  return new Promise((resolve4) => setTimeout(resolve4, 0));
}
async function waitForImportsToResolve() {
  await waitNextTick();
  let state = getWorkerState(), promises = [], resolvingCount = 0;
  for (let mod of state.moduleCache.values())
    mod.promise && !mod.evaluated && promises.push(mod.promise), mod.resolving && resolvingCount++;
  !promises.length && !resolvingCount || (await Promise.allSettled(promises), await waitForImportsToResolve());
}

// ../../node_modules/.pnpm/vitest@3.2.1_@types+node@18.19.70_jiti@2.4.2_jsdom@20.0.3_msw@2.8.7_@types+node@18.19.7_59b23bdad58d2b08cdc86d448ade34f5/node_modules/vitest/dist/chunks/_commonjsHelpers.BFTU3MAI.js
init_cjs_shims();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs3(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}

// ../../node_modules/.pnpm/@vitest+snapshot@3.2.1/node_modules/@vitest/snapshot/dist/index.js
init_cjs_shims();
var comma = 44, chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar2 = new Uint8Array(64), charToInt2 = new Uint8Array(128);
for (let i = 0; i < chars2.length; i++) {
  let c = chars2.charCodeAt(i);
  intToChar2[i] = c, charToInt2[c] = i;
}
function decodeInteger(reader, relative2) {
  let value = 0, shift = 0, integer = 0;
  do {
    let c = reader.next();
    integer = charToInt2[c], value |= (integer & 31) << shift, shift += 5;
  } while (integer & 32);
  let shouldNegate = value & 1;
  return value >>>= 1, shouldNegate && (value = -2147483648 | -value), relative2 + value;
}
function hasMoreVlq(reader, max) {
  return reader.pos >= max ? !1 : reader.peek() !== comma;
}
var StringReader = class {
  constructor(buffer) {
    this.pos = 0, this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    let { buffer, pos } = this, idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode(mappings) {
  let { length } = mappings, reader = new StringReader(mappings), decoded = [], genColumn = 0, sourcesIndex = 0, sourceLine = 0, sourceColumn = 0, namesIndex = 0;
  do {
    let semi = reader.indexOf(";"), line = [], sorted = !0, lastCol = 0;
    for (genColumn = 0; reader.pos < semi; ) {
      let seg;
      genColumn = decodeInteger(reader, genColumn), genColumn < lastCol && (sorted = !1), lastCol = genColumn, hasMoreVlq(reader, semi) ? (sourcesIndex = decodeInteger(reader, sourcesIndex), sourceLine = decodeInteger(reader, sourceLine), sourceColumn = decodeInteger(reader, sourceColumn), hasMoreVlq(reader, semi) ? (namesIndex = decodeInteger(reader, namesIndex), seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]) : seg = [genColumn, sourcesIndex, sourceLine, sourceColumn]) : seg = [genColumn], line.push(seg), reader.pos++;
    }
    sorted || sort(line), decoded.push(line), reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a3, b) {
  return a3[0] - b[0];
}
var schemeRegex = /^[\w+.-]+:\/\//, urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i, UrlType2;
(function(UrlType3) {
  UrlType3[UrlType3.Empty = 1] = "Empty", UrlType3[UrlType3.Hash = 2] = "Hash", UrlType3[UrlType3.Query = 3] = "Query", UrlType3[UrlType3.RelativePath = 4] = "RelativePath", UrlType3[UrlType3.AbsolutePath = 5] = "AbsolutePath", UrlType3[UrlType3.SchemeRelative = 6] = "SchemeRelative", UrlType3[UrlType3.Absolute = 7] = "Absolute";
})(UrlType2 || (UrlType2 = {}));
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  let match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
  let match = fileRegex.exec(input), path = match[2];
  return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path, query, hash) {
  return {
    scheme,
    user,
    host,
    port,
    path,
    query,
    hash,
    type: UrlType2.Absolute
  };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    let url2 = parseAbsoluteUrl("http:" + input);
    return url2.scheme = "", url2.type = UrlType2.SchemeRelative, url2;
  }
  if (isAbsolutePath(input)) {
    let url2 = parseAbsoluteUrl("http://foo.com" + input);
    return url2.scheme = "", url2.host = "", url2.type = UrlType2.AbsolutePath, url2;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  let url = parseAbsoluteUrl("http://foo.com/" + input);
  return url.scheme = "", url.host = "", url.type = input ? input.startsWith("?") ? UrlType2.Query : input.startsWith("#") ? UrlType2.Hash : UrlType2.RelativePath : UrlType2.Empty, url;
}
function stripPathFilename(path) {
  if (path.endsWith("/.."))
    return path;
  let index2 = path.lastIndexOf("/");
  return path.slice(0, index2 + 1);
}
function mergePaths(url, base) {
  normalizePath(base, base.type), url.path === "/" ? url.path = base.path : url.path = stripPathFilename(base.path) + url.path;
}
function normalizePath(url, type3) {
  let rel = type3 <= UrlType2.RelativePath, pieces = url.path.split("/"), pointer = 1, positive = 0, addTrailingSlash = !1;
  for (let i = 1; i < pieces.length; i++) {
    let piece = pieces[i];
    if (!piece) {
      addTrailingSlash = !0;
      continue;
    }
    if (addTrailingSlash = !1, piece !== ".") {
      if (piece === "..") {
        positive ? (addTrailingSlash = !0, positive--, pointer--) : rel && (pieces[pointer++] = piece);
        continue;
      }
      pieces[pointer++] = piece, positive++;
    }
  }
  let path = "";
  for (let i = 1; i < pointer; i++)
    path += "/" + pieces[i];
  (!path || addTrailingSlash && !path.endsWith("/..")) && (path += "/"), url.path = path;
}
function resolve$1(input, base) {
  if (!input && !base)
    return "";
  let url = parseUrl(input), inputType = url.type;
  if (base && inputType !== UrlType2.Absolute) {
    let baseUrl = parseUrl(base), baseType = baseUrl.type;
    switch (inputType) {
      case UrlType2.Empty:
        url.hash = baseUrl.hash;
      // fall through
      case UrlType2.Hash:
        url.query = baseUrl.query;
      // fall through
      case UrlType2.Query:
      case UrlType2.RelativePath:
        mergePaths(url, baseUrl);
      // fall through
      case UrlType2.AbsolutePath:
        url.user = baseUrl.user, url.host = baseUrl.host, url.port = baseUrl.port;
      // fall through
      case UrlType2.SchemeRelative:
        url.scheme = baseUrl.scheme;
    }
    baseType > inputType && (inputType = baseType);
  }
  normalizePath(url, inputType);
  let queryHash = url.query + url.hash;
  switch (inputType) {
    // This is impossible, because of the empty checks at the start of the function.
    // case UrlType.Empty:
    case UrlType2.Hash:
    case UrlType2.Query:
      return queryHash;
    case UrlType2.RelativePath: {
      let path = url.path.slice(1);
      return path ? isRelative(base || input) && !isRelative(path) ? "./" + path + queryHash : path + queryHash : queryHash || ".";
    }
    case UrlType2.AbsolutePath:
      return url.path + queryHash;
    default:
      return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
  }
}
function resolve3(input, base) {
  return base && !base.endsWith("/") && (base += "/"), resolve$1(input, base);
}
function stripFilename(path) {
  if (!path)
    return "";
  let index2 = path.lastIndexOf("/");
  return path.slice(0, index2 + 1);
}
var COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  let unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  owned || (mappings = mappings.slice());
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))
    mappings[i] = sortSegments(mappings[i], owned);
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++)
    if (!isSorted(mappings[i]))
      return i;
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++)
    if (line[j][COLUMN] < line[j - 1][COLUMN])
      return !1;
  return !0;
}
function sortSegments(line, owned) {
  return owned || (line = line.slice()), line.sort(sortComparator);
}
function sortComparator(a3, b) {
  return a3[COLUMN] - b[COLUMN];
}
var found = !1;
function binarySearch(haystack, needle, low, high) {
  for (; low <= high; ) {
    let mid = low + (high - low >> 1), cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0)
      return found = !0, mid;
    cmp < 0 ? low = mid + 1 : high = mid - 1;
  }
  return found = !1, low - 1;
}
function upperBound(haystack, needle, index2) {
  for (let i = index2 + 1; i < haystack.length && haystack[i][COLUMN] === needle; index2 = i++)
    ;
  return index2;
}
function lowerBound(haystack, needle, index2) {
  for (let i = index2 - 1; i >= 0 && haystack[i][COLUMN] === needle; index2 = i--)
    ;
  return index2;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  let { lastKey, lastNeedle, lastIndex } = state, low = 0, high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle)
      return found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle, lastIndex;
    needle >= lastNeedle ? low = lastIndex === -1 ? 0 : lastIndex : high = lastIndex;
  }
  return state.lastKey = key, state.lastNeedle = needle, state.lastIndex = binarySearch(haystack, needle, low, high);
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)", COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)", LEAST_UPPER_BOUND = -1, GREATEST_LOWER_BOUND = 1, TraceMap = class {
  constructor(map2, mapUrl) {
    let isString = typeof map2 == "string";
    if (!isString && map2._decodedMemo)
      return map2;
    let parsed = isString ? JSON.parse(map2) : map2, { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version, this.file = file, this.names = names || [], this.sourceRoot = sourceRoot, this.sources = sources, this.sourcesContent = sourcesContent, this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    let from = resolve3(sourceRoot || "", stripFilename(mapUrl));
    this.resolvedSources = sources.map((s2) => resolve3(s2 || "", from));
    let { mappings } = parsed;
    typeof mappings == "string" ? (this._encoded = mappings, this._decoded = void 0) : (this._encoded = void 0, this._decoded = maybeSort(mappings, isString)), this._decodedMemo = memoizedState(), this._bySources = void 0, this._bySourceMemos = void 0;
  }
};
function decodedMappings(map2) {
  var _a;
  return (_a = map2)._decoded || (_a._decoded = decode(map2._encoded));
}
function originalPositionFor(map2, needle) {
  let { line, column, bias } = needle;
  if (line--, line < 0)
    throw new Error(LINE_GTR_ZERO);
  if (column < 0)
    throw new Error(COL_GTR_EQ_ZERO);
  let decoded = decodedMappings(map2);
  if (line >= decoded.length)
    return OMapping(null, null, null, null);
  let segments = decoded[line], index2 = traceSegmentInternal(segments, map2._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
  if (index2 === -1)
    return OMapping(null, null, null, null);
  let segment = segments[index2];
  if (segment.length === 1)
    return OMapping(null, null, null, null);
  let { names, resolvedSources } = map2;
  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function OMapping(source, line, column, name) {
  return { source, line, column, name };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index2 = memoizedBinarySearch(segments, column, memo, line);
  return found ? index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2) : bias === LEAST_UPPER_BOUND && index2++, index2 === -1 || index2 === segments.length ? -1 : index2;
}
function notNullish2(v) {
  return v != null;
}
function isPrimitive3(value) {
  return value === null || typeof value != "function" && typeof value != "object";
}
function isObject2(item) {
  return item != null && typeof item == "object" && !Array.isArray(item);
}
function getCallLastIndex2(code) {
  let charIndex = -1, inString = null, startedBracers = 0, endedBracers = 0, beforeChar = null;
  for (; charIndex <= code.length; ) {
    beforeChar = code[charIndex], charIndex++;
    let char = code[charIndex];
    if ((char === '"' || char === "'" || char === "`") && beforeChar !== "\\" && (inString === char ? inString = null : inString || (inString = char)), inString || (char === "(" && startedBracers++, char === ")" && endedBracers++), startedBracers && endedBracers && startedBracers === endedBracers)
      return charIndex;
  }
  return null;
}
var CHROME_IE_STACK_REGEXP2 = /^\s*at .*(?:\S:\d+|\(native\))/m, SAFARI_NATIVE_CODE_REGEXP2 = /^(?:eval@)?(?:\[native code\])?$/, stackIgnorePatterns = [
  "node:internal",
  /\/packages\/\w+\/dist\//,
  /\/@vitest\/\w+\/dist\//,
  "/vitest/dist/",
  "/vitest/src/",
  "/vite-node/dist/",
  "/vite-node/src/",
  "/node_modules/chai/",
  "/node_modules/tinypool/",
  "/node_modules/tinyspy/",
  "/deps/chunk-",
  "/deps/@vitest",
  "/deps/loupe",
  "/deps/chai",
  /node:\w+/,
  /__vitest_test__/,
  /__vitest_browser__/,
  /\/deps\/vitest_/
];
function extractLocation2(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike];
  let parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/^\(|\)$/g, ""));
  if (!parts)
    return [urlLike];
  let url = parts[1];
  if (url.startsWith("async ") && (url = url.slice(6)), url.startsWith("http:") || url.startsWith("https:")) {
    let urlObj = new URL(url);
    urlObj.searchParams.delete("import"), urlObj.searchParams.delete("browserv"), url = urlObj.pathname + urlObj.hash + urlObj.search;
  }
  if (url.startsWith("/@fs/")) {
    let isWindows = /^\/@fs\/[a-zA-Z]:\//.test(url);
    url = url.slice(isWindows ? 5 : 4);
  }
  return [
    url,
    parts[2] || void 0,
    parts[3] || void 0
  ];
}
function parseSingleFFOrSafariStack2(raw) {
  let line = raw.trim();
  if (SAFARI_NATIVE_CODE_REGEXP2.test(line) || (line.includes(" > eval") && (line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), !line.includes("@") && !line.includes(":")))
    return null;
  let functionNameRegex = /((.*".+"[^@]*)?[^@]*)(@)/, matches = line.match(functionNameRegex), functionName2 = matches && matches[1] ? matches[1] : void 0, [url, lineNumber, columnNumber] = extractLocation2(line.replace(functionNameRegex, ""));
  return !url || !lineNumber || !columnNumber ? null : {
    file: url,
    method: functionName2 || "",
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
function parseSingleV8Stack2(raw) {
  let line = raw.trim();
  if (!CHROME_IE_STACK_REGEXP2.test(line))
    return null;
  line.includes("(eval ") && (line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
  let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, ""), location = sanitizedLine.match(/ (\(.+\)$)/);
  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
  let [url, lineNumber, columnNumber] = extractLocation2(location ? location[1] : sanitizedLine), method = location && sanitizedLine || "", file = url && ["eval", "<anonymous>"].includes(url) ? void 0 : url;
  return !file || !lineNumber || !columnNumber ? null : (method.startsWith("async ") && (method = method.slice(6)), file.startsWith("file://") && (file = file.slice(7)), file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve2(file), method && (method = method.replace(/__vite_ssr_import_\d+__\./g, "")), {
    method,
    file,
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  });
}
function parseStacktrace(stack, options = {}) {
  let { ignoreStackEntries = stackIgnorePatterns } = options;
  return (CHROME_IE_STACK_REGEXP2.test(stack) ? parseV8Stacktrace(stack) : parseFFOrSafariStackTrace(stack)).map((stack2) => {
    var _options$getSourceMap;
    options.getUrlId && (stack2.file = options.getUrlId(stack2.file));
    let map2 = (_options$getSourceMap = options.getSourceMap) === null || _options$getSourceMap === void 0 ? void 0 : _options$getSourceMap.call(options, stack2.file);
    if (!map2 || typeof map2 != "object" || !map2.version)
      return shouldFilter(ignoreStackEntries, stack2.file) ? null : stack2;
    let traceMap = new TraceMap(map2), { line, column, source, name } = originalPositionFor(traceMap, stack2), file = stack2.file;
    if (source) {
      let fileUrl = stack2.file.startsWith("file://") ? stack2.file : `file://${stack2.file}`, sourceRootUrl = map2.sourceRoot ? new URL(map2.sourceRoot, fileUrl) : fileUrl;
      file = new URL(source, sourceRootUrl).pathname, file.match(/\/\w:\//) && (file = file.slice(1));
    }
    return shouldFilter(ignoreStackEntries, file) ? null : line != null && column != null ? {
      line,
      column,
      file,
      method: name || stack2.method
    } : stack2;
  }).filter((s2) => s2 != null);
}
function shouldFilter(ignoreStackEntries, file) {
  return ignoreStackEntries.some((p3) => file.match(p3));
}
function parseFFOrSafariStackTrace(stack) {
  return stack.split(`
`).map((line) => parseSingleFFOrSafariStack2(line)).filter(notNullish2);
}
function parseV8Stacktrace(stack) {
  return stack.split(`
`).map((line) => parseSingleV8Stack2(line)).filter(notNullish2);
}
function parseErrorStacktrace(e, options = {}) {
  if (!e || isPrimitive3(e))
    return [];
  if (e.stacks)
    return e.stacks;
  let stackStr = e.stack || "", stackFrames = typeof stackStr == "string" ? parseStacktrace(stackStr, options) : [];
  if (!stackFrames.length) {
    let e_ = e;
    e_.fileName != null && e_.lineNumber != null && e_.columnNumber != null && (stackFrames = parseStacktrace(`${e_.fileName}:${e_.lineNumber}:${e_.columnNumber}`, options)), e_.sourceURL != null && e_.line != null && e_._column != null && (stackFrames = parseStacktrace(`${e_.sourceURL}:${e_.line}:${e_.column}`, options));
  }
  return options.frameFilter && (stackFrames = stackFrames.filter((f3) => options.frameFilter(e, f3) !== !1)), e.stacks = stackFrames, stackFrames;
}
var getPromiseValue3 = () => "Promise{\u2026}";
try {
  let { getPromiseDetails, kPending, kRejected } = process.binding("util");
  Array.isArray(getPromiseDetails(Promise.resolve())) && (getPromiseValue3 = (value, options) => {
    let [state, innerValue] = getPromiseDetails(value);
    return state === kPending ? "Promise{<pending>}" : `Promise${state === kRejected ? "!" : ""}{${options.inspect(innerValue, options)}}`;
  });
} catch {
}
var nodeInspect3 = !1;
try {
  let nodeUtil = __require("util");
  nodeInspect3 = nodeUtil.inspect ? nodeUtil.inspect.custom : !1;
} catch {
  nodeInspect3 = !1;
}
var { AsymmetricMatcher: AsymmetricMatcher$1, DOMCollection: DOMCollection$1, DOMElement: DOMElement$1, Immutable: Immutable$1, ReactElement: ReactElement$1, ReactTestComponent: ReactTestComponent$1 } = plugins;
function getDefaultExportFromCjs4(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}
var jsTokens_12, hasRequiredJsTokens2;
function requireJsTokens2() {
  if (hasRequiredJsTokens2) return jsTokens_12;
  hasRequiredJsTokens2 = 1;
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  return RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu, Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y, Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu, StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y, NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y, Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y, WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu, LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y, MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y, SingleLineComment = /\/\/.*/y, JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y, JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu, JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y, JSXText = /[^<>{}]+/y, TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/, TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/, KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/, KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/, Newline = RegExp(LineTerminatorSequence.source), jsTokens_12 = function* (input, { jsx = !1 } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
    for ({ length } = input, lastIndex = 0, lastSignificantToken = "", stack = [
      { tag: "JS" }
    ], braces = [], parenNesting = 0, postfixIncDec = !1; lastIndex < length; ) {
      switch (mode = stack[stack.length - 1], mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)) && (RegularExpressionLiteral.lastIndex = lastIndex, match = RegularExpressionLiteral.exec(input))) {
            lastIndex = RegularExpressionLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };
            continue;
          }
          if (Punctuator.lastIndex = lastIndex, match = Punctuator.exec(input)) {
            switch (punctuator = match[0], nextLastIndex = Punctuator.lastIndex, nextLastSignificantToken = punctuator, punctuator) {
              case "(":
                lastSignificantToken === "?NonExpressionParenKeyword" && stack.push({
                  tag: "JSNonExpressionParen",
                  nesting: parenNesting
                }), parenNesting++, postfixIncDec = !1;
                break;
              case ")":
                parenNesting--, postfixIncDec = !0, mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting && (stack.pop(), nextLastSignificantToken = "?NonExpressionParenEnd", postfixIncDec = !1);
                break;
              case "{":
                Punctuator.lastIndex = 0, isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)), braces.push(isExpression), postfixIncDec = !1;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex, match = Template.exec(input), lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", postfixIncDec = !1, yield {
                        type: "TemplateMiddle",
                        value: match[0]
                      }) : (stack.pop(), postfixIncDec = !0, yield {
                        type: "TemplateTail",
                        value: match[0],
                        closed: match[1] === "`"
                      });
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack.pop(), lastIndex += 1, lastSignificantToken = "}", yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop(), nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = !0;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack.push({ tag: "JSXTag" }), lastIndex += 1, lastSignificantToken = "<", yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = !1;
                break;
              default:
                postfixIncDec = !1;
            }
            lastIndex = nextLastIndex, lastSignificantToken = nextLastSignificantToken, yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          if (Identifier.lastIndex = lastIndex, match = Identifier.exec(input)) {
            switch (lastIndex = Identifier.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                lastSignificantToken !== "." && lastSignificantToken !== "?." && (nextLastSignificantToken = "?NonExpressionParenKeyword");
            }
            lastSignificantToken = nextLastSignificantToken, postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]), yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          if (StringLiteral.lastIndex = lastIndex, match = StringLiteral.exec(input)) {
            lastIndex = StringLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          if (NumericLiteral.lastIndex = lastIndex, match = NumericLiteral.exec(input)) {
            lastIndex = NumericLiteral.lastIndex, lastSignificantToken = match[0], postfixIncDec = !0, yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          if (Template.lastIndex = lastIndex, match = Template.exec(input)) {
            lastIndex = Template.lastIndex, lastSignificantToken = match[0], match[1] === "${" ? (lastSignificantToken = "?InterpolationInTemplate", stack.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            }), postfixIncDec = !1, yield {
              type: "TemplateHead",
              value: match[0]
            }) : (postfixIncDec = !0, yield {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            });
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          if (JSXPunctuator.lastIndex = lastIndex, match = JSXPunctuator.exec(input)) {
            switch (lastIndex = JSXPunctuator.lastIndex, nextLastSignificantToken = match[0], match[0]) {
              case "<":
                stack.push({ tag: "JSXTag" });
                break;
              case ">":
                stack.pop(), lastSignificantToken === "/" || mode.tag === "JSXTagEnd" ? (nextLastSignificantToken = "?JSX", postfixIncDec = !0) : stack.push({ tag: "JSXChildren" });
                break;
              case "{":
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                }), nextLastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1;
                break;
              case "/":
                lastSignificantToken === "<" && (stack.pop(), stack[stack.length - 1].tag === "JSXChildren" && stack.pop(), stack.push({ tag: "JSXTagEnd" }));
            }
            lastSignificantToken = nextLastSignificantToken, yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          if (JSXIdentifier.lastIndex = lastIndex, match = JSXIdentifier.exec(input)) {
            lastIndex = JSXIdentifier.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          if (JSXString.lastIndex = lastIndex, match = JSXString.exec(input)) {
            lastIndex = JSXString.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          if (JSXText.lastIndex = lastIndex, match = JSXText.exec(input)) {
            lastIndex = JSXText.lastIndex, lastSignificantToken = match[0], yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input[lastIndex]) {
            case "<":
              stack.push({ tag: "JSXTag" }), lastIndex++, lastSignificantToken = "<", yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              }), lastIndex++, lastSignificantToken = "?InterpolationInJSX", postfixIncDec = !1, yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      if (WhiteSpace.lastIndex = lastIndex, match = WhiteSpace.exec(input)) {
        lastIndex = WhiteSpace.lastIndex, yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      if (LineTerminatorSequence.lastIndex = lastIndex, match = LineTerminatorSequence.exec(input)) {
        lastIndex = LineTerminatorSequence.lastIndex, postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere"), yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      if (MultiLineComment.lastIndex = lastIndex, match = MultiLineComment.exec(input)) {
        lastIndex = MultiLineComment.lastIndex, Newline.test(match[0]) && (postfixIncDec = !1, KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken) && (lastSignificantToken = "?NoLineTerminatorHere")), yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      if (SingleLineComment.lastIndex = lastIndex, match = SingleLineComment.exec(input)) {
        lastIndex = SingleLineComment.lastIndex, postfixIncDec = !1, yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex)), lastIndex += firstCodePoint.length, lastSignificantToken = firstCodePoint, postfixIncDec = !1, yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
  }, jsTokens_12;
}
requireJsTokens2();
var reservedWords2 = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(reservedWords2.keyword);
new Set(reservedWords2.strict);
var f2 = {
  reset: [0, 0],
  bold: [1, 22, "\x1B[22m\x1B[1m"],
  dim: [2, 22, "\x1B[22m\x1B[2m"],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  gray: [90, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
}, h2 = Object.entries(f2);
function a2(n) {
  return String(n);
}
a2.open = "";
a2.close = "";
function C2(n = !1) {
  let e = typeof process < "u" ? process : void 0, i = e?.env || {}, g = e?.argv || [];
  return !("NO_COLOR" in i || g.includes("--no-color")) && ("FORCE_COLOR" in i || g.includes("--color") || e?.platform === "win32" || n && i.TERM !== "dumb" || "CI" in i) || typeof window < "u" && !!window.chrome;
}
function p2(n = !1) {
  let e = C2(n), i = (r2, t, c, o) => {
    let l = "", s2 = 0;
    do
      l += r2.substring(s2, o) + c, s2 = o + t.length, o = r2.indexOf(t, s2);
    while (~o);
    return l + r2.substring(s2);
  }, g = (r2, t, c = r2) => {
    let o = (l) => {
      let s2 = String(l), b = s2.indexOf(t, r2.length);
      return ~b ? r2 + i(s2, t, c, b) + t : r2 + s2 + t;
    };
    return o.open = r2, o.close = t, o;
  }, u2 = {
    isColorSupported: e
  }, d = (r2) => `\x1B[${r2}m`;
  for (let [r2, t] of h2)
    u2[r2] = e ? g(
      d(t[0]),
      d(t[1]),
      t[2]
    ) : a2;
  return u2;
}
p2();
var lineSplitRE = /\r?\n/;
function positionToOffset(source, lineNumber, columnNumber) {
  let lines = source.split(lineSplitRE), nl = /\r\n/.test(source) ? 2 : 1, start = 0;
  if (lineNumber > lines.length)
    return source.length;
  for (let i = 0; i < lineNumber - 1; i++)
    start += lines[i].length + nl;
  return start + columnNumber;
}
function offsetToLineNumber(source, offset) {
  if (offset > source.length)
    throw new Error(`offset is longer than source length! offset ${offset} > length ${source.length}`);
  let lines = source.split(lineSplitRE), nl = /\r\n/.test(source) ? 2 : 1, counted = 0, line = 0;
  for (; line < lines.length; line++) {
    let lineLength = lines[line].length + nl;
    if (counted + lineLength >= offset)
      break;
    counted += lineLength;
  }
  return line + 1;
}
async function saveInlineSnapshots(environment, snapshots) {
  let MagicString = (await import("./magic-string.es-UZAAPNRE.js")).default, files = new Set(snapshots.map((i) => i.file));
  await Promise.all(Array.from(files).map(async (file) => {
    let snaps = snapshots.filter((i) => i.file === file), code = await environment.readSnapshotFile(file), s2 = new MagicString(code);
    for (let snap of snaps) {
      let index2 = positionToOffset(code, snap.line, snap.column);
      replaceInlineSnap(code, s2, index2, snap.snapshot);
    }
    let transformed = s2.toString();
    transformed !== code && await environment.saveSnapshotFile(file, transformed);
  }));
}
var startObjectRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*\{/;
function replaceObjectSnap(code, s2, index2, newSnap) {
  let _code = code.slice(index2), startMatch = startObjectRegex.exec(_code);
  if (!startMatch)
    return !1;
  _code = _code.slice(startMatch.index);
  let callEnd = getCallLastIndex2(_code);
  if (callEnd === null)
    return !1;
  callEnd += index2 + startMatch.index;
  let shapeStart = index2 + startMatch.index + startMatch[0].length, shapeEnd = getObjectShapeEndIndex(code, shapeStart), snap = `, ${prepareSnapString(newSnap, code, index2)}`;
  return shapeEnd === callEnd ? s2.appendLeft(callEnd, snap) : s2.overwrite(shapeEnd, callEnd, snap), !0;
}
function getObjectShapeEndIndex(code, index2) {
  let startBraces = 1, endBraces = 0;
  for (; startBraces !== endBraces && index2 < code.length; ) {
    let s2 = code[index2++];
    s2 === "{" ? startBraces++ : s2 === "}" && endBraces++;
  }
  return index2;
}
function prepareSnapString(snap, source, index2) {
  let lineNumber = offsetToLineNumber(source, index2), indent = source.split(lineSplitRE)[lineNumber - 1].match(/^\s*/)[0] || "", indentNext = indent.includes("	") ? `${indent}	` : `${indent}  `, lines = snap.trim().replace(/\\/g, "\\\\").split(/\n/g), isOneline = lines.length <= 1, quote = "`";
  return isOneline ? `${quote}${lines.join(`
`).replace(/`/g, "\\`").replace(/\$\{/g, "\\${")}${quote}` : `${quote}
${lines.map((i) => i ? indentNext + i : "").join(`
`).replace(/`/g, "\\`").replace(/\$\{/g, "\\${")}
${indent}${quote}`;
}
var toMatchInlineName = "toMatchInlineSnapshot", toThrowErrorMatchingInlineName = "toThrowErrorMatchingInlineSnapshot";
function getCodeStartingAtIndex(code, index2) {
  let indexInline = index2 - toMatchInlineName.length;
  if (code.slice(indexInline, index2) === toMatchInlineName)
    return {
      code: code.slice(indexInline),
      index: indexInline
    };
  let indexThrowInline = index2 - toThrowErrorMatchingInlineName.length;
  return code.slice(index2 - indexThrowInline, index2) === toThrowErrorMatchingInlineName ? {
    code: code.slice(index2 - indexThrowInline),
    index: index2 - indexThrowInline
  } : {
    code: code.slice(index2),
    index: index2
  };
}
var startRegex = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\s\S]*\*\/\s*|\/\/.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]))*[\w$]*(['"`)])/;
function replaceInlineSnap(code, s2, currentIndex, newSnap) {
  let { code: codeStartingAtIndex, index: index2 } = getCodeStartingAtIndex(code, currentIndex), startMatch = startRegex.exec(codeStartingAtIndex), firstKeywordMatch = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(codeStartingAtIndex);
  if (!startMatch || startMatch.index !== firstKeywordMatch?.index)
    return replaceObjectSnap(code, s2, index2, newSnap);
  let quote = startMatch[1], startIndex = index2 + startMatch.index + startMatch[0].length, snapString = prepareSnapString(newSnap, code, index2);
  if (quote === ")")
    return s2.appendRight(startIndex - 1, snapString), !0;
  let endMatch = new RegExp(`(?:^|[^\\\\])${quote}`).exec(code.slice(startIndex));
  if (!endMatch)
    return !1;
  let endIndex = startIndex + endMatch.index + endMatch[0].length;
  return s2.overwrite(startIndex - 1, endIndex, snapString), !0;
}
var INDENTATION_REGEX = /^([^\S\n]*)\S/m;
function stripSnapshotIndentation(inlineSnapshot) {
  let match = inlineSnapshot.match(INDENTATION_REGEX);
  if (!match || !match[1])
    return inlineSnapshot;
  let indentation = match[1], lines = inlineSnapshot.split(/\n/g);
  if (lines.length <= 2 || lines[0].trim() !== "" || lines[lines.length - 1].trim() !== "")
    return inlineSnapshot;
  for (let i = 1; i < lines.length - 1; i++)
    if (lines[i] !== "") {
      if (lines[i].indexOf(indentation) !== 0)
        return inlineSnapshot;
      lines[i] = lines[i].substring(indentation.length);
    }
  return lines[lines.length - 1] = "", inlineSnapshot = lines.join(`
`), inlineSnapshot;
}
async function saveRawSnapshots(environment, snapshots) {
  await Promise.all(snapshots.map(async (snap) => {
    snap.readonly || await environment.saveSnapshotFile(snap.file, snap.snapshot);
  }));
}
var naturalCompare$1 = { exports: {} }, hasRequiredNaturalCompare;
function requireNaturalCompare() {
  if (hasRequiredNaturalCompare) return naturalCompare$1.exports;
  hasRequiredNaturalCompare = 1;
  var naturalCompare2 = function(a3, b) {
    var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
    function getCode(str, pos, code) {
      if (code) {
        for (i = pos; code = getCode(str, i), code < 76 && code > 65; ) ++i;
        return +str.slice(pos - 1, i);
      }
      return code = alphabet && alphabet.indexOf(str.charAt(pos)), code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127 ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63);
    }
    if ((a3 += "") != (b += "")) {
      for (; codeB; )
        if (codeA = getCode(a3, posA++), codeB = getCode(b, posB++), codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66 && (codeA = getCode(a3, posA, posA), codeB = getCode(b, posB, posA = i), posB = i), codeA != codeB) return codeA < codeB ? -1 : 1;
    }
    return 0;
  };
  try {
    naturalCompare$1.exports = naturalCompare2;
  } catch {
    String.naturalCompare = naturalCompare2;
  }
  return naturalCompare$1.exports;
}
var naturalCompareExports = requireNaturalCompare(), naturalCompare = /* @__PURE__ */ getDefaultExportFromCjs4(naturalCompareExports), serialize$12 = (val, config2, indentation, depth, refs, printer2) => {
  let name = val.getMockName(), nameString = name === "vi.fn()" ? "" : ` ${name}`, callsString = "";
  if (val.mock.calls.length !== 0) {
    let indentationNext = indentation + config2.indent;
    callsString = ` {${config2.spacingOuter}${indentationNext}"calls": ${printer2(val.mock.calls, config2, indentationNext, depth, refs)}${config2.min ? ", " : ","}${config2.spacingOuter}${indentationNext}"results": ${printer2(val.mock.results, config2, indentationNext, depth, refs)}${config2.min ? "" : ","}${config2.spacingOuter}${indentation}}`;
  }
  return `[MockFunction${nameString}]${callsString}`;
}, test4 = (val) => val && !!val._isMockFunction, plugin2 = {
  serialize: serialize$12,
  test: test4
}, { DOMCollection: DOMCollection3, DOMElement: DOMElement3, Immutable: Immutable3, ReactElement: ReactElement3, ReactTestComponent: ReactTestComponent3, AsymmetricMatcher: AsymmetricMatcher4 } = plugins, PLUGINS3 = [
  ReactTestComponent3,
  ReactElement3,
  DOMElement3,
  DOMCollection3,
  Immutable3,
  AsymmetricMatcher4,
  plugin2
];
function addSerializer(plugin3) {
  PLUGINS3 = [plugin3].concat(PLUGINS3);
}
function getSerializers() {
  return PLUGINS3;
}
function testNameToKey(testName2, count) {
  return `${testName2} ${count}`;
}
function keyToTestName(key) {
  if (!/ \d+$/.test(key))
    throw new Error("Snapshot keys must end with a number.");
  return key.replace(/ \d+$/, "");
}
function getSnapshotData(content, options) {
  let update = options.updateSnapshot, data = /* @__PURE__ */ Object.create(null), snapshotContents = "", dirty = !1;
  if (content != null)
    try {
      snapshotContents = content, new Function("exports", snapshotContents)(data);
    } catch {
    }
  return (update === "all" || update === "new") && snapshotContents && (dirty = !0), {
    data,
    dirty
  };
}
function addExtraLineBreaks(string2) {
  return string2.includes(`
`) ? `
${string2}
` : string2;
}
function removeExtraLineBreaks(string2) {
  return string2.length > 2 && string2.startsWith(`
`) && string2.endsWith(`
`) ? string2.slice(1, -1) : string2;
}
var escapeRegex = !0, printFunctionName = !1;
function serialize2(val, indent = 2, formatOverrides = {}) {
  return normalizeNewlines(format(val, {
    escapeRegex,
    indent,
    plugins: getSerializers(),
    printFunctionName,
    ...formatOverrides
  }));
}
function escapeBacktickString(str) {
  return str.replace(/`|\\|\$\{/g, "\\$&");
}
function printBacktickString(str) {
  return `\`${escapeBacktickString(str)}\``;
}
function normalizeNewlines(string2) {
  return string2.replace(/\r\n|\r/g, `
`);
}
async function saveSnapshotFile(environment, snapshotData, snapshotPath) {
  let snapshots = Object.keys(snapshotData).sort(naturalCompare).map((key) => `exports[${printBacktickString(key)}] = ${printBacktickString(normalizeNewlines(snapshotData[key]))};`), content = `${environment.getHeader()}

${snapshots.join(`

`)}
`, oldContent = await environment.readSnapshotFile(snapshotPath);
  oldContent != null && oldContent === content || await environment.saveSnapshotFile(snapshotPath, content);
}
function deepMergeArray(target = [], source = []) {
  let mergedOutput = Array.from(target);
  return source.forEach((sourceElement, index2) => {
    let targetElement = mergedOutput[index2];
    Array.isArray(target[index2]) ? mergedOutput[index2] = deepMergeArray(target[index2], sourceElement) : isObject2(targetElement) ? mergedOutput[index2] = deepMergeSnapshot(target[index2], sourceElement) : mergedOutput[index2] = sourceElement;
  }), mergedOutput;
}
function deepMergeSnapshot(target, source) {
  if (isObject2(target) && isObject2(source)) {
    let mergedOutput = { ...target };
    return Object.keys(source).forEach((key) => {
      isObject2(source[key]) && !source[key].$$typeof ? key in target ? mergedOutput[key] = deepMergeSnapshot(target[key], source[key]) : Object.assign(mergedOutput, { [key]: source[key] }) : Array.isArray(source[key]) ? mergedOutput[key] = deepMergeArray(target[key], source[key]) : Object.assign(mergedOutput, { [key]: source[key] });
    }), mergedOutput;
  } else if (Array.isArray(target) && Array.isArray(source))
    return deepMergeArray(target, source);
  return target;
}
var DefaultMap = class extends Map {
  constructor(defaultFn, entries) {
    super(entries), this.defaultFn = defaultFn;
  }
  get(key) {
    return this.has(key) || this.set(key, this.defaultFn(key)), super.get(key);
  }
}, CounterMap = class extends DefaultMap {
  constructor() {
    super(() => 0);
  }
  // compat for jest-image-snapshot https://github.com/vitest-dev/vitest/issues/7322
  // `valueOf` and `Snapshot.added` setter allows
  //   snapshotState.added = snapshotState.added + 1
  // to function as
  //   snapshotState.added.total_ = snapshotState.added.total() + 1
  _total;
  valueOf() {
    return this._total = this.total();
  }
  increment(key) {
    typeof this._total < "u" && this._total++, this.set(key, this.get(key) + 1);
  }
  total() {
    if (typeof this._total < "u")
      return this._total;
    let total = 0;
    for (let x of this.values())
      total += x;
    return total;
  }
};
function isSameStackPosition(x, y) {
  return x.file === y.file && x.column === y.column && x.line === y.line;
}
var SnapshotState = class _SnapshotState {
  _counters = new CounterMap();
  _dirty;
  _updateSnapshot;
  _snapshotData;
  _initialData;
  _inlineSnapshots;
  _inlineSnapshotStacks;
  _testIdToKeys = new DefaultMap(() => []);
  _rawSnapshots;
  _uncheckedKeys;
  _snapshotFormat;
  _environment;
  _fileExists;
  expand;
  // getter/setter for jest-image-snapshot compat
  // https://github.com/vitest-dev/vitest/issues/7322
  _added = new CounterMap();
  _matched = new CounterMap();
  _unmatched = new CounterMap();
  _updated = new CounterMap();
  get added() {
    return this._added;
  }
  set added(value) {
    this._added._total = value;
  }
  get matched() {
    return this._matched;
  }
  set matched(value) {
    this._matched._total = value;
  }
  get unmatched() {
    return this._unmatched;
  }
  set unmatched(value) {
    this._unmatched._total = value;
  }
  get updated() {
    return this._updated;
  }
  set updated(value) {
    this._updated._total = value;
  }
  constructor(testFilePath, snapshotPath, snapshotContent, options) {
    this.testFilePath = testFilePath, this.snapshotPath = snapshotPath;
    let { data, dirty } = getSnapshotData(snapshotContent, options);
    this._fileExists = snapshotContent != null, this._initialData = { ...data }, this._snapshotData = { ...data }, this._dirty = dirty, this._inlineSnapshots = [], this._inlineSnapshotStacks = [], this._rawSnapshots = [], this._uncheckedKeys = new Set(Object.keys(this._snapshotData)), this.expand = options.expand || !1, this._updateSnapshot = options.updateSnapshot, this._snapshotFormat = {
      printBasicPrototype: !1,
      escapeString: !1,
      ...options.snapshotFormat
    }, this._environment = options.snapshotEnvironment;
  }
  static async create(testFilePath, options) {
    let snapshotPath = await options.snapshotEnvironment.resolvePath(testFilePath), content = await options.snapshotEnvironment.readSnapshotFile(snapshotPath);
    return new _SnapshotState(testFilePath, snapshotPath, content, options);
  }
  get environment() {
    return this._environment;
  }
  markSnapshotsAsCheckedForTest(testName2) {
    this._uncheckedKeys.forEach((uncheckedKey) => {
      / \d+$| > /.test(uncheckedKey.slice(testName2.length)) && this._uncheckedKeys.delete(uncheckedKey);
    });
  }
  clearTest(testId) {
    this._inlineSnapshots = this._inlineSnapshots.filter((s2) => s2.testId !== testId), this._inlineSnapshotStacks = this._inlineSnapshotStacks.filter((s2) => s2.testId !== testId);
    for (let key of this._testIdToKeys.get(testId)) {
      let name = keyToTestName(key), count = this._counters.get(name);
      count > 0 && ((key in this._snapshotData || key in this._initialData) && (this._snapshotData[key] = this._initialData[key]), this._counters.set(name, count - 1));
    }
    this._testIdToKeys.delete(testId), this.added.delete(testId), this.updated.delete(testId), this.matched.delete(testId), this.unmatched.delete(testId);
  }
  _inferInlineSnapshotStack(stacks) {
    let promiseIndex = stacks.findIndex((i) => i.method.match(/__VITEST_(RESOLVES|REJECTS)__/));
    if (promiseIndex !== -1)
      return stacks[promiseIndex + 3];
    let stackIndex = stacks.findIndex((i) => i.method.includes("__INLINE_SNAPSHOT__"));
    return stackIndex !== -1 ? stacks[stackIndex + 2] : null;
  }
  _addSnapshot(key, receivedSerialized, options) {
    this._dirty = !0, options.stack ? this._inlineSnapshots.push({
      snapshot: receivedSerialized,
      testId: options.testId,
      ...options.stack
    }) : options.rawSnapshot ? this._rawSnapshots.push({
      ...options.rawSnapshot,
      snapshot: receivedSerialized
    }) : this._snapshotData[key] = receivedSerialized;
  }
  async save() {
    let hasExternalSnapshots = Object.keys(this._snapshotData).length, hasInlineSnapshots = this._inlineSnapshots.length, hasRawSnapshots = this._rawSnapshots.length, isEmpty = !hasExternalSnapshots && !hasInlineSnapshots && !hasRawSnapshots, status = {
      deleted: !1,
      saved: !1
    };
    return (this._dirty || this._uncheckedKeys.size) && !isEmpty ? (hasExternalSnapshots && (await saveSnapshotFile(this._environment, this._snapshotData, this.snapshotPath), this._fileExists = !0), hasInlineSnapshots && await saveInlineSnapshots(this._environment, this._inlineSnapshots), hasRawSnapshots && await saveRawSnapshots(this._environment, this._rawSnapshots), status.saved = !0) : !hasExternalSnapshots && this._fileExists && (this._updateSnapshot === "all" && (await this._environment.removeSnapshotFile(this.snapshotPath), this._fileExists = !1), status.deleted = !0), status;
  }
  getUncheckedCount() {
    return this._uncheckedKeys.size || 0;
  }
  getUncheckedKeys() {
    return Array.from(this._uncheckedKeys);
  }
  removeUncheckedKeys() {
    this._updateSnapshot === "all" && this._uncheckedKeys.size && (this._dirty = !0, this._uncheckedKeys.forEach((key) => delete this._snapshotData[key]), this._uncheckedKeys.clear());
  }
  match({ testId, testName: testName2, received, key, inlineSnapshot, isInline, error, rawSnapshot }) {
    this._counters.increment(testName2);
    let count = this._counters.get(testName2);
    key || (key = testNameToKey(testName2, count)), this._testIdToKeys.get(testId).push(key), isInline && this._snapshotData[key] !== void 0 || this._uncheckedKeys.delete(key);
    let receivedSerialized = rawSnapshot && typeof received == "string" ? received : serialize2(received, void 0, this._snapshotFormat);
    rawSnapshot || (receivedSerialized = addExtraLineBreaks(receivedSerialized)), rawSnapshot && rawSnapshot.content && rawSnapshot.content.match(/\r\n/) && !receivedSerialized.match(/\r\n/) && (rawSnapshot.content = normalizeNewlines(rawSnapshot.content));
    let expected = isInline ? inlineSnapshot : rawSnapshot ? rawSnapshot.content : this._snapshotData[key], expectedTrimmed = rawSnapshot ? expected : expected?.trim(), pass = expectedTrimmed === (rawSnapshot ? receivedSerialized : receivedSerialized.trim()), hasSnapshot = expected !== void 0, snapshotIsPersisted = isInline || this._fileExists || rawSnapshot && rawSnapshot.content != null;
    pass && !isInline && !rawSnapshot && (this._snapshotData[key] = receivedSerialized);
    let stack;
    if (isInline) {
      var _this$environment$pro, _this$environment;
      let stacks = parseErrorStacktrace(error || new Error("snapshot"), { ignoreStackEntries: [] }), _stack = this._inferInlineSnapshotStack(stacks);
      if (!_stack)
        throw new Error(`@vitest/snapshot: Couldn't infer stack frame for inline snapshot.
${JSON.stringify(stacks)}`);
      stack = ((_this$environment$pro = (_this$environment = this.environment).processStackTrace) === null || _this$environment$pro === void 0 ? void 0 : _this$environment$pro.call(_this$environment, _stack)) || _stack, stack.column--;
      let snapshotsWithSameStack = this._inlineSnapshotStacks.filter((s2) => isSameStackPosition(s2, stack));
      if (snapshotsWithSameStack.length > 0) {
        this._inlineSnapshots = this._inlineSnapshots.filter((s2) => !isSameStackPosition(s2, stack));
        let differentSnapshot = snapshotsWithSameStack.find((s2) => s2.snapshot !== receivedSerialized);
        if (differentSnapshot)
          throw Object.assign(new Error("toMatchInlineSnapshot with different snapshots cannot be called at the same location"), {
            actual: receivedSerialized,
            expected: differentSnapshot.snapshot
          });
      }
      this._inlineSnapshotStacks.push({
        ...stack,
        testId,
        snapshot: receivedSerialized
      });
    }
    return hasSnapshot && this._updateSnapshot === "all" || (!hasSnapshot || !snapshotIsPersisted) && (this._updateSnapshot === "new" || this._updateSnapshot === "all") ? (this._updateSnapshot === "all" ? pass ? this.matched.increment(testId) : (hasSnapshot ? this.updated.increment(testId) : this.added.increment(testId), this._addSnapshot(key, receivedSerialized, {
      stack,
      testId,
      rawSnapshot
    })) : (this._addSnapshot(key, receivedSerialized, {
      stack,
      testId,
      rawSnapshot
    }), this.added.increment(testId)), {
      actual: "",
      count,
      expected: "",
      key,
      pass: !0
    }) : pass ? (this.matched.increment(testId), {
      actual: "",
      count,
      expected: "",
      key,
      pass: !0
    }) : (this.unmatched.increment(testId), {
      actual: rawSnapshot ? receivedSerialized : removeExtraLineBreaks(receivedSerialized),
      count,
      expected: expectedTrimmed !== void 0 ? rawSnapshot ? expectedTrimmed : removeExtraLineBreaks(expectedTrimmed) : void 0,
      key,
      pass: !1
    });
  }
  async pack() {
    let snapshot = {
      filepath: this.testFilePath,
      added: 0,
      fileDeleted: !1,
      matched: 0,
      unchecked: 0,
      uncheckedKeys: [],
      unmatched: 0,
      updated: 0
    }, uncheckedCount = this.getUncheckedCount(), uncheckedKeys = this.getUncheckedKeys();
    uncheckedCount && this.removeUncheckedKeys();
    let status = await this.save();
    return snapshot.fileDeleted = status.deleted, snapshot.added = this.added.total(), snapshot.matched = this.matched.total(), snapshot.unmatched = this.unmatched.total(), snapshot.updated = this.updated.total(), snapshot.unchecked = status.deleted ? 0 : uncheckedCount, snapshot.uncheckedKeys = Array.from(uncheckedKeys), snapshot;
  }
};
function createMismatchError(message, expand, actual, expected) {
  let error = new Error(message);
  return Object.defineProperty(error, "actual", {
    value: actual,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }), Object.defineProperty(error, "expected", {
    value: expected,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }), Object.defineProperty(error, "diffOptions", { value: { expand } }), error;
}
var SnapshotClient = class {
  snapshotStateMap = /* @__PURE__ */ new Map();
  constructor(options = {}) {
    this.options = options;
  }
  async setup(filepath, options) {
    this.snapshotStateMap.has(filepath) || this.snapshotStateMap.set(filepath, await SnapshotState.create(filepath, options));
  }
  async finish(filepath) {
    let result = await this.getSnapshotState(filepath).pack();
    return this.snapshotStateMap.delete(filepath), result;
  }
  skipTest(filepath, testName2) {
    this.getSnapshotState(filepath).markSnapshotsAsCheckedForTest(testName2);
  }
  clearTest(filepath, testId) {
    this.getSnapshotState(filepath).clearTest(testId);
  }
  getSnapshotState(filepath) {
    let state = this.snapshotStateMap.get(filepath);
    if (!state)
      throw new Error(`The snapshot state for '${filepath}' is not found. Did you call 'SnapshotClient.setup()'?`);
    return state;
  }
  assert(options) {
    let { filepath, name, testId = name, message, isInline = !1, properties, inlineSnapshot, error, errorMessage, rawSnapshot } = options, { received } = options;
    if (!filepath)
      throw new Error("Snapshot cannot be used outside of test");
    let snapshotState = this.getSnapshotState(filepath);
    if (typeof properties == "object") {
      if (typeof received != "object" || !received)
        throw new Error("Received value must be an object when the matcher has properties");
      try {
        var _this$options$isEqual, _this$options;
        if (((_this$options$isEqual = (_this$options = this.options).isEqual) === null || _this$options$isEqual === void 0 ? void 0 : _this$options$isEqual.call(_this$options, received, properties)) ?? !1)
          received = deepMergeSnapshot(received, properties);
        else
          throw createMismatchError("Snapshot properties mismatched", snapshotState.expand, received, properties);
      } catch (err) {
        throw err.message = errorMessage || "Snapshot mismatched", err;
      }
    }
    let testName2 = [name, ...message ? [message] : []].join(" > "), { actual, expected, key, pass } = snapshotState.match({
      testId,
      testName: testName2,
      received,
      isInline,
      error,
      inlineSnapshot,
      rawSnapshot
    });
    if (!pass)
      throw createMismatchError(`Snapshot \`${key || "unknown"}\` mismatched`, snapshotState.expand, rawSnapshot ? actual : actual?.trim(), rawSnapshot ? expected : expected?.trim());
  }
  async assertRaw(options) {
    if (!options.rawSnapshot)
      throw new Error("Raw snapshot is required");
    let { filepath, rawSnapshot } = options;
    if (rawSnapshot.content == null) {
      if (!filepath)
        throw new Error("Snapshot cannot be used outside of test");
      let snapshotState = this.getSnapshotState(filepath);
      options.filepath || (options.filepath = filepath), rawSnapshot.file = await snapshotState.environment.resolveRawPath(filepath, rawSnapshot.file), rawSnapshot.content = await snapshotState.environment.readSnapshotFile(rawSnapshot.file) ?? void 0;
    }
    return this.assert(options);
  }
  clear() {
    this.snapshotStateMap.clear();
  }
};

// ../../node_modules/.pnpm/vitest@3.2.1_@types+node@18.19.70_jiti@2.4.2_jsdom@20.0.3_msw@2.8.7_@types+node@18.19.7_59b23bdad58d2b08cdc86d448ade34f5/node_modules/vitest/dist/chunks/date.Bq6ZW5rf.js
init_cjs_shims();
var RealDate = Date, now2 = null, MockDate = class _MockDate extends RealDate {
  constructor(y, m2, d, h3, M, s2, ms) {
    super();
    let date;
    switch (arguments.length) {
      case 0:
        now2 !== null ? date = new RealDate(now2.valueOf()) : date = new RealDate();
        break;
      case 1:
        date = new RealDate(y);
        break;
      default:
        d = typeof d > "u" ? 1 : d, h3 = h3 || 0, M = M || 0, s2 = s2 || 0, ms = ms || 0, date = new RealDate(y, m2, d, h3, M, s2, ms);
        break;
    }
    return Object.setPrototypeOf(date, _MockDate.prototype), date;
  }
};
MockDate.UTC = RealDate.UTC;
MockDate.now = function() {
  return new MockDate().valueOf();
};
MockDate.parse = function(dateString) {
  return RealDate.parse(dateString);
};
MockDate.toString = function() {
  return RealDate.toString();
};
function mockDate(date) {
  let dateObj = new RealDate(date.valueOf());
  if (Number.isNaN(dateObj.getTime())) throw new TypeError(`mockdate: The time set is an invalid date: ${date}`);
  globalThis.Date = MockDate, now2 = dateObj.valueOf();
}
function resetDate() {
  globalThis.Date = RealDate;
}

// ../../node_modules/.pnpm/vitest@3.2.1_@types+node@18.19.70_jiti@2.4.2_jsdom@20.0.3_msw@2.8.7_@types+node@18.19.7_59b23bdad58d2b08cdc86d448ade34f5/node_modules/vitest/dist/chunks/vi.bdSIJ99Y.js
var unsupported = [
  "matchSnapshot",
  "toMatchSnapshot",
  "toMatchInlineSnapshot",
  "toThrowErrorMatchingSnapshot",
  "toThrowErrorMatchingInlineSnapshot",
  "throws",
  "Throw",
  "throw",
  "toThrow",
  "toThrowError"
];
function createExpectPoll(expect2) {
  return function(fn2, options = {}) {
    let defaults = getWorkerState().config.expect?.poll ?? {}, { interval = defaults.interval ?? 50, timeout = defaults.timeout ?? 1e3, message } = options, assertion = expect2(null, message).withContext({ poll: !0 });
    fn2 = fn2.bind(assertion);
    let test5 = utils_exports.flag(assertion, "vitest-test");
    if (!test5) throw new Error("expect.poll() must be called inside a test");
    let proxy = new Proxy(assertion, { get(target, key, receiver) {
      let assertionFunction = Reflect.get(target, key, receiver);
      if (typeof assertionFunction != "function") return assertionFunction instanceof Assertion ? proxy : assertionFunction;
      if (key === "assert") return assertionFunction;
      if (typeof key == "string" && unsupported.includes(key)) throw new SyntaxError(`expect.poll() is not supported in combination with .${key}(). Use vi.waitFor() if your assertion condition is unstable.`);
      return function(...args) {
        let STACK_TRACE_ERROR = new Error("STACK_TRACE_ERROR"), promise = () => new Promise((resolve4, reject) => {
          let intervalId, timeoutId, lastError, { setTimeout, clearTimeout } = getSafeTimers(), check = async () => {
            try {
              utils_exports.flag(assertion, "_name", key);
              let obj = await fn2();
              utils_exports.flag(assertion, "object", obj), resolve4(await assertionFunction.call(assertion, ...args)), clearTimeout(intervalId), clearTimeout(timeoutId);
            } catch (err) {
              lastError = err, utils_exports.flag(assertion, "_isLastPollAttempt") || (intervalId = setTimeout(check, interval));
            }
          };
          timeoutId = setTimeout(() => {
            clearTimeout(intervalId), utils_exports.flag(assertion, "_isLastPollAttempt", !0);
            let rejectWithCause = (cause) => {
              reject(copyStackTrace$1(new Error("Matcher did not succeed in time.", { cause }), STACK_TRACE_ERROR));
            };
            check().then(() => rejectWithCause(lastError)).catch((e) => rejectWithCause(e));
          }, timeout), check();
        }), awaited = !1;
        test5.onFinished ??= [], test5.onFinished.push(() => {
          if (!awaited) {
            let negated = utils_exports.flag(assertion, "negate") ? "not." : "", assertionString = `expect.${utils_exports.flag(assertion, "_poll.element") ? "element(locator)" : "poll(assertion)"}.${negated}${String(key)}()`, error = new Error(`${assertionString} was not awaited. This assertion is asynchronous and must be awaited; otherwise, it is not executed to avoid unhandled rejections:

await ${assertionString}
`);
            throw copyStackTrace$1(error, STACK_TRACE_ERROR);
          }
        });
        let resultPromise;
        return {
          then(onFulfilled, onRejected) {
            return awaited = !0, (resultPromise ||= promise()).then(onFulfilled, onRejected);
          },
          catch(onRejected) {
            return (resultPromise ||= promise()).catch(onRejected);
          },
          finally(onFinally) {
            return (resultPromise ||= promise()).finally(onFinally);
          },
          [Symbol.toStringTag]: "Promise"
        };
      };
    } });
    return proxy;
  };
}
function copyStackTrace$1(target, source) {
  return source.stack !== void 0 && (target.stack = source.stack.replace(source.message, target.message)), target;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var chaiSubset$1 = { exports: {} }, chaiSubset = chaiSubset$1.exports, hasRequiredChaiSubset;
function requireChaiSubset() {
  return hasRequiredChaiSubset || (hasRequiredChaiSubset = 1, function(module, exports) {
    (function() {
      (function(chaiSubset2) {
        return typeof commonjsRequire == "function" ? module.exports = chaiSubset2 : chai.use(chaiSubset2);
      })(function(chai2, utils) {
        var Assertion2 = chai2.Assertion, assertionPrototype = Assertion2.prototype;
        Assertion2.addMethod("containSubset", function(expected) {
          var actual = utils.flag(this, "object"), showDiff = chai2.config.showDiff;
          assertionPrototype.assert.call(
            this,
            compare(expected, actual),
            "expected #{act} to contain subset #{exp}",
            "expected #{act} to not contain subset #{exp}",
            expected,
            actual,
            showDiff
          );
        }), chai2.assert.containSubset = function(val, exp, msg) {
          new chai2.Assertion(val, msg).to.be.containSubset(exp);
        };
        function compare(expected, actual) {
          if (expected === actual)
            return !0;
          if (typeof actual != typeof expected)
            return !1;
          if (typeof expected != "object" || expected === null)
            return expected === actual;
          if (expected && !actual)
            return !1;
          if (Array.isArray(expected)) {
            if (typeof actual.length != "number")
              return !1;
            var aa = Array.prototype.slice.call(actual);
            return expected.every(function(exp) {
              return aa.some(function(act) {
                return compare(exp, act);
              });
            });
          }
          return expected instanceof Date ? actual instanceof Date ? expected.getTime() === actual.getTime() : !1 : Object.keys(expected).every(function(key) {
            var eo = expected[key], ao = actual[key];
            return typeof eo == "object" && eo !== null && ao !== null ? compare(eo, ao) : typeof eo == "function" ? eo(ao) : ao === eo;
          });
        }
      });
    }).call(chaiSubset);
  }(chaiSubset$1)), chaiSubset$1.exports;
}
var chaiSubsetExports = requireChaiSubset(), Subset = /* @__PURE__ */ getDefaultExportFromCjs3(chaiSubsetExports);
function createAssertionMessage2(util, assertion, hasArgs) {
  let not = util.flag(assertion, "negate") ? "not." : "", name = `${util.flag(assertion, "_name")}(expected)`, promiseName = util.flag(assertion, "promise");
  return `expect(actual)${promiseName ? `.${promiseName}` : ""}.${not}${name}`;
}
function recordAsyncExpect2(_test2, promise, assertion, error) {
  let test5 = _test2;
  if (test5 && promise instanceof Promise) {
    promise = promise.finally(() => {
      if (!test5.promises) return;
      let index2 = test5.promises.indexOf(promise);
      index2 !== -1 && test5.promises.splice(index2, 1);
    }), test5.promises || (test5.promises = []), test5.promises.push(promise);
    let resolved = !1;
    return test5.onFinished ??= [], test5.onFinished.push(() => {
      if (!resolved) {
        let stack = (globalThis.__vitest_worker__?.onFilterStackTrace || ((s2) => s2 || ""))(error.stack);
        console.warn([
          `Promise returned by \`${assertion}\` was not awaited. `,
          "Vitest currently auto-awaits hanging assertions at the end of the test, but this will cause the test to fail in Vitest 3. ",
          `Please remember to await the assertion.
`,
          stack
        ].join(""));
      }
    }), {
      then(onFulfilled, onRejected) {
        return resolved = !0, promise.then(onFulfilled, onRejected);
      },
      catch(onRejected) {
        return promise.catch(onRejected);
      },
      finally(onFinally) {
        return promise.finally(onFinally);
      },
      [Symbol.toStringTag]: "Promise"
    };
  }
  return promise;
}
var _client;
function getSnapshotClient() {
  return _client || (_client = new SnapshotClient({ isEqual: (received, expected) => equals(received, expected, [iterableEquality, subsetEquality]) })), _client;
}
function getError(expected, promise) {
  if (typeof expected != "function") {
    if (!promise) throw new Error(`expected must be a function, received ${typeof expected}`);
    return expected;
  }
  try {
    expected();
  } catch (e) {
    return e;
  }
  throw new Error("snapshot function didn't throw");
}
function getTestNames(test5) {
  return {
    filepath: test5.file.filepath,
    name: getNames(test5).slice(1).join(" > "),
    testId: test5.id
  };
}
var SnapshotPlugin = (chai2, utils) => {
  function getTest(assertionName, obj) {
    let test5 = utils.flag(obj, "vitest-test");
    if (!test5) throw new Error(`'${assertionName}' cannot be used without test context`);
    return test5;
  }
  for (let key of ["matchSnapshot", "toMatchSnapshot"]) utils.addMethod(chai2.Assertion.prototype, key, function(properties, message) {
    if (utils.flag(this, "_name", key), utils.flag(this, "negate")) throw new Error(`${key} cannot be used with "not"`);
    let expected = utils.flag(this, "object"), test5 = getTest(key, this);
    typeof properties == "string" && typeof message > "u" && (message = properties, properties = void 0);
    let errorMessage = utils.flag(this, "message");
    getSnapshotClient().assert({
      received: expected,
      message,
      isInline: !1,
      properties,
      errorMessage,
      ...getTestNames(test5)
    });
  });
  utils.addMethod(chai2.Assertion.prototype, "toMatchFileSnapshot", function(file, message) {
    if (utils.flag(this, "_name", "toMatchFileSnapshot"), utils.flag(this, "negate")) throw new Error('toMatchFileSnapshot cannot be used with "not"');
    let error = new Error("resolves"), expected = utils.flag(this, "object"), test5 = getTest("toMatchFileSnapshot", this), errorMessage = utils.flag(this, "message"), promise = getSnapshotClient().assertRaw({
      received: expected,
      message,
      isInline: !1,
      rawSnapshot: { file },
      errorMessage,
      ...getTestNames(test5)
    });
    return recordAsyncExpect2(test5, promise, createAssertionMessage2(utils, this), error);
  }), utils.addMethod(chai2.Assertion.prototype, "toMatchInlineSnapshot", function(properties, inlineSnapshot, message) {
    if (utils.flag(this, "_name", "toMatchInlineSnapshot"), utils.flag(this, "negate")) throw new Error('toMatchInlineSnapshot cannot be used with "not"');
    let test5 = getTest("toMatchInlineSnapshot", this);
    if (test5.each || test5.suite?.each) throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
    let expected = utils.flag(this, "object"), error = utils.flag(this, "error");
    typeof properties == "string" && (message = inlineSnapshot, inlineSnapshot = properties, properties = void 0), inlineSnapshot && (inlineSnapshot = stripSnapshotIndentation(inlineSnapshot));
    let errorMessage = utils.flag(this, "message");
    getSnapshotClient().assert({
      received: expected,
      message,
      isInline: !0,
      properties,
      inlineSnapshot,
      error,
      errorMessage,
      ...getTestNames(test5)
    });
  }), utils.addMethod(chai2.Assertion.prototype, "toThrowErrorMatchingSnapshot", function(message) {
    if (utils.flag(this, "_name", "toThrowErrorMatchingSnapshot"), utils.flag(this, "negate")) throw new Error('toThrowErrorMatchingSnapshot cannot be used with "not"');
    let expected = utils.flag(this, "object"), test5 = getTest("toThrowErrorMatchingSnapshot", this), promise = utils.flag(this, "promise"), errorMessage = utils.flag(this, "message");
    getSnapshotClient().assert({
      received: getError(expected, promise),
      message,
      errorMessage,
      ...getTestNames(test5)
    });
  }), utils.addMethod(chai2.Assertion.prototype, "toThrowErrorMatchingInlineSnapshot", function(inlineSnapshot, message) {
    if (utils.flag(this, "negate")) throw new Error('toThrowErrorMatchingInlineSnapshot cannot be used with "not"');
    let test5 = getTest("toThrowErrorMatchingInlineSnapshot", this);
    if (test5.each || test5.suite?.each) throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
    let expected = utils.flag(this, "object"), error = utils.flag(this, "error"), promise = utils.flag(this, "promise"), errorMessage = utils.flag(this, "message");
    inlineSnapshot && (inlineSnapshot = stripSnapshotIndentation(inlineSnapshot)), getSnapshotClient().assert({
      received: getError(expected, promise),
      message,
      inlineSnapshot,
      isInline: !0,
      error,
      errorMessage,
      ...getTestNames(test5)
    });
  }), utils.addMethod(chai2.expect, "addSnapshotSerializer", addSerializer);
};
use(JestExtend);
use(JestChaiExpect);
use(Subset);
use(SnapshotPlugin);
use(JestAsymmetricMatchers);
function createExpect(test5) {
  let expect2 = (value, message) => {
    let { assertionCalls } = getState(expect2);
    setState({ assertionCalls: assertionCalls + 1 }, expect2);
    let assert4 = expect(value, message), _test2 = test5 || getCurrentTest();
    return _test2 ? assert4.withTest(_test2) : assert4;
  };
  Object.assign(expect2, expect), Object.assign(expect2, globalThis[ASYMMETRIC_MATCHERS_OBJECT]), expect2.getState = () => getState(expect2), expect2.setState = (state) => setState(state, expect2);
  let globalState = getState(globalThis[GLOBAL_EXPECT]) || {};
  setState({
    ...globalState,
    assertionCalls: 0,
    isExpectingAssertions: !1,
    isExpectingAssertionsError: null,
    expectedAssertionsNumber: null,
    expectedAssertionsNumberErrorGen: null,
    environment: getCurrentEnvironment(),
    get testPath() {
      return getWorkerState().filepath;
    },
    currentTestName: test5 ? getTestName(test5) : globalState.currentTestName
  }, expect2), expect2.extend = (matchers) => expect.extend(expect2, matchers), expect2.addEqualityTesters = (customTesters) => addCustomEqualityTesters(customTesters), expect2.soft = (...args) => expect2(...args).withContext({ soft: !0 }), expect2.poll = createExpectPoll(expect2), expect2.unreachable = (message) => {
    assert3.fail(`expected${message ? ` "${message}" ` : " "}not to be reached`);
  };
  function assertions(expected) {
    let errorGen = () => new Error(`expected number of assertions to be ${expected}, but got ${expect2.getState().assertionCalls}`);
    Error.captureStackTrace && Error.captureStackTrace(errorGen(), assertions), expect2.setState({
      expectedAssertionsNumber: expected,
      expectedAssertionsNumberErrorGen: errorGen
    });
  }
  function hasAssertions() {
    let error = new Error("expected any number of assertion, but got none");
    Error.captureStackTrace && Error.captureStackTrace(error, hasAssertions), expect2.setState({
      isExpectingAssertions: !0,
      isExpectingAssertionsError: error
    });
  }
  return utils_exports.addMethod(expect2, "assertions", assertions), utils_exports.addMethod(expect2, "hasAssertions", hasAssertions), expect2.extend(customMatchers), expect2;
}
var globalExpect = createExpect();
Object.defineProperty(globalThis, GLOBAL_EXPECT, {
  value: globalExpect,
  writable: !0,
  configurable: !0
});
var fakeTimersSrc = {}, global2, hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal) return global2;
  hasRequiredGlobal = 1;
  var globalObject;
  return typeof commonjsGlobal < "u" ? globalObject = commonjsGlobal : typeof window < "u" ? globalObject = window : globalObject = self, global2 = globalObject, global2;
}
var throwsOnProto_1, hasRequiredThrowsOnProto;
function requireThrowsOnProto() {
  if (hasRequiredThrowsOnProto) return throwsOnProto_1;
  hasRequiredThrowsOnProto = 1;
  let throwsOnProto;
  try {
    ({}).__proto__, throwsOnProto = !1;
  } catch {
    throwsOnProto = !0;
  }
  return throwsOnProto_1 = throwsOnProto, throwsOnProto_1;
}
var copyPrototypeMethods, hasRequiredCopyPrototypeMethods;
function requireCopyPrototypeMethods() {
  if (hasRequiredCopyPrototypeMethods) return copyPrototypeMethods;
  hasRequiredCopyPrototypeMethods = 1;
  var call2 = Function.call, throwsOnProto = requireThrowsOnProto(), disallowedProperties = [
    // ignore size because it throws from Map
    "size",
    "caller",
    "callee",
    "arguments"
  ];
  return throwsOnProto && disallowedProperties.push("__proto__"), copyPrototypeMethods = function(prototype) {
    return Object.getOwnPropertyNames(prototype).reduce(
      function(result, name) {
        return disallowedProperties.includes(name) || typeof prototype[name] != "function" || (result[name] = call2.bind(prototype[name])), result;
      },
      /* @__PURE__ */ Object.create(null)
    );
  }, copyPrototypeMethods;
}
var array, hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array;
  hasRequiredArray = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  return array = copyPrototype(Array.prototype), array;
}
var calledInOrder_1, hasRequiredCalledInOrder;
function requireCalledInOrder() {
  if (hasRequiredCalledInOrder) return calledInOrder_1;
  hasRequiredCalledInOrder = 1;
  var every2 = requireArray().every;
  function hasCallsLeft(callMap, spy) {
    return callMap[spy.id] === void 0 && (callMap[spy.id] = 0), callMap[spy.id] < spy.callCount;
  }
  function checkAdjacentCalls(callMap, spy, index2, spies2) {
    var calledBeforeNext = !0;
    return index2 !== spies2.length - 1 && (calledBeforeNext = spy.calledBefore(spies2[index2 + 1])), hasCallsLeft(callMap, spy) && calledBeforeNext ? (callMap[spy.id] += 1, !0) : !1;
  }
  function calledInOrder(spies2) {
    var callMap = {}, _spies = arguments.length > 1 ? arguments : spies2;
    return every2(_spies, checkAdjacentCalls.bind(null, callMap));
  }
  return calledInOrder_1 = calledInOrder, calledInOrder_1;
}
var className_1, hasRequiredClassName;
function requireClassName() {
  if (hasRequiredClassName) return className_1;
  hasRequiredClassName = 1;
  function className(value) {
    return value.constructor && value.constructor.name || null;
  }
  return className_1 = className, className_1;
}
var deprecated = {}, hasRequiredDeprecated;
function requireDeprecated() {
  return hasRequiredDeprecated || (hasRequiredDeprecated = 1, function(exports) {
    exports.wrap = function(func, msg) {
      var wrapped = function() {
        return exports.printWarning(msg), func.apply(this, arguments);
      };
      return func.prototype && (wrapped.prototype = func.prototype), wrapped;
    }, exports.defaultMsg = function(packageName, funcName) {
      return `${packageName}.${funcName} is deprecated and will be removed from the public API in a future version of ${packageName}.`;
    }, exports.printWarning = function(msg) {
      typeof process == "object" && process.emitWarning ? process.emitWarning(msg) : console.info ? console.info(msg) : console.log(msg);
    };
  }(deprecated)), deprecated;
}
var every, hasRequiredEvery;
function requireEvery() {
  return hasRequiredEvery || (hasRequiredEvery = 1, every = function(obj, fn2) {
    var pass = !0;
    try {
      obj.forEach(function() {
        if (!fn2.apply(this, arguments))
          throw new Error();
      });
    } catch {
      pass = !1;
    }
    return pass;
  }), every;
}
var functionName, hasRequiredFunctionName;
function requireFunctionName() {
  return hasRequiredFunctionName || (hasRequiredFunctionName = 1, functionName = function(func) {
    if (!func)
      return "";
    try {
      return func.displayName || func.name || // Use function decomposition as a last resort to get function
      // name. Does not rely on function decomposition to work - if it
      // doesn't debugging will be slightly less informative
      // (i.e. toString will say 'spy' rather than 'myFunc').
      (String(func).match(/function ([^\s(]+)/) || [])[1];
    } catch {
      return "";
    }
  }), functionName;
}
var orderByFirstCall_1, hasRequiredOrderByFirstCall;
function requireOrderByFirstCall() {
  if (hasRequiredOrderByFirstCall) return orderByFirstCall_1;
  hasRequiredOrderByFirstCall = 1;
  var sort2 = requireArray().sort, slice = requireArray().slice;
  function comparator(a3, b) {
    var aCall = a3.getCall(0), bCall = b.getCall(0), aId = aCall && aCall.callId || -1, bId = bCall && bCall.callId || -1;
    return aId < bId ? -1 : 1;
  }
  function orderByFirstCall(spies2) {
    return sort2(slice(spies2), comparator);
  }
  return orderByFirstCall_1 = orderByFirstCall, orderByFirstCall_1;
}
var _function, hasRequired_function;
function require_function() {
  if (hasRequired_function) return _function;
  hasRequired_function = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  return _function = copyPrototype(Function.prototype), _function;
}
var map, hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  return map = copyPrototype(Map.prototype), map;
}
var object, hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  return object = copyPrototype(Object.prototype), object;
}
var set2, hasRequiredSet;
function requireSet() {
  if (hasRequiredSet) return set2;
  hasRequiredSet = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  return set2 = copyPrototype(Set.prototype), set2;
}
var string, hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  var copyPrototype = requireCopyPrototypeMethods();
  return string = copyPrototype(String.prototype), string;
}
var prototypes, hasRequiredPrototypes;
function requirePrototypes() {
  return hasRequiredPrototypes || (hasRequiredPrototypes = 1, prototypes = {
    array: requireArray(),
    function: require_function(),
    map: requireMap(),
    object: requireObject(),
    set: requireSet(),
    string: requireString()
  }), prototypes;
}
var typeDetect$1 = { exports: {} }, typeDetect = typeDetect$1.exports, hasRequiredTypeDetect;
function requireTypeDetect() {
  return hasRequiredTypeDetect || (hasRequiredTypeDetect = 1, function(module, exports) {
    (function(global3, factory) {
      module.exports = factory();
    })(typeDetect, function() {
      var promiseExists = typeof Promise == "function", globalObject = typeof self == "object" ? self : commonjsGlobal, symbolExists = typeof Symbol < "u", mapExists = typeof Map < "u", setExists = typeof Set < "u", weakMapExists = typeof WeakMap < "u", weakSetExists = typeof WeakSet < "u", dataViewExists = typeof DataView < "u", symbolIteratorExists = symbolExists && typeof Symbol.iterator < "u", symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag < "u", setEntriesExists = setExists && typeof Set.prototype.entries == "function", mapEntriesExists = mapExists && typeof Map.prototype.entries == "function", setIteratorPrototype = setEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries()), mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries()), arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] == "function", arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]()), stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] == "function", stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]()), toStringLeftSliceLength = 8, toStringRightSliceLength = -1;
      function typeDetect2(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== "object")
          return typeofObj;
        if (obj === null)
          return "null";
        if (obj === globalObject)
          return "global";
        if (Array.isArray(obj) && (symbolToStringTagExists === !1 || !(Symbol.toStringTag in obj)))
          return "Array";
        if (typeof window == "object" && window !== null) {
          if (typeof window.location == "object" && obj === window.location)
            return "Location";
          if (typeof window.document == "object" && obj === window.document)
            return "Document";
          if (typeof window.navigator == "object") {
            if (typeof window.navigator.mimeTypes == "object" && obj === window.navigator.mimeTypes)
              return "MimeTypeArray";
            if (typeof window.navigator.plugins == "object" && obj === window.navigator.plugins)
              return "PluginArray";
          }
          if ((typeof window.HTMLElement == "function" || typeof window.HTMLElement == "object") && obj instanceof window.HTMLElement) {
            if (obj.tagName === "BLOCKQUOTE")
              return "HTMLQuoteElement";
            if (obj.tagName === "TD")
              return "HTMLTableDataCellElement";
            if (obj.tagName === "TH")
              return "HTMLTableHeaderCellElement";
          }
        }
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag == "string")
          return stringTag;
        var objPrototype = Object.getPrototypeOf(obj);
        return objPrototype === RegExp.prototype ? "RegExp" : objPrototype === Date.prototype ? "Date" : promiseExists && objPrototype === Promise.prototype ? "Promise" : setExists && objPrototype === Set.prototype ? "Set" : mapExists && objPrototype === Map.prototype ? "Map" : weakSetExists && objPrototype === WeakSet.prototype ? "WeakSet" : weakMapExists && objPrototype === WeakMap.prototype ? "WeakMap" : dataViewExists && objPrototype === DataView.prototype ? "DataView" : mapExists && objPrototype === mapIteratorPrototype ? "Map Iterator" : setExists && objPrototype === setIteratorPrototype ? "Set Iterator" : arrayIteratorExists && objPrototype === arrayIteratorPrototype ? "Array Iterator" : stringIteratorExists && objPrototype === stringIteratorPrototype ? "String Iterator" : objPrototype === null ? "Object" : Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect2;
    });
  }(typeDetect$1)), typeDetect$1.exports;
}
var typeOf, hasRequiredTypeOf;
function requireTypeOf() {
  if (hasRequiredTypeOf) return typeOf;
  hasRequiredTypeOf = 1;
  var type3 = requireTypeDetect();
  return typeOf = function(value) {
    return type3(value).toLowerCase();
  }, typeOf;
}
var valueToString_1, hasRequiredValueToString;
function requireValueToString() {
  if (hasRequiredValueToString) return valueToString_1;
  hasRequiredValueToString = 1;
  function valueToString(value) {
    return value && value.toString ? value.toString() : String(value);
  }
  return valueToString_1 = valueToString, valueToString_1;
}
var lib, hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, lib = {
    global: requireGlobal(),
    calledInOrder: requireCalledInOrder(),
    className: requireClassName(),
    deprecated: requireDeprecated(),
    every: requireEvery(),
    functionName: requireFunctionName(),
    orderByFirstCall: requireOrderByFirstCall(),
    prototypes: requirePrototypes(),
    typeOf: requireTypeOf(),
    valueToString: requireValueToString()
  }), lib;
}
var hasRequiredFakeTimersSrc;
function requireFakeTimersSrc() {
  if (hasRequiredFakeTimersSrc) return fakeTimersSrc;
  hasRequiredFakeTimersSrc = 1;
  let globalObject = requireLib().global, timersModule, timersPromisesModule;
  if (typeof __vitest_required__ < "u") {
    try {
      timersModule = __vitest_required__.timers;
    } catch {
    }
    try {
      timersPromisesModule = __vitest_required__.timersPromises;
    } catch {
    }
  }
  function withGlobal(_global) {
    let maxTimeout = Math.pow(2, 31) - 1, idCounterStart = 1e12, NOOP = function() {
    }, NOOP_ARRAY = function() {
      return [];
    }, isPresent = {}, timeoutResult, addTimerReturnsObject = !1;
    _global.setTimeout && (isPresent.setTimeout = !0, timeoutResult = _global.setTimeout(NOOP, 0), addTimerReturnsObject = typeof timeoutResult == "object"), isPresent.clearTimeout = !!_global.clearTimeout, isPresent.setInterval = !!_global.setInterval, isPresent.clearInterval = !!_global.clearInterval, isPresent.hrtime = _global.process && typeof _global.process.hrtime == "function", isPresent.hrtimeBigint = isPresent.hrtime && typeof _global.process.hrtime.bigint == "function", isPresent.nextTick = _global.process && typeof _global.process.nextTick == "function";
    let utilPromisify = _global.process && _global.__vitest_required__ && _global.__vitest_required__.util.promisify;
    isPresent.performance = _global.performance && typeof _global.performance.now == "function";
    let hasPerformancePrototype = _global.Performance && (typeof _global.Performance).match(/^(function|object)$/), hasPerformanceConstructorPrototype = _global.performance && _global.performance.constructor && _global.performance.constructor.prototype;
    isPresent.queueMicrotask = _global.hasOwnProperty("queueMicrotask"), isPresent.requestAnimationFrame = _global.requestAnimationFrame && typeof _global.requestAnimationFrame == "function", isPresent.cancelAnimationFrame = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame == "function", isPresent.requestIdleCallback = _global.requestIdleCallback && typeof _global.requestIdleCallback == "function", isPresent.cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback == "function", isPresent.setImmediate = _global.setImmediate && typeof _global.setImmediate == "function", isPresent.clearImmediate = _global.clearImmediate && typeof _global.clearImmediate == "function", isPresent.Intl = _global.Intl && typeof _global.Intl == "object", _global.clearTimeout && _global.clearTimeout(timeoutResult);
    let NativeDate = _global.Date, NativeIntl = isPresent.Intl ? Object.defineProperties(
      /* @__PURE__ */ Object.create(null),
      Object.getOwnPropertyDescriptors(_global.Intl)
    ) : void 0, uniqueTimerId = idCounterStart;
    if (NativeDate === void 0)
      throw new Error(
        "The global scope doesn't have a `Date` object (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)"
      );
    isPresent.Date = !0;
    class FakePerformanceEntry {
      constructor(name, entryType, startTime, duration) {
        this.name = name, this.entryType = entryType, this.startTime = startTime, this.duration = duration;
      }
      toJSON() {
        return JSON.stringify({ ...this });
      }
    }
    function isNumberFinite(num) {
      return Number.isFinite ? Number.isFinite(num) : isFinite(num);
    }
    let isNearInfiniteLimit = !1;
    function checkIsNearInfiniteLimit(clock, i) {
      clock.loopLimit && i === clock.loopLimit - 1 && (isNearInfiniteLimit = !0);
    }
    function resetIsNearInfiniteLimit() {
      isNearInfiniteLimit = !1;
    }
    function parseTime(str) {
      if (!str)
        return 0;
      let strings = str.split(":"), l = strings.length, i = l, ms = 0, parsed;
      if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str))
        throw new Error(
          "tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits"
        );
      for (; i--; ) {
        if (parsed = parseInt(strings[i], 10), parsed >= 60)
          throw new Error(`Invalid time ${str}`);
        ms += parsed * Math.pow(60, l - i - 1);
      }
      return ms * 1e3;
    }
    function nanoRemainder(msFloat) {
      let remainder = msFloat * 1e6 % 1e6, positiveRemainder = remainder < 0 ? remainder + 1e6 : remainder;
      return Math.floor(positiveRemainder);
    }
    function getEpoch(epoch) {
      if (!epoch)
        return 0;
      if (typeof epoch.getTime == "function")
        return epoch.getTime();
      if (typeof epoch == "number")
        return epoch;
      throw new TypeError("now should be milliseconds since UNIX epoch");
    }
    function inRange(from, to, timer) {
      return timer && timer.callAt >= from && timer.callAt <= to;
    }
    function getInfiniteLoopError(clock, job) {
      let infiniteLoopError = new Error(
        `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`
      );
      if (!job.error)
        return infiniteLoopError;
      let computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/, clockMethodPattern = new RegExp(
        String(Object.keys(clock).join("|"))
      );
      addTimerReturnsObject && (clockMethodPattern = new RegExp(
        `\\s+at (Object\\.)?(?:${Object.keys(clock).join("|")})\\s+`
      ));
      let matchedLineIndex = -1;
      job.error.stack.split(`
`).some(function(line, i) {
        return line.match(computedTargetPattern) ? (matchedLineIndex = i, !0) : line.match(clockMethodPattern) ? (matchedLineIndex = i, !1) : matchedLineIndex >= 0;
      });
      let stack = `${infiniteLoopError}
${job.type || "Microtask"} - ${job.func.name || "anonymous"}
${job.error.stack.split(`
`).slice(matchedLineIndex + 1).join(`
`)}`;
      try {
        Object.defineProperty(infiniteLoopError, "stack", {
          value: stack
        });
      } catch {
      }
      return infiniteLoopError;
    }
    function createDate() {
      class ClockDate extends NativeDate {
        /**
         * @param {number} year
         * @param {number} month
         * @param {number} date
         * @param {number} hour
         * @param {number} minute
         * @param {number} second
         * @param {number} ms
         * @returns void
         */
        // eslint-disable-next-line no-unused-vars
        constructor(year, month, date, hour, minute, second, ms) {
          arguments.length === 0 ? super(ClockDate.clock.now) : super(...arguments), Object.defineProperty(this, "constructor", {
            value: NativeDate,
            enumerable: !1
          });
        }
        static [Symbol.hasInstance](instance) {
          return instance instanceof NativeDate;
        }
      }
      return ClockDate.isFake = !0, NativeDate.now && (ClockDate.now = function() {
        return ClockDate.clock.now;
      }), NativeDate.toSource && (ClockDate.toSource = function() {
        return NativeDate.toSource();
      }), ClockDate.toString = function() {
        return NativeDate.toString();
      }, new Proxy(ClockDate, {
        // handler for [[Call]] invocations (i.e. not using `new`)
        apply() {
          if (this instanceof ClockDate)
            throw new TypeError(
              "A Proxy should only capture `new` calls with the `construct` handler. This is not supposed to be possible, so check the logic."
            );
          return new NativeDate(ClockDate.clock.now).toString();
        }
      });
    }
    function createIntl() {
      let ClockIntl = {};
      return Object.getOwnPropertyNames(NativeIntl).forEach(
        (property) => ClockIntl[property] = NativeIntl[property]
      ), ClockIntl.DateTimeFormat = function(...args) {
        let realFormatter = new NativeIntl.DateTimeFormat(...args), formatter = {};
        return ["formatRange", "formatRangeToParts", "resolvedOptions"].forEach(
          (method) => {
            formatter[method] = realFormatter[method].bind(realFormatter);
          }
        ), ["format", "formatToParts"].forEach((method) => {
          formatter[method] = function(date) {
            return realFormatter[method](date || ClockIntl.clock.now);
          };
        }), formatter;
      }, ClockIntl.DateTimeFormat.prototype = Object.create(
        NativeIntl.DateTimeFormat.prototype
      ), ClockIntl.DateTimeFormat.supportedLocalesOf = NativeIntl.DateTimeFormat.supportedLocalesOf, ClockIntl;
    }
    function enqueueJob(clock, job) {
      clock.jobs || (clock.jobs = []), clock.jobs.push(job);
    }
    function runJobs(clock) {
      if (clock.jobs) {
        for (let i = 0; i < clock.jobs.length; i++) {
          let job = clock.jobs[i];
          if (job.func.apply(null, job.args), checkIsNearInfiniteLimit(clock, i), clock.loopLimit && i > clock.loopLimit)
            throw getInfiniteLoopError(clock, job);
        }
        resetIsNearInfiniteLimit(), clock.jobs = [];
      }
    }
    function addTimer(clock, timer) {
      if (timer.func === void 0)
        throw new Error("Callback must be provided to timer calls");
      if (addTimerReturnsObject && typeof timer.func != "function")
        throw new TypeError(
          `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${timer.func} of type ${typeof timer.func}`
        );
      if (isNearInfiniteLimit && (timer.error = new Error()), timer.type = timer.immediate ? "Immediate" : "Timeout", timer.hasOwnProperty("delay") && (typeof timer.delay != "number" && (timer.delay = parseInt(timer.delay, 10)), isNumberFinite(timer.delay) || (timer.delay = 0), timer.delay = timer.delay > maxTimeout ? 1 : timer.delay, timer.delay = Math.max(0, timer.delay)), timer.hasOwnProperty("interval") && (timer.type = "Interval", timer.interval = timer.interval > maxTimeout ? 1 : timer.interval), timer.hasOwnProperty("animation") && (timer.type = "AnimationFrame", timer.animation = !0), timer.hasOwnProperty("idleCallback") && (timer.type = "IdleCallback", timer.idleCallback = !0), clock.timers || (clock.timers = {}), timer.id = uniqueTimerId++, timer.createdAt = clock.now, timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0)), clock.timers[timer.id] = timer, addTimerReturnsObject) {
        let res = {
          refed: !0,
          ref: function() {
            return this.refed = !0, res;
          },
          unref: function() {
            return this.refed = !1, res;
          },
          hasRef: function() {
            return this.refed;
          },
          refresh: function() {
            return timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0)), clock.timers[timer.id] = timer, res;
          },
          [Symbol.toPrimitive]: function() {
            return timer.id;
          }
        };
        return res;
      }
      return timer.id;
    }
    function compareTimers(a3, b) {
      if (a3.callAt < b.callAt)
        return -1;
      if (a3.callAt > b.callAt)
        return 1;
      if (a3.immediate && !b.immediate)
        return -1;
      if (!a3.immediate && b.immediate)
        return 1;
      if (a3.createdAt < b.createdAt)
        return -1;
      if (a3.createdAt > b.createdAt)
        return 1;
      if (a3.id < b.id)
        return -1;
      if (a3.id > b.id)
        return 1;
    }
    function firstTimerInRange(clock, from, to) {
      let timers2 = clock.timers, timer = null, id, isInRange;
      for (id in timers2)
        timers2.hasOwnProperty(id) && (isInRange = inRange(from, to, timers2[id]), isInRange && (!timer || compareTimers(timer, timers2[id]) === 1) && (timer = timers2[id]));
      return timer;
    }
    function firstTimer(clock) {
      let timers2 = clock.timers, timer = null, id;
      for (id in timers2)
        timers2.hasOwnProperty(id) && (!timer || compareTimers(timer, timers2[id]) === 1) && (timer = timers2[id]);
      return timer;
    }
    function lastTimer(clock) {
      let timers2 = clock.timers, timer = null, id;
      for (id in timers2)
        timers2.hasOwnProperty(id) && (!timer || compareTimers(timer, timers2[id]) === -1) && (timer = timers2[id]);
      return timer;
    }
    function callTimer(clock, timer) {
      if (typeof timer.interval == "number" ? clock.timers[timer.id].callAt += timer.interval : delete clock.timers[timer.id], typeof timer.func == "function")
        timer.func.apply(null, timer.args);
      else {
        let eval2 = eval;
        (function() {
          eval2(timer.func);
        })();
      }
    }
    function getClearHandler(ttype) {
      return ttype === "IdleCallback" || ttype === "AnimationFrame" ? `cancel${ttype}` : `clear${ttype}`;
    }
    function getScheduleHandler(ttype) {
      return ttype === "IdleCallback" || ttype === "AnimationFrame" ? `request${ttype}` : `set${ttype}`;
    }
    function createWarnOnce() {
      let calls = 0;
      return function(msg) {
        !calls++ && console.warn(msg);
      };
    }
    let warnOnce = createWarnOnce();
    function clearTimer(clock, timerId, ttype) {
      if (!timerId)
        return;
      clock.timers || (clock.timers = {});
      let id = Number(timerId);
      if (Number.isNaN(id) || id < idCounterStart) {
        let handlerName = getClearHandler(ttype);
        if (clock.shouldClearNativeTimers === !0) {
          let nativeHandler = clock[`_${handlerName}`];
          return typeof nativeHandler == "function" ? nativeHandler(timerId) : void 0;
        }
        warnOnce(
          `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.
To automatically clean-up native timers, use \`shouldClearNativeTimers\`.`
        );
      }
      if (clock.timers.hasOwnProperty(id)) {
        let timer = clock.timers[id];
        if (timer.type === ttype || timer.type === "Timeout" && ttype === "Interval" || timer.type === "Interval" && ttype === "Timeout")
          delete clock.timers[id];
        else {
          let clear = getClearHandler(ttype), schedule = getScheduleHandler(timer.type);
          throw new Error(
            `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`
          );
        }
      }
    }
    function uninstall(clock, config2) {
      let method, i, l, installedHrTime = "_hrtime", installedNextTick = "_nextTick";
      for (i = 0, l = clock.methods.length; i < l; i++) {
        if (method = clock.methods[i], method === "hrtime" && _global.process)
          _global.process.hrtime = clock[installedHrTime];
        else if (method === "nextTick" && _global.process)
          _global.process.nextTick = clock[installedNextTick];
        else if (method === "performance") {
          let originalPerfDescriptor = Object.getOwnPropertyDescriptor(
            clock,
            `_${method}`
          );
          originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set ? Object.defineProperty(
            _global,
            method,
            originalPerfDescriptor
          ) : originalPerfDescriptor.configurable && (_global[method] = clock[`_${method}`]);
        } else if (_global[method] && _global[method].hadOwnProperty)
          _global[method] = clock[`_${method}`];
        else
          try {
            delete _global[method];
          } catch {
          }
        if (clock.timersModuleMethods !== void 0)
          for (let j = 0; j < clock.timersModuleMethods.length; j++) {
            let entry = clock.timersModuleMethods[j];
            timersModule[entry.methodName] = entry.original;
          }
        if (clock.timersPromisesModuleMethods !== void 0)
          for (let j = 0; j < clock.timersPromisesModuleMethods.length; j++) {
            let entry = clock.timersPromisesModuleMethods[j];
            timersPromisesModule[entry.methodName] = entry.original;
          }
      }
      config2.shouldAdvanceTime === !0 && _global.clearInterval(clock.attachedInterval), clock.methods = [];
      for (let [listener, signal] of clock.abortListenerMap.entries())
        signal.removeEventListener("abort", listener), clock.abortListenerMap.delete(listener);
      return clock.timers ? Object.keys(clock.timers).map(function(key) {
        return clock.timers[key];
      }) : [];
    }
    function hijackMethod(target, method, clock) {
      if (clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(
        target,
        method
      ), clock[`_${method}`] = target[method], method === "Date")
        target[method] = clock[method];
      else if (method === "Intl")
        target[method] = clock[method];
      else if (method === "performance") {
        let originalPerfDescriptor = Object.getOwnPropertyDescriptor(
          target,
          method
        );
        if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {
          Object.defineProperty(
            clock,
            `_${method}`,
            originalPerfDescriptor
          );
          let perfDescriptor = Object.getOwnPropertyDescriptor(
            clock,
            method
          );
          Object.defineProperty(target, method, perfDescriptor);
        } else
          target[method] = clock[method];
      } else
        target[method] = function() {
          return clock[method].apply(clock, arguments);
        }, Object.defineProperties(
          target[method],
          Object.getOwnPropertyDescriptors(clock[method])
        );
      target[method].clock = clock;
    }
    function doIntervalTick(clock, advanceTimeDelta) {
      clock.tick(advanceTimeDelta);
    }
    let timers = {
      setTimeout: _global.setTimeout,
      clearTimeout: _global.clearTimeout,
      setInterval: _global.setInterval,
      clearInterval: _global.clearInterval,
      Date: _global.Date
    };
    isPresent.setImmediate && (timers.setImmediate = _global.setImmediate), isPresent.clearImmediate && (timers.clearImmediate = _global.clearImmediate), isPresent.hrtime && (timers.hrtime = _global.process.hrtime), isPresent.nextTick && (timers.nextTick = _global.process.nextTick), isPresent.performance && (timers.performance = _global.performance), isPresent.requestAnimationFrame && (timers.requestAnimationFrame = _global.requestAnimationFrame), isPresent.queueMicrotask && (timers.queueMicrotask = _global.queueMicrotask), isPresent.cancelAnimationFrame && (timers.cancelAnimationFrame = _global.cancelAnimationFrame), isPresent.requestIdleCallback && (timers.requestIdleCallback = _global.requestIdleCallback), isPresent.cancelIdleCallback && (timers.cancelIdleCallback = _global.cancelIdleCallback), isPresent.Intl && (timers.Intl = NativeIntl);
    let originalSetTimeout = _global.setImmediate || _global.setTimeout;
    function createClock(start, loopLimit) {
      start = Math.floor(getEpoch(start)), loopLimit = loopLimit || 1e3;
      let nanos = 0, adjustedSystemTime = [0, 0], clock = {
        now: start,
        Date: createDate(),
        loopLimit
      };
      clock.Date.clock = clock;
      function getTimeToNextFrame() {
        return 16 - (clock.now - start) % 16;
      }
      function hrtime(prev) {
        let millisSinceStart = clock.now - adjustedSystemTime[0] - start, secsSinceStart = Math.floor(millisSinceStart / 1e3), remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];
        if (Array.isArray(prev)) {
          if (prev[1] > 1e9)
            throw new TypeError(
              "Number of nanoseconds can't exceed a billion"
            );
          let oldSecs = prev[0], nanoDiff = remainderInNanos - prev[1], secDiff = secsSinceStart - oldSecs;
          return nanoDiff < 0 && (nanoDiff += 1e9, secDiff -= 1), [secDiff, nanoDiff];
        }
        return [secsSinceStart, remainderInNanos];
      }
      function fakePerformanceNow() {
        let hrt = hrtime();
        return hrt[0] * 1e3 + hrt[1] / 1e6;
      }
      isPresent.hrtimeBigint && (hrtime.bigint = function() {
        let parts = hrtime();
        return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]);
      }), isPresent.Intl && (clock.Intl = createIntl(), clock.Intl.clock = clock), clock.requestIdleCallback = function(func, timeout) {
        let timeToNextIdlePeriod = 0;
        clock.countTimers() > 0 && (timeToNextIdlePeriod = 50);
        let result = addTimer(clock, {
          func,
          args: Array.prototype.slice.call(arguments, 2),
          delay: typeof timeout > "u" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),
          idleCallback: !0
        });
        return Number(result);
      }, clock.cancelIdleCallback = function(timerId) {
        return clearTimer(clock, timerId, "IdleCallback");
      }, clock.setTimeout = function(func, timeout) {
        return addTimer(clock, {
          func,
          args: Array.prototype.slice.call(arguments, 2),
          delay: timeout
        });
      }, typeof _global.Promise < "u" && utilPromisify && (clock.setTimeout[utilPromisify.custom] = function(timeout, arg) {
        return new _global.Promise(function(resolve4) {
          addTimer(clock, {
            func: resolve4,
            args: [arg],
            delay: timeout
          });
        });
      }), clock.clearTimeout = function(timerId) {
        return clearTimer(clock, timerId, "Timeout");
      }, clock.nextTick = function(func) {
        return enqueueJob(clock, {
          func,
          args: Array.prototype.slice.call(arguments, 1),
          error: isNearInfiniteLimit ? new Error() : null
        });
      }, clock.queueMicrotask = function(func) {
        return clock.nextTick(func);
      }, clock.setInterval = function(func, timeout) {
        return timeout = parseInt(timeout, 10), addTimer(clock, {
          func,
          args: Array.prototype.slice.call(arguments, 2),
          delay: timeout,
          interval: timeout
        });
      }, clock.clearInterval = function(timerId) {
        return clearTimer(clock, timerId, "Interval");
      }, isPresent.setImmediate && (clock.setImmediate = function(func) {
        return addTimer(clock, {
          func,
          args: Array.prototype.slice.call(arguments, 1),
          immediate: !0
        });
      }, typeof _global.Promise < "u" && utilPromisify && (clock.setImmediate[utilPromisify.custom] = function(arg) {
        return new _global.Promise(
          function(resolve4) {
            addTimer(clock, {
              func: resolve4,
              args: [arg],
              immediate: !0
            });
          }
        );
      }), clock.clearImmediate = function(timerId) {
        return clearTimer(clock, timerId, "Immediate");
      }), clock.countTimers = function() {
        return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;
      }, clock.requestAnimationFrame = function(func) {
        let result = addTimer(clock, {
          func,
          delay: getTimeToNextFrame(),
          get args() {
            return [fakePerformanceNow()];
          },
          animation: !0
        });
        return Number(result);
      }, clock.cancelAnimationFrame = function(timerId) {
        return clearTimer(clock, timerId, "AnimationFrame");
      }, clock.runMicrotasks = function() {
        runJobs(clock);
      };
      function doTick(tickValue, isAsync, resolve4, reject) {
        let msFloat = typeof tickValue == "number" ? tickValue : parseTime(tickValue), ms = Math.floor(msFloat), remainder = nanoRemainder(msFloat), nanosTotal = nanos + remainder, tickTo = clock.now + ms;
        if (msFloat < 0)
          throw new TypeError("Negative ticks are not supported");
        nanosTotal >= 1e6 && (tickTo += 1, nanosTotal -= 1e6), nanos = nanosTotal;
        let tickFrom = clock.now, previous = clock.now, timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;
        clock.duringTick = !0, oldNow = clock.now, runJobs(clock), oldNow !== clock.now && (tickFrom += clock.now - oldNow, tickTo += clock.now - oldNow);
        function doTickInner() {
          for (timer = firstTimerInRange(clock, tickFrom, tickTo); timer && tickFrom <= tickTo; ) {
            if (clock.timers[timer.id]) {
              tickFrom = timer.callAt, clock.now = timer.callAt, oldNow = clock.now;
              try {
                runJobs(clock), callTimer(clock, timer);
              } catch (e) {
                firstException = firstException || e;
              }
              if (isAsync) {
                originalSetTimeout(nextPromiseTick);
                return;
              }
              compensationCheck();
            }
            postTimerCall();
          }
          if (oldNow = clock.now, runJobs(clock), oldNow !== clock.now && (tickFrom += clock.now - oldNow, tickTo += clock.now - oldNow), clock.duringTick = !1, timer = firstTimerInRange(clock, tickFrom, tickTo), timer)
            try {
              clock.tick(tickTo - clock.now);
            } catch (e) {
              firstException = firstException || e;
            }
          else
            clock.now = tickTo, nanos = nanosTotal;
          if (firstException)
            throw firstException;
          if (isAsync)
            resolve4(clock.now);
          else
            return clock.now;
        }
        return nextPromiseTick = isAsync && function() {
          try {
            compensationCheck(), postTimerCall(), doTickInner();
          } catch (e) {
            reject(e);
          }
        }, compensationCheck = function() {
          oldNow !== clock.now && (tickFrom += clock.now - oldNow, tickTo += clock.now - oldNow, previous += clock.now - oldNow);
        }, postTimerCall = function() {
          timer = firstTimerInRange(clock, previous, tickTo), previous = tickFrom;
        }, doTickInner();
      }
      return clock.tick = function(tickValue) {
        return doTick(tickValue, !1);
      }, typeof _global.Promise < "u" && (clock.tickAsync = function(tickValue) {
        return new _global.Promise(function(resolve4, reject) {
          originalSetTimeout(function() {
            try {
              doTick(tickValue, !0, resolve4, reject);
            } catch (e) {
              reject(e);
            }
          });
        });
      }), clock.next = function() {
        runJobs(clock);
        let timer = firstTimer(clock);
        if (!timer)
          return clock.now;
        clock.duringTick = !0;
        try {
          return clock.now = timer.callAt, callTimer(clock, timer), runJobs(clock), clock.now;
        } finally {
          clock.duringTick = !1;
        }
      }, typeof _global.Promise < "u" && (clock.nextAsync = function() {
        return new _global.Promise(function(resolve4, reject) {
          originalSetTimeout(function() {
            try {
              let timer = firstTimer(clock);
              if (!timer) {
                resolve4(clock.now);
                return;
              }
              let err;
              clock.duringTick = !0, clock.now = timer.callAt;
              try {
                callTimer(clock, timer);
              } catch (e) {
                err = e;
              }
              clock.duringTick = !1, originalSetTimeout(function() {
                err ? reject(err) : resolve4(clock.now);
              });
            } catch (e) {
              reject(e);
            }
          });
        });
      }), clock.runAll = function() {
        let numTimers, i;
        for (runJobs(clock), i = 0; i < clock.loopLimit; i++) {
          if (!clock.timers || (numTimers = Object.keys(clock.timers).length, numTimers === 0))
            return resetIsNearInfiniteLimit(), clock.now;
          clock.next(), checkIsNearInfiniteLimit(clock, i);
        }
        let excessJob = firstTimer(clock);
        throw getInfiniteLoopError(clock, excessJob);
      }, clock.runToFrame = function() {
        return clock.tick(getTimeToNextFrame());
      }, typeof _global.Promise < "u" && (clock.runAllAsync = function() {
        return new _global.Promise(function(resolve4, reject) {
          let i = 0;
          function doRun() {
            originalSetTimeout(function() {
              try {
                runJobs(clock);
                let numTimers;
                if (i < clock.loopLimit) {
                  if (!clock.timers) {
                    resetIsNearInfiniteLimit(), resolve4(clock.now);
                    return;
                  }
                  if (numTimers = Object.keys(
                    clock.timers
                  ).length, numTimers === 0) {
                    resetIsNearInfiniteLimit(), resolve4(clock.now);
                    return;
                  }
                  clock.next(), i++, doRun(), checkIsNearInfiniteLimit(clock, i);
                  return;
                }
                let excessJob = firstTimer(clock);
                reject(getInfiniteLoopError(clock, excessJob));
              } catch (e) {
                reject(e);
              }
            });
          }
          doRun();
        });
      }), clock.runToLast = function() {
        let timer = lastTimer(clock);
        return timer ? clock.tick(timer.callAt - clock.now) : (runJobs(clock), clock.now);
      }, typeof _global.Promise < "u" && (clock.runToLastAsync = function() {
        return new _global.Promise(function(resolve4, reject) {
          originalSetTimeout(function() {
            try {
              let timer = lastTimer(clock);
              timer || (runJobs(clock), resolve4(clock.now)), resolve4(clock.tickAsync(timer.callAt - clock.now));
            } catch (e) {
              reject(e);
            }
          });
        });
      }), clock.reset = function() {
        nanos = 0, clock.timers = {}, clock.jobs = [], clock.now = start;
      }, clock.setSystemTime = function(systemTime) {
        let newNow = getEpoch(systemTime), difference = newNow - clock.now, id, timer;
        adjustedSystemTime[0] = adjustedSystemTime[0] + difference, adjustedSystemTime[1] = adjustedSystemTime[1] + nanos, clock.now = newNow, nanos = 0;
        for (id in clock.timers)
          clock.timers.hasOwnProperty(id) && (timer = clock.timers[id], timer.createdAt += difference, timer.callAt += difference);
      }, clock.jump = function(tickValue) {
        let msFloat = typeof tickValue == "number" ? tickValue : parseTime(tickValue), ms = Math.floor(msFloat);
        for (let timer of Object.values(clock.timers))
          clock.now + ms > timer.callAt && (timer.callAt = clock.now + ms);
        clock.tick(ms);
      }, isPresent.performance && (clock.performance = /* @__PURE__ */ Object.create(null), clock.performance.now = fakePerformanceNow), isPresent.hrtime && (clock.hrtime = hrtime), clock;
    }
    function install(config2) {
      if (arguments.length > 1 || config2 instanceof Date || Array.isArray(config2) || typeof config2 == "number")
        throw new TypeError(
          `FakeTimers.install called with ${String(
            config2
          )} install requires an object parameter`
        );
      if (_global.Date.isFake === !0)
        throw new TypeError(
          "Can't install fake timers twice on the same global object."
        );
      if (config2 = typeof config2 < "u" ? config2 : {}, config2.shouldAdvanceTime = config2.shouldAdvanceTime || !1, config2.advanceTimeDelta = config2.advanceTimeDelta || 20, config2.shouldClearNativeTimers = config2.shouldClearNativeTimers || !1, config2.target)
        throw new TypeError(
          "config.target is no longer supported. Use `withGlobal(target)` instead."
        );
      function handleMissingTimer(timer) {
        if (!config2.ignoreMissingTimers)
          throw new ReferenceError(
            `non-existent timers and/or objects cannot be faked: '${timer}'`
          );
      }
      let i, l, clock = createClock(config2.now, config2.loopLimit);
      if (clock.shouldClearNativeTimers = config2.shouldClearNativeTimers, clock.uninstall = function() {
        return uninstall(clock, config2);
      }, clock.abortListenerMap = /* @__PURE__ */ new Map(), clock.methods = config2.toFake || [], clock.methods.length === 0 && (clock.methods = Object.keys(timers)), config2.shouldAdvanceTime === !0) {
        let intervalTick = doIntervalTick.bind(
          null,
          clock,
          config2.advanceTimeDelta
        ), intervalId = _global.setInterval(
          intervalTick,
          config2.advanceTimeDelta
        );
        clock.attachedInterval = intervalId;
      }
      if (clock.methods.includes("performance")) {
        let proto = (() => {
          if (hasPerformanceConstructorPrototype)
            return _global.performance.constructor.prototype;
          if (hasPerformancePrototype)
            return _global.Performance.prototype;
        })();
        if (proto)
          Object.getOwnPropertyNames(proto).forEach(function(name) {
            name !== "now" && (clock.performance[name] = name.indexOf("getEntries") === 0 ? NOOP_ARRAY : NOOP);
          }), clock.performance.mark = (name) => new FakePerformanceEntry(name, "mark", 0, 0), clock.performance.measure = (name) => new FakePerformanceEntry(name, "measure", 0, 100), clock.performance.timeOrigin = getEpoch(config2.now);
        else if ((config2.toFake || []).includes("performance"))
          return handleMissingTimer("performance");
      }
      for (_global === globalObject && timersModule && (clock.timersModuleMethods = []), _global === globalObject && timersPromisesModule && (clock.timersPromisesModuleMethods = []), i = 0, l = clock.methods.length; i < l; i++) {
        let nameOfMethodToReplace = clock.methods[i];
        if (!isPresent[nameOfMethodToReplace]) {
          handleMissingTimer(nameOfMethodToReplace);
          continue;
        }
        if (nameOfMethodToReplace === "hrtime" ? _global.process && typeof _global.process.hrtime == "function" && hijackMethod(_global.process, nameOfMethodToReplace, clock) : nameOfMethodToReplace === "nextTick" ? _global.process && typeof _global.process.nextTick == "function" && hijackMethod(_global.process, nameOfMethodToReplace, clock) : hijackMethod(_global, nameOfMethodToReplace, clock), clock.timersModuleMethods !== void 0 && timersModule[nameOfMethodToReplace]) {
          let original = timersModule[nameOfMethodToReplace];
          clock.timersModuleMethods.push({
            methodName: nameOfMethodToReplace,
            original
          }), timersModule[nameOfMethodToReplace] = _global[nameOfMethodToReplace];
        }
        clock.timersPromisesModuleMethods !== void 0 && (nameOfMethodToReplace === "setTimeout" ? (clock.timersPromisesModuleMethods.push({
          methodName: "setTimeout",
          original: timersPromisesModule.setTimeout
        }), timersPromisesModule.setTimeout = (delay, value, options = {}) => new Promise((resolve4, reject) => {
          let abort = () => {
            options.signal.removeEventListener(
              "abort",
              abort
            ), clock.abortListenerMap.delete(abort), clock.clearTimeout(handle), reject(options.signal.reason);
          }, handle = clock.setTimeout(() => {
            options.signal && (options.signal.removeEventListener(
              "abort",
              abort
            ), clock.abortListenerMap.delete(abort)), resolve4(value);
          }, delay);
          options.signal && (options.signal.aborted ? abort() : (options.signal.addEventListener(
            "abort",
            abort
          ), clock.abortListenerMap.set(
            abort,
            options.signal
          )));
        })) : nameOfMethodToReplace === "setImmediate" ? (clock.timersPromisesModuleMethods.push({
          methodName: "setImmediate",
          original: timersPromisesModule.setImmediate
        }), timersPromisesModule.setImmediate = (value, options = {}) => new Promise((resolve4, reject) => {
          let abort = () => {
            options.signal.removeEventListener(
              "abort",
              abort
            ), clock.abortListenerMap.delete(abort), clock.clearImmediate(handle), reject(options.signal.reason);
          }, handle = clock.setImmediate(() => {
            options.signal && (options.signal.removeEventListener(
              "abort",
              abort
            ), clock.abortListenerMap.delete(abort)), resolve4(value);
          });
          options.signal && (options.signal.aborted ? abort() : (options.signal.addEventListener(
            "abort",
            abort
          ), clock.abortListenerMap.set(
            abort,
            options.signal
          )));
        })) : nameOfMethodToReplace === "setInterval" && (clock.timersPromisesModuleMethods.push({
          methodName: "setInterval",
          original: timersPromisesModule.setInterval
        }), timersPromisesModule.setInterval = (delay, value, options = {}) => ({
          [Symbol.asyncIterator]: () => {
            let createResolvable = () => {
              let resolve4, reject, promise = new Promise((res, rej) => {
                resolve4 = res, reject = rej;
              });
              return promise.resolve = resolve4, promise.reject = reject, promise;
            }, done = !1, hasThrown = !1, returnCall, nextAvailable = 0, nextQueue = [], handle = clock.setInterval(() => {
              nextQueue.length > 0 ? nextQueue.shift().resolve() : nextAvailable++;
            }, delay), abort = () => {
              options.signal.removeEventListener(
                "abort",
                abort
              ), clock.abortListenerMap.delete(abort), clock.clearInterval(handle), done = !0;
              for (let resolvable of nextQueue)
                resolvable.resolve();
            };
            return options.signal && (options.signal.aborted ? done = !0 : (options.signal.addEventListener(
              "abort",
              abort
            ), clock.abortListenerMap.set(
              abort,
              options.signal
            ))), {
              next: async () => {
                if (options.signal?.aborted && !hasThrown)
                  throw hasThrown = !0, options.signal.reason;
                if (done)
                  return { done: !0, value: void 0 };
                if (nextAvailable > 0)
                  return nextAvailable--, { done: !1, value };
                let resolvable = createResolvable();
                if (nextQueue.push(resolvable), await resolvable, returnCall && nextQueue.length === 0 && returnCall.resolve(), options.signal?.aborted && !hasThrown)
                  throw hasThrown = !0, options.signal.reason;
                return done ? { done: !0, value: void 0 } : { done: !1, value };
              },
              return: async () => done ? { done: !0, value: void 0 } : (nextQueue.length > 0 && (returnCall = createResolvable(), await returnCall), clock.clearInterval(handle), done = !0, options.signal && (options.signal.removeEventListener(
                "abort",
                abort
              ), clock.abortListenerMap.delete(abort)), { done: !0, value: void 0 })
            };
          }
        })));
      }
      return clock;
    }
    return {
      timers,
      createClock,
      install,
      withGlobal
    };
  }
  let defaultImplementation = withGlobal(globalObject);
  return fakeTimersSrc.timers = defaultImplementation.timers, fakeTimersSrc.createClock = defaultImplementation.createClock, fakeTimersSrc.install = defaultImplementation.install, fakeTimersSrc.withGlobal = withGlobal, fakeTimersSrc;
}
var fakeTimersSrcExports = requireFakeTimersSrc(), FakeTimers = class {
  _global;
  _clock;
  // | _fakingTime | _fakingDate |
  // +-------------+-------------+
  // | false       | falsy       | initial
  // | false       | truthy     | vi.setSystemTime called first (for mocking only Date without fake timers)
  // | true        | falsy       | vi.useFakeTimers called first
  // | true        | truthy     | unreachable
  _fakingTime;
  _fakingDate;
  _fakeTimers;
  _userConfig;
  _now = RealDate.now;
  constructor({ global: global3, config: config2 }) {
    this._userConfig = config2, this._fakingDate = null, this._fakingTime = !1, this._fakeTimers = fakeTimersSrcExports.withGlobal(global3), this._global = global3;
  }
  clearAllTimers() {
    this._fakingTime && this._clock.reset();
  }
  dispose() {
    this.useRealTimers();
  }
  runAllTimers() {
    this._checkFakeTimers() && this._clock.runAll();
  }
  async runAllTimersAsync() {
    this._checkFakeTimers() && await this._clock.runAllAsync();
  }
  runOnlyPendingTimers() {
    this._checkFakeTimers() && this._clock.runToLast();
  }
  async runOnlyPendingTimersAsync() {
    this._checkFakeTimers() && await this._clock.runToLastAsync();
  }
  advanceTimersToNextTimer(steps = 1) {
    if (this._checkFakeTimers()) for (let i = steps; i > 0 && (this._clock.next(), this._clock.tick(0), this._clock.countTimers() !== 0); i--)
      ;
  }
  async advanceTimersToNextTimerAsync(steps = 1) {
    if (this._checkFakeTimers()) for (let i = steps; i > 0 && (await this._clock.nextAsync(), this._clock.tick(0), this._clock.countTimers() !== 0); i--)
      ;
  }
  advanceTimersByTime(msToRun) {
    this._checkFakeTimers() && this._clock.tick(msToRun);
  }
  async advanceTimersByTimeAsync(msToRun) {
    this._checkFakeTimers() && await this._clock.tickAsync(msToRun);
  }
  advanceTimersToNextFrame() {
    this._checkFakeTimers() && this._clock.runToFrame();
  }
  runAllTicks() {
    this._checkFakeTimers() && this._clock.runMicrotasks();
  }
  useRealTimers() {
    this._fakingDate && (resetDate(), this._fakingDate = null), this._fakingTime && (this._clock.uninstall(), this._fakingTime = !1);
  }
  useFakeTimers() {
    if (this._fakingDate) throw new Error('"setSystemTime" was called already and date was mocked. Reset timers using `vi.useRealTimers()` if you want to use fake timers again.');
    if (!this._fakingTime) {
      let toFake = Object.keys(this._fakeTimers.timers).filter((timer) => timer !== "nextTick" && timer !== "queueMicrotask");
      if (this._userConfig?.toFake?.includes("nextTick") && isChildProcess()) throw new Error("process.nextTick cannot be mocked inside child_process");
      this._clock = this._fakeTimers.install({
        now: Date.now(),
        ...this._userConfig,
        toFake: this._userConfig?.toFake || toFake,
        ignoreMissingTimers: !0
      }), this._fakingTime = !0;
    }
  }
  reset() {
    if (this._checkFakeTimers()) {
      let { now: now3 } = this._clock;
      this._clock.reset(), this._clock.setSystemTime(now3);
    }
  }
  setSystemTime(now3) {
    let date = typeof now3 > "u" || now3 instanceof Date ? now3 : new Date(now3);
    this._fakingTime ? this._clock.setSystemTime(date) : (this._fakingDate = date ?? new Date(this.getRealSystemTime()), mockDate(this._fakingDate));
  }
  getMockedSystemTime() {
    return this._fakingTime ? new Date(this._clock.now) : this._fakingDate;
  }
  getRealSystemTime() {
    return this._now();
  }
  getTimerCount() {
    return this._checkFakeTimers() ? this._clock.countTimers() : 0;
  }
  configure(config2) {
    this._userConfig = config2;
  }
  isFakeTimers() {
    return this._fakingTime;
  }
  _checkFakeTimers() {
    if (!this._fakingTime) throw new Error('Timers are not mocked. Try calling "vi.useFakeTimers()" first.');
    return this._fakingTime;
  }
};
function copyStackTrace(target, source) {
  return source.stack !== void 0 && (target.stack = source.stack.replace(source.message, target.message)), target;
}
function waitFor(callback, options = {}) {
  let { setTimeout, setInterval, clearTimeout, clearInterval } = getSafeTimers(), { interval = 50, timeout = 1e3 } = typeof options == "number" ? { timeout: options } : options, STACK_TRACE_ERROR = new Error("STACK_TRACE_ERROR");
  return new Promise((resolve4, reject) => {
    let lastError, promiseStatus = "idle", timeoutId, intervalId, onResolve = (result) => {
      timeoutId && clearTimeout(timeoutId), intervalId && clearInterval(intervalId), resolve4(result);
    }, handleTimeout = () => {
      intervalId && clearInterval(intervalId);
      let error = lastError;
      error || (error = copyStackTrace(new Error("Timed out in waitFor!"), STACK_TRACE_ERROR)), reject(error);
    }, checkCallback = () => {
      if (vi.isFakeTimers() && vi.advanceTimersByTime(interval), promiseStatus !== "pending")
        try {
          let result = callback();
          if (result !== null && typeof result == "object" && typeof result.then == "function") {
            let thenable = result;
            promiseStatus = "pending", thenable.then((resolvedValue) => {
              promiseStatus = "resolved", onResolve(resolvedValue);
            }, (rejectedValue) => {
              promiseStatus = "rejected", lastError = rejectedValue;
            });
          } else
            return onResolve(result), !0;
        } catch (error) {
          lastError = error;
        }
    };
    checkCallback() !== !0 && (timeoutId = setTimeout(handleTimeout, timeout), intervalId = setInterval(checkCallback, interval));
  });
}
function waitUntil(callback, options = {}) {
  let { setTimeout, setInterval, clearTimeout, clearInterval } = getSafeTimers(), { interval = 50, timeout = 1e3 } = typeof options == "number" ? { timeout: options } : options, STACK_TRACE_ERROR = new Error("STACK_TRACE_ERROR");
  return new Promise((resolve4, reject) => {
    let promiseStatus = "idle", timeoutId, intervalId, onReject = (error) => {
      intervalId && clearInterval(intervalId), error || (error = copyStackTrace(new Error("Timed out in waitUntil!"), STACK_TRACE_ERROR)), reject(error);
    }, onResolve = (result) => {
      if (result)
        return timeoutId && clearTimeout(timeoutId), intervalId && clearInterval(intervalId), resolve4(result), !0;
    }, checkCallback = () => {
      if (vi.isFakeTimers() && vi.advanceTimersByTime(interval), promiseStatus !== "pending")
        try {
          let result = callback();
          if (result !== null && typeof result == "object" && typeof result.then == "function") {
            let thenable = result;
            promiseStatus = "pending", thenable.then((resolvedValue) => {
              promiseStatus = "resolved", onResolve(resolvedValue);
            }, (rejectedValue) => {
              promiseStatus = "rejected", onReject(rejectedValue);
            });
          } else return onResolve(result);
        } catch (error) {
          onReject(error);
        }
    };
    checkCallback() !== !0 && (timeoutId = setTimeout(onReject, timeout), intervalId = setInterval(checkCallback, interval));
  });
}
function createVitest() {
  let _config = null, workerState = getWorkerState(), _timers, timers = () => _timers ||= new FakeTimers({
    global: globalThis,
    config: workerState.config.fakeTimers
  }), _stubsGlobal = /* @__PURE__ */ new Map(), _stubsEnv = /* @__PURE__ */ new Map(), _envBooleans = [
    "PROD",
    "DEV",
    "SSR"
  ], utils = {
    useFakeTimers(config2) {
      if (isChildProcess() && (config2?.toFake?.includes("nextTick") || workerState.config?.fakeTimers?.toFake?.includes("nextTick")))
        throw new Error('vi.useFakeTimers({ toFake: ["nextTick"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.');
      return config2 ? timers().configure({
        ...workerState.config.fakeTimers,
        ...config2
      }) : timers().configure(workerState.config.fakeTimers), timers().useFakeTimers(), utils;
    },
    isFakeTimers() {
      return timers().isFakeTimers();
    },
    useRealTimers() {
      return timers().useRealTimers(), utils;
    },
    runOnlyPendingTimers() {
      return timers().runOnlyPendingTimers(), utils;
    },
    async runOnlyPendingTimersAsync() {
      return await timers().runOnlyPendingTimersAsync(), utils;
    },
    runAllTimers() {
      return timers().runAllTimers(), utils;
    },
    async runAllTimersAsync() {
      return await timers().runAllTimersAsync(), utils;
    },
    runAllTicks() {
      return timers().runAllTicks(), utils;
    },
    advanceTimersByTime(ms) {
      return timers().advanceTimersByTime(ms), utils;
    },
    async advanceTimersByTimeAsync(ms) {
      return await timers().advanceTimersByTimeAsync(ms), utils;
    },
    advanceTimersToNextTimer() {
      return timers().advanceTimersToNextTimer(), utils;
    },
    async advanceTimersToNextTimerAsync() {
      return await timers().advanceTimersToNextTimerAsync(), utils;
    },
    advanceTimersToNextFrame() {
      return timers().advanceTimersToNextFrame(), utils;
    },
    getTimerCount() {
      return timers().getTimerCount();
    },
    setSystemTime(time) {
      return timers().setSystemTime(time), utils;
    },
    getMockedSystemTime() {
      return timers().getMockedSystemTime();
    },
    getRealSystemTime() {
      return timers().getRealSystemTime();
    },
    clearAllTimers() {
      return timers().clearAllTimers(), utils;
    },
    spyOn,
    fn,
    waitFor,
    waitUntil,
    hoisted(factory) {
      return assertTypes(factory, '"vi.hoisted" factory', ["function"]), factory();
    },
    mock(path, factory) {
      if (typeof path != "string") throw new TypeError(`vi.mock() expects a string path, but received a ${typeof path}`);
      let importer = getImporter("mock");
      _mocker().queueMock(path, importer, typeof factory == "function" ? () => factory(() => _mocker().importActual(path, importer, _mocker().getMockContext().callstack)) : factory);
    },
    unmock(path) {
      if (typeof path != "string") throw new TypeError(`vi.unmock() expects a string path, but received a ${typeof path}`);
      _mocker().queueUnmock(path, getImporter("unmock"));
    },
    doMock(path, factory) {
      if (typeof path != "string") throw new TypeError(`vi.doMock() expects a string path, but received a ${typeof path}`);
      let importer = getImporter("doMock");
      _mocker().queueMock(path, importer, typeof factory == "function" ? () => factory(() => _mocker().importActual(path, importer, _mocker().getMockContext().callstack)) : factory);
    },
    doUnmock(path) {
      if (typeof path != "string") throw new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof path}`);
      _mocker().queueUnmock(path, getImporter("doUnmock"));
    },
    async importActual(path) {
      return _mocker().importActual(path, getImporter("importActual"), _mocker().getMockContext().callstack);
    },
    async importMock(path) {
      return _mocker().importMock(path, getImporter("importMock"));
    },
    mockObject(value) {
      return _mocker().mockObject({ value }).value;
    },
    mocked(item, _options = {}) {
      return item;
    },
    isMockFunction(fn2) {
      return isMockFunction2(fn2);
    },
    clearAllMocks() {
      return [...mocks].reverse().forEach((spy) => spy.mockClear()), utils;
    },
    resetAllMocks() {
      return [...mocks].reverse().forEach((spy) => spy.mockReset()), utils;
    },
    restoreAllMocks() {
      return [...mocks].reverse().forEach((spy) => spy.mockRestore()), utils;
    },
    stubGlobal(name, value) {
      return _stubsGlobal.has(name) || _stubsGlobal.set(name, Object.getOwnPropertyDescriptor(globalThis, name)), Object.defineProperty(globalThis, name, {
        value,
        writable: !0,
        configurable: !0,
        enumerable: !0
      }), utils;
    },
    stubEnv(name, value) {
      return _stubsEnv.has(name) || _stubsEnv.set(name, process.env[name]), _envBooleans.includes(name) ? process.env[name] = value ? "1" : "" : value === void 0 ? delete process.env[name] : process.env[name] = String(value), utils;
    },
    unstubAllGlobals() {
      return _stubsGlobal.forEach((original, name) => {
        original ? Object.defineProperty(globalThis, name, original) : Reflect.deleteProperty(globalThis, name);
      }), _stubsGlobal.clear(), utils;
    },
    unstubAllEnvs() {
      return _stubsEnv.forEach((original, name) => {
        original === void 0 ? delete process.env[name] : process.env[name] = original;
      }), _stubsEnv.clear(), utils;
    },
    resetModules() {
      return resetModules(workerState.moduleCache), utils;
    },
    async dynamicImportSettled() {
      return waitForImportsToResolve();
    },
    setConfig(config2) {
      _config || (_config = { ...workerState.config }), Object.assign(workerState.config, config2);
    },
    resetConfig() {
      _config && Object.assign(workerState.config, _config);
    }
  };
  return utils;
}
var vitest = createVitest(), vi = vitest;
function _mocker() {
  return typeof __vitest_mocker__ < "u" ? __vitest_mocker__ : new Proxy({}, { get(_, name) {
    throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(name)}() is forbidden.`);
  } });
}
function getImporter(name) {
  let stackArray = createSimpleStackTrace({ stackTraceLimit: 5 }).split(`
`), importerStackIndex = stackArray.findIndex((stack2) => stack2.includes(` at Object.${name}`) || stack2.includes(`${name}@`));
  return parseSingleStack(stackArray[importerStackIndex + 1])?.file || "";
}

// ../../node_modules/.pnpm/vitest@3.2.1_@types+node@18.19.70_jiti@2.4.2_jsdom@20.0.3_msw@2.8.7_@types+node@18.19.7_59b23bdad58d2b08cdc86d448ade34f5/node_modules/vitest/dist/index.js
init_cjs_shims();
var import_expect_type = __toESM(require_dist(), 1);

export {
  test2 as test,
  describe,
  beforeEach,
  afterEach,
  globalExpect,
  vi
};
/*! Bundled license information:

@vitest/pretty-format/dist/index.js:
  (**
   * @license React
   * react-is.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

chai/chai.js:
  (*!
   * Chai - flag utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - test utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - expectTypes utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getActual utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - message composition utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - transferFlags utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * chai
   * http://chaijs.com
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - isProxyEnabled helper
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addProperty utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addLengthGuard utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getProperties utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - proxify utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - overwriteProperty utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - overwriteMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - addChainingMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - overwriteChainableMethod utility
   * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - compareByInspect utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getOwnEnumerablePropertySymbols utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - getOwnEnumerableProperties utility
   * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Chai - isNaN utility
   * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
   * MIT Licensed
   *)
  (*!
   * chai
   * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * chai
   * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*! Bundled license information:
  
  deep-eql/index.js:
    (*!
     * deep-eql
     * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
     * MIT Licensed
     *)
    (*!
     * Check to see if the MemoizeMap has recorded a result of the two operands
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {MemoizeMap} memoizeMap
     * @returns {Boolean|null} result
    *)
    (*!
     * Set the result of the equality into the MemoizeMap
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {MemoizeMap} memoizeMap
     * @param {Boolean} result
    *)
    (*!
     * Primary Export
     *)
    (*!
     * The main logic of the `deepEqual` function.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (optional) Additional options
     * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
     * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
        complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
        references to blow the stack.
     * @return {Boolean} equal match
    *)
    (*!
     * Compare two Regular Expressions for equality.
     *
     * @param {RegExp} leftHandOperand
     * @param {RegExp} rightHandOperand
     * @return {Boolean} result
     *)
    (*!
     * Compare two Sets/Maps for equality. Faster than other equality functions.
     *
     * @param {Set} leftHandOperand
     * @param {Set} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
     *
     * @param {Iterable} leftHandOperand
     * @param {Iterable} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Simple equality for generator objects such as those returned by generator functions.
     *
     * @param {Iterable} leftHandOperand
     * @param {Iterable} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Determine if the given object has an @@iterator function.
     *
     * @param {Object} target
     * @return {Boolean} `true` if the object has an @@iterator function.
     *)
    (*!
     * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
     * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
     *
     * @param {Object} target
     * @returns {Array} an array of entries from the @@iterator function
     *)
    (*!
     * Gets all entries from a Generator. This will consume the generator - which could have side effects.
     *
     * @param {Generator} target
     * @returns {Array} an array of entries from the Generator.
     *)
    (*!
     * Gets all own and inherited enumerable keys from a target.
     *
     * @param {Object} target
     * @returns {Array} an array of own and inherited enumerable keys from the target.
     *)
    (*!
     * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
     * each key. If any value of the given key is not equal, the function will return false (early).
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
     * for each enumerable key in the object.
     *
     * @param {Mixed} leftHandOperand
     * @param {Mixed} rightHandOperand
     * @param {Object} [options] (Optional)
     * @return {Boolean} result
     *)
    (*!
     * Returns true if the argument is a primitive.
     *
     * This intentionally returns true for all objects that can be compared by reference,
     * including functions and symbols.
     *
     * @param {Mixed} value
     * @return {Boolean} result
     *)
  *)

@vitest/snapshot/dist/index.js:
  (*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   *)
*/
//# sourceMappingURL=chunk-BQ3PZIHZ.js.map
