import {
  AbortController,
  AbortError,
  BugError,
  captureOutput,
  envPaths,
  exec,
  fileExists,
  findPathUp,
  glob,
  inferPackageManagerForGlobalCLI,
  isUnitTest,
  mimicFunction,
  outputContent,
  outputDebug,
  outputToken,
  readFile,
  require_get_stream,
  runWithTimer,
  writeFile
} from "./chunk-34TWZ632.js";
import {
  require_semver
} from "./chunk-F7F4BQYW.js";
import {
  dirname,
  joinPath
} from "./chunk-Y2JP6WFP.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        if (super(), !exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super(), this._items = typeof code == "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        let item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => (c instanceof Name && (names[c.str] = (names[c.str] || 0) + 1), names), {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      let code = [strs[0]], i = 0;
      for (; i < args.length; )
        addCodeArg(code, args[i]), code.push(strs[++i]);
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      let expr = [safeStringify(strs[0])], i = 0;
      for (; i < args.length; )
        expr.push(plus), addCodeArg(expr, args[i]), expr.push(plus, safeStringify(strs[++i]));
      return optimize(expr), new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      arg instanceof _Code ? code.push(...arg._items) : arg instanceof Name ? code.push(arg) : code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      for (; i < expr.length - 1; ) {
        if (expr[i] === plus) {
          let res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string")
        return b instanceof Name || a[a.length - 1] !== '"' ? void 0 : typeof b != "string" ? `${a.slice(0, -1)}${b}"` : b[0] === '"' ? a.slice(0, -1) + b.slice(1) : void 0;
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty3(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty3;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key))
        return new _Code(`${key}`);
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code(), ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`), this.value = name.value;
      }
    }, UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2.Started = 0] = "Started", UsedValueState2[UsedValueState2.Completed = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {}, this._prefixes = prefixes, this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        let ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (!((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0) && _b.has(prefix) || this._prefixes && !this._prefixes.has(prefix))
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr), this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value, this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`, ValueScope = class extends Scope {
      constructor(opts) {
        super(opts), this._values = {}, this._scope = opts.scope, this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        let name = this.toName(nameOrPrefix), { prefix } = name, valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref, vs = this._values[prefix];
        if (vs) {
          let _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        vs.set(valueKey, name);
        let s = this._scope[prefix] || (this._scope[prefix] = []), itemIndex = s.length;
        return s[itemIndex] = value.ref, name.setValue(value, { property: prefix, itemIndex }), name;
      }
      getValue(prefix, keyOrRef) {
        let vs = this._values[prefix];
        if (vs)
          return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (let prefix in values) {
          let vs = values[prefix];
          if (!vs)
            continue;
          let nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              let def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode?.(name))
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            else
              throw new ValueError(name);
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code(), scope_1 = require_scope(), code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: !0, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: !0, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: !0, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: !0, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: !0, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: !0, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: !0, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }, Def = class extends Node {
      constructor(varKind, name, rhs) {
        super(), this.varKind = varKind, this.name = name, this.rhs = rhs;
      }
      render({ es5, _n }) {
        let varKind = es5 ? scope_1.varKinds.var : this.varKind, rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (names[this.name.str])
          return this.rhs && (this.rhs = optimizeExpr(this.rhs, names, constants)), this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }, Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super(), this.lhs = lhs, this.rhs = rhs, this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!(this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects))
          return this.rhs = optimizeExpr(this.rhs, names, constants), this;
      }
      get names() {
        let names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    }, AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects), this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }, Label = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }, Break = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `break${this.label ? ` ${this.label}` : ""};` + _n;
      }
    }, Throw = class extends Node {
      constructor(error) {
        super(), this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }, AnyCode = class extends Node {
      constructor(code) {
        super(), this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        return this.code = optimizeExpr(this.code, names, constants), this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }, ParentNode = class extends Node {
      constructor(nodes = []) {
        super(), this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i].optimizeNodes();
          Array.isArray(n) ? nodes.splice(i, 1, ...n) : n ? nodes[i] = n : nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i];
          n.optimizeNames(names, constants) || (subtractNames(names, n.names), nodes.splice(i, 1));
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    }, BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }, Root = class extends ParentNode {
    }, Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes), this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        return this.else && (code += "else " + this.else.render(opts)), code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let cond = this.condition;
        if (cond === !0)
          return this.nodes;
        let e = this.else;
        if (e) {
          let ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e)
          return cond === !1 ? e instanceof _If ? e : e.nodes : this.nodes.length ? this : new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        if (!(cond === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(names, constants) {
        var _a;
        if (this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants), !!(super.optimizeNames(names, constants) || this.else))
          return this.condition = optimizeExpr(this.condition, names, constants), this;
      }
      get names() {
        let names = super.names;
        return addExprNames(names, this.condition), this.else && addNames(names, this.else.names), names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super(), this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iteration = optimizeExpr(this.iteration, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }, ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super(), this.varKind = varKind, this.name = name, this.from = from, this.to = to;
      }
      render(opts) {
        let varKind = opts.es5 ? scope_1.varKinds.var : this.varKind, { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        let names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    }, ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super(), this.loop = loop, this.varKind = varKind, this.name = name, this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iterable = optimizeExpr(this.iterable, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }, Func = class extends BlockNode {
      constructor(name, args, async) {
        super(), this.name = name, this.args = args, this.async = async;
      }
      render(opts) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        return this.catch && (code += this.catch.render(opts)), this.finally && (code += this.finally.render(opts)), code;
      }
      optimizeNodes() {
        var _a, _b;
        return super.optimizeNodes(), (_a = this.catch) === null || _a === void 0 || _a.optimizeNodes(), (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes(), this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        return super.optimizeNames(names, constants), (_a = this.catch) === null || _a === void 0 || _a.optimizeNames(names, constants), (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants), this;
      }
      get names() {
        let names = super.names;
        return this.catch && addNames(names, this.catch.names), this.finally && addNames(names, this.finally.names), names;
      }
    }, Catch = class extends BlockNode {
      constructor(error) {
        super(), this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...opts, _n: opts.lines ? `
` : "" }, this._extScope = extScope, this._scope = new scope_1.Scope({ parent: extScope }), this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        let name = this._extScope.value(prefixOrName, value);
        return (this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name), name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        let name = this._scope.toName(nameOrPrefix);
        return rhs !== void 0 && constant && (this._constants[name.str] = rhs), this._leafNode(new Def(varKind, name, rhs)), name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        return typeof c == "function" ? c() : c !== code_1.nil && this._leafNode(new AnyCode(c)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        let code = ["{"];
        for (let [key, value] of keyValues)
          code.length > 1 && code.push(","), code.push(key), (key !== value || this.opts.es5) && (code.push(":"), (0, code_1.addCodeArg)(code, value));
        return code.push("}"), new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        if (this._blockNode(new If(condition)), thenBody && elseBody)
          this.code(thenBody).else().code(elseBody).endIf();
        else if (thenBody)
          this.code(thenBody).endIf();
        else if (elseBody)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        return this._blockNode(node), forBody && this.code(forBody).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        let name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          let arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`), forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        let node = new Return();
        if (this._blockNode(node), this.code(value), node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        let node = new Try();
        if (this._blockNode(node), this.code(tryBody), catchCode) {
          let error = this.name("e");
          this._currNode = node.catch = new Catch(error), catchCode(error);
        }
        return finallyCode && (this._currNode = node.finally = new Finally(), this.code(finallyCode)), this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        return this._blockStarts.push(this._nodes.length), body && this.code(body).endBlock(nodeCount), this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        let len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        let toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount)
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        return this._nodes.length = len, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        return this._blockNode(new Func(name, args, async)), funcBody && this.code(funcBody).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        for (; n-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(node) {
        return this._currNode.nodes.push(node), this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node), this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        let n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        let n = this._currNode;
        if (!(n instanceof If))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = n.else = node, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        let ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => (c instanceof code_1.Name && (c = replaceName(c)), c instanceof code_1._Code ? items.push(...c._items) : items.push(c), items), []));
      function replaceName(n) {
        let c = constants[n.str];
        return c === void 0 || names[n.str] !== 1 ? n : (delete names[n.str], c);
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen(), code_1 = require_code();
    function toHash(arr) {
      let hash = {};
      for (let item of arr)
        hash[item] = !0;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      return typeof schema == "boolean" ? schema : Object.keys(schema).length === 0 ? !0 : (checkUnknownRules(it, schema), !schemaHasRules(schema, it.self.RULES.all));
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      let { opts, self } = it;
      if (!opts.strictSchema || typeof schema == "boolean")
        return;
      let rules = self.RULES.keywords;
      for (let key in schema)
        rules[key] || checkStrictMode(it, `unknown keyword: "${key}"`);
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (rules[key])
          return !0;
      return !1;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (key !== "$ref" && RULES.all[key])
          return !0;
      return !1;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      return typeof str == "number" ? `${str}` : str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs))
        for (let x of xs)
          f(x);
      else
        f(xs);
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        let res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, !0), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          from === !0 ? gen.assign(to, !0) : (gen.assign(to, (0, codegen_1._)`${to} || {}`), setEvaluated(gen, to, from));
        }),
        mergeValues: (from, to) => from === !0 ? !0 : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === !0 ? !0 : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === !0 ? !0 : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === !0)
        return gen.var("props", !0);
      let props = gen.var("props", (0, codegen_1._)`{}`);
      return ps !== void 0 && setEvaluated(gen, props, ps), props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, !0));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2.Num = 0] = "Num", Type2[Type2.Str = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        let isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (mode) {
        if (msg = `strict mode: ${msg}`, mode === !0)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error, errorPaths);
      overrideAllErrors ?? (compositeRule || allErrors) ? addError(gen, errObj) : returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj), compositeRule || allErrors || returnErrors(it, names_1.default.vErrors);
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount), gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      let err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`), gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath))), gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`), it.opts.verbose && (gen.assign((0, codegen_1._)`${err}.schema`, schemaValue), gen.assign((0, codegen_1._)`${err}.data`, data));
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      let err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`), gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      let { gen, validateName, schemaEnv } = it;
      schemaEnv.$async ? gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`) : (gen.assign((0, codegen_1._)`${validateName}.errors`, errs), gen.return(!1));
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      let { createErrors } = cxt.it;
      return createErrors === !1 ? (0, codegen_1._)`{}` : errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      let { gen, it } = cxt, keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      return extraErrorProps(cxt, error, keyValues), gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      let instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      return schemaPath && (schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`), [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      let { keyword, data, schemaValue, it } = cxt, { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]), opts.messages && keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]), opts.verbose && keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]), propertyName && keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors(), codegen_1 = require_codegen(), names_1 = require_names(), boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      let { gen, schema, validateName } = it;
      schema === !1 ? falseSchemaError(it, !1) : typeof schema == "object" && schema.$async === !0 ? gen.return(names_1.default.data) : (gen.assign((0, codegen_1._)`${validateName}.errors`, null), gen.return(!0));
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      let { gen, schema } = it;
      schema === !1 ? (gen.var(valid, !1), falseSchemaError(it)) : gen.var(valid, !0);
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      let { gen, data } = it, cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"], jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      let groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      let group = self.RULES.types[type];
      return group && group !== !0 && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules(), applicability_1 = require_applicability(), errors_1 = require_errors(), codegen_1 = require_codegen(), util_1 = require_util(), DataType;
    (function(DataType2) {
      DataType2[DataType2.Correct = 0] = "Correct", DataType2[DataType2.Wrong = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      let types2 = getJSONTypes(schema.type);
      if (types2.includes("null")) {
        if (schema.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        schema.nullable === !0 && types2.push("null");
      }
      return types2;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      let types2 = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types2) {
      let { gen, data, opts } = it, coerceTo = coerceToTypes(types2, opts.coerceTypes), checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types2[0]));
      if (checkTypes) {
        let wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          coerceTo.length ? coerceData(it, types2, coerceTo) : reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types2, coerceTo) {
      let { gen, data, opts } = it, dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`), coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      opts.coerceTypes === "array" && gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen.assign(coerced, data))), gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (let t of coerceTo)
        (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") && coerceSpecificType(t);
      gen.else(), reportTypeError(it), gen.endIf(), gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced), assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, !1).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, !0);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`), gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      let EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ, cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1)
        return checkDataType(dataTypes[0], data, strictNums, correct);
      let cond, types2 = (0, util_1.toHash)(dataTypes);
      if (types2.array && types2.object) {
        let notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`, delete types2.null, delete types2.array, delete types2.object;
      } else
        cond = codegen_1.nil;
      types2.number && delete types2.integer;
      for (let t in types2)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      let cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      let { gen, data, schema } = it, schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function assignDefaults(it, ty) {
      let { properties, items } = it.schema;
      if (ty === "object" && properties)
        for (let key in properties)
          assignDefault(it, key, properties[key].default);
      else ty === "array" && Array.isArray(items) && items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      let { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      let childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      opts.useDefaults === "empty" && (condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`), gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names(), util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      let { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, !0), cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, !0), cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      let dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data, valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      it.opts.dynamicRef && valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      let args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      let u = opts.unicodeRegExp ? "u" : "", { regExp } = opts.code, rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      if (it.allErrors) {
        let validArr = gen.let("valid", !0);
        return validateItems(() => gen.assign(validArr, !1)), validArr;
      }
      return gen.var(valid, !0), validateItems(() => gen.break()), valid;
      function validateItems(notValid) {
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid), gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      let { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated)
        return;
      let valid = gen.let("valid", !1), schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        let schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: !0
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`), cxt.mergeValidEvaluated(schCxt, schValid) || gen.if((0, codegen_1.not)(valid));
      })), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
    }
    exports.validateUnion = validateUnion;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen(), names_1 = require_names(), code_1 = require_code2(), errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      let { gen, keyword, schema, parentSchema, it } = cxt, macroSchema = def.macro.call(it.self, schema, parentSchema, it), schemaRef = useKeyword(gen, keyword, macroSchema);
      it.opts.validateSchema !== !1 && it.self.validateSchema(macroSchema, !0);
      let valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: !0
      }, valid), cxt.pass(valid, () => cxt.error(!0));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      let { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      let validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate, validateRef = useKeyword(gen, keyword, validate), valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword), cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === !1)
          assignValid(), def.modifying && modifyData(cxt), reportErrs(() => cxt.error());
        else {
          let ruleErrs = def.async ? validateAsync() : validateSync();
          def.modifying && modifyData(cxt), reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        let ruleErrs = gen.let("ruleErrs", null);
        return gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, !1).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e))), ruleErrs;
      }
      function validateSync() {
        let validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        return gen.assign(validateErrs, null), assignValid(codegen_1.nil), validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        let passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self, passSchema = !("compile" in def && !$data || def.schema === !1);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      let { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      let { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`), (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = !1) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema > "u");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword)
        throw new Error("ajv implementation error");
      let deps = def.dependencies;
      if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)))
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      if (def.validateSchema && !def.validateSchema(schema[keyword])) {
        let msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (keyword !== void 0) {
        let sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      let { gen } = it;
      if (dataProp !== void 0) {
        let { errorPath, dataPathArr, opts } = it, nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, !0);
        dataContextProps(nextData), subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`, subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`, subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        let nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, !0);
        dataContextProps(nextData), propertyName !== void 0 && (subschema.propertyName = propertyName);
      }
      dataTypes && (subschema.dataTypes = dataTypes);
      function dataContextProps(_nextData) {
        subschema.data = _nextData, subschema.dataLevel = it.dataLevel + 1, subschema.dataTypes = [], it.definedProperties = /* @__PURE__ */ new Set(), subschema.parentData = it.data, subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      compositeRule !== void 0 && (subschema.compositeRule = compositeRule), createErrors !== void 0 && (subschema.createErrors = createErrors), allErrors !== void 0 && (subschema.allErrors = allErrors), subschema.jtdDiscriminator = jtdDiscriminator, subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = function equal(a, b) {
      if (a === b) return !0;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return !1;
        var length, i, keys;
        if (Array.isArray(a)) {
          if (length = a.length, length != b.length) return !1;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return !1;
          return !0;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return !1;
        }
        return !0;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var traverse = module.exports = function(schema, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      }, post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    };
    traverse.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    };
    traverse.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    };
    traverse.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords)
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object")
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util(), equal = require_fast_deep_equal(), traverse = require_json_schema_traverse(), SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = !0) {
      return typeof schema == "boolean" ? !0 : limit === !0 ? !hasRef(schema) : limit ? countKeys(schema) <= limit : !1;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (let key in schema) {
        if (REF_KEYWORDS.has(key))
          return !0;
        let sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef) || typeof sch == "object" && hasRef(sch))
          return !0;
      }
      return !1;
    }
    function countKeys(schema) {
      let count = 0;
      for (let key in schema) {
        if (key === "$ref")
          return 1 / 0;
        if (count++, !SIMPLE_INLINED.has(key) && (typeof schema[key] == "object" && (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch)), count === 1 / 0))
          return 1 / 0;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      normalize !== !1 && (id = normalizeId(id));
      let p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      return resolver.serialize(p).split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      return id = normalizeId(id), resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      let { schemaId, uriResolver } = this.opts, schId = normalizeId(schema[schemaId] || baseId), baseIds = { "": schId }, pathPrefix = getFullPath(uriResolver, schId, !1), localRefs = {}, schemaRefs = /* @__PURE__ */ new Set();
      return traverse(schema, { allKeys: !0 }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        let fullPath = pathPrefix + jsonPtr, innerBaseId = baseIds[parentJsonPtr];
        typeof sch[schemaId] == "string" && (innerBaseId = addRef.call(this, sch[schemaId])), addAnchor.call(this, sch.$anchor), addAnchor.call(this, sch.$dynamicAnchor), baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          let _resolve = this.opts.uriResolver.resolve;
          if (ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref), schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          return typeof schOrRef == "string" && (schOrRef = this.refs[schOrRef]), typeof schOrRef == "object" ? checkAmbiguosRef(sch, schOrRef.schema, ref) : ref !== normalizeId(fullPath) && (ref[0] === "#" ? (checkAmbiguosRef(sch, localRefs[ref], ref), localRefs[ref] = sch) : this.refs[ref] = fullPath), ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      }), localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema(), dataType_1 = require_dataType(), applicability_1 = require_applicability(), dataType_2 = require_dataType(), defaults_1 = require_defaults(), keyword_1 = require_keyword(), subschema_1 = require_subschema(), codegen_1 = require_codegen(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        topSchemaObjCode(it);
        return;
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      opts.code.es5 ? gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`), destructureValCxtES5(gen, opts), gen.code(body);
      }) : gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`), gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`), gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`), gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`), gen.var(names_1.default.rootData, names_1.default.data), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      let { schema, opts, gen } = it;
      validateFunction(it, () => {
        opts.$comment && schema.$comment && commentKeyword(it), checkNoDefault(it), gen.let(names_1.default.vErrors, null), gen.let(names_1.default.errors, 0), opts.unevaluated && resetEvaluated(it), typeAndKeywords(it), returnResults(it);
      });
    }
    function resetEvaluated(it) {
      let { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`), gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`)), gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      let schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        subSchemaObjCode(it, valid);
        return;
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (self.RULES.all[key])
          return !0;
      return !1;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      let { schema, gen, opts } = it;
      opts.$comment && schema.$comment && commentKeyword(it), updateContext(it), checkAsyncSchema(it);
      let errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount), gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it), checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], !1, errsCount);
      let types2 = (0, dataType_1.getSchemaTypes)(it.schema), checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types2);
      schemaKeywords(it, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      let { schema, errSchemaPath, opts, self } = it;
      schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES) && self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
    function checkNoDefault(it) {
      let { schema, opts } = it;
      schema.default !== void 0 && opts.useDefaults && opts.strictSchema && (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
    function updateContext(it) {
      let schId = it.schema[it.opts.schemaId];
      schId && (it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId));
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      let msg = schema.$comment;
      if (opts.$comment === !0)
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      else if (typeof opts.$comment == "function") {
        let schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`, rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      let { gen, schemaEnv, validateName, ValidationError, opts } = it;
      schemaEnv.$async ? gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`)) : (gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors), opts.unevaluated && assignEvaluated(it), gen.return((0, codegen_1._)`${names_1.default.errors} === 0`));
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      props instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.props`, props), items instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types2, typeErrors, errsCount) {
      let { gen, schema, data, allErrors, opts, self } = it, { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      opts.jtd || checkStrictTypes(it, types2), gen.block(() => {
        for (let group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        (0, applicability_1.shouldUseGroup)(schema, group) && (group.type ? (gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)), iterateKeywords(it, group), types2.length === 1 && types2[0] === group.type && typeErrors && (gen.else(), (0, dataType_2.reportTypeError)(it)), gen.endIf()) : iterateKeywords(it, group), allErrors || gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`));
      }
    }
    function iterateKeywords(it, group) {
      let { gen, schema, opts: { useDefaults } } = it;
      useDefaults && (0, defaults_1.assignDefaults)(it, group.type), gen.block(() => {
        for (let rule of group.rules)
          (0, applicability_1.shouldUseRule)(schema, rule) && keywordCode(it, rule.keyword, rule.definition, group.type);
      });
    }
    function checkStrictTypes(it, types2) {
      it.schemaEnv.meta || !it.opts.strictTypes || (checkContextTypes(it, types2), it.opts.allowUnionTypes || checkMultipleTypes(it, types2), checkKeywordTypes(it, it.dataTypes));
    }
    function checkContextTypes(it, types2) {
      if (types2.length) {
        if (!it.dataTypes.length) {
          it.dataTypes = types2;
          return;
        }
        types2.forEach((t) => {
          includesType(it.dataTypes, t) || strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }), narrowSchemaTypes(it, types2);
      }
    }
    function checkMultipleTypes(it, ts) {
      ts.length > 1 && !(ts.length === 2 && ts.includes("null")) && strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
    function checkKeywordTypes(it, ts) {
      let rules = it.self.RULES.all;
      for (let keyword in rules) {
        let rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          let { type } = rule.definition;
          type.length && !type.some((t) => hasApplicableType(ts, t)) && strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      let ts = [];
      for (let t of it.dataTypes)
        includesType(withTypes, t) ? ts.push(t) : withTypes.includes("integer") && t === "number" && ts.push("integer");
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      let schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`, (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        if ((0, keyword_1.validateKeywordUsage)(it, def, keyword), this.gen = it.gen, this.allErrors = it.allErrors, this.keyword = keyword, this.data = it.data, this.schema = it.schema[keyword], this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data), this.schemaType = def.schemaType, this.parentSchema = it.schema, this.params = {}, this.it = it, this.def = def, this.$data)
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        else if (this.schemaCode = this.schemaValue, !(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined))
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        ("code" in def ? def.trackErrors : def.errors !== !1) && (this.errsCount = it.gen.const("_errs", names_1.default.errors));
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition), failAction ? failAction() : this.error(), successAction ? (this.gen.else(), successAction(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(condition), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        let { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams), this._error(append, errorPaths), this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        this.allErrors || this.gen.if(cond);
      }
      setParams(obj, assign) {
        assign ? Object.assign(this.params, obj) : this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid), codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        let { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid)), valid !== codegen_1.nil && gen.assign(valid, !0), (schemaType.length || def.validateSchema) && (gen.elseIf(this.invalid$data()), this.$dataError(), valid !== codegen_1.nil && gen.assign(valid, !1)), gen.else();
      }
      invalid$data() {
        let { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            let st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            let validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        let subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl), (0, subschema_1.extendSubschemaMode)(subschema, appl);
        let nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        return subschemaCode(nextContext, valid), nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        let { it, gen } = this;
        it.opts.unevaluated && (it.props !== !0 && schemaCxt.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)), it.items !== !0 && schemaCxt.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)));
      }
      mergeValidEvaluated(schemaCxt, valid) {
        let { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== !0 || it.items !== !0))
          return gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name)), !0;
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      let cxt = new KeywordCxt(it, def, keyword);
      "code" in def ? def.code(cxt, ruleType) : cxt.$data && def.validate ? (0, keyword_1.funcKeywordCode)(cxt, def) : "macro" in def ? (0, keyword_1.macroKeywordCode)(cxt, def) : (def.compile || def.validate) && (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer, data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data, data = names_1.default.rootData;
      } else {
        let matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        let up = +matches[1];
        if (jsonPointer = matches[2], jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        if (data = dataNames[dataLevel - up], !jsonPointer)
          return data;
      }
      let expr = data, segments = jsonPointer.split("/");
      for (let segment of segments)
        segment && (data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`, expr = (0, codegen_1._)`${expr} && ${data}`);
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed"), this.errors = errors, this.ajv = this.validation = !0;
      }
    };
    exports.default = ValidationError;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var resolve_1 = require_resolve(), MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`), this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref), this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen(), validation_error_1 = require_validation_error(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), validate_1 = require_validate(), SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {}, this.dynamicAnchors = {};
        let schema;
        typeof env.schema == "object" && (schema = env.schema), this.schema = env.schema, this.schemaId = env.schemaId, this.root = env.root || this, this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema?.[env.schemaId || "$id"]), this.schemaPath = env.schemaPath, this.localRefs = env.localRefs, this.meta = env.meta, this.$async = schema?.$async, this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      let _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      let rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId), { es5, lines } = this.opts.code, { ownProperties } = this.opts, gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties }), _ValidationError;
      sch.$async && (_ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      }));
      let validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      let schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === !0 ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      }, sourceCode;
      try {
        this._compilations.add(sch), (0, validate_1.validateFunctionCode)(schemaCxt), gen.optimize(this.opts.code.optimize);
        let validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`, this.opts.code.process && (sourceCode = this.opts.code.process(sourceCode, sch));
        let validate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode)(this, this.scope.get());
        if (this.scope.value(validateName, { ref: validate }), validate.errors = null, validate.schema = sch.schema, validate.schemaEnv = sch, sch.$async && (validate.$async = !0), this.opts.code.source === !0 && (validate.source = { validateName, validateCode, scopeValues: gen._values }), this.opts.unevaluated) {
          let { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          }, validate.source && (validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated));
        }
        return sch.validate = validate, sch;
      } catch (e) {
        throw delete sch.validate, delete sch.validateName, sourceCode && this.logger.error("Error compiling schema, function code:", sourceCode), e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      let schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        let schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref], { schemaId } = this.opts;
        schema && (_sch = new SchemaEnv({ schema, schemaId, root, baseId }));
      }
      if (_sch !== void 0)
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      return (0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs) ? sch.schema : sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (let sch of this._compilations)
        if (sameSchemaEnv(sch, schEnv))
          return sch;
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      for (; typeof (sch = this.refs[ref]) == "string"; )
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      let p = this.opts.uriResolver.parse(ref), refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p), baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId)
        return getJsonPointer.call(this, p, root);
      let id = (0, resolve_1.normalizeId)(refPath), schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        let sch = resolveSchema.call(this, root, schOrRef);
        return typeof sch?.schema != "object" ? void 0 : getJsonPointer.call(this, p, sch);
      }
      if (typeof schOrRef?.schema == "object") {
        if (schOrRef.validate || compileSchema.call(this, schOrRef), id === (0, resolve_1.normalizeId)(ref)) {
          let { schema } = schOrRef, { schemaId } = this.opts, schId = schema[schemaId];
          return schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId)), new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
      }
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (let part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
          return;
        let partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        let schId = typeof schema == "object" && schema[this.opts.schemaId];
        !PREVENT_SCOPE_CHANGE.has(part) && schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId));
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        let $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      let { schemaId } = this.opts;
      if (env = env || new SchemaEnv({ schema, schemaId, root, baseId }), env.schema !== env.root.schema)
        return env;
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: !1
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/scopedChars.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module.exports = {
      HEX
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { HEX } = require_scopedChars(), IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3)
        return { host, isIPV4: !1 };
      let matches = host.match(IPV4_REG) || [], [address] = matches;
      return address ? { host: stripLeadingZeros(address, "."), isIPV4: !0 } : { host, isIPV4: !1 };
    }
    function stringArrayToHexStripped(input, keepZero = !1) {
      let acc = "", strip = !0;
      for (let c of input) {
        if (HEX[c] === void 0) return;
        c !== "0" && strip === !0 && (strip = !1), strip || (acc += c);
      }
      return keepZero && acc.length === 0 && (acc = "0"), acc;
    }
    function getIPV6(input) {
      let tokenCount = 0, output = { error: !1, address: "", zone: "" }, address = [], buffer = [], isZone = !1, endipv6Encountered = !1, endIpv6 = !1;
      function consume() {
        if (buffer.length) {
          if (isZone === !1) {
            let hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0)
              address.push(hex);
            else
              return output.error = !0, !1;
          }
          buffer.length = 0;
        }
        return !0;
      }
      for (let i = 0; i < input.length; i++) {
        let cursor = input[i];
        if (!(cursor === "[" || cursor === "]"))
          if (cursor === ":") {
            if (endipv6Encountered === !0 && (endIpv6 = !0), !consume())
              break;
            if (tokenCount++, address.push(":"), tokenCount > 7) {
              output.error = !0;
              break;
            }
            i - 1 >= 0 && input[i - 1] === ":" && (endipv6Encountered = !0);
            continue;
          } else if (cursor === "%") {
            if (!consume())
              break;
            isZone = !0;
          } else {
            buffer.push(cursor);
            continue;
          }
      }
      return buffer.length && (isZone ? output.zone = buffer.join("") : endIpv6 ? address.push(buffer.join("")) : address.push(stringArrayToHexStripped(buffer))), output.address = address.join(""), output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2)
        return { host, isIPV6: !1 };
      let ipv6 = getIPV6(host);
      if (ipv6.error)
        return { host, isIPV6: !1 };
      {
        let newHost = ipv6.address, escapedHost = ipv6.address;
        return ipv6.zone && (newHost += "%" + ipv6.zone, escapedHost += "%25" + ipv6.zone), { host: newHost, escapedHost, isIPV6: !0 };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "", skip = !0, l = str.length;
      for (let i = 0; i < l; i++) {
        let c = str[i];
        c === "0" && skip ? (i + 1 <= l && str[i + 1] === token || i + 1 === l) && (out += c, skip = !1) : (c === token ? skip = !0 : skip = !1, out += c);
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++)
        str[i] === token && ind++;
      return ind;
    }
    var RDS1 = /^\.\.?\//u, RDS2 = /^\/\.(?:\/|$)/u, RDS3 = /^\/\.\.(?:\/|$)/u, RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      let output = [];
      for (; input.length; )
        if (input.match(RDS1))
          input = input.replace(RDS1, "");
        else if (input.match(RDS2))
          input = input.replace(RDS2, "/");
        else if (input.match(RDS3))
          input = input.replace(RDS3, "/"), output.pop();
        else if (input === "." || input === "..")
          input = "";
        else {
          let im = input.match(RDS5);
          if (im) {
            let s = im[0];
            input = input.slice(s.length), output.push(s);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      let func = esc !== !0 ? escape : unescape;
      return components.scheme !== void 0 && (components.scheme = func(components.scheme)), components.userinfo !== void 0 && (components.userinfo = func(components.userinfo)), components.host !== void 0 && (components.host = func(components.host)), components.path !== void 0 && (components.path = func(components.path)), components.query !== void 0 && (components.query = func(components.query)), components.fragment !== void 0 && (components.fragment = func(components.fragment)), components;
    }
    function recomposeAuthority(components) {
      let uriTokens = [];
      if (components.userinfo !== void 0 && (uriTokens.push(components.userinfo), uriTokens.push("@")), components.host !== void 0) {
        let host = unescape(components.host), ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4)
          host = ipV4res.host;
        else {
          let ipV6res = normalizeIPv6(ipV4res.host);
          ipV6res.isIPV6 === !0 ? host = `[${ipV6res.escapedHost}]` : host = components.host;
        }
        uriTokens.push(host);
      }
      return (typeof components.port == "number" || typeof components.port == "string") && (uriTokens.push(":"), uriTokens.push(String(components.port))), uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure == "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      return components.host || (components.error = components.error || "HTTP URIs must have a host."), components;
    }
    function httpSerialize(components) {
      let secure = String(components.scheme).toLowerCase() === "https";
      return (components.port === (secure ? 443 : 80) || components.port === "") && (components.port = void 0), components.path || (components.path = "/"), components;
    }
    function wsParse(wsComponents) {
      return wsComponents.secure = isSecure(wsComponents), wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : ""), wsComponents.path = void 0, wsComponents.query = void 0, wsComponents;
    }
    function wsSerialize(wsComponents) {
      if ((wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") && (wsComponents.port = void 0), typeof wsComponents.secure == "boolean" && (wsComponents.scheme = wsComponents.secure ? "wss" : "ws", wsComponents.secure = void 0), wsComponents.resourceName) {
        let [path4, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path4 && path4 !== "/" ? path4 : void 0, wsComponents.query = query, wsComponents.resourceName = void 0;
      }
      return wsComponents.fragment = void 0, wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path)
        return urnComponents.error = "URN can not be parsed", urnComponents;
      let matches = urnComponents.path.match(URN_REG);
      if (matches) {
        let scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase(), urnComponents.nss = matches[2];
        let urnScheme = `${scheme}:${options.nid || urnComponents.nid}`, schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0, schemeHandler && (urnComponents = schemeHandler.parse(urnComponents, options));
      } else
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      let scheme = options.scheme || urnComponents.scheme || "urn", nid = urnComponents.nid.toLowerCase(), urnScheme = `${scheme}:${options.nid || nid}`, schemeHandler = SCHEMES[urnScheme];
      schemeHandler && (urnComponents = schemeHandler.serialize(urnComponents, options));
      let uriComponents = urnComponents, nss = urnComponents.nss;
      return uriComponents.path = `${nid || options.nid}:${nss}`, options.skipEscape = !0, uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      let uuidComponents = urnComponents;
      return uuidComponents.uuid = uuidComponents.nss, uuidComponents.nss = void 0, !options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid)) && (uuidComponents.error = uuidComponents.error || "UUID is not valid."), uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      let urnComponents = uuidComponents;
      return urnComponents.nss = (uuidComponents.uuid || "").toLowerCase(), urnComponents;
    }
    var http3 = {
      scheme: "http",
      domainHost: !0,
      parse: httpParse,
      serialize: httpSerialize
    }, https2 = {
      scheme: "https",
      domainHost: http3.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    }, ws = {
      scheme: "ws",
      domainHost: !0,
      parse: wsParse,
      serialize: wsSerialize
    }, wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    }, urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: !0
    }, urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: !0
    }, SCHEMES = {
      http: http3,
      https: https2,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module.exports = SCHEMES;
  }
});

// ../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "../../node_modules/.pnpm/fast-uri@3.0.6/node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils(), SCHEMES = require_schemes();
    function normalize(uri, options) {
      return typeof uri == "string" ? uri = serialize(parse(uri, options), options) : typeof uri == "object" && (uri = parse(serialize(uri, options), options)), uri;
    }
    function resolve(baseURI, relativeURI, options) {
      let schemelessOptions = Object.assign({ scheme: "null" }, options), resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, !0);
      return serialize(resolved, { ...schemelessOptions, skipEscape: !0 });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      let target = {};
      return skipNormalization || (base = parse(serialize(base, options), options), relative = parse(serialize(relative, options), options)), options = options || {}, !options.tolerant && relative.scheme ? (target.scheme = relative.scheme, target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0 ? (target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.path ? (relative.path.charAt(0) === "/" ? target.path = removeDotSegments(relative.path) : ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path ? target.path = "/" + relative.path : base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path, target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, relative.query !== void 0 ? target.query = relative.query : target.query = base.query), target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), target.scheme = base.scheme), target.fragment = relative.fragment, target;
    }
    function equal(uriA, uriB, options) {
      return typeof uriA == "string" ? (uriA = unescape(uriA), uriA = serialize(normalizeComponentEncoding(parse(uriA, options), !0), { ...options, skipEscape: !0 })) : typeof uriA == "object" && (uriA = serialize(normalizeComponentEncoding(uriA, !0), { ...options, skipEscape: !0 })), typeof uriB == "string" ? (uriB = unescape(uriB), uriB = serialize(normalizeComponentEncoding(parse(uriB, options), !0), { ...options, skipEscape: !0 })) : typeof uriB == "object" && (uriB = serialize(normalizeComponentEncoding(uriB, !0), { ...options, skipEscape: !0 })), uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      let components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      }, options = Object.assign({}, opts), uriTokens = [], schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      schemeHandler && schemeHandler.serialize && schemeHandler.serialize(components, options), components.path !== void 0 && (options.skipEscape ? components.path = unescape(components.path) : (components.path = escape(components.path), components.scheme !== void 0 && (components.path = components.path.split("%3A").join(":")))), options.reference !== "suffix" && components.scheme && uriTokens.push(components.scheme, ":");
      let authority = recomposeAuthority(components);
      if (authority !== void 0 && (options.reference !== "suffix" && uriTokens.push("//"), uriTokens.push(authority), components.path && components.path.charAt(0) !== "/" && uriTokens.push("/")), components.path !== void 0) {
        let s = components.path;
        !options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath) && (s = removeDotSegments(s)), authority === void 0 && (s = s.replace(/^\/\//u, "/%2F")), uriTokens.push(s);
      }
      return components.query !== void 0 && uriTokens.push("?", components.query), components.fragment !== void 0 && uriTokens.push("#", components.fragment), uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i)
        if (code = value.charCodeAt(i), code > 126 || hexLookUp[code])
          return !0;
      return !1;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      let options = Object.assign({}, opts), parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, gotEncoding = uri.indexOf("%") !== -1, isIP = !1;
      options.reference === "suffix" && (uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri);
      let matches = uri.match(URI_PARSE);
      if (matches) {
        if (parsed.scheme = matches[1], parsed.userinfo = matches[3], parsed.host = matches[4], parsed.port = parseInt(matches[5], 10), parsed.path = matches[6] || "", parsed.query = matches[7], parsed.fragment = matches[8], isNaN(parsed.port) && (parsed.port = matches[5]), parsed.host) {
          let ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === !1) {
            let ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase(), isIP = ipv6result.isIPV6;
          } else
            parsed.host = ipv4result.host, isIP = !0;
        }
        parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path ? parsed.reference = "same-document" : parsed.scheme === void 0 ? parsed.reference = "relative" : parsed.fragment === void 0 ? parsed.reference = "absolute" : parsed.reference = "uri", options.reference && options.reference !== "suffix" && options.reference !== parsed.reference && (parsed.error = parsed.error || "URI is not a " + options.reference + " reference.");
        let schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport) && parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === !1 && nonSimpleDomain(parsed.host))
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) && (gotEncoding && parsed.scheme !== void 0 && (parsed.scheme = unescape(parsed.scheme)), gotEncoding && parsed.host !== void 0 && (parsed.host = unescape(parsed.host)), parsed.path && (parsed.path = escape(unescape(parsed.path))), parsed.fragment && (parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment)))), schemeHandler && schemeHandler.parse && schemeHandler.parse(parsed, options);
      } else
        parsed.error = parsed.error || "URI can not be parsed.";
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error(), ref_error_1 = require_ref_error(), rules_1 = require_rules(), compile_1 = require_compile(), codegen_2 = require_codegen(), resolve_1 = require_resolve(), dataType_1 = require_dataType(), util_1 = require_util(), $dataRefSchema = require_data(), uri_1 = require_uri(), defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"], EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      let s = o.strict, _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize, optimize = _optz === !0 || _optz === void 0 ? 1 : _optz || 0, regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp, uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : !0,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : !0,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : !1,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : !0,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : !0,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : !0,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : !0,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : !0,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : !0,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : !0,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : !0,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), opts = this.opts = { ...opts, ...requiredOptions(opts) };
        let { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines }), this.logger = getLogger(opts.logger);
        let formatOpt = opts.validateFormats;
        opts.validateFormats = !1, this.RULES = (0, rules_1.getRules)(), checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED"), checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn"), this._metaOpts = getMetaSchemaOptions.call(this), opts.formats && addInitialFormats.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), opts.keywords && addInitialKeywords.call(this, opts.keywords), typeof opts.meta == "object" && this.addMetaSchema(opts.meta), addInitialSchemas.call(this), opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data, meta, schemaId } = this.opts, _dataRefSchema = $dataRefSchema;
        schemaId === "id" && (_dataRefSchema = { ...$dataRefSchema }, _dataRefSchema.id = _dataRefSchema.$id, delete _dataRefSchema.$id), meta && $data && this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], !1);
      }
      defaultMeta() {
        let { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          if (v = this.getSchema(schemaKeyRef), !v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else
          v = this.compile(schemaKeyRef);
        let valid = v(data);
        return "$async" in v || (this.errors = v.errors), valid;
      }
      compile(schema, _meta) {
        let sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        let { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          let sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          $ref && !this.getSchema($ref) && await runCompileAsync.call(this, { $ref }, !0);
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            return checkLoaded.call(this, e), await loadMissingSchema.call(this, e.missingSchema), _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref])
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
        async function loadMissingSchema(ref) {
          let _schema = await _loadSchema.call(this, ref);
          this.refs[ref] || await loadMetaSchema.call(this, _schema.$schema), this.refs[ref] || this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          let p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (let sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema == "object") {
          let { schemaId } = this.opts;
          if (id = schema[schemaId], id !== void 0 && typeof id != "string")
            throw new Error(`schema ${schemaId} must be string`);
        }
        return key = (0, resolve_1.normalizeId)(key || id), this._checkUnique(key), this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        return this.addSchema(schema, key, !0, _validateSchema), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return !0;
        let $schema;
        if ($schema = schema.$schema, $schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        if ($schema = $schema || this.opts.defaultMeta || this.defaultMeta(), !$schema)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        let valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          let message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        for (; typeof (sch = getSchEnv.call(this, keyRef)) == "string"; )
          keyRef = sch;
        if (sch === void 0) {
          let { schemaId } = this.opts, root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          if (sch = compile_1.resolveSchema.call(this, root, keyRef), !sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp)
          return this._removeAllSchemas(this.schemas, schemaKeyRef), this._removeAllSchemas(this.refs, schemaKeyRef), this;
        switch (typeof schemaKeyRef) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            let sch = getSchEnv.call(this, schemaKeyRef);
            return typeof sch == "object" && this._cache.delete(sch.schema), delete this.schemas[schemaKeyRef], delete this.refs[schemaKeyRef], this;
          }
          case "object": {
            let cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            return id && (id = (0, resolve_1.normalizeId)(id), delete this.schemas[id], delete this.refs[id]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (let def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string")
          keyword = kwdOrDef, typeof def == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), def.keyword = keyword);
        else if (typeof kwdOrDef == "object" && def === void 0) {
          if (def = kwdOrDef, keyword = def.keyword, Array.isArray(keyword) && !keyword.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (checkKeyword.call(this, keyword, def), !def)
          return (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd)), this;
        keywordMetaschema.call(this, def);
        let definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        return (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))), this;
      }
      getKeyword(keyword) {
        let rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        let { RULES } = this;
        delete RULES.keywords[keyword], delete RULES.all[keyword];
        for (let group of RULES.rules) {
          let i = group.rules.findIndex((rule) => rule.keyword === keyword);
          i >= 0 && group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        return typeof format == "string" && (format = new RegExp(format)), this.formats[name] = format, this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        return !errors || errors.length === 0 ? "No errors" : errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        let rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (let jsonPointer of keywordsJsonPointers) {
          let segments = jsonPointer.split("/").slice(1), keywords = metaSchema;
          for (let seg of segments)
            keywords = keywords[seg];
          for (let key in rules) {
            let rule = rules[key];
            if (typeof rule != "object")
              continue;
            let { $data } = rule.definition, schema = keywords[key];
            $data && schema && (keywords[key] = schemaOrData(schema));
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (let keyRef in schemas) {
          let sch = schemas[keyRef];
          (!regex || regex.test(keyRef)) && (typeof sch == "string" ? delete schemas[keyRef] : sch && !sch.meta && (this._cache.delete(sch.schema), delete schemas[keyRef]));
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id, { schemaId } = this.opts;
        if (typeof schema == "object")
          id = schema[schemaId];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        let localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        return sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs }), this._cache.set(sch.schema, sch), addSchema && !baseId.startsWith("#") && (baseId && this._checkUnique(baseId), this.refs[baseId] = sch), validateSchema && this.validateSchema(schema, !0), sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id])
          throw new Error(`schema with key or id "${id}" already exists`);
      }
      _compileSchemaEnv(sch) {
        if (sch.meta ? this._compileMetaSchema(sch) : compile_1.compileSchema.call(this, sch), !sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        let currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (let key in checkOpts) {
        let opt = key;
        opt in options && this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      return keyRef = (0, resolve_1.normalizeId)(keyRef), this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      let optsSchemas = this.opts.schemas;
      if (optsSchemas)
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (let key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (let name in this.opts.formats) {
        let format = this.opts.formats[name];
        format && this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let keyword in defs) {
        let def = defs[keyword];
        def.keyword || (def.keyword = keyword), this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      let metaOpts = { ...this.opts };
      for (let opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === !1)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      let { RULES } = this;
      if ((0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      }), !!def && def.$data && !("code" in def || "validate" in def))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      let post = definition?.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      let { RULES } = this, ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (ruleGroup || (ruleGroup = { type: dataType, rules: [] }, RULES.rules.push(ruleGroup)), RULES.keywords[keyword] = !0, !definition)
        return;
      let rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      definition.before ? addBeforeRule.call(this, ruleGroup, rule, definition.before) : ruleGroup.rules.push(rule), RULES.all[keyword] = rule, (_a = definition.implements) === null || _a === void 0 || _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      let i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      i >= 0 ? ruleGroup.rules.splice(i, 0, rule) : (ruleGroup.rules.push(rule), this.logger.warn(`rule ${before} is not defined`));
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      metaSchema !== void 0 && (def.$data && this.opts.$data && (metaSchema = schemaOrData(metaSchema)), def.validateSchema = this.compile(metaSchema, !0));
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error(), code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), compile_1 = require_compile(), util_1 = require_util(), def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        let { gen, schema: $ref, it } = cxt, { baseId, schemaEnv: env, validateName, opts, self } = it, { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        let schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          let rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          let v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          let schName = gen.scopeValue("schema", opts.code.source === !0 ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch }), valid = gen.name("valid"), schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt), cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      let { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      let { gen, it } = cxt, { allErrors, schemaEnv: env, opts } = it, passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      $async ? callAsyncRef() : callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        let valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`), addEvaluatedFrom(v), allErrors || gen.assign(valid, !0);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e)), addErrorsFrom(e), allErrors || gen.assign(valid, !1);
        }), cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        let errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`), gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        let schEvaluated = (_a = sch?.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== !0)
          if (schEvaluated && !schEvaluated.dynamicProps)
            schEvaluated.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props));
          else {
            let props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        if (it.items !== !0)
          if (schEvaluated && !schEvaluated.dynamicItems)
            schEvaluated.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items));
          else {
            let items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var id_1 = require_id(), ref_1 = require_ref(), core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    }, def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: !0,
      error,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    }, def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error,
      code(cxt) {
        let { gen, data, schemaCode, it } = cxt, prec = it.opts.multipleOfPrecision, res = gen.let("res"), invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function ucs2length(str) {
      let len = str.length, length = 0, pos = 0, value;
      for (; pos < len; )
        length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), (value & 64512) === 56320 && pos++);
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), ucs2length_1 = require_ucs2length(), error = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error,
      code(cxt) {
        let { keyword, data, schemaCode, it } = cxt, op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT, len = it.opts.unicode === !1 ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    }, def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error,
      code(cxt) {
        let { data, $data, schema, schemaCode, it } = cxt, u = it.opts.unicodeRegExp ? "u" : "", regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    }, def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error,
      code(cxt) {
        let { gen, schema, schemaCode, data, $data, it } = cxt, { opts } = it;
        if (!$data && schema.length === 0)
          return;
        let useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors ? allErrorsMode() : exitOnErrorMode(), opts.strictRequired) {
          let props = cxt.parentSchema.properties, { definedProperties } = cxt.it;
          for (let requiredKey of schema)
            if (props?.[requiredKey] === void 0 && !definedProperties.has(requiredKey)) {
              let schemaPath = it.schemaEnv.baseId + it.errSchemaPath, msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
        }
        function allErrorsMode() {
          if (useLoop || $data)
            cxt.block$data(codegen_1.nil, loopAllRequired);
          else
            for (let prop of schema)
              (0, code_1.checkReportMissingProp)(cxt, prop);
        }
        function exitOnErrorMode() {
          let missing = gen.let("missing");
          if (useLoop || $data) {
            let valid = gen.let("valid", !0);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid)), cxt.ok(valid);
          } else
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing)), (0, code_1.reportMissingProp)(cxt, missing), gen.else();
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop }), gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing }), gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties)), gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(), gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var dataType_1 = require_dataType(), codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    }, def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error,
      code(cxt) {
        let { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        let valid = gen.let("valid"), itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`), cxt.ok(valid);
        function validateUniqueItems() {
          let i = gen.let("i", (0, codegen_1._)`${data}.length`), j = gen.let("j");
          cxt.setParams({ i, j }), gen.assign(valid, !0), gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          let item = gen.name("item"), wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong), indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`), gen.if(wrongType, (0, codegen_1._)`continue`), itemTypes.length > 1 && gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`), gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`), cxt.error(), gen.assign(valid, !1).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          let eql = (0, util_1.useFunc)(gen, equal_1.default), outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error(), gen.assign(valid, !1).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    }, def = {
      keyword: "const",
      $data: !0,
      error,
      code(cxt) {
        let { gen, data, $data, schemaCode, schema } = cxt;
        $data || schema && typeof schema == "object" ? cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`) : cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    }, def = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error,
      code(cxt) {
        let { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        let useLoop = schema.length >= it.opts.loopEnum, eql, getEql = () => eql ?? (eql = (0, util_1.useFunc)(gen, equal_1.default)), valid;
        if (useLoop || $data)
          valid = gen.let("valid"), cxt.block$data(valid, loopEnum);
        else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          let vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, !1), gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, !0).break()));
        }
        function equalCode(vSchema, i) {
          let sch = schema[i];
          return typeof sch == "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var limitNumber_1 = require_limitNumber(), multipleOf_1 = require_multipleOf(), limitLength_1 = require_limitLength(), pattern_1 = require_pattern(), limitProperties_1 = require_limitProperties(), required_1 = require_required(), limitItems_1 = require_limitItems(), uniqueItems_1 = require_uniqueItems(), const_1 = require_const(), enum_1 = require_enum(), validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        let { parentSchema, it } = cxt, { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      let { gen, schema, data, keyword, it } = cxt;
      it.items = !0;
      let len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === !1)
        cxt.setParams({ len: items.length }), cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        let valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid)), cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid), it.allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        let { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      let { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema), it.opts.unevaluated && schArr.length && it.items !== !0 && (it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items));
      let valid = gen.name("valid"), len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        (0, util_1.alwaysValidSchema)(it, sch) || (gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid)), cxt.ok(valid));
      });
      function checkStrictTuple(sch) {
        let { opts, errSchemaPath } = it, l = schArr.length, fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === !1);
        if (opts.strictTuples && !fullTuple) {
          let msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var items_1 = require_items(), def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), additionalItems_1 = require_additionalItems(), error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        let { schema, parentSchema, it } = cxt, { prefixItems } = parentSchema;
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && (prefixItems ? (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems) : cxt.ok((0, code_1.validateArray)(cxt)));
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    }, def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error,
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt, min, max, { minContains, maxContains } = parentSchema;
        it.opts.next ? (min = minContains === void 0 ? 1 : minContains, max = maxContains) : min = 1;
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (cxt.setParams({ min, max }), max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid'), cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          max !== void 0 && (cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`), cxt.pass(cond);
          return;
        }
        it.items = !0;
        let valid = gen.name("valid");
        max === void 0 && min === 1 ? validateItems(valid, () => gen.if(valid, () => gen.break())) : min === 0 ? (gen.let(valid, !0), max !== void 0 && gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount)) : (gen.let(valid, !1), validateItemsWithCount()), cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          let schValid = gen.name("_valid"), count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: !0
            }, _valid), block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`), max === void 0 ? gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0).break()) : (gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, !1).break()), min === 1 ? gen.assign(valid, !0) : gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0)));
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        let property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        let [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps), validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      let propertyDeps = {}, schemaDeps = {};
      for (let key in schema) {
        if (key === "__proto__")
          continue;
        let deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      let { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      let missing = gen.let("missing");
      for (let prop in propertyDeps) {
        let deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        let hasProperty2 = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        }), it.allErrors ? gen.if(hasProperty2, () => {
          for (let depProp of deps)
            (0, code_1.checkReportMissingProp)(cxt, depProp);
        }) : (gen.if((0, codegen_1._)`${hasProperty2} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`), (0, code_1.reportMissingProp)(cxt, missing), gen.else());
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      for (let prop in schemaDeps)
        (0, util_1.alwaysValidSchema)(it, schemaDeps[prop]) || (gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            let schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, !0)
          // TODO var
        ), cxt.ok(valid));
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    }, def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        let { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        let valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key }), cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: !0
          }, valid), gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(!0), it.allErrors || gen.break();
          });
        }), cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), util_1 = require_util(), error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    }, def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error,
      code(cxt) {
        let { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        let { allErrors, opts } = it;
        if (it.props = !0, opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        let props = (0, code_1.allSchemaProperties)(parentSchema.properties), patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties(), cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            !props.length && !patProps.length ? additionalPropertyCode(key) : gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            let propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else props.length ? definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`)) : definedProp = codegen_1.nil;
          return patProps.length && (definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`))), (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === !1) {
            deleteAdditional(key);
            return;
          }
          if (schema === !1) {
            cxt.setParams({ additionalProperty: key }), cxt.error(), allErrors || gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            let valid = gen.name("valid");
            opts.removeAdditional === "failing" ? (applyAdditionalSchema(key, valid, !1), gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset(), deleteAdditional(key);
            })) : (applyAdditionalSchema(key, valid), allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break()));
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          let subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          errors === !1 && Object.assign(subschema, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var validate_1 = require_validate(), code_1 = require_code2(), util_1 = require_util(), additionalProperties_1 = require_additionalProperties(), def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt;
        it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0 && additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        let allProps = (0, code_1.allSchemaProperties)(schema);
        for (let prop of allProps)
          it.definedProperties.add(prop);
        it.opts.unevaluated && allProps.length && it.props !== !0 && (it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props));
        let properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        let valid = gen.name("valid");
        for (let prop of properties)
          hasDefault(prop) ? applyPropertySchema(prop) : (gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)), applyPropertySchema(prop), it.allErrors || gen.else().var(valid, !0), gen.endIf()), cxt.it.definedProperties.add(prop), cxt.ok(valid);
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), util_2 = require_util(), def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, data, parentSchema, it } = cxt, { opts } = it, patterns = (0, code_1.allSchemaProperties)(schema), alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === !0))
          return;
        let checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties, valid = gen.name("valid");
        it.props !== !0 && !(it.props instanceof codegen_1.Name) && (it.props = (0, util_2.evaluatedPropsToName)(gen, it.props));
        let { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (let pat of patterns)
            checkProperties && checkMatchingProperties(pat), it.allErrors ? validateProperties(pat) : (gen.var(valid, !0), validateProperties(pat), gen.if(valid));
        }
        function checkMatchingProperties(pat) {
          for (let prop in checkProperties)
            new RegExp(pat).test(prop) && (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              let alwaysValid = alwaysValidPatterns.includes(pat);
              alwaysValid || cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid), it.opts.unevaluated && props !== !0 ? gen.assign((0, codegen_1._)`${props}[${key}]`, !0) : !alwaysValid && !it.allErrors && gen.if((0, codegen_1.not)(valid), () => gen.break());
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(cxt) {
        let { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        let valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, valid), cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    }, def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error,
      code(cxt) {
        let { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        let schArr = schema, valid = gen.let("valid", !1), passing = gen.let("passing", null), schValid = gen.name("_valid");
        cxt.setParams({ passing }), gen.block(validateOneOf), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            (0, util_1.alwaysValidSchema)(it, sch) ? gen.var(schValid, !0) : schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: !0
            }, schValid), i > 0 && gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, !1).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else(), gen.if(schValid, () => {
              gen.assign(valid, !0), gen.assign(passing, i), schCxt && cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        let { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        let valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          let schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid), cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    }, def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error,
      code(cxt) {
        let { gen, parentSchema, it } = cxt;
        parentSchema.then === void 0 && parentSchema.else === void 0 && (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        let hasThen = hasSchema(it, "then"), hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        let valid = gen.let("valid", !0), schValid = gen.name("_valid");
        if (validateIf(), cxt.reset(), hasThen && hasElse) {
          let ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause }), gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else hasThen ? gen.if(schValid, validateClause("then")) : gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        cxt.pass(valid, () => cxt.error(!0));
        function validateIf() {
          let schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            let schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid), cxt.mergeValidEvaluated(schCxt, valid), ifClause ? gen.assign(ifClause, (0, codegen_1._)`${keyword}`) : cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      let schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        parentSchema.if === void 0 && (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var additionalItems_1 = require_additionalItems(), prefixItems_1 = require_prefixItems(), items_1 = require_items(), items2020_1 = require_items2020(), contains_1 = require_contains(), dependencies_1 = require_dependencies(), propertyNames_1 = require_propertyNames(), additionalProperties_1 = require_additionalProperties(), properties_1 = require_properties(), patternProperties_1 = require_patternProperties(), not_1 = require_not(), anyOf_1 = require_anyOf(), oneOf_1 = require_oneOf(), allOf_1 = require_allOf(), if_1 = require_if(), thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = !1) {
      let applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      return draft2020 ? applicator.push(prefixItems_1.default, items2020_1.default) : applicator.push(additionalItems_1.default, items_1.default), applicator.push(contains_1.default), applicator;
    }
    exports.default = getApplicator;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    }, def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error,
      code(cxt, ruleType) {
        let { gen, data, $data, schema, schemaCode, it } = cxt, { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        $data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`), fType = gen.let("fType"), format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)), cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            return opts.strictSchema === !1 ? codegen_1.nil : (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            let callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`, validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          let formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === !0)
            return;
          let [fmtType, format, fmtRef] = getFormat(formatDef);
          fmtType === ruleType && cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === !1) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            let code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0, fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            return typeof fmtDef == "object" && !(fmtDef instanceof RegExp) ? [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`] : ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var format_1 = require_format(), format = [format_1.default];
    exports.default = format;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var core_1 = require_core2(), validation_1 = require_validation(), applicator_1 = require_applicator(), format_1 = require_format2(), metadata_1 = require_metadata(), draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2.Tag = "tag", DiscrError2.Mapping = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), types_1 = require_types(), compile_1 = require_compile(), ref_error_1 = require_ref_error(), util_1 = require_util(), error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    }, def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        let { gen, data, schema, parentSchema, it } = cxt, { oneOf } = parentSchema;
        if (!it.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        let tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        let valid = gen.let("valid", !1), tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(!1, { discrError: types_1.DiscrError.Tag, tag, tagName })), cxt.ok(valid);
        function validateMapping() {
          let mapping = getMapping();
          gen.if(!1);
          for (let tagValue in mapping)
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`), gen.assign(valid, applyTagSchema(mapping[tagValue]));
          gen.else(), cxt.error(!1, { discrError: types_1.DiscrError.Mapping, tag, tagName }), gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          let _valid = gen.name("valid"), schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          return cxt.mergeEvaluated(schCxt, codegen_1.Name), _valid;
        }
        function getMapping() {
          var _a;
          let oneOfMapping = {}, topRequired = hasRequired(parentSchema), tagRequired = !0;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (sch?.$ref && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              let ref = sch.$ref;
              if (sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref), sch instanceof compile_1.SchemaEnv && (sch = sch.schema), sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            let propSch = (_a = sch?.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            tagRequired = tagRequired && (topRequired || hasRequired(sch)), addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const)
              addMapping(sch.const, i);
            else if (sch.enum)
              for (let tagValue of sch.enum)
                addMapping(tagValue, i);
            else
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping)
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: !0,
        readOnly: {
          type: "boolean",
          default: !1
        },
        examples: {
          type: "array",
          items: !0
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: !1
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: {
          type: "array",
          items: !0,
          minItems: 1,
          uniqueItems: !0
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: !0
    };
  }
});

// ../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core(), draft7_1 = require_draft7(), discriminator_1 = require_discriminator(), draft7MetaSchema = require_json_schema_draft_07(), META_SUPPORT_DATA = ["/properties"], META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies(), draft7_1.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        let metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, !1), this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: !0, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: !0, get: function() {
      return ref_error_1.default;
    } });
  }
});

// ../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      let matches = DATE.exec(str);
      if (!matches)
        return !1;
      let year = +matches[1], month = +matches[2], day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (d1 && d2)
        return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      let matches = TIME.exec(str);
      if (!matches)
        return !1;
      let hour = +matches[1], minute = +matches[2], second = +matches[3], timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2))
        return;
      let a1 = TIME.exec(t1), a2 = TIME.exec(t2);
      if (a1 && a2)
        return t1 = a1[1] + a1[2] + a1[3] + (a1[4] || ""), t2 = a2[1] + a2[2] + a2[3] + (a2[4] || ""), t1 > t2 ? 1 : t1 < t2 ? -1 : 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      let dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], !0);
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let [d1, t1] = dt1.split(DATE_TIME_SEPARATOR), [d2, t2] = dt2.split(DATE_TIME_SEPARATOR), res = compareDate(d1, d2);
      if (res !== void 0)
        return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      return BYTE.lastIndex = 0, BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31), MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return !0;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return !1;
      try {
        return new RegExp(str), !0;
      } catch {
        return !1;
      }
    }
  }
});

// ../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv(), codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error = {
      message: ({ keyword, schemaCode }) => codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: !0,
      error,
      code(cxt) {
        let { gen, data, schemaCode, keyword, it } = cxt, { opts, self } = it;
        if (!opts.validateFormats)
          return;
        let fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        fCxt.$data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          let format = fCxt.schema, fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === !0)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function")
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          let fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => (ajv.addKeyword(exports.formatLimitDefinition), ajv);
    exports.default = formatLimitPlugin;
  }
});

// ../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.17.1/node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formats_1 = require_formats(), limit_1 = require_limit(), codegen_1 = require_codegen(), fullName = new codegen_1.Name("fullFormats"), fastName = new codegen_1.Name("fastFormats"), formatsPlugin = (ajv, opts = { keywords: !0 }) => {
      if (Array.isArray(opts))
        return addFormats(ajv, opts, formats_1.fullFormats, fullName), ajv;
      let [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName], list = opts.formats || formats_1.formatNames;
      return addFormats(ajv, list, formats, exportName), opts.keywords && limit_1.default(ajv), ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      let f = (mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats)[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs3, exportName) {
      var _a, _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 || (_b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`);
      for (let f of list)
        ajv.addFormat(f, fs3[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.default = formatsPlugin;
  }
});

// ../../node_modules/.pnpm/defer-to-connect@2.0.1/node_modules/defer-to-connect/dist/source/index.js
var require_source = __commonJS({
  "../../node_modules/.pnpm/defer-to-connect@2.0.1/node_modules/defer-to-connect/dist/source/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function isTLSSocket(socket) {
      return socket.encrypted;
    }
    var deferToConnect2 = (socket, fn) => {
      let listeners;
      typeof fn == "function" ? listeners = { connect: fn } : listeners = fn;
      let hasConnectListener = typeof listeners.connect == "function", hasSecureConnectListener = typeof listeners.secureConnect == "function", hasCloseListener = typeof listeners.close == "function", onConnect = () => {
        hasConnectListener && listeners.connect(), isTLSSocket(socket) && hasSecureConnectListener && (socket.authorized ? listeners.secureConnect() : socket.authorizationError || socket.once("secureConnect", listeners.secureConnect)), hasCloseListener && socket.once("close", listeners.close);
      };
      socket.writable && !socket.connecting ? onConnect() : socket.connecting ? socket.once("connect", onConnect) : socket.destroyed && hasCloseListener && listeners.close(socket._hadError);
    };
    exports.default = deferToConnect2;
    module.exports = deferToConnect2;
    module.exports.default = deferToConnect2;
  }
});

// ../../node_modules/.pnpm/http-cache-semantics@4.2.0/node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "../../node_modules/.pnpm/http-cache-semantics@4.2.0/node_modules/http-cache-semantics/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var statusCodeCacheableByDefault = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ]), understoodStatuses = /* @__PURE__ */ new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]), errorStatusCodes = /* @__PURE__ */ new Set([
      500,
      502,
      503,
      504
    ]), hopByHopHeaders = {
      date: !0,
      // included, because we add Age update Date
      connection: !0,
      "keep-alive": !0,
      "proxy-authenticate": !0,
      "proxy-authorization": !0,
      te: !0,
      trailer: !0,
      "transfer-encoding": !0,
      upgrade: !0
    }, excludedFromRevalidationUpdate = {
      // Since the old body is reused, it doesn't make sense to change properties of the body
      "content-length": !0,
      "content-encoding": !0,
      "transfer-encoding": !0,
      "content-range": !0
    };
    function toNumberOrZero(s) {
      let n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response) {
      return response ? errorStatusCodes.has(response.status) : !0;
    }
    function parseCacheControl(header) {
      let cc = {};
      if (!header) return cc;
      let parts = header.trim().split(/,/);
      for (let part of parts) {
        let [k, v] = part.split(/=/, 2);
        cc[k.trim()] = v === void 0 ? !0 : v.trim().replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (let k in cc) {
        let v = cc[k];
        parts.push(v === !0 ? k : k + "=" + v);
      }
      if (parts.length)
        return parts.join(", ");
    }
    module.exports = class {
      /**
       * Creates a new CachePolicy instance.
       * @param {HttpRequest} req - Incoming client request.
       * @param {HttpResponse} res - Received server response.
       * @param {Object} [options={}] - Configuration options.
       * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.
       * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.
       * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.
       * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.
       * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.
       */
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers)
          throw Error("Response headers missing");
        this._assertRequestHasHeaders(req), this._responseTime = this.now(), this._isShared = shared !== !1, this._ignoreCargoCult = !!ignoreCargoCult, this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : 0.1, this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3, this._status = "status" in res ? res.status : 200, this._resHeaders = res.headers, this._rescc = parseCacheControl(res.headers["cache-control"]), this._method = "method" in req ? req.method : "GET", this._url = req.url, this._host = req.headers.host, this._noAuthorization = !req.headers.authorization, this._reqHeaders = res.headers.vary ? req.headers : null, this._reqcc = parseCacheControl(req.headers["cache-control"]), this._ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc && (delete this._rescc["pre-check"], delete this._rescc["post-check"], delete this._rescc["no-cache"], delete this._rescc["no-store"], delete this._rescc["must-revalidate"], this._resHeaders = Object.assign({}, this._resHeaders, {
          "cache-control": formatCacheControl(this._rescc)
        }), delete this._resHeaders.expires, delete this._resHeaders.pragma), res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma) && (this._rescc["no-cache"] = !0);
      }
      /**
       * You can monkey-patch it for testing.
       * @returns {number} Current time in milliseconds.
       */
      now() {
        return Date.now();
      }
      /**
       * Determines if the response is storable in a cache.
       * @returns {boolean} `false` if can never be cached.
       */
      storable() {
        return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
        // The request method is understood by the cache and defined as being cacheable, and
        (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
        understoodStatuses.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
        !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
        (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
        (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
        // contains an Expires header field, or
        (this._resHeaders.expires || // contains a max-age response directive, or
        // contains a s-maxage response directive and the cache is shared, or
        // contains a public response directive.
        this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
        statusCodeCacheableByDefault.has(this._status)));
      }
      /**
       * @returns {boolean} true if expiration is explicitly defined.
       */
      _hasExplicitExpiration() {
        return !!(this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires);
      }
      /**
       * @param {HttpRequest} req - a request
       * @throws {Error} if the headers are missing.
       */
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers)
          throw Error("Request headers missing");
      }
      /**
       * Checks if the request matches the cache and can be satisfied from the cache immediately,
       * without having to make a request to the server.
       *
       * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.
       *
       * @param {HttpRequest} req - The new incoming HTTP request.
       * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.
       */
      satisfiesWithoutRevalidation(req) {
        return !this.evaluateRequest(req).revalidation;
      }
      /**
       * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.
       * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.
       */
      _evaluateRequestHitResult(revalidation) {
        return {
          response: {
            headers: this.responseHeaders()
          },
          revalidation
        };
      }
      /**
       * @param {HttpRequest} request - new incoming
       * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).
       * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.
       */
      _evaluateRequestRevalidation(request, synchronous) {
        return {
          synchronous,
          headers: this.revalidationHeaders(request)
        };
      }
      /**
       * @param {HttpRequest} request - new incoming
       * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.
       */
      _evaluateRequestMissResult(request) {
        return {
          response: void 0,
          revalidation: this._evaluateRequestRevalidation(request, !0)
        };
      }
      /**
       * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:
       *
       * ```
       * {
       *     // If defined, you must send a request to the server.
       *     revalidation: {
       *         headers: {}, // HTTP headers to use when sending the revalidation response
       *         // If true, you MUST wait for a response from the server before using the cache
       *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.
       *         synchronous: bool,
       *     },
       *     // If defined, you can use this cached response.
       *     response: {
       *         headers: {}, // Updated cached HTTP headers you must use when responding to the client
       *     },
       * }
       * ```
       * @param {HttpRequest} req - new incoming HTTP request
       * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:
       *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server
       *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers
       */
      evaluateRequest(req) {
        if (this._assertRequestHasHeaders(req), this._rescc["must-revalidate"])
          return this._evaluateRequestMissResult(req);
        if (!this._requestMatches(req, !1))
          return this._evaluateRequestMissResult(req);
        let requestCC = parseCacheControl(req.headers["cache-control"]);
        return requestCC["no-cache"] || /no-cache/.test(req.headers.pragma) ? this._evaluateRequestMissResult(req) : requestCC["max-age"] && this.age() > toNumberOrZero(requestCC["max-age"]) ? this._evaluateRequestMissResult(req) : requestCC["min-fresh"] && this.maxAge() - this.age() < toNumberOrZero(requestCC["min-fresh"]) ? this._evaluateRequestMissResult(req) : this.stale() ? "max-stale" in requestCC && (requestCC["max-stale"] === !0 || requestCC["max-stale"] > this.age() - this.maxAge()) ? this._evaluateRequestHitResult(void 0) : this.useStaleWhileRevalidate() ? this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, !1)) : this._evaluateRequestMissResult(req) : this._evaluateRequestHitResult(void 0);
      }
      /**
       * @param {HttpRequest} req - check if this is for the same cache entry
       * @param {boolean} allowHeadMethod - allow a HEAD method to match.
       * @returns {boolean} `true` if the request matches.
       */
      _requestMatches(req, allowHeadMethod) {
        return !!((!this._url || this._url === req.url) && this._host === req.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
        (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && // selecting header fields nominated by the stored response (if any) match those presented, and
        this._varyMatches(req));
      }
      /**
       * Determines whether storing authenticated responses is allowed.
       * @returns {boolean} `true` if allowed.
       */
      _allowsStoringAuthenticated() {
        return !!(this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"]);
      }
      /**
       * Checks whether the Vary header in the response matches the new request.
       * @param {HttpRequest} req - incoming HTTP request
       * @returns {boolean} `true` if the vary headers match.
       */
      _varyMatches(req) {
        if (!this._resHeaders.vary)
          return !0;
        if (this._resHeaders.vary === "*")
          return !1;
        let fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (let name of fields)
          if (req.headers[name] !== this._reqHeaders[name]) return !1;
        return !0;
      }
      /**
       * Creates a copy of the given headers without any hop-by-hop headers.
       * @param {Record<string, string>} inHeaders - old headers from the cached response
       * @returns {Record<string, string>} A new headers object without hop-by-hop headers.
       */
      _copyWithoutHopByHopHeaders(inHeaders) {
        let headers = {};
        for (let name in inHeaders)
          hopByHopHeaders[name] || (headers[name] = inHeaders[name]);
        if (inHeaders.connection) {
          let tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (let name of tokens)
            delete headers[name];
        }
        if (headers.warning) {
          let warnings = headers.warning.split(/,/).filter((warning) => !/^\s*1[0-9][0-9]/.test(warning));
          warnings.length ? headers.warning = warnings.join(",").trim() : delete headers.warning;
        }
        return headers;
      }
      /**
       * Returns the response headers adjusted for serving the cached response.
       * Removes hop-by-hop headers and updates the Age and Date headers.
       * @returns {Record<string, string>} The adjusted response headers.
       */
      responseHeaders() {
        let headers = this._copyWithoutHopByHopHeaders(this._resHeaders), age = this.age();
        return age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24 && (headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"'), headers.age = `${Math.round(age)}`, headers.date = new Date(this.now()).toUTCString(), headers;
      }
      /**
       * Returns the Date header value from the response or the current time if invalid.
       * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.
       */
      date() {
        let serverDate = Date.parse(this._resHeaders.date);
        return isFinite(serverDate) ? serverDate : this._responseTime;
      }
      /**
       * Value of the Age header, in seconds, updated for the current time.
       * May be fractional.
       * @returns {number} The age in seconds.
       */
      age() {
        let age = this._ageValue(), residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      /**
       * @returns {number} The Age header value as a number.
       */
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      /**
       * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.
       * This counts since response's `Date`.
       *
       * For an up-to-date value, see `timeToLive()`.
       *
       * Returns the maximum age (freshness lifetime) of the response in seconds.
       * @returns {number} The max-age value in seconds.
       */
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"] || this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable || this._resHeaders.vary === "*")
          return 0;
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"])
            return 0;
          if (this._rescc["s-maxage"])
            return toNumberOrZero(this._rescc["s-maxage"]);
        }
        if (this._rescc["max-age"])
          return toNumberOrZero(this._rescc["max-age"]);
        let defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0, serverDate = this.date();
        if (this._resHeaders.expires) {
          let expires = Date.parse(this._resHeaders.expires);
          return Number.isNaN(expires) || expires < serverDate ? 0 : Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          let lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified)
            return Math.max(
              defaultMinTtl,
              (serverDate - lastModified) / 1e3 * this._cacheHeuristic
            );
        }
        return defaultMinTtl;
      }
      /**
       * Remaining time this cache entry may be useful for, in *milliseconds*.
       * You can use this as an expiration time for your cache storage.
       *
       * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.
       * @returns {number} Time-to-live in milliseconds.
       */
      timeToLive() {
        let age = this.maxAge() - this.age(), staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]), staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3);
      }
      /**
       * If true, this cache entry is past its expiration date.
       * Note that stale cache may be useful sometimes, see `evaluateRequest()`.
       * @returns {boolean} `false` doesn't mean it's fresh nor usable
       */
      stale() {
        return this.maxAge() <= this.age();
      }
      /**
       * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.
       */
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      /** See `evaluateRequest()` for a more complete solution
       * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.
       */
      useStaleWhileRevalidate() {
        let swr = toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return swr > 0 && this.maxAge() + swr > this.age();
      }
      /**
       * Creates a `CachePolicy` instance from a serialized object.
       * @param {Object} obj - The serialized object.
       * @returns {CachePolicy} A new CachePolicy instance.
       */
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      /**
       * @param {any} obj - The serialized object.
       * @throws {Error} If already initialized or if the object is invalid.
       */
      _fromObject(obj) {
        if (this._responseTime) throw Error("Reinitialized");
        if (!obj || obj.v !== 1) throw Error("Invalid serialization");
        this._responseTime = obj.t, this._isShared = obj.sh, this._cacheHeuristic = obj.ch, this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3, this._ignoreCargoCult = !!obj.icc, this._status = obj.st, this._resHeaders = obj.resh, this._rescc = obj.rescc, this._method = obj.m, this._url = obj.u, this._host = obj.h, this._noAuthorization = obj.a, this._reqHeaders = obj.reqh, this._reqcc = obj.reqcc;
      }
      /**
       * Serializes the `CachePolicy` instance into a JSON-serializable object.
       * @returns {Object} The serialized object.
       */
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          icc: this._ignoreCargoCult,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      /**
       * Headers for sending to the origin server to revalidate stale response.
       * Allows server to return 304 to allow reuse of the previous response.
       *
       * Hop by hop headers are always stripped.
       * Revalidation headers may be added or removed, depending on request.
       * @param {HttpRequest} incomingReq - The incoming HTTP request.
       * @returns {Record<string, string>} The headers for the revalidation request.
       */
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        let headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        if (delete headers["if-range"], !this._requestMatches(incomingReq, !0) || !this.storable())
          return delete headers["if-none-match"], delete headers["if-modified-since"], headers;
        if (this._resHeaders.etag && (headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag), headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET") {
          if (delete headers["if-modified-since"], headers["if-none-match"]) {
            let etags = headers["if-none-match"].split(/,/).filter((etag) => !/^\s*W\//.test(etag));
            etags.length ? headers["if-none-match"] = etags.join(",").trim() : delete headers["if-none-match"];
          }
        } else this._resHeaders["last-modified"] && !headers["if-modified-since"] && (headers["if-modified-since"] = this._resHeaders["last-modified"]);
        return headers;
      }
      /**
       * Creates new CachePolicy with information combined from the previews response,
       * and the new revalidation response.
       *
       * Returns {policy, modified} where modified is a boolean indicating
       * whether the response body has been modified, and old cached body can't be used.
       *
       * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.
       * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.
       * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.
       * @throws {Error} If the response headers are missing.
       */
      revalidatedPolicy(request, response) {
        if (this._assertRequestHasHeaders(request), this._useStaleIfError() && isErrorResponse(response))
          return {
            policy: this,
            modified: !1,
            matches: !0
          };
        if (!response || !response.headers)
          throw Error("Response headers missing");
        let matches = !1;
        response.status !== void 0 && response.status != 304 ? matches = !1 : response.headers.etag && !/^\s*W\//.test(response.headers.etag) ? matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag : this._resHeaders.etag && response.headers.etag ? matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "") : this._resHeaders["last-modified"] ? matches = this._resHeaders["last-modified"] === response.headers["last-modified"] : !this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"] && (matches = !0);
        let optionsCopy = {
          shared: this._isShared,
          cacheHeuristic: this._cacheHeuristic,
          immutableMinTimeToLive: this._immutableMinTtl,
          ignoreCargoCult: this._ignoreCargoCult
        };
        if (!matches)
          return {
            policy: new this.constructor(request, response, optionsCopy),
            // Client receiving 304 without body, even if it's invalid/mismatched has no option
            // but to reuse a cached body. We don't have a good way to tell clients to do
            // error recovery in such case.
            modified: response.status != 304,
            matches: !1
          };
        let headers = {};
        for (let k in this._resHeaders)
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        let newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse, optionsCopy),
          modified: !1,
          matches: !0
        };
      }
    };
  }
});

// ../../node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "../../node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js"(exports) {
    init_cjs_shims();
    exports.stringify = function stringify(o) {
      if (typeof o > "u") return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON && (o = o.toJSON()), o && typeof o == "object") {
        var s = "", array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = !0;
        for (var k in o) {
          var ignore = typeof o[k] == "function" || !array && typeof o[k] > "u";
          Object.hasOwnProperty.call(o, k) && !ignore && (first || (s += ","), first = !1, array ? o[k] == null ? s += "null" : s += stringify(o[k]) : o[k] !== void 0 && (s += stringify(k) + ":" + stringify(o[k])));
        }
        return s += array ? "]" : "}", s;
      } else return typeof o == "string" ? JSON.stringify(/^:/.test(o) ? ":" + o : o) : typeof o > "u" ? "null" : JSON.stringify(o);
    };
    exports.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        return typeof value == "string" ? /^:base64:/.test(value) ? Buffer.from(value.substring(8), "base64") : /^:/.test(value) ? value.substring(1) : value : value;
      });
    };
  }
});

// ../../node_modules/.pnpm/keyv@4.5.4/node_modules/keyv/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/keyv@4.5.4/node_modules/keyv/src/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var EventEmitter4 = __require("events"), JSONB = require_json_buffer(), loadStore = (options) => {
      let adapters = {
        redis: "@keyv/redis",
        rediss: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql",
        etcd: "@keyv/etcd",
        offline: "@keyv/offline",
        tiered: "@keyv/tiered"
      };
      if (options.adapter || options.uri) {
        let adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];
        return new (__require(adapters[adapter]))(options);
      }
      return /* @__PURE__ */ new Map();
    }, iterableAdapters = [
      "sqlite",
      "postgres",
      "mysql",
      "mongo",
      "redis",
      "tiered"
    ], Keyv2 = class extends EventEmitter4 {
      constructor(uri, { emitErrors = !0, ...options } = {}) {
        if (super(), this.opts = {
          namespace: "keyv",
          serialize: JSONB.stringify,
          deserialize: JSONB.parse,
          ...typeof uri == "string" ? { uri } : uri,
          ...options
        }, !this.opts.store) {
          let adapterOptions = { ...this.opts };
          this.opts.store = loadStore(adapterOptions);
        }
        if (this.opts.compression) {
          let compression = this.opts.compression;
          this.opts.serialize = compression.serialize.bind(compression), this.opts.deserialize = compression.deserialize.bind(compression);
        }
        typeof this.opts.store.on == "function" && emitErrors && this.opts.store.on("error", (error) => this.emit("error", error)), this.opts.store.namespace = this.opts.namespace;
        let generateIterator = (iterator) => async function* () {
          for await (let [key, raw] of typeof iterator == "function" ? iterator(this.opts.store.namespace) : iterator) {
            let data = await this.opts.deserialize(raw);
            if (!(this.opts.store.namespace && !key.includes(this.opts.store.namespace))) {
              if (typeof data.expires == "number" && Date.now() > data.expires) {
                this.delete(key);
                continue;
              }
              yield [this._getKeyUnprefix(key), data.value];
            }
          }
        };
        typeof this.opts.store[Symbol.iterator] == "function" && this.opts.store instanceof Map ? this.iterator = generateIterator(this.opts.store) : typeof this.opts.store.iterator == "function" && this.opts.store.opts && this._checkIterableAdaptar() && (this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store)));
      }
      _checkIterableAdaptar() {
        return iterableAdapters.includes(this.opts.store.opts.dialect) || iterableAdapters.findIndex((element) => this.opts.store.opts.url.includes(element)) >= 0;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      _getKeyPrefixArray(keys) {
        return keys.map((key) => `${this.opts.namespace}:${key}`);
      }
      _getKeyUnprefix(key) {
        return key.split(":").splice(1).join(":");
      }
      get(key, options) {
        let { store } = this.opts, isArray = Array.isArray(key), keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);
        if (isArray && store.getMany === void 0) {
          let promises = [];
          for (let key2 of keyPrefixed)
            promises.push(
              Promise.resolve().then(() => store.get(key2)).then((data) => typeof data == "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
                if (data != null)
                  return typeof data.expires == "number" && Date.now() > data.expires ? this.delete(key2).then(() => {
                  }) : options && options.raw ? data : data.value;
              })
            );
          return Promise.allSettled(promises).then((values) => {
            let data = [];
            for (let value of values)
              data.push(value.value);
            return data;
          });
        }
        return Promise.resolve().then(() => isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed)).then((data) => typeof data == "string" ? this.opts.deserialize(data) : this.opts.compression ? this.opts.deserialize(data) : data).then((data) => {
          if (data != null)
            return isArray ? data.map((row, index) => {
              if (typeof row == "string" && (row = this.opts.deserialize(row)), row != null) {
                if (typeof row.expires == "number" && Date.now() > row.expires) {
                  this.delete(key[index]).then(() => {
                  });
                  return;
                }
                return options && options.raw ? row : row.value;
              }
            }) : typeof data.expires == "number" && Date.now() > data.expires ? this.delete(key).then(() => {
            }) : options && options.raw ? data : data.value;
        });
      }
      set(key, value, ttl2) {
        let keyPrefixed = this._getKeyPrefix(key);
        typeof ttl2 > "u" && (ttl2 = this.opts.ttl), ttl2 === 0 && (ttl2 = void 0);
        let { store } = this.opts;
        return Promise.resolve().then(() => {
          let expires = typeof ttl2 == "number" ? Date.now() + ttl2 : null;
          return typeof value == "symbol" && this.emit("error", "symbol cannot be serialized"), value = { value, expires }, this.opts.serialize(value);
        }).then((value2) => store.set(keyPrefixed, value2, ttl2)).then(() => !0);
      }
      delete(key) {
        let { store } = this.opts;
        if (Array.isArray(key)) {
          let keyPrefixed2 = this._getKeyPrefixArray(key);
          if (store.deleteMany === void 0) {
            let promises = [];
            for (let key2 of keyPrefixed2)
              promises.push(store.delete(key2));
            return Promise.allSettled(promises).then((values) => values.every((x) => x.value === !0));
          }
          return Promise.resolve().then(() => store.deleteMany(keyPrefixed2));
        }
        let keyPrefixed = this._getKeyPrefix(key);
        return Promise.resolve().then(() => store.delete(keyPrefixed));
      }
      clear() {
        let { store } = this.opts;
        return Promise.resolve().then(() => store.clear());
      }
      has(key) {
        let keyPrefixed = this._getKeyPrefix(key), { store } = this.opts;
        return Promise.resolve().then(async () => typeof store.has == "function" ? store.has(keyPrefixed) : await store.get(keyPrefixed) !== void 0);
      }
      disconnect() {
        let { store } = this.opts;
        if (typeof store.disconnect == "function")
          return store.disconnect();
      }
    };
    module.exports = Keyv2;
  }
});

// ../../node_modules/.pnpm/mimic-response@3.1.0/node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "../../node_modules/.pnpm/mimic-response@3.1.0/node_modules/mimic-response/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var knownProperties2 = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy)
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      let fromProperties = new Set(Object.keys(fromStream).concat(knownProperties2)), properties = {};
      for (let property of fromProperties)
        property in toStream || (properties[property] = {
          get() {
            let value = fromStream[property];
            return typeof value == "function" ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: !0,
          configurable: !1
        });
      return Object.defineProperties(toStream, properties), fromStream.once("aborted", () => {
        toStream.destroy(), toStream.emit("aborted");
      }), fromStream.once("close", () => {
        fromStream.complete && toStream.readable ? toStream.once("end", () => {
          toStream.emit("close");
        }) : toStream.emit("close");
      }), toStream;
    };
  }
});

// ../../node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "../../node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { Transform, PassThrough } = __require("stream"), zlib = __require("zlib"), mimicResponse2 = require_mimic_response();
    module.exports = (response) => {
      let contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding))
        return response;
      let isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress != "function")
        return response.destroy(new Error("Brotli is not supported on Node.js < 12")), response;
      let isEmpty = !0, checker = new Transform({
        transform(data, _encoding, callback) {
          isEmpty = !1, callback(null, data);
        },
        flush(callback) {
          callback();
        }
      }), finalStream = new PassThrough({
        autoDestroy: !1,
        destroy(error, callback) {
          response.destroy(), callback(error);
        }
      }), decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      return decompressStream.once("error", (error) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      }), mimicResponse2(response, finalStream), response.pipe(checker).pipe(decompressStream).pipe(finalStream), finalStream;
    };
  }
});

// ../../node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js
var require_quick_lru = __commonJS({
  "../../node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var QuickLRU = class {
      constructor(options = {}) {
        if (!(options.maxSize && options.maxSize > 0))
          throw new TypeError("`maxSize` must be a number greater than 0");
        this.maxSize = options.maxSize, this.onEviction = options.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
      }
      _set(key, value) {
        if (this.cache.set(key, value), this._size++, this._size >= this.maxSize) {
          if (this._size = 0, typeof this.onEviction == "function")
            for (let [key2, value2] of this.oldCache.entries())
              this.onEviction(key2, value2);
          this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
        }
      }
      get(key) {
        if (this.cache.has(key))
          return this.cache.get(key);
        if (this.oldCache.has(key)) {
          let value = this.oldCache.get(key);
          return this.oldCache.delete(key), this._set(key, value), value;
        }
      }
      set(key, value) {
        return this.cache.has(key) ? this.cache.set(key, value) : this._set(key, value), this;
      }
      has(key) {
        return this.cache.has(key) || this.oldCache.has(key);
      }
      peek(key) {
        if (this.cache.has(key))
          return this.cache.get(key);
        if (this.oldCache.has(key))
          return this.oldCache.get(key);
      }
      delete(key) {
        let deleted = this.cache.delete(key);
        return deleted && this._size--, this.oldCache.delete(key) || deleted;
      }
      clear() {
        this.cache.clear(), this.oldCache.clear(), this._size = 0;
      }
      *keys() {
        for (let [key] of this)
          yield key;
      }
      *values() {
        for (let [, value] of this)
          yield value;
      }
      *[Symbol.iterator]() {
        for (let item of this.cache)
          yield item;
        for (let item of this.oldCache) {
          let [key] = item;
          this.cache.has(key) || (yield item);
        }
      }
      get size() {
        let oldCacheSize = 0;
        for (let key of this.oldCache.keys())
          this.cache.has(key) || oldCacheSize++;
        return Math.min(this._size + oldCacheSize, this.maxSize);
      }
    };
    module.exports = QuickLRU;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/delay-async-destroy.js
var require_delay_async_destroy = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (stream2) => {
      if (stream2.listenerCount("error") !== 0)
        return stream2;
      stream2.__destroy = stream2._destroy, stream2._destroy = (...args) => {
        let callback = args.pop();
        stream2.__destroy(...args, async (error) => {
          await Promise.resolve(), callback(error);
        });
      };
      let onError = (error) => {
        Promise.resolve().then(() => {
          stream2.emit("error", error);
        });
      };
      return stream2.once("error", onError), Promise.resolve().then(() => {
        stream2.off("error", onError);
      }), stream2;
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/agent.js
var require_agent = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/agent.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { URL: URL4 } = __require("url"), EventEmitter4 = __require("events"), tls = __require("tls"), http22 = __require("http2"), QuickLRU = require_quick_lru(), delayAsyncDestroy = require_delay_async_destroy(), kCurrentStreamCount = Symbol("currentStreamCount"), kRequest = Symbol("request"), kOriginSet = Symbol("cachedOriginSet"), kGracefullyClosing = Symbol("gracefullyClosing"), kLength = Symbol("length"), nameKeys = [
      // Not an Agent option actually
      "createConnection",
      // `http2.connect()` options
      "maxDeflateDynamicTableSize",
      "maxSettings",
      "maxSessionMemory",
      "maxHeaderListPairs",
      "maxOutstandingPings",
      "maxReservedRemoteStreams",
      "maxSendHeaderBlockLength",
      "paddingStrategy",
      "peerMaxConcurrentStreams",
      "settings",
      // `tls.connect()` source options
      "family",
      "localAddress",
      "rejectUnauthorized",
      // `tls.connect()` secure context options
      "pskCallback",
      "minDHSize",
      // `tls.connect()` destination options
      // - `servername` is automatically validated, skip it
      // - `host` and `port` just describe the destination server,
      "path",
      "socket",
      // `tls.createSecureContext()` options
      "ca",
      "cert",
      "sigalgs",
      "ciphers",
      "clientCertEngine",
      "crl",
      "dhparam",
      "ecdhCurve",
      "honorCipherOrder",
      "key",
      "privateKeyEngine",
      "privateKeyIdentifier",
      "maxVersion",
      "minVersion",
      "pfx",
      "secureOptions",
      "secureProtocol",
      "sessionIdContext",
      "ticketKeys"
    ], getSortedIndex = (array, value, compare) => {
      let low = 0, high = array.length;
      for (; low < high; ) {
        let mid = low + high >>> 1;
        compare(array[mid], value) ? low = mid + 1 : high = mid;
      }
      return low;
    }, compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams, closeCoveredSessions = (where, session) => {
      for (let index = 0; index < where.length; index++) {
        let coveredSession = where[index];
        // Unfortunately `.every()` returns true for an empty array
        coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams && gracefullyClose(coveredSession);
      }
    }, closeSessionIfCovered = (where, coveredSession) => {
      for (let index = 0; index < where.length; index++) {
        let session = where[index];
        if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every((origin) => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams)
          return gracefullyClose(coveredSession), !0;
      }
      return !1;
    }, gracefullyClose = (session) => {
      session[kGracefullyClosing] = !0, session[kCurrentStreamCount] === 0 && session.close();
    }, Agent = class _Agent extends EventEmitter4 {
      constructor({ timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100 } = {}) {
        super(), this.sessions = {}, this.queue = {}, this.timeout = timeout, this.maxSessions = maxSessions, this.maxEmptySessions = maxEmptySessions, this._emptySessionCount = 0, this._sessionCount = 0, this.settings = {
          enablePush: !1,
          initialWindowSize: 1024 * 1024 * 32
          // 32MB, see https://github.com/nodejs/node/issues/38426
        }, this.tlsSessionCache = new QuickLRU({ maxSize: maxCachedTlsSessions });
      }
      get protocol() {
        return "https:";
      }
      normalizeOptions(options) {
        let normalized = "";
        for (let index = 0; index < nameKeys.length; index++) {
          let key = nameKeys[index];
          normalized += ":", options && options[key] !== void 0 && (normalized += options[key]);
        }
        return normalized;
      }
      _processQueue() {
        if (this._sessionCount >= this.maxSessions) {
          this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
          return;
        }
        for (let normalizedOptions in this.queue)
          for (let normalizedOrigin in this.queue[normalizedOptions]) {
            let item = this.queue[normalizedOptions][normalizedOrigin];
            item.completed || (item.completed = !0, item());
          }
      }
      _isBetterSession(thisStreamCount, thatStreamCount) {
        return thisStreamCount > thatStreamCount;
      }
      _accept(session, listeners, normalizedOrigin, options) {
        let index = 0;
        for (; index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams; )
          listeners[index].resolve(session), index++;
        listeners.splice(0, index), listeners.length > 0 && (this.getSession(normalizedOrigin, options, listeners), listeners.length = 0);
      }
      getSession(origin, options, listeners) {
        return new Promise((resolve, reject) => {
          Array.isArray(listeners) && listeners.length > 0 ? (listeners = [...listeners], resolve()) : listeners = [{ resolve, reject }];
          try {
            if (typeof origin == "string")
              origin = new URL4(origin);
            else if (!(origin instanceof URL4))
              throw new TypeError("The `origin` argument needs to be a string or an URL object");
            if (options) {
              let { servername } = options, { hostname } = origin;
              if (servername && hostname !== servername)
                throw new Error(`Origin ${hostname} differs from servername ${servername}`);
            }
          } catch (error) {
            for (let index = 0; index < listeners.length; index++)
              listeners[index].reject(error);
            return;
          }
          let normalizedOptions = this.normalizeOptions(options), normalizedOrigin = origin.origin;
          if (normalizedOptions in this.sessions) {
            let sessions = this.sessions[normalizedOptions], maxConcurrentStreams = -1, currentStreamsCount = -1, optimalSession;
            for (let index = 0; index < sessions.length; index++) {
              let session = sessions[index], sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;
              if (sessionMaxConcurrentStreams < maxConcurrentStreams)
                break;
              if (!session[kOriginSet].includes(normalizedOrigin))
                continue;
              let sessionCurrentStreamsCount = session[kCurrentStreamCount];
              sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing] || session.destroyed || (optimalSession || (maxConcurrentStreams = sessionMaxConcurrentStreams), this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount) && (optimalSession = session, currentStreamsCount = sessionCurrentStreamsCount));
            }
            if (optimalSession) {
              this._accept(optimalSession, listeners, normalizedOrigin, options);
              return;
            }
          }
          if (normalizedOptions in this.queue) {
            if (normalizedOrigin in this.queue[normalizedOptions]) {
              this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);
              return;
            }
          } else
            this.queue[normalizedOptions] = {
              [kLength]: 0
            };
          let removeFromQueue = () => {
            normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry && (delete this.queue[normalizedOptions][normalizedOrigin], --this.queue[normalizedOptions][kLength] === 0 && delete this.queue[normalizedOptions]);
          }, entry = async () => {
            this._sessionCount++;
            let name = `${normalizedOrigin}:${normalizedOptions}`, receivedSettings = !1, socket;
            try {
              let computedOptions = { ...options };
              computedOptions.settings === void 0 && (computedOptions.settings = this.settings), computedOptions.session === void 0 && (computedOptions.session = this.tlsSessionCache.get(name)), socket = await (computedOptions.createConnection || this.createConnection).call(this, origin, computedOptions), computedOptions.createConnection = () => socket;
              let session = http22.connect(origin, computedOptions);
              session[kCurrentStreamCount] = 0, session[kGracefullyClosing] = !1;
              let getOriginSet = () => {
                let { socket: socket2 } = session, originSet;
                return socket2.servername === !1 ? (socket2.servername = socket2.remoteAddress, originSet = session.originSet, socket2.servername = !1) : originSet = session.originSet, originSet;
              }, isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;
              session.socket.once("session", (tlsSession) => {
                this.tlsSessionCache.set(name, tlsSession);
              }), session.once("error", (error) => {
                for (let index = 0; index < listeners.length; index++)
                  listeners[index].reject(error);
                this.tlsSessionCache.delete(name);
              }), session.setTimeout(this.timeout, () => {
                session.destroy();
              }), session.once("close", () => {
                if (this._sessionCount--, receivedSettings) {
                  this._emptySessionCount--;
                  let where = this.sessions[normalizedOptions];
                  where.length === 1 ? delete this.sessions[normalizedOptions] : where.splice(where.indexOf(session), 1);
                } else {
                  removeFromQueue();
                  let error = new Error("Session closed without receiving a SETTINGS frame");
                  error.code = "HTTP2WRAPPER_NOSETTINGS";
                  for (let index = 0; index < listeners.length; index++)
                    listeners[index].reject(error);
                }
                this._processQueue();
              });
              let processListeners = () => {
                let queue = this.queue[normalizedOptions];
                if (!queue)
                  return;
                let originSet = session[kOriginSet];
                for (let index = 0; index < originSet.length; index++) {
                  let origin2 = originSet[index];
                  if (origin2 in queue) {
                    let { listeners: listeners2, completed } = queue[origin2], index2 = 0;
                    for (; index2 < listeners2.length && isFree(); )
                      listeners2[index2].resolve(session), index2++;
                    if (queue[origin2].listeners.splice(0, index2), queue[origin2].listeners.length === 0 && !completed && (delete queue[origin2], --queue[kLength] === 0)) {
                      delete this.queue[normalizedOptions];
                      break;
                    }
                    if (!isFree())
                      break;
                  }
                }
              };
              session.on("origin", () => {
                session[kOriginSet] = getOriginSet() || [], session[kGracefullyClosing] = !1, closeSessionIfCovered(this.sessions[normalizedOptions], session), !(session[kGracefullyClosing] || !isFree()) && (processListeners(), isFree() && closeCoveredSessions(this.sessions[normalizedOptions], session));
              }), session.once("remoteSettings", () => {
                if (entry.destroyed) {
                  let error = new Error("Agent has been destroyed");
                  for (let index = 0; index < listeners.length; index++)
                    listeners[index].reject(error);
                  session.destroy();
                  return;
                }
                if (session.setLocalWindowSize && session.setLocalWindowSize(1024 * 1024 * 4), session[kOriginSet] = getOriginSet() || [], session.socket.encrypted) {
                  let mainOrigin = session[kOriginSet][0];
                  if (mainOrigin !== normalizedOrigin) {
                    let error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);
                    for (let index = 0; index < listeners.length; index++)
                      listeners[index].reject(error);
                    session.destroy();
                    return;
                  }
                }
                removeFromQueue();
                {
                  let where = this.sessions;
                  if (normalizedOptions in where) {
                    let sessions = where[normalizedOptions];
                    sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);
                  } else
                    where[normalizedOptions] = [session];
                }
                receivedSettings = !0, this._emptySessionCount++, this.emit("session", session), this._accept(session, listeners, normalizedOrigin, options), session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions && this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions), session.on("remoteSettings", () => {
                  isFree() && (processListeners(), isFree() && closeCoveredSessions(this.sessions[normalizedOptions], session));
                });
              }), session[kRequest] = session.request, session.request = (headers, streamOptions) => {
                if (session[kGracefullyClosing])
                  throw new Error("The session is gracefully closing. No new streams are allowed.");
                let stream2 = session[kRequest](headers, streamOptions);
                return session.ref(), session[kCurrentStreamCount]++ === 0 && this._emptySessionCount--, stream2.once("close", () => {
                  if (--session[kCurrentStreamCount] === 0 && (this._emptySessionCount++, session.unref(), this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing])) {
                    session.close();
                    return;
                  }
                  session.destroyed || session.closed || isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session) && (closeCoveredSessions(this.sessions[normalizedOptions], session), processListeners(), session[kCurrentStreamCount] === 0 && this._processQueue());
                }), stream2;
              };
            } catch (error) {
              removeFromQueue(), this._sessionCount--;
              for (let index = 0; index < listeners.length; index++)
                listeners[index].reject(error);
            }
          };
          entry.listeners = listeners, entry.completed = !1, entry.destroyed = !1, this.queue[normalizedOptions][normalizedOrigin] = entry, this.queue[normalizedOptions][kLength]++, this._processQueue();
        });
      }
      request(origin, options, headers, streamOptions) {
        return new Promise((resolve, reject) => {
          this.getSession(origin, options, [{
            reject,
            resolve: (session) => {
              try {
                let stream2 = session.request(headers, streamOptions);
                delayAsyncDestroy(stream2), resolve(stream2);
              } catch (error) {
                reject(error);
              }
            }
          }]);
        });
      }
      async createConnection(origin, options) {
        return _Agent.connect(origin, options);
      }
      static connect(origin, options) {
        options.ALPNProtocols = ["h2"];
        let port = origin.port || 443, host = origin.hostname;
        typeof options.servername > "u" && (options.servername = host);
        let socket = tls.connect(port, host, options);
        return options.socket && (socket._peername = {
          family: void 0,
          address: void 0,
          port
        }), socket;
      }
      closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {
        let closedCount = 0, { sessions } = this;
        for (let key in sessions) {
          let thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++) {
            let session = thisSessions[index];
            if (session[kCurrentStreamCount] === 0 && (closedCount++, session.close(), closedCount >= maxCount))
              return closedCount;
          }
        }
        return closedCount;
      }
      destroy(reason) {
        let { sessions, queue } = this;
        for (let key in sessions) {
          let thisSessions = sessions[key];
          for (let index = 0; index < thisSessions.length; index++)
            thisSessions[index].destroy(reason);
        }
        for (let normalizedOptions in queue) {
          let entries2 = queue[normalizedOptions];
          for (let normalizedOrigin in entries2)
            entries2[normalizedOrigin].destroyed = !0;
        }
        this.queue = {}, this.tlsSessionCache.clear();
      }
      get emptySessionCount() {
        return this._emptySessionCount;
      }
      get pendingSessionCount() {
        return this._sessionCount - this._emptySessionCount;
      }
      get sessionCount() {
        return this._sessionCount;
      }
    };
    Agent.kCurrentStreamCount = kCurrentStreamCount;
    Agent.kGracefullyClosing = kGracefullyClosing;
    module.exports = {
      Agent,
      globalAgent: new Agent()
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/incoming-message.js
var require_incoming_message = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/incoming-message.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { Readable } = __require("stream"), IncomingMessage = class extends Readable {
      constructor(socket, highWaterMark) {
        super({
          emitClose: !1,
          autoDestroy: !0,
          highWaterMark
        }), this.statusCode = null, this.statusMessage = "", this.httpVersion = "2.0", this.httpVersionMajor = 2, this.httpVersionMinor = 0, this.headers = {}, this.trailers = {}, this.req = null, this.aborted = !1, this.complete = !1, this.upgrade = null, this.rawHeaders = [], this.rawTrailers = [], this.socket = socket, this._dumped = !1;
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      _destroy(error, callback) {
        this.readableEnded || (this.aborted = !0), callback(), this.req._request.destroy(error);
      }
      setTimeout(ms, callback) {
        return this.req.setTimeout(ms, callback), this;
      }
      _dump() {
        this._dumped || (this._dumped = !0, this.removeAllListeners("data"), this.resume());
      }
      _read() {
        this.req && this.req._request.resume();
      }
    };
    module.exports = IncomingMessage;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/proxy-events.js
var require_proxy_events = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/proxy-events.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (from, to, events) => {
      for (let event of events)
        from.on(event, (...args) => to.emit(event, ...args));
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/errors.js
var require_errors2 = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/errors.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var makeError = (Base, key, getMessage) => {
      module.exports[key] = class extends Base {
        constructor(...args) {
          super(typeof getMessage == "string" ? getMessage : getMessage(args)), this.name = `${super.name} [${key}]`, this.code = key;
        }
      };
    };
    makeError(TypeError, "ERR_INVALID_ARG_TYPE", (args) => {
      let type = args[0].includes(".") ? "property" : "argument", valid = args[1], isManyTypes = Array.isArray(valid);
      return isManyTypes && (valid = `${valid.slice(0, -1).join(", ")} or ${valid.slice(-1)}`), `The "${args[0]}" ${type} must be ${isManyTypes ? "one of" : "of"} type ${valid}. Received ${typeof args[2]}`;
    });
    makeError(
      TypeError,
      "ERR_INVALID_PROTOCOL",
      (args) => `Protocol "${args[0]}" not supported. Expected "${args[1]}"`
    );
    makeError(
      Error,
      "ERR_HTTP_HEADERS_SENT",
      (args) => `Cannot ${args[0]} headers after they are sent to the client`
    );
    makeError(
      TypeError,
      "ERR_INVALID_HTTP_TOKEN",
      (args) => `${args[0]} must be a valid HTTP token [${args[1]}]`
    );
    makeError(
      TypeError,
      "ERR_HTTP_INVALID_HEADER_VALUE",
      (args) => `Invalid value "${args[0]} for header "${args[1]}"`
    );
    makeError(
      TypeError,
      "ERR_INVALID_CHAR",
      (args) => `Invalid character in ${args[0]} [${args[1]}]`
    );
    makeError(
      Error,
      "ERR_HTTP2_NO_SOCKET_MANIPULATION",
      "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
    );
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js
var require_is_request_pseudo_header = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (header) => {
      switch (header) {
        case ":method":
        case ":scheme":
        case ":authority":
        case ":path":
          return !0;
        default:
          return !1;
      }
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/validate-header-name.js
var require_validate_header_name = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/validate-header-name.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { ERR_INVALID_HTTP_TOKEN } = require_errors2(), isRequestPseudoHeader = require_is_request_pseudo_header(), isValidHttpToken = /^[\^`\-\w!#$%&*+.|~]+$/;
    module.exports = (name) => {
      if (typeof name != "string" || !isValidHttpToken.test(name) && !isRequestPseudoHeader(name))
        throw new ERR_INVALID_HTTP_TOKEN("Header name", name);
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/validate-header-value.js
var require_validate_header_value = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/validate-header-value.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var {
      ERR_HTTP_INVALID_HEADER_VALUE,
      ERR_INVALID_CHAR
    } = require_errors2(), isInvalidHeaderValue = /[^\t\u0020-\u007E\u0080-\u00FF]/;
    module.exports = (name, value) => {
      if (typeof value > "u")
        throw new ERR_HTTP_INVALID_HEADER_VALUE(value, name);
      if (isInvalidHeaderValue.test(value))
        throw new ERR_INVALID_CHAR("header content", name);
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/proxy-socket-handler.js
var require_proxy_socket_handler = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { ERR_HTTP2_NO_SOCKET_MANIPULATION } = require_errors2(), proxySocketHandler = {
      has(stream2, property) {
        let reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
        return property in stream2 || property in reference;
      },
      get(stream2, property) {
        switch (property) {
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return stream2[property].bind(stream2);
          case "writable":
          case "destroyed":
            return stream2[property];
          case "readable":
            return stream2.destroyed ? !1 : stream2.readable;
          case "setTimeout": {
            let { session } = stream2;
            return session !== void 0 ? session.setTimeout.bind(session) : stream2.setTimeout.bind(stream2);
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            let reference = stream2.session === void 0 ? stream2 : stream2.session.socket, value = reference[property];
            return typeof value == "function" ? value.bind(reference) : value;
          }
        }
      },
      getPrototypeOf(stream2) {
        return stream2.session !== void 0 ? Reflect.getPrototypeOf(stream2.session.socket) : Reflect.getPrototypeOf(stream2);
      },
      set(stream2, property, value) {
        switch (property) {
          case "writable":
          case "readable":
          case "destroyed":
          case "on":
          case "once":
          case "end":
          case "emit":
          case "destroy":
            return stream2[property] = value, !0;
          case "setTimeout": {
            let { session } = stream2;
            return session === void 0 ? stream2.setTimeout = value : session.setTimeout = value, !0;
          }
          case "write":
          case "read":
          case "pause":
          case "resume":
            throw new ERR_HTTP2_NO_SOCKET_MANIPULATION();
          default: {
            let reference = stream2.session === void 0 ? stream2 : stream2.session.socket;
            return reference[property] = value, !0;
          }
        }
      }
    };
    module.exports = proxySocketHandler;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/client-request.js
var require_client_request = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/client-request.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { URL: URL4, urlToHttpOptions } = __require("url"), http22 = __require("http2"), { Writable } = __require("stream"), { Agent, globalAgent } = require_agent(), IncomingMessage = require_incoming_message(), proxyEvents2 = require_proxy_events(), {
      ERR_INVALID_ARG_TYPE,
      ERR_INVALID_PROTOCOL,
      ERR_HTTP_HEADERS_SENT
    } = require_errors2(), validateHeaderName = require_validate_header_name(), validateHeaderValue = require_validate_header_value(), proxySocketHandler = require_proxy_socket_handler(), {
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_METHOD_CONNECT
    } = http22.constants, kHeaders = Symbol("headers"), kOrigin = Symbol("origin"), kSession = Symbol("session"), kOptions = Symbol("options"), kFlushedHeaders = Symbol("flushedHeaders"), kJobs = Symbol("jobs"), kPendingAgentPromise = Symbol("pendingAgentPromise"), ClientRequest = class extends Writable {
      constructor(input, options, callback) {
        if (super({
          autoDestroy: !1,
          emitClose: !1
        }), typeof input == "string" ? input = urlToHttpOptions(new URL4(input)) : input instanceof URL4 ? input = urlToHttpOptions(input) : input = { ...input }, typeof options == "function" || options === void 0 ? (callback = options, options = input) : options = Object.assign(input, options), options.h2session) {
          if (this[kSession] = options.h2session, this[kSession].destroyed)
            throw new Error("The session has been closed already");
          this.protocol = this[kSession].socket.encrypted ? "https:" : "http:";
        } else if (options.agent === !1)
          this.agent = new Agent({ maxEmptySessions: 0 });
        else if (typeof options.agent > "u" || options.agent === null)
          this.agent = globalAgent;
        else if (typeof options.agent.request == "function")
          this.agent = options.agent;
        else
          throw new ERR_INVALID_ARG_TYPE("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], options.agent);
        if (this.agent && (this.protocol = this.agent.protocol), options.protocol && options.protocol !== this.protocol)
          throw new ERR_INVALID_PROTOCOL(options.protocol, this.protocol);
        options.port || (options.port = options.defaultPort || this.agent && this.agent.defaultPort || 443), options.host = options.hostname || options.host || "localhost", delete options.hostname;
        let { timeout } = options;
        options.timeout = void 0, this[kHeaders] = /* @__PURE__ */ Object.create(null), this[kJobs] = [], this[kPendingAgentPromise] = void 0, this.socket = null, this.connection = null, this.method = options.method || "GET", this.method === "CONNECT" && (options.path === "/" || options.path === void 0) || (this.path = options.path), this.res = null, this.aborted = !1, this.reusedSocket = !1;
        let { headers } = options;
        if (headers)
          for (let header in headers)
            this.setHeader(header, headers[header]);
        options.auth && !("authorization" in this[kHeaders]) && (this[kHeaders].authorization = "Basic " + Buffer.from(options.auth).toString("base64")), options.session = options.tlsSession, options.path = options.socketPath, this[kOptions] = options, this[kOrigin] = new URL4(`${this.protocol}//${options.servername || options.host}:${options.port}`);
        let reuseSocket = options._reuseSocket;
        reuseSocket && (options.createConnection = (...args) => reuseSocket.destroyed ? this.agent.createConnection(...args) : reuseSocket, this.agent.getSession(this[kOrigin], this[kOptions]).catch(() => {
        })), timeout && this.setTimeout(timeout), callback && this.once("response", callback), this[kFlushedHeaders] = !1;
      }
      get method() {
        return this[kHeaders][HTTP2_HEADER_METHOD];
      }
      set method(value) {
        value && (this[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase());
      }
      get path() {
        let header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
        return this[kHeaders][header];
      }
      set path(value) {
        if (value) {
          let header = this.method === "CONNECT" ? HTTP2_HEADER_AUTHORITY : HTTP2_HEADER_PATH;
          this[kHeaders][header] = value;
        }
      }
      get host() {
        return this[kOrigin].hostname;
      }
      set host(_value) {
      }
      get _mustNotHaveABody() {
        return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
      }
      _write(chunk, encoding, callback) {
        if (this._mustNotHaveABody) {
          callback(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
          return;
        }
        this.flushHeaders();
        let callWrite = () => this._request.write(chunk, encoding, callback);
        this._request ? callWrite() : this[kJobs].push(callWrite);
      }
      _final(callback) {
        this.flushHeaders();
        let callEnd = () => {
          if (this._mustNotHaveABody || this.method === "CONNECT") {
            callback();
            return;
          }
          this._request.end(callback);
        };
        this._request ? callEnd() : this[kJobs].push(callEnd);
      }
      abort() {
        this.res && this.res.complete || (this.aborted || process.nextTick(() => this.emit("abort")), this.aborted = !0, this.destroy());
      }
      async _destroy(error, callback) {
        this.res && this.res._dump(), this._request ? this._request.destroy() : process.nextTick(() => {
          this.emit("close");
        });
        try {
          await this[kPendingAgentPromise];
        } catch (internalError) {
          this.aborted && (error = internalError);
        }
        callback(error);
      }
      async flushHeaders() {
        if (this[kFlushedHeaders] || this.destroyed)
          return;
        this[kFlushedHeaders] = !0;
        let isConnectMethod = this.method === HTTP2_METHOD_CONNECT, onStream = (stream2) => {
          if (this._request = stream2, this.destroyed) {
            stream2.destroy();
            return;
          }
          isConnectMethod || proxyEvents2(stream2, this, ["timeout", "continue"]), stream2.once("error", (error) => {
            this.destroy(error);
          }), stream2.once("aborted", () => {
            let { res } = this;
            res ? (res.aborted = !0, res.emit("aborted"), res.destroy()) : this.destroy(new Error("The server aborted the HTTP/2 stream"));
          });
          let onResponse = (headers, flags, rawHeaders) => {
            let response = new IncomingMessage(this.socket, stream2.readableHighWaterMark);
            this.res = response, response.url = `${this[kOrigin].origin}${this.path}`, response.req = this, response.statusCode = headers[HTTP2_HEADER_STATUS], response.headers = headers, response.rawHeaders = rawHeaders, response.once("end", () => {
              response.complete = !0, response.socket = null, response.connection = null;
            }), isConnectMethod ? (response.upgrade = !0, this.emit("connect", response, stream2, Buffer.alloc(0)) ? this.emit("close") : stream2.destroy()) : (stream2.on("data", (chunk) => {
              !response._dumped && !response.push(chunk) && stream2.pause();
            }), stream2.once("end", () => {
              this.aborted || response.push(null);
            }), this.emit("response", response) || response._dump());
          };
          stream2.once("response", onResponse), stream2.once("headers", (headers) => this.emit("information", { statusCode: headers[HTTP2_HEADER_STATUS] })), stream2.once("trailers", (trailers, flags, rawTrailers) => {
            let { res } = this;
            if (res === null) {
              onResponse(trailers, flags, rawTrailers);
              return;
            }
            res.trailers = trailers, res.rawTrailers = rawTrailers;
          }), stream2.once("close", () => {
            let { aborted, res } = this;
            if (res) {
              aborted && (res.aborted = !0, res.emit("aborted"), res.destroy());
              let finish = () => {
                res.emit("close"), this.destroy(), this.emit("close");
              };
              res.readable ? res.once("end", finish) : finish();
              return;
            }
            if (!this.destroyed) {
              this.destroy(new Error("The HTTP/2 stream has been early terminated")), this.emit("close");
              return;
            }
            this.destroy(), this.emit("close");
          }), this.socket = new Proxy(stream2, proxySocketHandler);
          for (let job of this[kJobs])
            job();
          this[kJobs].length = 0, this.emit("socket", this.socket);
        };
        if (!(HTTP2_HEADER_AUTHORITY in this[kHeaders]) && !isConnectMethod && (this[kHeaders][HTTP2_HEADER_AUTHORITY] = this[kOrigin].host), this[kSession])
          try {
            onStream(this[kSession].request(this[kHeaders]));
          } catch (error) {
            this.destroy(error);
          }
        else {
          this.reusedSocket = !0;
          try {
            let promise = this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]);
            this[kPendingAgentPromise] = promise, onStream(await promise), this[kPendingAgentPromise] = !1;
          } catch (error) {
            this[kPendingAgentPromise] = !1, this.destroy(error);
          }
        }
      }
      get connection() {
        return this.socket;
      }
      set connection(value) {
        this.socket = value;
      }
      getHeaderNames() {
        return Object.keys(this[kHeaders]);
      }
      hasHeader(name) {
        if (typeof name != "string")
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        return !!this[kHeaders][name.toLowerCase()];
      }
      getHeader(name) {
        if (typeof name != "string")
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        return this[kHeaders][name.toLowerCase()];
      }
      get headersSent() {
        return this[kFlushedHeaders];
      }
      removeHeader(name) {
        if (typeof name != "string")
          throw new ERR_INVALID_ARG_TYPE("name", "string", name);
        if (this.headersSent)
          throw new ERR_HTTP_HEADERS_SENT("remove");
        delete this[kHeaders][name.toLowerCase()];
      }
      setHeader(name, value) {
        if (this.headersSent)
          throw new ERR_HTTP_HEADERS_SENT("set");
        validateHeaderName(name), validateHeaderValue(name, value);
        let lowercased = name.toLowerCase();
        if (lowercased === "connection") {
          if (value.toLowerCase() === "keep-alive")
            return;
          throw new Error(`Invalid 'connection' header: ${value}`);
        }
        lowercased === "host" && this.method === "CONNECT" ? this[kHeaders][HTTP2_HEADER_AUTHORITY] = value : this[kHeaders][lowercased] = value;
      }
      setNoDelay() {
      }
      setSocketKeepAlive() {
      }
      setTimeout(ms, callback) {
        let applyTimeout = () => this._request.setTimeout(ms, callback);
        return this._request ? applyTimeout() : this[kJobs].push(applyTimeout), this;
      }
      get maxHeadersCount() {
        if (!this.destroyed && this._request)
          return this._request.session.localSettings.maxHeaderListSize;
      }
      set maxHeadersCount(_value) {
      }
    };
    module.exports = ClientRequest;
  }
});

// ../../node_modules/.pnpm/resolve-alpn@1.2.1/node_modules/resolve-alpn/index.js
var require_resolve_alpn = __commonJS({
  "../../node_modules/.pnpm/resolve-alpn@1.2.1/node_modules/resolve-alpn/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var tls = __require("tls");
    module.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {
      let timeout = !1, socket, callback = async () => {
        await socketPromise, socket.off("timeout", onTimeout), socket.off("error", reject), options.resolveSocket ? (resolve({ alpnProtocol: socket.alpnProtocol, socket, timeout }), timeout && (await Promise.resolve(), socket.emit("timeout"))) : (socket.destroy(), resolve({ alpnProtocol: socket.alpnProtocol, timeout }));
      }, onTimeout = async () => {
        timeout = !0, callback();
      }, socketPromise = (async () => {
        try {
          socket = await connect(options, callback), socket.on("error", reject), socket.once("timeout", onTimeout);
        } catch (error) {
          reject(error);
        }
      })();
    });
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/calculate-server-name.js
var require_calculate_server_name = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/calculate-server-name.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { isIP } = __require("net"), assert3 = __require("assert"), getHost = (host) => {
      if (host[0] === "[") {
        let idx2 = host.indexOf("]");
        return assert3(idx2 !== -1), host.slice(1, idx2);
      }
      let idx = host.indexOf(":");
      return idx === -1 ? host : host.slice(0, idx);
    };
    module.exports = (host) => {
      let servername = getHost(host);
      return isIP(servername) ? "" : servername;
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/auto.js
var require_auto = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/auto.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { URL: URL4, urlToHttpOptions } = __require("url"), http3 = __require("http"), https2 = __require("https"), resolveALPN = require_resolve_alpn(), QuickLRU = require_quick_lru(), { Agent, globalAgent } = require_agent(), Http2ClientRequest = require_client_request(), calculateServerName = require_calculate_server_name(), delayAsyncDestroy = require_delay_async_destroy(), cache = new QuickLRU({ maxSize: 100 }), queue = /* @__PURE__ */ new Map(), installSocket = (agent, socket, options) => {
      socket._httpMessage = { shouldKeepAlive: !0 };
      let onFree = () => {
        agent.emit("free", socket, options);
      };
      socket.on("free", onFree);
      let onClose = () => {
        agent.removeSocket(socket, options);
      };
      socket.on("close", onClose);
      let onTimeout = () => {
        let { freeSockets } = agent;
        for (let sockets of Object.values(freeSockets))
          if (sockets.includes(socket)) {
            socket.destroy();
            return;
          }
      };
      socket.on("timeout", onTimeout);
      let onRemove = () => {
        agent.removeSocket(socket, options), socket.off("close", onClose), socket.off("free", onFree), socket.off("timeout", onTimeout), socket.off("agentRemove", onRemove);
      };
      socket.on("agentRemove", onRemove), agent.emit("free", socket, options);
    }, createResolveProtocol = (cache2, queue2 = /* @__PURE__ */ new Map(), connect = void 0) => async (options) => {
      let name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;
      if (!cache2.has(name)) {
        if (queue2.has(name))
          return { alpnProtocol: (await queue2.get(name)).alpnProtocol };
        let { path: path4 } = options;
        options.path = options.socketPath;
        let resultPromise = resolveALPN(options, connect);
        queue2.set(name, resultPromise);
        try {
          let result = await resultPromise;
          return cache2.set(name, result.alpnProtocol), queue2.delete(name), options.path = path4, result;
        } catch (error) {
          throw queue2.delete(name), options.path = path4, error;
        }
      }
      return { alpnProtocol: cache2.get(name) };
    }, defaultResolveProtocol = createResolveProtocol(cache, queue);
    module.exports = async (input, options, callback) => {
      if (typeof input == "string" ? input = urlToHttpOptions(new URL4(input)) : input instanceof URL4 ? input = urlToHttpOptions(input) : input = { ...input }, typeof options == "function" || options === void 0 ? (callback = options, options = input) : options = Object.assign(input, options), options.ALPNProtocols = options.ALPNProtocols || ["h2", "http/1.1"], !Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0)
        throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
      options.protocol = options.protocol || "https:";
      let isHttps = options.protocol === "https:";
      options.host = options.hostname || options.host || "localhost", options.session = options.tlsSession, options.servername = options.servername || calculateServerName(options.headers && options.headers.host || options.host), options.port = options.port || (isHttps ? 443 : 80), options._defaultAgent = isHttps ? https2.globalAgent : http3.globalAgent;
      let resolveProtocol = options.resolveProtocol || defaultResolveProtocol, { agent } = options;
      if (agent !== void 0 && agent !== !1 && agent.constructor.name !== "Object")
        throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
      if (isHttps) {
        options.resolveSocket = !0;
        let { socket, alpnProtocol, timeout } = await resolveProtocol(options);
        if (timeout) {
          socket && socket.destroy();
          let error = new Error(`Timed out resolving ALPN: ${options.timeout} ms`);
          throw error.code = "ETIMEDOUT", error.ms = options.timeout, error;
        }
        socket && options.createConnection && (socket.destroy(), socket = void 0), delete options.resolveSocket;
        let isHttp2 = alpnProtocol === "h2";
        if (agent && (agent = isHttp2 ? agent.http2 : agent.https, options.agent = agent), agent === void 0 && (agent = isHttp2 ? globalAgent : https2.globalAgent), socket)
          if (agent === !1)
            socket.destroy();
          else {
            let defaultCreateConnection = (isHttp2 ? Agent : https2.Agent).prototype.createConnection;
            agent.createConnection === defaultCreateConnection ? isHttp2 ? options._reuseSocket = socket : installSocket(agent, socket, options) : socket.destroy();
          }
        if (isHttp2)
          return delayAsyncDestroy(new Http2ClientRequest(options, callback));
      } else agent && (options.agent = agent.http);
      return options.headers && (options.headers = { ...options.headers }, options.headers[":authority"] && (options.headers.host || (options.headers.host = options.headers[":authority"]), delete options.headers[":authority"]), delete options.headers[":method"], delete options.headers[":scheme"], delete options.headers[":path"]), delayAsyncDestroy(http3.request(options, callback));
    };
    module.exports.protocolCache = cache;
    module.exports.resolveProtocol = defaultResolveProtocol;
    module.exports.createResolveProtocol = createResolveProtocol;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/js-stream-socket.js
var require_js_stream_socket = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/js-stream-socket.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var stream2 = __require("stream"), tls = __require("tls"), JSStreamSocket = new tls.TLSSocket(new stream2.PassThrough())._handle._parentWrap.constructor;
    module.exports = JSStreamSocket;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js
var require_unexpected_status_code_error = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var UnexpectedStatusCodeError = class extends Error {
      constructor(statusCode, statusMessage = "") {
        super(`The proxy server rejected the request with status code ${statusCode} (${statusMessage || "empty status message"})`), this.statusCode = statusCode, this.statusMessage = statusMessage;
      }
    };
    module.exports = UnexpectedStatusCodeError;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/check-type.js
var require_check_type = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/utils/check-type.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var checkType = (name, value, types2) => {
      if (!types2.some((type) => typeof type === "string" ? typeof value === type : value instanceof type)) {
        let names = types2.map((type) => typeof type == "string" ? type : type.name);
        throw new TypeError(`Expected '${name}' to be a type of ${names.join(" or ")}, got ${typeof value}`);
      }
    };
    module.exports = checkType;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/initialize.js
var require_initialize = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/initialize.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { URL: URL4 } = __require("url"), checkType = require_check_type();
    module.exports = (self, proxyOptions) => {
      checkType("proxyOptions", proxyOptions, ["object"]), checkType("proxyOptions.headers", proxyOptions.headers, ["object", "undefined"]), checkType("proxyOptions.raw", proxyOptions.raw, ["boolean", "undefined"]), checkType("proxyOptions.url", proxyOptions.url, [URL4, "string"]);
      let url = new URL4(proxyOptions.url);
      self.proxyOptions = {
        raw: !0,
        ...proxyOptions,
        headers: { ...proxyOptions.headers },
        url
      };
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/get-auth-headers.js
var require_get_auth_headers = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (self) => {
      let { username, password } = self.proxyOptions.url;
      if (username || password) {
        let data = `${username}:${password}`, authorization = `Basic ${Buffer.from(data).toString("base64")}`;
        return {
          "proxy-authorization": authorization,
          authorization
        };
      }
      return {};
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h1-over-h2.js
var require_h1_over_h2 = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var tls = __require("tls"), http3 = __require("http"), https2 = __require("https"), JSStreamSocket = require_js_stream_socket(), { globalAgent } = require_agent(), UnexpectedStatusCodeError = require_unexpected_status_code_error(), initialize = require_initialize(), getAuthorizationHeaders = require_get_auth_headers(), createConnection = (self, options, callback) => {
      (async () => {
        try {
          let { proxyOptions } = self, { url, headers, raw } = proxyOptions, stream2 = await globalAgent.request(url, proxyOptions, {
            ...getAuthorizationHeaders(self),
            ...headers,
            ":method": "CONNECT",
            ":authority": `${options.host}:${options.port}`
          });
          stream2.once("error", callback), stream2.once("response", (headers2) => {
            let statusCode = headers2[":status"];
            if (statusCode !== 200) {
              callback(new UnexpectedStatusCodeError(statusCode, ""));
              return;
            }
            let encrypted = self instanceof https2.Agent;
            if (raw && encrypted) {
              options.socket = stream2;
              let secureStream = tls.connect(options);
              secureStream.once("close", () => {
                stream2.destroy();
              }), callback(null, secureStream);
              return;
            }
            let socket = new JSStreamSocket(stream2);
            socket.encrypted = !1, socket._handle.getpeername = (out) => {
              out.family = void 0, out.address = void 0, out.port = void 0;
            }, callback(null, socket);
          });
        } catch (error) {
          callback(error);
        }
      })();
    }, HttpOverHttp2 = class extends http3.Agent {
      constructor(options) {
        super(options), initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    }, HttpsOverHttp2 = class extends https2.Agent {
      constructor(options) {
        super(options), initialize(this, options.proxyOptions);
      }
      createConnection(options, callback) {
        createConnection(this, options, callback);
      }
    };
    module.exports = {
      HttpOverHttp2,
      HttpsOverHttp2
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h2-over-hx.js
var require_h2_over_hx = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { Agent } = require_agent(), JSStreamSocket = require_js_stream_socket(), UnexpectedStatusCodeError = require_unexpected_status_code_error(), initialize = require_initialize(), Http2OverHttpX = class extends Agent {
      constructor(options) {
        super(options), initialize(this, options.proxyOptions);
      }
      async createConnection(origin, options) {
        let authority = `${origin.hostname}:${origin.port || 443}`, [stream2, statusCode, statusMessage] = await this._getProxyStream(authority);
        if (statusCode !== 200)
          throw new UnexpectedStatusCodeError(statusCode, statusMessage);
        if (this.proxyOptions.raw)
          options.socket = stream2;
        else {
          let socket = new JSStreamSocket(stream2);
          return socket.encrypted = !1, socket._handle.getpeername = (out) => {
            out.family = void 0, out.address = void 0, out.port = void 0;
          }, socket;
        }
        return super.createConnection(origin, options);
      }
    };
    module.exports = Http2OverHttpX;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h2-over-h2.js
var require_h2_over_h2 = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { globalAgent } = require_agent(), Http2OverHttpX = require_h2_over_hx(), getAuthorizationHeaders = require_get_auth_headers(), getStatusCode = (stream2) => new Promise((resolve, reject) => {
      stream2.once("error", reject), stream2.once("response", (headers) => {
        stream2.off("error", reject), resolve(headers[":status"]);
      });
    }), Http2OverHttp2 = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        let { proxyOptions } = this, headers = {
          ...getAuthorizationHeaders(this),
          ...proxyOptions.headers,
          ":method": "CONNECT",
          ":authority": authority
        }, stream2 = await globalAgent.request(proxyOptions.url, proxyOptions, headers), statusCode = await getStatusCode(stream2);
        return [stream2, statusCode, ""];
      }
    };
    module.exports = Http2OverHttp2;
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h2-over-h1.js
var require_h2_over_h1 = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var http3 = __require("http"), https2 = __require("https"), Http2OverHttpX = require_h2_over_hx(), getAuthorizationHeaders = require_get_auth_headers(), getStream3 = (request) => new Promise((resolve, reject) => {
      let onConnect = (response, socket, head) => {
        socket.unshift(head), request.off("error", reject), resolve([socket, response.statusCode, response.statusMessage]);
      };
      request.once("error", reject), request.once("connect", onConnect);
    }), Http2OverHttp = class extends Http2OverHttpX {
      async _getProxyStream(authority) {
        let { proxyOptions } = this, { url, headers } = this.proxyOptions, request = (url.protocol === "https:" ? https2 : http3).request({
          ...proxyOptions,
          hostname: url.hostname,
          port: url.port,
          path: authority,
          headers: {
            ...getAuthorizationHeaders(this),
            ...headers,
            host: authority
          },
          method: "CONNECT"
        }).end();
        return getStream3(request);
      }
    };
    module.exports = {
      Http2OverHttp,
      Http2OverHttps: Http2OverHttp
    };
  }
});

// ../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/index.js
var require_source2 = __commonJS({
  "../../node_modules/.pnpm/http2-wrapper@2.2.1/node_modules/http2-wrapper/source/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var http22 = __require("http2"), {
      Agent,
      globalAgent
    } = require_agent(), ClientRequest = require_client_request(), IncomingMessage = require_incoming_message(), auto = require_auto(), {
      HttpOverHttp2,
      HttpsOverHttp2
    } = require_h1_over_h2(), Http2OverHttp2 = require_h2_over_h2(), {
      Http2OverHttp,
      Http2OverHttps
    } = require_h2_over_h1(), validateHeaderName = require_validate_header_name(), validateHeaderValue = require_validate_header_value(), request = (url, options, callback) => new ClientRequest(url, options, callback), get = (url, options, callback) => {
      let req = new ClientRequest(url, options, callback);
      return req.end(), req;
    };
    module.exports = {
      ...http22,
      ClientRequest,
      IncomingMessage,
      Agent,
      globalAgent,
      request,
      get,
      auto,
      proxies: {
        HttpOverHttp2,
        HttpsOverHttp2,
        Http2OverHttp2,
        Http2OverHttp,
        Http2OverHttps
      },
      validateHeaderName,
      validateHeaderValue
    };
  }
});

// ../../node_modules/.pnpm/ini@1.3.8/node_modules/ini/ini.js
var require_ini = __commonJS({
  "../../node_modules/.pnpm/ini@1.3.8/node_modules/ini/ini.js"(exports) {
    init_cjs_shims();
    exports.parse = exports.decode = decode;
    exports.stringify = exports.encode = encode;
    exports.safe = safe;
    exports.unsafe = unsafe;
    var eol = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
    function encode(obj, opt) {
      var children = [], out = "";
      typeof opt == "string" ? opt = {
        section: opt,
        whitespace: !1
      } : (opt = opt || {}, opt.whitespace = opt.whitespace === !0);
      var separator = opt.whitespace ? " = " : "=";
      return Object.keys(obj).forEach(function(k, _, __) {
        var val = obj[k];
        val && Array.isArray(val) ? val.forEach(function(item) {
          out += safe(k + "[]") + separator + safe(item) + `
`;
        }) : val && typeof val == "object" ? children.push(k) : out += safe(k) + separator + safe(val) + eol;
      }), opt.section && out.length && (out = "[" + safe(opt.section) + "]" + eol + out), children.forEach(function(k, _, __) {
        var nk = dotSplit(k).join("\\."), section = (opt.section ? opt.section + "." : "") + nk, child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        out.length && child.length && (out += eol), out += child;
      }), out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {}, p = out, section = null, re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, lines = str.split(/[\r\n]+/g);
      return lines.forEach(function(line, _, __) {
        if (!(!line || line.match(/^\s*[;#]/))) {
          var match = line.match(re);
          if (match) {
            if (match[1] !== void 0) {
              if (section = unsafe(match[1]), section === "__proto__") {
                p = {};
                return;
              }
              p = out[section] = out[section] || {};
              return;
            }
            var key = unsafe(match[2]);
            if (key !== "__proto__") {
              var value = match[3] ? unsafe(match[4]) : !0;
              switch (value) {
                case "true":
                case "false":
                case "null":
                  value = JSON.parse(value);
              }
              if (key.length > 2 && key.slice(-2) === "[]") {
                if (key = key.substring(0, key.length - 2), key === "__proto__")
                  return;
                p[key] ? Array.isArray(p[key]) || (p[key] = [p[key]]) : p[key] = [];
              }
              Array.isArray(p[key]) ? p[key].push(value) : p[key] = value;
            }
          }
        }
      }), Object.keys(out).filter(function(k, _, __) {
        if (!out[k] || typeof out[k] != "object" || Array.isArray(out[k]))
          return !1;
        var parts = dotSplit(k), p2 = out, l = parts.pop(), nl = l.replace(/\\\./g, ".");
        return parts.forEach(function(part, _2, __2) {
          part !== "__proto__" && ((!p2[part] || typeof p2[part] != "object") && (p2[part] = {}), p2 = p2[part]);
        }), p2 === out && nl === l ? !1 : (p2[nl] = out[k], !0);
      }).forEach(function(del, _, __) {
        delete out[del];
      }), out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val != "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      if (val = (val || "").trim(), isQuoted(val)) {
        val.charAt(0) === "'" && (val = val.substr(1, val.length - 2));
        try {
          val = JSON.parse(val);
        } catch {
        }
      } else {
        for (var esc = !1, unesc = "", i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc)
            "\\;#".indexOf(c) !== -1 ? unesc += c : unesc += "\\" + c, esc = !1;
          else {
            if (";#".indexOf(c) !== -1)
              break;
            c === "\\" ? esc = !0 : unesc += c;
          }
        }
        return esc && (unesc += "\\"), unesc.trim();
      }
      return val;
    }
  }
});

// ../../node_modules/.pnpm/strip-json-comments@2.0.1/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "../../node_modules/.pnpm/strip-json-comments@2.0.1/node_modules/strip-json-comments/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var singleComment = 1, multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, " ");
    }
    module.exports = function(str, opts) {
      opts = opts || {};
      for (var currentChar, nextChar, insideString = !1, insideComment = !1, offset = 0, ret = "", strip = opts.whitespace === !1 ? stripWithoutWhitespace : stripWithWhitespace, i = 0; i < str.length; i++) {
        if (currentChar = str[i], nextChar = str[i + 1], !insideComment && currentChar === '"') {
          var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
          escaped || (insideString = !insideString);
        }
        if (!insideString) {
          if (!insideComment && currentChar + nextChar === "//")
            ret += str.slice(offset, i), offset = i, insideComment = singleComment, i++;
          else if (insideComment === singleComment && currentChar + nextChar === `\r
`) {
            i++, insideComment = !1, ret += strip(str, offset, i), offset = i;
            continue;
          } else if (insideComment === singleComment && currentChar === `
`)
            insideComment = !1, ret += strip(str, offset, i), offset = i;
          else if (!insideComment && currentChar + nextChar === "/*") {
            ret += str.slice(offset, i), offset = i, insideComment = multiComment, i++;
            continue;
          } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
            i++, insideComment = !1, ret += strip(str, offset, i + 1), offset = i + 1;
            continue;
          }
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  }
});

// ../../node_modules/.pnpm/rc@1.2.8/node_modules/rc/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/rc@1.2.8/node_modules/rc/lib/utils.js"(exports) {
    "use strict";
    init_cjs_shims();
    var fs3 = __require("fs"), ini = require_ini(), path4 = __require("path"), stripJsonComments = require_strip_json_comments(), parse = exports.parse = function(content) {
      return /^\s*{/.test(content) ? JSON.parse(stripJsonComments(content)) : ini.parse(content);
    }, file = exports.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if (typeof args[i] != "string")
          return;
      var file2 = path4.join.apply(null, args), content;
      try {
        return fs3.readFileSync(file2, "utf-8");
      } catch {
        return;
      }
    }, json = exports.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse(content) : null;
    }, env = exports.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {}, l = prefix.length;
      for (var k in env2)
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          for (var keypath = k.substring(l).split("__"), _emptyStringIndex; (_emptyStringIndex = keypath.indexOf("")) > -1; )
            keypath.splice(_emptyStringIndex, 1);
          var cursor = obj;
          keypath.forEach(function(_subkey, i) {
            !_subkey || typeof cursor != "object" || (i === keypath.length - 1 && (cursor[_subkey] = env2[k]), cursor[_subkey] === void 0 && (cursor[_subkey] = {}), cursor = cursor[_subkey]);
          });
        }
      return obj;
    }, find = exports.find = function() {
      var rel = path4.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path4.join(start, rel2);
        try {
          return fs3.statSync(file2), file2;
        } catch {
          if (path4.dirname(start) !== start)
            return find2(path4.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// ../../node_modules/.pnpm/deep-extend@0.6.0/node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "../../node_modules/.pnpm/deep-extend@0.6.0/node_modules/deep-extend/lib/deep-extend.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        return val.copy(x), x;
      } else {
        if (val instanceof Date)
          return new Date(val.getTime());
        if (val instanceof RegExp)
          return new RegExp(val);
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      return arr.forEach(function(item, index) {
        typeof item == "object" && item !== null ? Array.isArray(item) ? clone[index] = deepCloneArray(item) : isSpecificValue(item) ? clone[index] = cloneSpecificValue(item) : clone[index] = deepExtend({}, item) : clone[index] = item;
      }), clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] != "object")
        return !1;
      if (arguments.length < 2)
        return arguments[0];
      var target = arguments[0], args = Array.prototype.slice.call(arguments, 1), val, src, clone;
      return args.forEach(function(obj) {
        typeof obj != "object" || obj === null || Array.isArray(obj) || Object.keys(obj).forEach(function(key) {
          if (src = safeGetProperty(target, key), val = safeGetProperty(obj, key), val !== target)
            if (typeof val != "object" || val === null) {
              target[key] = val;
              return;
            } else if (Array.isArray(val)) {
              target[key] = deepCloneArray(val);
              return;
            } else if (isSpecificValue(val)) {
              target[key] = cloneSpecificValue(val);
              return;
            } else if (typeof src != "object" || src === null || Array.isArray(src)) {
              target[key] = deepExtend({}, val);
              return;
            } else {
              target[key] = deepExtend(src, val);
              return;
            }
        });
      }), target;
    };
  }
});

// ../../node_modules/.pnpm/minimist@1.2.8/node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../../node_modules/.pnpm/minimist@1.2.8/node_modules/minimist/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      return typeof x == "number" || /^0x[0-9a-f]+$/i.test(x) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] == "function" || key === "__proto__";
    }
    module.exports = function(args, opts) {
      opts || (opts = {});
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      typeof opts.unknown == "function" && (flags.unknownFn = opts.unknown), typeof opts.boolean == "boolean" && opts.boolean ? flags.allBools = !0 : [].concat(opts.boolean).filter(Boolean).forEach(function(key2) {
        flags.bools[key2] = !0;
      });
      var aliases2 = {};
      function aliasIsBoolean(key2) {
        return aliases2[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases2[key2] = [].concat(opts.alias[key2]), aliases2[key2].forEach(function(x) {
          aliases2[x] = [key2].concat(aliases2[key2].filter(function(y) {
            return x !== y;
          }));
        });
      }), [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = !0, aliases2[key2] && [].concat(aliases2[key2]).forEach(function(k) {
          flags.strings[k] = !0;
        });
      });
      var defaults2 = opts.default || {}, argv = { _: [] };
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases2[key2];
      }
      function setKey(obj, keys, value2) {
        for (var o = obj, i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2))
            return;
          o[key2] === void 0 && (o[key2] = {}), (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) && (o[key2] = {}), o[key2] === Array.prototype && (o[key2] = []), o = o[key2];
        }
        var lastKey = keys[keys.length - 1];
        isConstructorOrProto(o, lastKey) || ((o === Object.prototype || o === Number.prototype || o === String.prototype) && (o = {}), o === Array.prototype && (o = []), o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] == "boolean" ? o[lastKey] = value2 : Array.isArray(o[lastKey]) ? o[lastKey].push(value2) : o[lastKey] = [o[lastKey], value2]);
      }
      function setArg(key2, val, arg2) {
        if (!(arg2 && flags.unknownFn && !argDefined(key2, arg2) && flags.unknownFn(arg2) === !1)) {
          var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
          setKey(argv, key2.split("."), value2), (aliases2[key2] || []).forEach(function(x) {
            setKey(argv, x.split("."), value2);
          });
        }
      }
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults2[key2] === void 0 ? !1 : defaults2[key2]);
      });
      var notFlags = [];
      args.indexOf("--") !== -1 && (notFlags = args.slice(args.indexOf("--") + 1), args = args.slice(0, args.indexOf("--")));
      for (var i = 0; i < args.length; i++) {
        var arg = args[i], key, next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key = m[1];
          var value = m[2];
          flags.bools[key] && (value = value !== "false"), setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg))
          key = arg.match(/^--no-(.+)/)[1], setArg(key, !1, arg);
        else if (/^--.+/.test(arg))
          key = arg.match(/^--(.+)/)[1], next = args[i + 1], next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key] && !flags.allBools && (!aliases2[key] || !aliasIsBoolean(key)) ? (setArg(key, next, arg), i += 1) : /^(true|false)$/.test(next) ? (setArg(key, next === "true", arg), i += 1) : setArg(key, flags.strings[key] ? "" : !0, arg);
        else if (/^-[^-]+/.test(arg)) {
          for (var letters = arg.slice(1, -1).split(""), broken = !1, j = 0; j < letters.length; j++) {
            if (next = arg.slice(j + 2), next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg), broken = !0;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg), broken = !0;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg), broken = !0;
              break;
            } else
              setArg(letters[j], flags.strings[letters[j]] ? "" : !0, arg);
          }
          key = arg.slice(-1)[0], !broken && key !== "-" && (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (!aliases2[key] || !aliasIsBoolean(key)) ? (setArg(key, args[i + 1], arg), i += 1) : args[i + 1] && /^(true|false)$/.test(args[i + 1]) ? (setArg(key, args[i + 1] === "true", arg), i += 1) : setArg(key, flags.strings[key] ? "" : !0, arg));
        } else if ((!flags.unknownFn || flags.unknownFn(arg) !== !1) && argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg)), opts.stopEarly) {
          argv._.push.apply(argv._, args.slice(i + 1));
          break;
        }
      }
      return Object.keys(defaults2).forEach(function(k) {
        hasKey(argv, k.split(".")) || (setKey(argv, k.split("."), defaults2[k]), (aliases2[k] || []).forEach(function(x) {
          setKey(argv, x.split("."), defaults2[k]);
        }));
      }), opts["--"] ? argv["--"] = notFlags.slice() : notFlags.forEach(function(k) {
        argv._.push(k);
      }), argv;
    };
  }
});

// ../../node_modules/.pnpm/rc@1.2.8/node_modules/rc/index.js
var require_rc = __commonJS({
  "../../node_modules/.pnpm/rc@1.2.8/node_modules/rc/index.js"(exports, module) {
    init_cjs_shims();
    var cc = require_utils2(), join = __require("path").join, deepExtend = require_deep_extend(), etc = "/etc", win = process.platform === "win32", home = win ? process.env.USERPROFILE : process.env.HOME;
    module.exports = function(name, defaults2, argv, parse) {
      if (typeof name != "string")
        throw new Error("rc(name): name *must* be string");
      argv || (argv = require_minimist()(process.argv.slice(2))), defaults2 = (typeof defaults2 == "string" ? cc.json(defaults2) : defaults2) || {}, parse = parse || cc.parse;
      var env = cc.env(name + "_"), configs = [defaults2], configFiles = [];
      function addConfigFile(file) {
        if (!(configFiles.indexOf(file) >= 0)) {
          var fileConfig = cc.file(file);
          fileConfig && (configs.push(parse(fileConfig)), configFiles.push(file));
        }
      }
      return win || [
        join(etc, name, "config"),
        join(etc, name + "rc")
      ].forEach(addConfigFile), home && [
        join(home, ".config", name, "config"),
        join(home, ".config", name),
        join(home, "." + name, "config"),
        join(home, "." + name + "rc")
      ].forEach(addConfigFile), addConfigFile(cc.find("." + name + "rc")), env.config && addConfigFile(env.config), argv.config && addConfigFile(argv.config), deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js"(exports, module) {
    init_cjs_shims();
    var constants = __require("constants"), origCwd = process.cwd, cwd = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      return cwd || (cwd = origCwd.call(process)), cwd;
    };
    try {
      process.cwd();
    } catch {
    }
    typeof process.chdir == "function" && (chdir = process.chdir, process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, chdir));
    var chdir;
    module.exports = patch;
    function patch(fs3) {
      constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && patchLchmod(fs3), fs3.lutimes || patchLutimes(fs3), fs3.chown = chownFix(fs3.chown), fs3.fchown = chownFix(fs3.fchown), fs3.lchown = chownFix(fs3.lchown), fs3.chmod = chmodFix(fs3.chmod), fs3.fchmod = chmodFix(fs3.fchmod), fs3.lchmod = chmodFix(fs3.lchmod), fs3.chownSync = chownFixSync(fs3.chownSync), fs3.fchownSync = chownFixSync(fs3.fchownSync), fs3.lchownSync = chownFixSync(fs3.lchownSync), fs3.chmodSync = chmodFixSync(fs3.chmodSync), fs3.fchmodSync = chmodFixSync(fs3.fchmodSync), fs3.lchmodSync = chmodFixSync(fs3.lchmodSync), fs3.stat = statFix(fs3.stat), fs3.fstat = statFix(fs3.fstat), fs3.lstat = statFix(fs3.lstat), fs3.statSync = statFixSync(fs3.statSync), fs3.fstatSync = statFixSync(fs3.fstatSync), fs3.lstatSync = statFixSync(fs3.lstatSync), fs3.chmod && !fs3.lchmod && (fs3.lchmod = function(path4, mode, cb) {
        cb && process.nextTick(cb);
      }, fs3.lchmodSync = function() {
      }), fs3.chown && !fs3.lchown && (fs3.lchown = function(path4, uid, gid, cb) {
        cb && process.nextTick(cb);
      }, fs3.lchownSync = function() {
      }), platform === "win32" && (fs3.rename = typeof fs3.rename != "function" ? fs3.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now(), backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs3.stat(to, function(stater, st) {
                  stater && stater.code === "ENOENT" ? fs$rename(from, to, CB) : cb(er);
                });
              }, backoff), backoff < 100 && (backoff += 10);
              return;
            }
            cb && cb(er);
          });
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(rename, fs$rename), rename;
      }(fs3.rename)), fs3.read = typeof fs3.read != "function" ? fs3.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ == "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10)
                return eagCounter++, fs$read.call(fs3, fd, buffer, offset, length, position, callback);
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs3, fd, buffer, offset, length, position, callback);
        }
        return Object.setPrototypeOf && Object.setPrototypeOf(read, fs$read), read;
      }(fs3.read), fs3.readSync = typeof fs3.readSync != "function" ? fs3.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          for (var eagCounter = 0; ; )
            try {
              return fs$readSync.call(fs3, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
        };
      }(fs3.readSync);
      function patchLchmod(fs4) {
        fs4.lchmod = function(path4, mode, callback) {
          fs4.open(
            path4,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                callback && callback(err);
                return;
              }
              fs4.fchmod(fd, mode, function(err2) {
                fs4.close(fd, function(err22) {
                  callback && callback(err2 || err22);
                });
              });
            }
          );
        }, fs4.lchmodSync = function(path4, mode) {
          var fd = fs4.openSync(path4, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0, ret;
          try {
            ret = fs4.fchmodSync(fd, mode), threw = !1;
          } finally {
            if (threw)
              try {
                fs4.closeSync(fd);
              } catch {
              }
            else
              fs4.closeSync(fd);
          }
          return ret;
        };
      }
      function patchLutimes(fs4) {
        constants.hasOwnProperty("O_SYMLINK") && fs4.futimes ? (fs4.lutimes = function(path4, at, mt, cb) {
          fs4.open(path4, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              cb && cb(er);
              return;
            }
            fs4.futimes(fd, at, mt, function(er2) {
              fs4.close(fd, function(er22) {
                cb && cb(er2 || er22);
              });
            });
          });
        }, fs4.lutimesSync = function(path4, at, mt) {
          var fd = fs4.openSync(path4, constants.O_SYMLINK), ret, threw = !0;
          try {
            ret = fs4.futimesSync(fd, at, mt), threw = !1;
          } finally {
            if (threw)
              try {
                fs4.closeSync(fd);
              } catch {
              }
            else
              fs4.closeSync(fd);
          }
          return ret;
        }) : fs4.futimes && (fs4.lutimes = function(_a, _b, _c, cb) {
          cb && process.nextTick(cb);
        }, fs4.lutimesSync = function() {
        });
      }
      function chmodFix(orig) {
        return orig && function(target, mode, cb) {
          return orig.call(fs3, target, mode, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        return orig && function(target, mode) {
          try {
            return orig.call(fs3, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        return orig && function(target, uid, gid, cb) {
          return orig.call(fs3, target, uid, gid, function(er) {
            chownErOk(er) && (er = null), cb && cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        return orig && function(target, uid, gid) {
          try {
            return orig.call(fs3, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        return orig && function(target, options, cb) {
          typeof options == "function" && (cb = options, options = null);
          function callback(er, stats) {
            stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), cb && cb.apply(this, arguments);
          }
          return options ? orig.call(fs3, target, options, callback) : orig.call(fs3, target, callback);
        };
      }
      function statFixSync(orig) {
        return orig && function(target, options) {
          var stats = options ? orig.call(fs3, target, options) : orig.call(fs3, target);
          return stats && (stats.uid < 0 && (stats.uid += 4294967296), stats.gid < 0 && (stats.gid += 4294967296)), stats;
        };
      }
      function chownErOk(er) {
        if (!er || er.code === "ENOSYS")
          return !0;
        var nonroot = !process.getuid || process.getuid() !== 0;
        return !!(nonroot && (er.code === "EINVAL" || er.code === "EPERM"));
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    init_cjs_shims();
    var Stream = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs3) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path4, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path4, options);
        Stream.call(this);
        var self = this;
        this.path = path4, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.end === void 0)
            this.end = 1 / 0;
          else if (typeof this.end != "number")
            throw TypeError("end must be a Number");
          if (this.start > this.end)
            throw new Error("start must be <= end");
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs3.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err), self.readable = !1;
            return;
          }
          self.fd = fd, self.emit("open", fd), self._read();
        });
      }
      function WriteStream(path4, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path4, options);
        Stream.call(this), this.path = path4, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
        for (var keys = Object.keys(options), index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start != "number")
            throw TypeError("start must be a Number");
          if (this.start < 0)
            throw new Error("start must be >= zero");
          this.pos = this.start;
        }
        this.busy = !1, this._queue = [], this.fd === null && (this._open = fs3.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj != "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      return Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      }), copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    init_cjs_shims();
    var fs3 = __require("fs"), polyfills = require_polyfills(), legacy = require_legacy_streams(), clone = require_clone(), util = __require("util"), gracefulQueue, previousSymbol;
    typeof Symbol == "function" && typeof Symbol.for == "function" ? (gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous")) : (gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous");
    function noop3() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop3;
    util.debuglog ? debug = util.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
    });
    fs3[gracefulQueue] || (queue = global[gracefulQueue] || [], publishQueue(fs3, queue), fs3.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs3, fd, function(err) {
          err || resetQueue(), typeof cb == "function" && cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs3.close), fs3.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs3, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs3.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
      debug(fs3[gracefulQueue]), __require("assert").equal(fs3[gracefulQueue].length, 0);
    }));
    var queue;
    global[gracefulQueue] || publishQueue(global, fs3[gracefulQueue]);
    module.exports = patch(clone(fs3));
    process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs3.__patched && (module.exports = patch(fs3), fs3.__patched = !0);
    function patch(fs4) {
      polyfills(fs4), fs4.gracefulify = patch, fs4.createReadStream = createReadStream, fs4.createWriteStream = createWriteStream;
      var fs$readFile = fs4.readFile;
      fs4.readFile = readFile2;
      function readFile2(path4, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$readFile(path4, options, cb);
        function go$readFile(path5, options2, cb2, startTime) {
          return fs$readFile(path5, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$readFile, [path5, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$writeFile = fs4.writeFile;
      fs4.writeFile = writeFile2;
      function writeFile2(path4, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$writeFile(path4, data, options, cb);
        function go$writeFile(path5, data2, options2, cb2, startTime) {
          return fs$writeFile(path5, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$writeFile, [path5, data2, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$appendFile = fs4.appendFile;
      fs$appendFile && (fs4.appendFile = appendFile);
      function appendFile(path4, data, options, cb) {
        return typeof options == "function" && (cb = options, options = null), go$appendFile(path4, data, options, cb);
        function go$appendFile(path5, data2, options2, cb2, startTime) {
          return fs$appendFile(path5, data2, options2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$appendFile, [path5, data2, options2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$copyFile = fs4.copyFile;
      fs$copyFile && (fs4.copyFile = copyFile);
      function copyFile(src, dest, flags, cb) {
        return typeof flags == "function" && (cb = flags, flags = 0), go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      var fs$readdir = fs4.readdir;
      fs4.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path4, options, cb) {
        typeof options == "function" && (cb = options, options = null);
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path5, options2, cb2, startTime) {
          return fs$readdir(path5, fs$readdirCallback(
            path5,
            options2,
            cb2,
            startTime
          ));
        } : function(path5, options2, cb2, startTime) {
          return fs$readdir(path5, options2, fs$readdirCallback(
            path5,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path4, options, cb);
        function fs$readdirCallback(path5, options2, cb2, startTime) {
          return function(err, files) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([
              go$readdir,
              [path5, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]) : (files && files.sort && files.sort(), typeof cb2 == "function" && cb2.call(this, err, files));
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs4);
        ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs4.ReadStream;
      fs$ReadStream && (ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open);
      var fs$WriteStream = fs4.WriteStream;
      fs$WriteStream && (WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open), Object.defineProperty(fs4, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      }), Object.defineProperty(fs4, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs4, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs4, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: !0,
        configurable: !0
      });
      function ReadStream(path4, options) {
        return this instanceof ReadStream ? (fs$ReadStream.apply(this, arguments), this) : ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.autoClose && that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd), that.read());
        });
      }
      function WriteStream(path4, options) {
        return this instanceof WriteStream ? (fs$WriteStream.apply(this, arguments), this) : WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          err ? (that.destroy(), that.emit("error", err)) : (that.fd = fd, that.emit("open", fd));
        });
      }
      function createReadStream(path4, options) {
        return new fs4.ReadStream(path4, options);
      }
      function createWriteStream(path4, options) {
        return new fs4.WriteStream(path4, options);
      }
      var fs$open = fs4.open;
      fs4.open = open;
      function open(path4, flags, mode, cb) {
        return typeof mode == "function" && (cb = mode, mode = null), go$open(path4, flags, mode, cb);
        function go$open(path5, flags2, mode2, cb2, startTime) {
          return fs$open(path5, flags2, mode2, function(err, fd) {
            err && (err.code === "EMFILE" || err.code === "ENFILE") ? enqueue([go$open, [path5, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]) : typeof cb2 == "function" && cb2.apply(this, arguments);
          });
        }
      }
      return fs4;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]), fs3[gracefulQueue].push(elem), retry();
    }
    var retryTimer;
    function resetQueue() {
      for (var now = Date.now(), i = 0; i < fs3[gracefulQueue].length; ++i)
        fs3[gracefulQueue][i].length > 2 && (fs3[gracefulQueue][i][3] = now, fs3[gracefulQueue][i][4] = now);
      retry();
    }
    function retry() {
      if (clearTimeout(retryTimer), retryTimer = void 0, fs3[gracefulQueue].length !== 0) {
        var elem = fs3[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
        if (startTime === void 0)
          debug("RETRY", fn.name, args), fn.apply(null, args);
        else if (Date.now() - startTime >= 6e4) {
          debug("TIMEOUT", fn.name, args);
          var cb = args.pop();
          typeof cb == "function" && cb.call(null, err);
        } else {
          var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
          sinceAttempt >= desiredDelay ? (debug("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]))) : fs3[gracefulQueue].push(elem);
        }
        retryTimer === void 0 && (retryTimer = setTimeout(retry, 0));
      }
    }
  }
});

// ../../node_modules/.pnpm/@pnpm+network.ca-file@1.0.2/node_modules/@pnpm/network.ca-file/dist/ca-file.js
var require_ca_file = __commonJS({
  "../../node_modules/.pnpm/@pnpm+network.ca-file@1.0.2/node_modules/@pnpm/network.ca-file/dist/ca-file.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.readCAFileSync = void 0;
    var graceful_fs_1 = __importDefault(require_graceful_fs());
    function readCAFileSync(filePath) {
      try {
        let contents = graceful_fs_1.default.readFileSync(filePath, "utf8"), delim = "-----END CERTIFICATE-----";
        return contents.split(delim).filter((ca) => !!ca.trim()).map((ca) => `${ca.trimLeft()}${delim}`);
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
    }
    exports.readCAFileSync = readCAFileSync;
  }
});

// ../../node_modules/.pnpm/@pnpm+network.ca-file@1.0.2/node_modules/@pnpm/network.ca-file/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/@pnpm+network.ca-file@1.0.2/node_modules/@pnpm/network.ca-file/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_ca_file(), exports);
  }
});

// ../../node_modules/.pnpm/proto-list@1.2.4/node_modules/proto-list/proto-list.js
var require_proto_list = __commonJS({
  "../../node_modules/.pnpm/proto-list@1.2.4/node_modules/proto-list/proto-list.js"(exports, module) {
    init_cjs_shims();
    module.exports = ProtoList;
    function setProto(obj, proto) {
      if (typeof Object.setPrototypeOf == "function")
        return Object.setPrototypeOf(obj, proto);
      obj.__proto__ = proto;
    }
    function ProtoList() {
      this.list = [];
      var root = null;
      Object.defineProperty(this, "root", {
        get: function() {
          return root;
        },
        set: function(r) {
          root = r, this.list.length && setProto(this.list[this.list.length - 1], r);
        },
        enumerable: !0,
        configurable: !0
      });
    }
    ProtoList.prototype = {
      get length() {
        return this.list.length;
      },
      get keys() {
        var k = [];
        for (var i in this.list[0]) k.push(i);
        return k;
      },
      get snapshot() {
        var o = {};
        return this.keys.forEach(function(k) {
          o[k] = this.get(k);
        }, this), o;
      },
      get store() {
        return this.list[0];
      },
      push: function(obj) {
        return typeof obj != "object" && (obj = { valueOf: obj }), this.list.length >= 1 && setProto(this.list[this.list.length - 1], obj), setProto(obj, this.root), this.list.push(obj);
      },
      pop: function() {
        return this.list.length >= 2 && setProto(this.list[this.list.length - 2], this.root), this.list.pop();
      },
      unshift: function(obj) {
        return setProto(obj, this.list[0] || this.root), this.list.unshift(obj);
      },
      shift: function() {
        return this.list.length === 1 && setProto(this.list[0], this.root), this.list.shift();
      },
      get: function(key) {
        return this.list[0][key];
      },
      set: function(key, val, save) {
        return this.length || this.push({}), save && this.list[0].hasOwnProperty(key) && this.push({}), this.list[0][key] = val;
      },
      forEach: function(fn, thisp) {
        for (var key in this.list[0]) fn.call(thisp, key, this.list[0][key]);
      },
      slice: function() {
        return this.list.slice.apply(this.list, arguments);
      },
      splice: function() {
        for (var ret = this.list.splice.apply(this.list, arguments), i = 0, l = this.list.length; i < l; i++)
          setProto(this.list[i], this.list[i + 1] || this.root);
        return ret;
      }
    };
  }
});

// ../../node_modules/.pnpm/config-chain@1.1.13/node_modules/config-chain/index.js
var require_config_chain = __commonJS({
  "../../node_modules/.pnpm/config-chain@1.1.13/node_modules/config-chain/index.js"(exports, module) {
    init_cjs_shims();
    var ProtoList = require_proto_list(), path4 = __require("path"), fs3 = __require("fs"), ini = require_ini(), EE = __require("events").EventEmitter, url = __require("url"), http3 = __require("http"), exports = module.exports = function() {
      for (var args = [].slice.call(arguments), conf = new ConfigChain(); args.length; ) {
        var a = args.shift();
        a && conf.push(typeof a == "string" ? json(a) : a);
      }
      return conf;
    }, find = exports.find = function() {
      var rel = path4.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file = path4.join(start, rel2);
        try {
          return fs3.statSync(file), file;
        } catch {
          if (path4.dirname(start) !== start)
            return find2(path4.dirname(start), rel2);
        }
      }
      return find2(__dirname, rel);
    }, parse = exports.parse = function(content, file, type) {
      if (content = "" + content, type)
        if (type === "json")
          if (this.emit)
            try {
              return JSON.parse(content);
            } catch (er) {
              this.emit("error", er);
            }
          else
            return JSON.parse(content);
        else
          return ini.parse(content);
      else try {
        return JSON.parse(content);
      } catch {
        return ini.parse(content);
      }
    }, json = exports.json = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      }), file = path4.join.apply(null, args), content;
      try {
        content = fs3.readFileSync(file, "utf-8");
      } catch {
        return;
      }
      return parse(content, file, "json");
    }, env = exports.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {}, l = prefix.length;
      for (var k in env2)
        k.indexOf(prefix) === 0 && (obj[k.substring(l)] = env2[k]);
      return obj;
    };
    exports.ConfigChain = ConfigChain;
    function ConfigChain() {
      EE.apply(this), ProtoList.apply(this, arguments), this._awaiting = 0, this._saving = 0, this.sources = {};
    }
    var extras = {
      constructor: { value: ConfigChain }
    };
    Object.keys(EE.prototype).forEach(function(k) {
      extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
    });
    ConfigChain.prototype = Object.create(ProtoList.prototype, extras);
    ConfigChain.prototype.del = function(key, where) {
      if (where) {
        var target = this.sources[where];
        if (target = target && target.data, !target)
          return this.emit("error", new Error("not found " + where));
        delete target[key];
      } else
        for (var i = 0, l = this.list.length; i < l; i++)
          delete this.list[i][key];
      return this;
    };
    ConfigChain.prototype.set = function(key, value, where) {
      var target;
      if (where) {
        if (target = this.sources[where], target = target && target.data, !target)
          return this.emit("error", new Error("not found " + where));
      } else if (target = this.list[0], !target)
        return this.emit("error", new Error("cannot set, no confs!"));
      return target[key] = value, this;
    };
    ConfigChain.prototype.get = function(key, where) {
      return where ? (where = this.sources[where], where && (where = where.data), where && Object.hasOwnProperty.call(where, key) ? where[key] : void 0) : this.list[0][key];
    };
    ConfigChain.prototype.save = function(where, type, cb) {
      typeof type == "function" && (cb = type, type = null);
      var target = this.sources[where];
      if (!target || !(target.path || target.source) || !target.data)
        return this.emit("error", new Error("bad save target: " + where));
      if (target.source) {
        var pref = target.prefix || "";
        return Object.keys(target.data).forEach(function(k) {
          target.source[pref + k] = target.data[k];
        }), this;
      }
      var type = type || target.type, data = target.data;
      return target.type === "json" ? data = JSON.stringify(data) : data = ini.stringify(data), this._saving++, fs3.writeFile(target.path, data, "utf8", function(er) {
        if (this._saving--, er)
          return cb ? cb(er) : this.emit("error", er);
        this._saving === 0 && (cb && cb(), this.emit("save"));
      }.bind(this)), this;
    };
    ConfigChain.prototype.addFile = function(file, type, name) {
      name = name || file;
      var marker = { __source__: name };
      return this.sources[name] = { path: file, type }, this.push(marker), this._await(), fs3.readFile(file, "utf8", function(er, data) {
        er && this.emit("error", er), this.addString(data, file, type, marker);
      }.bind(this)), this;
    };
    ConfigChain.prototype.addEnv = function(prefix, env2, name) {
      name = name || "env";
      var data = exports.env(prefix, env2);
      return this.sources[name] = { data, source: env2, prefix }, this.add(data, name);
    };
    ConfigChain.prototype.addUrl = function(req, type, name) {
      this._await();
      var href = url.format(req);
      name = name || href;
      var marker = { __source__: name };
      return this.sources[name] = { href, type }, this.push(marker), http3.request(req, function(res) {
        var c = [], ct = res.headers["content-type"];
        type || (type = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null, marker.type = type), res.on("data", c.push.bind(c)).on("end", function() {
          this.addString(Buffer.concat(c), href, type, marker);
        }.bind(this)).on("error", this.emit.bind(this, "error"));
      }.bind(this)).on("error", this.emit.bind(this, "error")).end(), this;
    };
    ConfigChain.prototype.addString = function(data, file, type, marker) {
      return data = this.parse(data, file, type), this.add(data, marker), this;
    };
    ConfigChain.prototype.add = function(data, marker) {
      if (marker && typeof marker == "object") {
        var i = this.list.indexOf(marker);
        if (i === -1)
          return this.emit("error", new Error("bad marker"));
        this.splice(i, 1, data), marker = marker.__source__, this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data, this._resolve();
      } else
        typeof marker == "string" && (this.sources[marker] = this.sources[marker] || {}, this.sources[marker].data = data), this._await(), this.push(data), process.nextTick(this._resolve.bind(this));
      return this;
    };
    ConfigChain.prototype.parse = exports.parse;
    ConfigChain.prototype._await = function() {
      this._awaiting++;
    };
    ConfigChain.prototype._resolve = function() {
      this._awaiting--, this._awaiting === 0 && this.emit("load", this);
    };
  }
});

// ../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/envKeyToSetting.js
var require_envKeyToSetting = __commonJS({
  "../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/envKeyToSetting.js"(exports, module) {
    init_cjs_shims();
    module.exports = function(x) {
      let colonIndex = x.indexOf(":");
      if (colonIndex === -1)
        return normalize(x);
      let firstPart = x.substr(0, colonIndex), secondPart = x.substr(colonIndex + 1);
      return `${normalize(firstPart)}:${normalize(secondPart)}`;
    };
    function normalize(s) {
      if (s = s.toLowerCase(), s === "_authtoken") return "_authToken";
      let r = s[0];
      for (let i = 1; i < s.length; i++)
        r += s[i] === "_" ? "-" : s[i];
      return r;
    }
  }
});

// ../../node_modules/.pnpm/@pnpm+config.env-replace@1.1.0/node_modules/@pnpm/config.env-replace/dist/env-replace.js
var require_env_replace = __commonJS({
  "../../node_modules/.pnpm/@pnpm+config.env-replace@1.1.0/node_modules/@pnpm/config.env-replace/dist/env-replace.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.envReplace = void 0;
    var ENV_EXPR = /(?<!\\)(\\*)\$\{([^${}]+)\}/g;
    function envReplace(settingValue, env) {
      return settingValue.replace(ENV_EXPR, replaceEnvMatch.bind(null, env));
    }
    exports.envReplace = envReplace;
    function replaceEnvMatch(env, orig, escape2, name) {
      if (escape2.length % 2)
        return orig.slice((escape2.length + 1) / 2);
      let envValue = getEnvValue(env, name);
      if (envValue === void 0)
        throw new Error(`Failed to replace env in config: ${orig}`);
      return `${escape2.slice(escape2.length / 2)}${envValue}`;
    }
    var ENV_VALUE = /([^:-]+)(:?)-(.+)/;
    function getEnvValue(env, name) {
      let matched = name.match(ENV_VALUE);
      if (!matched)
        return env[name];
      let [, variableName, colon, fallback] = matched;
      return Object.prototype.hasOwnProperty.call(env, variableName) ? !env[variableName] && colon ? fallback : env[variableName] : fallback;
    }
  }
});

// ../../node_modules/.pnpm/@pnpm+config.env-replace@1.1.0/node_modules/@pnpm/config.env-replace/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/.pnpm/@pnpm+config.env-replace@1.1.0/node_modules/@pnpm/config.env-replace/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.envReplace = void 0;
    var env_replace_1 = require_env_replace();
    Object.defineProperty(exports, "envReplace", { enumerable: !0, get: function() {
      return env_replace_1.envReplace;
    } });
  }
});

// ../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    var fs3 = __require("fs"), path4 = __require("path"), { envReplace } = require_dist3(), parseKey = (key) => typeof key != "string" ? key : envReplace(key, process.env), parseField = (types2, field, key) => {
      if (typeof field != "string")
        return field;
      let typeList = [].concat(types2[key]), isPath = typeList.indexOf(path4) !== -1, isBool = typeList.indexOf(Boolean) !== -1, isString2 = typeList.indexOf(String) !== -1, isNumber = typeList.indexOf(Number) !== -1;
      if (field = `${field}`.trim(), /^".*"$/.test(field))
        try {
          field = JSON.parse(field);
        } catch {
          throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
        }
      if (isBool && !isString2 && field === "")
        return !0;
      switch (field) {
        // eslint-disable-line default-case
        case "true":
          return !0;
        case "false":
          return !1;
        case "null":
          return null;
        case "undefined":
          return;
      }
      return field = envReplace(field, process.env), isPath && ((process.platform === "win32" ? /^~(\/|\\)/ : /^~\//).test(field) && process.env.HOME && (field = path4.resolve(process.env.HOME, field.substr(2))), field = path4.resolve(field)), isNumber && !isNaN(field) && (field = Number(field)), field;
    }, findPrefix = (name) => {
      name = path4.resolve(name);
      let walkedUp = !1;
      for (; path4.basename(name) === "node_modules"; )
        name = path4.dirname(name), walkedUp = !0;
      if (walkedUp)
        return name;
      let find = (name2, original) => {
        let regex = /^[a-zA-Z]:(\\|\/)?$/;
        if (name2 === "/" || process.platform === "win32" && regex.test(name2))
          return original;
        try {
          let files = fs3.readdirSync(name2);
          if (files.includes("node_modules") || files.includes("package.json") || files.includes("package.json5") || files.includes("package.yaml") || files.includes("pnpm-workspace.yaml"))
            return name2;
          let dirname2 = path4.dirname(name2);
          return dirname2 === name2 ? original : find(dirname2, original);
        } catch (error) {
          if (name2 === original) {
            if (error.code === "ENOENT")
              return original;
            throw error;
          }
          return original;
        }
      };
      return find(name, name);
    };
    exports.envReplace = envReplace;
    exports.findPrefix = findPrefix;
    exports.parseField = parseField;
    exports.parseKey = parseKey;
  }
});

// ../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    var path4 = __require("path"), Stream = __require("stream").Stream, url = __require("url"), Umask = () => {
    }, getLocalAddresses = () => [], semver3 = () => {
    };
    exports.types = {
      access: [null, "restricted", "public"],
      "allow-same-version": Boolean,
      "always-auth": Boolean,
      also: [null, "dev", "development"],
      audit: Boolean,
      "auth-type": ["legacy", "sso", "saml", "oauth"],
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: path4,
      cache: path4,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      cidr: [null, String, Array],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      "dry-run": Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      "commit-hooks": Boolean,
      global: Boolean,
      globalconfig: path4,
      "global-style": Boolean,
      group: [Number, String],
      "https-proxy": [null, url],
      "user-agent": String,
      "ham-it-up": Boolean,
      heading: String,
      "if-present": Boolean,
      "ignore-prepublish": Boolean,
      "ignore-scripts": Boolean,
      "init-module": path4,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", url],
      "init-license": String,
      "init-version": semver3,
      json: Boolean,
      key: [null, String],
      "legacy-bundling": Boolean,
      link: Boolean,
      // local-address must be listed as an IP for a local network interface
      // must be IPv4 due to node bug
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
      logstream: Stream,
      "logs-max": Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "metrics-registry": [null, String],
      "node-options": [null, String],
      "node-version": [null, semver3],
      "no-proxy": [null, String, Array],
      offline: Boolean,
      "onload-script": [null, String],
      only: [null, "dev", "development", "prod", "production"],
      optional: Boolean,
      "package-lock": Boolean,
      otp: [null, String],
      "package-lock-only": Boolean,
      parseable: Boolean,
      "prefer-offline": Boolean,
      "prefer-online": Boolean,
      prefix: path4,
      production: Boolean,
      progress: Boolean,
      proxy: [null, !1, url],
      provenance: Boolean,
      // allow proxy to be disabled explicitly
      "read-only": Boolean,
      "rebuild-bundle": Boolean,
      registry: [null, url],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      "save-prod": Boolean,
      scope: String,
      "script-shell": [null, String],
      "scripts-prepend-node-path": [!1, !0, "auto", "warn-only"],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      "send-metrics": Boolean,
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-tag": Boolean,
      "sso-poll-frequency": Number,
      "sso-type": [null, "oauth", "saml"],
      "strict-ssl": Boolean,
      tag: String,
      timing: Boolean,
      tmp: path4,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: path4,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
  }
});

// ../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/conf.js
var require_conf = __commonJS({
  "../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/conf.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { readCAFileSync } = require_dist2(), fs3 = __require("fs"), path4 = __require("path"), { ConfigChain } = require_config_chain(), envKeyToSetting = require_envKeyToSetting(), util = require_util2(), Conf2 = class extends ConfigChain {
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L203-L217
      constructor(base, types2) {
        super(base), this.root = base, this._parseField = util.parseField.bind(null, types2 || require_types2());
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L326-L338
      add(data, marker) {
        try {
          for (let [key, value] of Object.entries(data)) {
            let substKey = util.parseKey(key);
            substKey !== key && delete data[key], data[substKey] = this._parseField(value, substKey);
          }
        } catch (error) {
          throw error;
        }
        return super.add(data, marker);
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L306-L319
      addFile(file, name) {
        name = name || file;
        let marker = { __source__: name };
        this.sources[name] = { path: file, type: "ini" }, this.push(marker), this._await();
        try {
          let contents = fs3.readFileSync(file, "utf8");
          this.addString(contents, file, "ini", marker);
        } catch (error) {
          if (error.code === "ENOENT")
            this.add({}, marker);
          else if (error.code !== "EISDIR")
            return `Issue while reading "${file}". ${error.message}`;
        }
      }
      // https://github.com/npm/cli/blob/latest/lib/config/core.js#L341-L357
      addEnv(env) {
        env = env || process.env;
        let conf = {};
        return Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
          if (!env[x])
            return;
          let key = envKeyToSetting(x.substr(11)), rawVal = env[x];
          conf[key] = deserializeEnvVal(key, rawVal);
        }), super.addEnv("", conf, "env");
      }
      // https://github.com/npm/cli/blob/latest/lib/config/load-prefix.js
      loadPrefix() {
        let cli = this.list[0];
        Object.defineProperty(this, "prefix", {
          enumerable: !0,
          set: (prefix) => {
            let g = this.get("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          },
          get: () => this.get("global") ? this.globalPrefix : this.localPrefix
        }), Object.defineProperty(this, "globalPrefix", {
          enumerable: !0,
          set: (prefix) => {
            this.set("prefix", prefix);
          },
          get: () => path4.resolve(this.get("prefix"))
        });
        let p;
        if (Object.defineProperty(this, "localPrefix", {
          enumerable: !0,
          set: (prefix) => {
            p = prefix;
          },
          get: () => p
        }), Object.prototype.hasOwnProperty.call(cli, "prefix"))
          p = path4.resolve(cli.prefix);
        else
          try {
            p = util.findPrefix(process.cwd());
          } catch (error) {
            throw error;
          }
        return p;
      }
      // https://github.com/npm/cli/blob/latest/lib/config/load-cafile.js
      loadCAFile(file) {
        if (!file)
          return;
        let ca = readCAFileSync(file);
        ca && this.set("ca", ca);
      }
      // https://github.com/npm/cli/blob/latest/lib/config/set-user.js
      loadUser() {
        let defConf = this.root;
        if (this.get("global"))
          return;
        if (process.env.SUDO_UID) {
          defConf.user = Number(process.env.SUDO_UID);
          return;
        }
        let prefix = path4.resolve(this.get("prefix"));
        try {
          let stats = fs3.statSync(prefix);
          defConf.user = stats.uid;
        } catch (error) {
          if (error.code === "ENOENT")
            return;
          throw error;
        }
      }
    };
    function deserializeEnvVal(envKey, envValue) {
      function deserializeList(envValue2) {
        let npmConfigSep = `

`;
        return envValue2.indexOf(npmConfigSep) ? envValue2.split(npmConfigSep) : envValue2.split(",");
      }
      switch (envKey) {
        case "hoist-pattern":
        case "public-hoist-pattern":
          return deserializeList(envValue);
      }
      return envValue;
    }
    module.exports = Conf2;
  }
});

// ../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/defaults.js
var require_defaults2 = __commonJS({
  "../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/lib/defaults.js"(exports) {
    "use strict";
    init_cjs_shims();
    var os3 = __require("os"), path4 = __require("path"), temp = os3.tmpdir(), uidOrPid = process.getuid ? process.getuid() : process.pid, hasUnicode = () => !0, isWindows = process.platform === "win32", osenv = {
      editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
    }, umask = {
      fromString: () => process.umask()
    }, home = os3.homedir();
    home ? process.env.HOME = home : home = path4.resolve(temp, "npm-" + uidOrPid);
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm", cacheRoot = process.platform === "win32" && process.env.APPDATA || home, cache = path4.resolve(cacheRoot, cacheExtra), defaults2, globalPrefix;
    Object.defineProperty(exports, "defaults", {
      get: function() {
        return defaults2 || (process.env.PREFIX ? globalPrefix = process.env.PREFIX : process.platform === "win32" ? globalPrefix = path4.dirname(process.execPath) : (globalPrefix = path4.dirname(path4.dirname(process.execPath)), process.env.DESTDIR && (globalPrefix = path4.join(process.env.DESTDIR, globalPrefix))), defaults2 = {
          access: null,
          "allow-same-version": !1,
          "always-auth": !1,
          also: null,
          audit: !0,
          "auth-type": "legacy",
          "bin-links": !0,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": 1 / 0,
          "cache-min": 10,
          cert: null,
          cidr: null,
          color: process.env.NO_COLOR == null,
          depth: 1 / 0,
          description: !0,
          dev: !1,
          "dry-run": !1,
          editor: osenv.editor(),
          "engine-strict": !1,
          force: !1,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": !0,
          "commit-hooks": !0,
          global: !1,
          globalconfig: path4.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": !1,
          group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
          "ham-it-up": !1,
          heading: "npm",
          "if-present": !1,
          "ignore-prepublish": !1,
          "ignore-scripts": !1,
          "init-module": path4.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: !1,
          key: null,
          "legacy-bundling": !1,
          link: !1,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: !1,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-options": null,
          // We remove node-version to fix the issue described here: https://github.com/pnpm/pnpm/issues/4203#issuecomment-1133872769
          offline: !1,
          "onload-script": !1,
          only: null,
          optional: !0,
          otp: null,
          "package-lock": !0,
          "package-lock-only": !1,
          parseable: !1,
          "prefer-offline": !1,
          "prefer-online": !1,
          prefix: globalPrefix,
          production: process.env.NODE_ENV === "production",
          progress: !process.env.TRAVIS && !process.env.CI,
          provenance: !1,
          proxy: null,
          "https-proxy": null,
          "no-proxy": null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "read-only": !1,
          "rebuild-bundle": !0,
          registry: "https://registry.npmjs.org/",
          rollback: !0,
          save: !0,
          "save-bundle": !1,
          "save-dev": !1,
          "save-exact": !1,
          "save-optional": !1,
          "save-prefix": "^",
          "save-prod": !1,
          scope: "",
          "script-shell": null,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": !1,
          shell: osenv.shell(),
          shrinkwrap: !0,
          "sign-git-tag": !1,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": !0,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: !1,
          tmp: temp,
          unicode: hasUnicode(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          usage: !1,
          user: process.platform === "win32" ? 0 : "nobody",
          userconfig: path4.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: !1,
          versions: !1,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: !0
        }, defaults2);
      }
    });
  }
});

// ../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/index.js
var require_npm_conf = __commonJS({
  "../../node_modules/.pnpm/@pnpm+npm-conf@2.3.1/node_modules/@pnpm/npm-conf/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path4 = __require("path"), Conf2 = require_conf(), _defaults = require_defaults2();
    module.exports = (opts, types2, defaults2) => {
      let conf = new Conf2(Object.assign({}, _defaults.defaults, defaults2), types2);
      conf.add(Object.assign({}, opts), "cli");
      let warnings = [], failedToLoadBuiltInConfig = !1;
      if (__require.resolve.paths) {
        let paths = __require.resolve.paths("npm"), npmPath;
        try {
          npmPath = __require.resolve("npm", { paths: paths.slice(-1) });
        } catch {
          failedToLoadBuiltInConfig = !0;
        }
        npmPath && warnings.push(conf.addFile(path4.resolve(path4.dirname(npmPath), "..", "npmrc"), "builtin"));
      }
      conf.addEnv(), conf.loadPrefix();
      let projectConf = path4.resolve(conf.localPrefix, ".npmrc"), userConf = conf.get("userconfig");
      if (!conf.get("global") && projectConf !== userConf ? warnings.push(conf.addFile(projectConf, "project")) : conf.add({}, "project"), conf.get("workspace-prefix") && conf.get("workspace-prefix") !== projectConf) {
        let workspaceConf = path4.resolve(conf.get("workspace-prefix"), ".npmrc");
        warnings.push(conf.addFile(workspaceConf, "workspace"));
      }
      if (warnings.push(conf.addFile(conf.get("userconfig"), "user")), conf.get("prefix")) {
        let etc = path4.resolve(conf.get("prefix"), "etc");
        conf.root.globalconfig = path4.resolve(etc, "npmrc"), conf.root.globalignorefile = path4.resolve(etc, "npmignore");
      }
      warnings.push(conf.addFile(conf.get("globalconfig"), "global")), conf.loadUser();
      let caFile = conf.get("cafile");
      return caFile && conf.loadCAFile(caFile), {
        config: conf,
        warnings: warnings.filter(Boolean),
        failedToLoadBuiltInConfig
      };
    };
    Object.defineProperty(module.exports, "defaults", {
      get() {
        return _defaults.defaults;
      },
      enumerable: !0
    });
  }
});

// ../../node_modules/.pnpm/registry-auth-token@5.1.0/node_modules/registry-auth-token/index.js
var require_registry_auth_token = __commonJS({
  "../../node_modules/.pnpm/registry-auth-token@5.1.0/node_modules/registry-auth-token/index.js"(exports, module) {
    init_cjs_shims();
    var npmConf = require_npm_conf(), tokenKey = ":_authToken", legacyTokenKey = ":_auth", userKey = ":username", passwordKey = ":_password";
    module.exports = function() {
      let checkUrl, options;
      arguments.length >= 2 ? (checkUrl = arguments[0], options = Object.assign({}, arguments[1])) : typeof arguments[0] == "string" ? checkUrl = arguments[0] : options = Object.assign({}, arguments[0]), options = options || {};
      let providedNpmrc = options.npmrc;
      return options.npmrc = (options.npmrc ? {
        config: {
          get: (key) => providedNpmrc[key]
        }
      } : npmConf()).config, checkUrl = checkUrl || options.npmrc.get("registry") || npmConf.defaults.registry, getRegistryAuthInfo(checkUrl, options) || getLegacyAuthInfo(options.npmrc);
    };
    function urlResolve(from, to) {
      let resolvedUrl = new URL(to, new URL(from.startsWith("//") ? `./${from}` : from, "resolve://"));
      if (resolvedUrl.protocol === "resolve:") {
        let { pathname, search, hash } = resolvedUrl;
        return pathname + search + hash;
      }
      return resolvedUrl.toString();
    }
    function getRegistryAuthInfo(checkUrl, options) {
      let parsed = checkUrl instanceof URL ? checkUrl : new URL(checkUrl.startsWith("//") ? `http:${checkUrl}` : checkUrl), pathname;
      for (; pathname !== "/" && parsed.pathname !== pathname; ) {
        pathname = parsed.pathname || "/";
        let regUrl = "//" + parsed.host + pathname.replace(/\/$/, ""), authInfo = getAuthInfoForUrl(regUrl, options.npmrc);
        if (authInfo)
          return authInfo;
        if (!options.recursive)
          return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(new URL("./", parsed), options);
        parsed.pathname = urlResolve(normalizePath(pathname), "..") || "/";
      }
    }
    function getLegacyAuthInfo(npmrc) {
      return npmrc.get("_auth") ? { token: replaceEnvironmentVariable(npmrc.get("_auth")), type: "Basic" } : void 0;
    }
    function normalizePath(path4) {
      return path4[path4.length - 1] === "/" ? path4 : path4 + "/";
    }
    function getAuthInfoForUrl(regUrl, npmrc) {
      let bearerAuth = getBearerToken(npmrc.get(regUrl + tokenKey) || npmrc.get(regUrl + "/" + tokenKey));
      if (bearerAuth)
        return bearerAuth;
      let username = npmrc.get(regUrl + userKey) || npmrc.get(regUrl + "/" + userKey), password = npmrc.get(regUrl + passwordKey) || npmrc.get(regUrl + "/" + passwordKey), basicAuth = getTokenForUsernameAndPassword(username, password);
      if (basicAuth)
        return basicAuth;
      let basicAuthWithToken = getLegacyAuthToken(npmrc.get(regUrl + legacyTokenKey) || npmrc.get(regUrl + "/" + legacyTokenKey));
      if (basicAuthWithToken)
        return basicAuthWithToken;
    }
    function replaceEnvironmentVariable(token) {
      return token.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
        return process.env[envVar];
      });
    }
    function getBearerToken(tok) {
      return tok ? { token: replaceEnvironmentVariable(tok), type: "Bearer" } : void 0;
    }
    function getTokenForUsernameAndPassword(username, password) {
      if (!username || !password)
        return;
      let pass = Buffer.from(replaceEnvironmentVariable(password), "base64").toString("utf8");
      return {
        token: Buffer.from(username + ":" + pass, "utf8").toString("base64"),
        type: "Basic",
        password: pass,
        username
      };
    }
    function getLegacyAuthToken(tok) {
      return tok ? { token: replaceEnvironmentVariable(tok), type: "Basic" } : void 0;
    }
  }
});

// ../cli-kit/dist/public/node/node-package-manager.js
var node_package_manager_exports = {};
__export(node_package_manager_exports, {
  FindUpAndReadPackageJsonNotFoundError: () => FindUpAndReadPackageJsonNotFoundError,
  PackageJsonNotFoundError: () => PackageJsonNotFoundError,
  UnknownPackageManagerError: () => UnknownPackageManagerError,
  addNPMDependencies: () => addNPMDependencies,
  addNPMDependenciesIfNeeded: () => addNPMDependenciesIfNeeded,
  addNPMDependenciesWithoutVersionIfNeeded: () => addNPMDependenciesWithoutVersionIfNeeded,
  addResolutionOrOverride: () => addResolutionOrOverride,
  bunLockfile: () => bunLockfile,
  checkForCachedNewVersion: () => checkForCachedNewVersion,
  checkForNewVersion: () => checkForNewVersion,
  findUpAndReadPackageJson: () => findUpAndReadPackageJson,
  getDependencies: () => getDependencies,
  getPackageManager: () => getPackageManager,
  getPackageName: () => getPackageName,
  getPackageVersion: () => getPackageVersion,
  inferPackageManager: () => inferPackageManager,
  installNPMDependenciesRecursively: () => installNPMDependenciesRecursively,
  installNodeModules: () => installNodeModules,
  lockfiles: () => lockfiles,
  lockfilesByManager: () => lockfilesByManager,
  npmLockfile: () => npmLockfile,
  packageManager: () => packageManager,
  packageManagerFromUserAgent: () => packageManagerFromUserAgent,
  pnpmLockfile: () => pnpmLockfile,
  pnpmWorkspaceFile: () => pnpmWorkspaceFile,
  readAndParsePackageJson: () => readAndParsePackageJson,
  usesWorkspaces: () => usesWorkspaces,
  versionSatisfies: () => versionSatisfies,
  writePackageJSON: () => writePackageJSON,
  yarnLockfile: () => yarnLockfile
});
init_cjs_shims();

// ../cli-kit/dist/private/node/conf-store.js
init_cjs_shims();

// ../cli-kit/dist/public/node/local-storage.js
init_cjs_shims();

// ../../node_modules/.pnpm/conf@11.0.2/node_modules/conf/dist/source/index.js
init_cjs_shims();
import { isDeepStrictEqual } from "node:util";
import process6 from "node:process";
import { Buffer as Buffer2 } from "node:buffer";
import fs2 from "node:fs";
import path3 from "node:path";
import crypto from "node:crypto";
import assert from "node:assert";
import { EventEmitter } from "node:events";

// ../../node_modules/.pnpm/dot-prop@7.2.0/node_modules/dot-prop/index.js
init_cjs_shims();
var isObject = (value) => {
  let type = typeof value;
  return value !== null && (type === "object" || type === "function");
}, disallowedKeys = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]), digits = new Set("0123456789");
function getPathSegments(path4) {
  let parts = [], currentSegment = "", currentPart = "start", isIgnoring = !1;
  for (let character of path4)
    switch (character) {
      case "\\":
        if (currentPart === "index")
          throw new Error("Invalid character in an index");
        if (currentPart === "indexEnd")
          throw new Error("Invalid character after an index");
        isIgnoring && (currentSegment += character), currentPart = "property", isIgnoring = !isIgnoring;
        break;
      case ".":
        if (currentPart === "index")
          throw new Error("Invalid character in an index");
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = !1, currentSegment += character;
          break;
        }
        if (disallowedKeys.has(currentSegment))
          return [];
        parts.push(currentSegment), currentSegment = "", currentPart = "property";
        break;
      case "[":
        if (currentPart === "index")
          throw new Error("Invalid character in an index");
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = !1, currentSegment += character;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment))
            return [];
          parts.push(currentSegment), currentSegment = "";
        }
        currentPart = "index";
        break;
      case "]":
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10)), currentSegment = "", currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd")
          throw new Error("Invalid character after an index");
      // Falls through
      default:
        if (currentPart === "index" && !digits.has(character))
          throw new Error("Invalid character in an index");
        if (currentPart === "indexEnd")
          throw new Error("Invalid character after an index");
        currentPart === "start" && (currentPart = "property"), isIgnoring && (isIgnoring = !1, currentSegment += "\\"), currentSegment += character;
    }
  switch (isIgnoring && (currentSegment += "\\"), currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment))
        return [];
      parts.push(currentSegment);
      break;
    }
    case "index":
      throw new Error("Index was not closed");
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex(object, key) {
  if (typeof key != "number" && Array.isArray(object)) {
    let index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object[index] === object[key];
  }
  return !1;
}
function assertNotStringIndex(object, key) {
  if (isStringIndex(object, key))
    throw new Error("Cannot use string index");
}
function getProperty(object, path4, value) {
  if (!isObject(object) || typeof path4 != "string")
    return value === void 0 ? object : value;
  let pathArray = getPathSegments(path4);
  if (pathArray.length === 0)
    return value;
  for (let index = 0; index < pathArray.length; index++) {
    let key = pathArray[index];
    if (isStringIndex(object, key) ? object = index === pathArray.length - 1 ? void 0 : null : object = object[key], object == null) {
      if (index !== pathArray.length - 1)
        return value;
      break;
    }
  }
  return object === void 0 ? value : object;
}
function setProperty(object, path4, value) {
  if (!isObject(object) || typeof path4 != "string")
    return object;
  let root = object, pathArray = getPathSegments(path4);
  for (let index = 0; index < pathArray.length; index++) {
    let key = pathArray[index];
    assertNotStringIndex(object, key), index === pathArray.length - 1 ? object[key] = value : isObject(object[key]) || (object[key] = typeof pathArray[index + 1] == "number" ? [] : {}), object = object[key];
  }
  return root;
}
function deleteProperty(object, path4) {
  if (!isObject(object) || typeof path4 != "string")
    return !1;
  let pathArray = getPathSegments(path4);
  for (let index = 0; index < pathArray.length; index++) {
    let key = pathArray[index];
    if (assertNotStringIndex(object, key), index === pathArray.length - 1)
      return delete object[key], !0;
    if (object = object[key], !isObject(object))
      return !1;
  }
}
function hasProperty(object, path4) {
  if (!isObject(object) || typeof path4 != "string")
    return !1;
  let pathArray = getPathSegments(path4);
  if (pathArray.length === 0)
    return !1;
  for (let key of pathArray) {
    if (!isObject(object) || !(key in object) || isStringIndex(object, key))
      return !1;
    object = object[key];
  }
  return !0;
}

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/index.js
init_cjs_shims();
import path2 from "node:path";

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/index.js
init_cjs_shims();
import fs from "node:fs";
import { promisify } from "node:util";

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/attemptify.js
init_cjs_shims();
var attemptifyAsync = (fn, onError) => function(...args) {
  return fn.apply(void 0, args).catch(onError);
}, attemptifySync = (fn, onError) => function(...args) {
  try {
    return fn.apply(void 0, args);
  } catch (error) {
    return onError(error);
  }
};

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/constants.js
init_cjs_shims();
import process2 from "node:process";
var IS_USER_ROOT = process2.getuid ? !process2.getuid() : !1, LIMIT_FILES_DESCRIPTORS = 1e4, NOOP = () => {
};

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/handlers.js
init_cjs_shims();
var Handlers = {
  /* API */
  isChangeErrorOk: (error) => {
    if (!Handlers.isNodeError(error))
      return !1;
    let { code } = error;
    return code === "ENOSYS" || !IS_USER_ROOT && (code === "EINVAL" || code === "EPERM");
  },
  isNodeError: (error) => error instanceof Error,
  isRetriableError: (error) => {
    if (!Handlers.isNodeError(error))
      return !1;
    let { code } = error;
    return code === "EMFILE" || code === "ENFILE" || code === "EAGAIN" || code === "EBUSY" || code === "EACCESS" || code === "EACCES" || code === "EACCS" || code === "EPERM";
  },
  onChangeError: (error) => {
    if (!Handlers.isNodeError(error))
      throw error;
    if (!Handlers.isChangeErrorOk(error))
      throw error;
  }
}, handlers_default = Handlers;

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/retryify.js
init_cjs_shims();

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/retryify_queue.js
init_cjs_shims();
var RetryfyQueue = class {
  constructor() {
    this.interval = 25, this.intervalId = void 0, this.limit = LIMIT_FILES_DESCRIPTORS, this.queueActive = /* @__PURE__ */ new Set(), this.queueWaiting = /* @__PURE__ */ new Set(), this.init = () => {
      this.intervalId || (this.intervalId = setInterval(this.tick, this.interval));
    }, this.reset = () => {
      this.intervalId && (clearInterval(this.intervalId), delete this.intervalId);
    }, this.add = (fn) => {
      this.queueWaiting.add(fn), this.queueActive.size < this.limit / 2 ? this.tick() : this.init();
    }, this.remove = (fn) => {
      this.queueWaiting.delete(fn), this.queueActive.delete(fn);
    }, this.schedule = () => new Promise((resolve) => {
      let cleanup = () => this.remove(resolver), resolver = () => resolve(cleanup);
      this.add(resolver);
    }), this.tick = () => {
      if (!(this.queueActive.size >= this.limit)) {
        if (!this.queueWaiting.size)
          return this.reset();
        for (let fn of this.queueWaiting) {
          if (this.queueActive.size >= this.limit)
            break;
          this.queueWaiting.delete(fn), this.queueActive.add(fn), fn();
        }
      }
    };
  }
}, retryify_queue_default = new RetryfyQueue();

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/retryify.js
var retryifyAsync = (fn, isRetriableError) => function(timestamp) {
  return function attempt(...args) {
    return retryify_queue_default.schedule().then((cleanup) => {
      let onResolve = (result) => (cleanup(), result), onReject = (error) => {
        if (cleanup(), Date.now() >= timestamp)
          throw error;
        if (isRetriableError(error)) {
          let delay2 = Math.round(100 * Math.random());
          return new Promise((resolve) => setTimeout(resolve, delay2)).then(() => attempt.apply(void 0, args));
        }
        throw error;
      };
      return fn.apply(void 0, args).then(onResolve, onReject);
    });
  };
}, retryifySync = (fn, isRetriableError) => function(timestamp) {
  return function attempt(...args) {
    try {
      return fn.apply(void 0, args);
    } catch (error) {
      if (Date.now() > timestamp)
        throw error;
      if (isRetriableError(error))
        return attempt.apply(void 0, args);
      throw error;
    }
  };
};

// ../../node_modules/.pnpm/stubborn-fs@1.2.5/node_modules/stubborn-fs/dist/index.js
var FS = {
  attempt: {
    /* ASYNC */
    chmod: attemptifyAsync(promisify(fs.chmod), handlers_default.onChangeError),
    chown: attemptifyAsync(promisify(fs.chown), handlers_default.onChangeError),
    close: attemptifyAsync(promisify(fs.close), NOOP),
    fsync: attemptifyAsync(promisify(fs.fsync), NOOP),
    mkdir: attemptifyAsync(promisify(fs.mkdir), NOOP),
    realpath: attemptifyAsync(promisify(fs.realpath), NOOP),
    stat: attemptifyAsync(promisify(fs.stat), NOOP),
    unlink: attemptifyAsync(promisify(fs.unlink), NOOP),
    /* SYNC */
    chmodSync: attemptifySync(fs.chmodSync, handlers_default.onChangeError),
    chownSync: attemptifySync(fs.chownSync, handlers_default.onChangeError),
    closeSync: attemptifySync(fs.closeSync, NOOP),
    existsSync: attemptifySync(fs.existsSync, NOOP),
    fsyncSync: attemptifySync(fs.fsync, NOOP),
    mkdirSync: attemptifySync(fs.mkdirSync, NOOP),
    realpathSync: attemptifySync(fs.realpathSync, NOOP),
    statSync: attemptifySync(fs.statSync, NOOP),
    unlinkSync: attemptifySync(fs.unlinkSync, NOOP)
  },
  retry: {
    /* ASYNC */
    close: retryifyAsync(promisify(fs.close), handlers_default.isRetriableError),
    fsync: retryifyAsync(promisify(fs.fsync), handlers_default.isRetriableError),
    open: retryifyAsync(promisify(fs.open), handlers_default.isRetriableError),
    readFile: retryifyAsync(promisify(fs.readFile), handlers_default.isRetriableError),
    rename: retryifyAsync(promisify(fs.rename), handlers_default.isRetriableError),
    stat: retryifyAsync(promisify(fs.stat), handlers_default.isRetriableError),
    write: retryifyAsync(promisify(fs.write), handlers_default.isRetriableError),
    writeFile: retryifyAsync(promisify(fs.writeFile), handlers_default.isRetriableError),
    /* SYNC */
    closeSync: retryifySync(fs.closeSync, handlers_default.isRetriableError),
    fsyncSync: retryifySync(fs.fsyncSync, handlers_default.isRetriableError),
    openSync: retryifySync(fs.openSync, handlers_default.isRetriableError),
    readFileSync: retryifySync(fs.readFileSync, handlers_default.isRetriableError),
    renameSync: retryifySync(fs.renameSync, handlers_default.isRetriableError),
    statSync: retryifySync(fs.statSync, handlers_default.isRetriableError),
    writeSync: retryifySync(fs.writeSync, handlers_default.isRetriableError),
    writeFileSync: retryifySync(fs.writeFileSync, handlers_default.isRetriableError)
  }
}, dist_default = FS;

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/constants.js
init_cjs_shims();
import os from "node:os";
import process3 from "node:process";
var DEFAULT_ENCODING = "utf8", DEFAULT_FILE_MODE = 438, DEFAULT_FOLDER_MODE = 511;
var DEFAULT_WRITE_OPTIONS = {}, DEFAULT_USER_UID = os.userInfo().uid, DEFAULT_USER_GID = os.userInfo().gid;
var DEFAULT_TIMEOUT_SYNC = 1e3, IS_POSIX = !!process3.getuid, IS_USER_ROOT2 = process3.getuid ? !process3.getuid() : !1, LIMIT_BASENAME_LENGTH = 128;

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/utils/lang.js
init_cjs_shims();
var isException = (value) => value instanceof Error && "code" in value;
var isString = (value) => typeof value == "string", isUndefined = (value) => value === void 0;

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/utils/scheduler.js
init_cjs_shims();

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/utils/temp.js
init_cjs_shims();
import path from "node:path";

// ../../node_modules/.pnpm/when-exit@2.1.4/node_modules/when-exit/dist/node/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/when-exit@2.1.4/node_modules/when-exit/dist/node/interceptor.js
init_cjs_shims();
import process5 from "node:process";

// ../../node_modules/.pnpm/when-exit@2.1.4/node_modules/when-exit/dist/node/constants.js
init_cjs_shims();
import process4 from "node:process";
var IS_LINUX = process4.platform === "linux", IS_WINDOWS = process4.platform === "win32";

// ../../node_modules/.pnpm/when-exit@2.1.4/node_modules/when-exit/dist/node/signals.js
init_cjs_shims();
var Signals = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];
IS_WINDOWS || Signals.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
IS_LINUX && Signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
var signals_default = Signals;

// ../../node_modules/.pnpm/when-exit@2.1.4/node_modules/when-exit/dist/node/interceptor.js
var Interceptor = class {
  /* CONSTRUCTOR */
  constructor() {
    this.callbacks = /* @__PURE__ */ new Set(), this.exited = !1, this.exit = (signal) => {
      if (!this.exited) {
        this.exited = !0;
        for (let callback of this.callbacks)
          callback();
        signal && (IS_WINDOWS && signal !== "SIGINT" && signal !== "SIGTERM" && signal !== "SIGKILL" ? process5.kill(process5.pid, "SIGTERM") : process5.kill(process5.pid, signal));
      }
    }, this.hook = () => {
      process5.once("exit", () => this.exit());
      for (let signal of signals_default)
        try {
          process5.once(signal, () => this.exit(signal));
        } catch {
        }
    }, this.register = (callback) => (this.callbacks.add(callback), () => {
      this.callbacks.delete(callback);
    }), this.hook();
  }
}, interceptor_default = new Interceptor();

// ../../node_modules/.pnpm/when-exit@2.1.4/node_modules/when-exit/dist/node/index.js
var whenExit = interceptor_default.register, node_default = whenExit;

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/utils/temp.js
var Temp = {
  /* VARIABLES */
  store: {},
  /* API */
  create: (filePath) => {
    let randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6), suffix = `.tmp-${Date.now().toString().slice(-10)}${randomness}`;
    return `${filePath}${suffix}`;
  },
  get: (filePath, creator, purge = !0) => {
    let tempPath = Temp.truncate(creator(filePath));
    return tempPath in Temp.store ? Temp.get(filePath, creator, purge) : (Temp.store[tempPath] = purge, [tempPath, () => delete Temp.store[tempPath]]);
  },
  purge: (filePath) => {
    Temp.store[filePath] && (delete Temp.store[filePath], dist_default.attempt.unlink(filePath));
  },
  purgeSync: (filePath) => {
    Temp.store[filePath] && (delete Temp.store[filePath], dist_default.attempt.unlinkSync(filePath));
  },
  purgeSyncAll: () => {
    for (let filePath in Temp.store)
      Temp.purgeSync(filePath);
  },
  truncate: (filePath) => {
    let basename = path.basename(filePath);
    if (basename.length <= LIMIT_BASENAME_LENGTH)
      return filePath;
    let truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
    if (!truncable)
      return filePath;
    let truncationLength = basename.length - LIMIT_BASENAME_LENGTH;
    return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`;
  }
};
node_default(Temp.purgeSyncAll);
var temp_default = Temp;

// ../../node_modules/.pnpm/atomically@2.0.3/node_modules/atomically/dist/index.js
function writeFileSync(filePath, data, options = DEFAULT_WRITE_OPTIONS) {
  if (isString(options))
    return writeFileSync(filePath, data, { encoding: options });
  let timeout = Date.now() + ((options.timeout ?? DEFAULT_TIMEOUT_SYNC) || -1), tempDisposer = null, tempPath = null, fd = null;
  try {
    let filePathReal = dist_default.attempt.realpathSync(filePath), filePathExists = !!filePathReal;
    filePath = filePathReal || filePath, [tempPath, tempDisposer] = temp_default.get(filePath, options.tmpCreate || temp_default.create, options.tmpPurge !== !1);
    let useStatChown = IS_POSIX && isUndefined(options.chown), useStatMode = isUndefined(options.mode);
    if (filePathExists && (useStatChown || useStatMode)) {
      let stats = dist_default.attempt.statSync(filePath);
      stats && (options = { ...options }, useStatChown && (options.chown = { uid: stats.uid, gid: stats.gid }), useStatMode && (options.mode = stats.mode));
    }
    if (!filePathExists) {
      let parentPath = path2.dirname(filePath);
      dist_default.attempt.mkdirSync(parentPath, {
        mode: DEFAULT_FOLDER_MODE,
        recursive: !0
      });
    }
    fd = dist_default.retry.openSync(timeout)(tempPath, "w", options.mode || DEFAULT_FILE_MODE), options.tmpCreated && options.tmpCreated(tempPath), isString(data) ? dist_default.retry.writeSync(timeout)(fd, data, 0, options.encoding || DEFAULT_ENCODING) : isUndefined(data) || dist_default.retry.writeSync(timeout)(fd, data, 0, data.length, 0), options.fsync !== !1 && (options.fsyncWait !== !1 ? dist_default.retry.fsyncSync(timeout)(fd) : dist_default.attempt.fsync(fd)), dist_default.retry.closeSync(timeout)(fd), fd = null, options.chown && (options.chown.uid !== DEFAULT_USER_UID || options.chown.gid !== DEFAULT_USER_GID) && dist_default.attempt.chownSync(tempPath, options.chown.uid, options.chown.gid), options.mode && options.mode !== DEFAULT_FILE_MODE && dist_default.attempt.chmodSync(tempPath, options.mode);
    try {
      dist_default.retry.renameSync(timeout)(tempPath, filePath);
    } catch (error) {
      if (!isException(error) || error.code !== "ENAMETOOLONG")
        throw error;
      dist_default.retry.renameSync(timeout)(tempPath, temp_default.truncate(filePath));
    }
    tempDisposer(), tempPath = null;
  } finally {
    fd && dist_default.attempt.closeSync(fd), tempPath && temp_default.purge(tempPath);
  }
}

// ../../node_modules/.pnpm/conf@11.0.2/node_modules/conf/dist/source/index.js
var import_ajv = __toESM(require_ajv(), 1), import_ajv_formats = __toESM(require_dist(), 1);

// ../../node_modules/.pnpm/debounce-fn@5.1.2/node_modules/debounce-fn/index.js
init_cjs_shims();
var debounceFn = (inputFunction, options = {}) => {
  if (typeof inputFunction != "function")
    throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
  let {
    wait = 0,
    maxWait = Number.POSITIVE_INFINITY,
    before = !1,
    after = !0
  } = options;
  if (!before && !after)
    throw new Error("Both `before` and `after` are false, function wouldn't be called.");
  let timeout, maxTimeout, result, debouncedFunction = function(...arguments_) {
    let context = this, later = () => {
      timeout = void 0, maxTimeout && (clearTimeout(maxTimeout), maxTimeout = void 0), after && (result = inputFunction.apply(context, arguments_));
    }, maxLater = () => {
      maxTimeout = void 0, timeout && (clearTimeout(timeout), timeout = void 0), after && (result = inputFunction.apply(context, arguments_));
    }, shouldCallNow = before && !timeout;
    return clearTimeout(timeout), timeout = setTimeout(later, wait), maxWait > 0 && maxWait !== Number.POSITIVE_INFINITY && !maxTimeout && (maxTimeout = setTimeout(maxLater, maxWait)), shouldCallNow && (result = inputFunction.apply(context, arguments_)), result;
  };
  return mimicFunction(debouncedFunction, inputFunction), debouncedFunction.cancel = () => {
    timeout && (clearTimeout(timeout), timeout = void 0), maxTimeout && (clearTimeout(maxTimeout), maxTimeout = void 0);
  }, debouncedFunction;
}, debounce_fn_default = debounceFn;

// ../../node_modules/.pnpm/conf@11.0.2/node_modules/conf/dist/source/index.js
var import_semver = __toESM(require_semver(), 1), __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}, __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}, _Conf_validator, _Conf_encryptionKey, _Conf_options, _Conf_defaultValues, Ajv = import_ajv.default.default, ajvFormats = import_ajv_formats.default.default, encryptionAlgorithm = "aes-256-cbc", createPlainObject = () => /* @__PURE__ */ Object.create(null), isExist = (data) => data != null, checkValueType = (key, value) => {
  let nonJsonTypes = /* @__PURE__ */ new Set([
    "undefined",
    "symbol",
    "function"
  ]), type = typeof value;
  if (nonJsonTypes.has(type))
    throw new TypeError(`Setting a value of type \`${type}\` for key \`${key}\` is not allowed as it's not supported by JSON`);
}, INTERNAL_KEY = "__internal__", MIGRATION_KEY = `${INTERNAL_KEY}.migrations.version`, Conf = class {
  constructor(partialOptions = {}) {
    Object.defineProperty(this, "path", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), _Conf_validator.set(this, void 0), _Conf_encryptionKey.set(this, void 0), _Conf_options.set(this, void 0), _Conf_defaultValues.set(this, {}), Object.defineProperty(this, "_deserialize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (value) => JSON.parse(value)
    }), Object.defineProperty(this, "_serialize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (value) => JSON.stringify(value, void 0, "	")
    });
    let options = {
      configName: "config",
      fileExtension: "json",
      projectSuffix: "nodejs",
      clearInvalidConfig: !1,
      accessPropertiesByDotNotation: !0,
      configFileMode: 438,
      ...partialOptions
    };
    if (!options.cwd) {
      if (!options.projectName)
        throw new Error("Please specify the `projectName` option.");
      options.cwd = envPaths(options.projectName, { suffix: options.projectSuffix }).config;
    }
    if (__classPrivateFieldSet(this, _Conf_options, options, "f"), options.schema) {
      if (typeof options.schema != "object")
        throw new TypeError("The `schema` option must be an object.");
      let ajv = new Ajv({
        allErrors: !0,
        useDefaults: !0
      });
      ajvFormats(ajv);
      let schema = {
        type: "object",
        properties: options.schema
      };
      __classPrivateFieldSet(this, _Conf_validator, ajv.compile(schema), "f");
      for (let [key, value] of Object.entries(options.schema))
        value?.default && (__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key] = value.default);
    }
    options.defaults && __classPrivateFieldSet(this, _Conf_defaultValues, {
      ...__classPrivateFieldGet(this, _Conf_defaultValues, "f"),
      ...options.defaults
    }, "f"), options.serialize && (this._serialize = options.serialize), options.deserialize && (this._deserialize = options.deserialize), this.events = new EventEmitter(), __classPrivateFieldSet(this, _Conf_encryptionKey, options.encryptionKey, "f");
    let fileExtension = options.fileExtension ? `.${options.fileExtension}` : "";
    this.path = path3.resolve(options.cwd, `${options.configName ?? "config"}${fileExtension}`);
    let fileStore = this.store, store = Object.assign(createPlainObject(), options.defaults, fileStore);
    this._validate(store);
    try {
      assert.deepEqual(fileStore, store);
    } catch {
      this.store = store;
    }
    if (options.watch && this._watch(), options.migrations) {
      if (!options.projectVersion)
        throw new Error("Please specify the `projectVersion` option.");
      this._migrate(options.migrations, options.projectVersion, options.beforeEachMigration);
    }
  }
  get(key, defaultValue) {
    if (__classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation)
      return this._get(key, defaultValue);
    let { store } = this;
    return key in store ? store[key] : defaultValue;
  }
  set(key, value) {
    if (typeof key != "string" && typeof key != "object")
      throw new TypeError(`Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof key}`);
    if (typeof key != "object" && value === void 0)
      throw new TypeError("Use `delete()` to clear values");
    if (this._containsReservedKey(key))
      throw new TypeError(`Please don't use the ${INTERNAL_KEY} key, as it's used to manage this module internal operations.`);
    let { store } = this, set = (key2, value2) => {
      checkValueType(key2, value2), __classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation ? setProperty(store, key2, value2) : store[key2] = value2;
    };
    if (typeof key == "object") {
      let object = key;
      for (let [key2, value2] of Object.entries(object))
        set(key2, value2);
    } else
      set(key, value);
    this.store = store;
  }
  /**
      Check if an item exists.
  
      @param key - The key of the item to check.
      */
  has(key) {
    return __classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation ? hasProperty(this.store, key) : key in this.store;
  }
  /**
      Reset items to their default values, as defined by the `defaults` or `schema` option.
  
      @see `clear()` to reset all items.
  
      @param keys - The keys of the items to reset.
      */
  reset(...keys) {
    for (let key of keys)
      isExist(__classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]) && this.set(key, __classPrivateFieldGet(this, _Conf_defaultValues, "f")[key]);
  }
  delete(key) {
    let { store } = this;
    __classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation ? deleteProperty(store, key) : delete store[key], this.store = store;
  }
  /**
      Delete all items.
  
      This resets known items to their default values, if defined by the `defaults` or `schema` option.
      */
  clear() {
    this.store = createPlainObject();
    for (let key of Object.keys(__classPrivateFieldGet(this, _Conf_defaultValues, "f")))
      this.reset(key);
  }
  /**
      Watches the given `key`, calling `callback` on any changes.
  
      @param key - The key wo watch.
      @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
      @returns A function, that when called, will unsubscribe.
      */
  onDidChange(key, callback) {
    if (typeof key != "string")
      throw new TypeError(`Expected \`key\` to be of type \`string\`, got ${typeof key}`);
    if (typeof callback != "function")
      throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
    return this._handleChange(() => this.get(key), callback);
  }
  /**
      Watches the whole config object, calling `callback` on any changes.
  
      @param callback - A callback function that is called on any changes. When a `key` is first set `oldValue` will be `undefined`, and when a key is deleted `newValue` will be `undefined`.
      @returns A function, that when called, will unsubscribe.
      */
  onDidAnyChange(callback) {
    if (typeof callback != "function")
      throw new TypeError(`Expected \`callback\` to be of type \`function\`, got ${typeof callback}`);
    return this._handleChange(() => this.store, callback);
  }
  get size() {
    return Object.keys(this.store).length;
  }
  get store() {
    try {
      let data = fs2.readFileSync(this.path, __classPrivateFieldGet(this, _Conf_encryptionKey, "f") ? null : "utf8"), dataString = this._encryptData(data), deserializedData = this._deserialize(dataString);
      return this._validate(deserializedData), Object.assign(createPlainObject(), deserializedData);
    } catch (error) {
      if (error?.code === "ENOENT")
        return this._ensureDirectory(), createPlainObject();
      if (__classPrivateFieldGet(this, _Conf_options, "f").clearInvalidConfig && error.name === "SyntaxError")
        return createPlainObject();
      throw error;
    }
  }
  set store(value) {
    this._ensureDirectory(), this._validate(value), this._write(value), this.events.emit("change");
  }
  *[(_Conf_validator = /* @__PURE__ */ new WeakMap(), _Conf_encryptionKey = /* @__PURE__ */ new WeakMap(), _Conf_options = /* @__PURE__ */ new WeakMap(), _Conf_defaultValues = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
    for (let [key, value] of Object.entries(this.store))
      yield [key, value];
  }
  _encryptData(data) {
    if (!__classPrivateFieldGet(this, _Conf_encryptionKey, "f"))
      return data.toString();
    try {
      let initializationVector = data.slice(0, 16), password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512"), decipher = crypto.createDecipheriv(encryptionAlgorithm, password, initializationVector);
      return Buffer2.concat([decipher.update(Buffer2.from(data.slice(17))), decipher.final()]).toString("utf8");
    } catch {
    }
    return data.toString();
  }
  _handleChange(getter, callback) {
    let currentValue = getter(), onChange = () => {
      let oldValue = currentValue, newValue = getter();
      isDeepStrictEqual(newValue, oldValue) || (currentValue = newValue, callback.call(this, newValue, oldValue));
    };
    return this.events.on("change", onChange), () => this.events.removeListener("change", onChange);
  }
  _validate(data) {
    if (!__classPrivateFieldGet(this, _Conf_validator, "f") || __classPrivateFieldGet(this, _Conf_validator, "f").call(this, data) || !__classPrivateFieldGet(this, _Conf_validator, "f").errors)
      return;
    let errors = __classPrivateFieldGet(this, _Conf_validator, "f").errors.map(({ instancePath, message = "" }) => `\`${instancePath.slice(1)}\` ${message}`);
    throw new Error("Config schema violation: " + errors.join("; "));
  }
  _ensureDirectory() {
    fs2.mkdirSync(path3.dirname(this.path), { recursive: !0 });
  }
  _write(value) {
    let data = this._serialize(value);
    if (__classPrivateFieldGet(this, _Conf_encryptionKey, "f")) {
      let initializationVector = crypto.randomBytes(16), password = crypto.pbkdf2Sync(__classPrivateFieldGet(this, _Conf_encryptionKey, "f"), initializationVector.toString(), 1e4, 32, "sha512"), cipher = crypto.createCipheriv(encryptionAlgorithm, password, initializationVector);
      data = Buffer2.concat([initializationVector, Buffer2.from(":"), cipher.update(Buffer2.from(data)), cipher.final()]);
    }
    if (process6.env.SNAP)
      fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
    else
      try {
        writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
      } catch (error) {
        if (error?.code === "EXDEV") {
          fs2.writeFileSync(this.path, data, { mode: __classPrivateFieldGet(this, _Conf_options, "f").configFileMode });
          return;
        }
        throw error;
      }
  }
  _watch() {
    this._ensureDirectory(), fs2.existsSync(this.path) || this._write(createPlainObject()), process6.platform === "win32" ? fs2.watch(this.path, { persistent: !1 }, debounce_fn_default(() => {
      this.events.emit("change");
    }, { wait: 100 })) : fs2.watchFile(this.path, { persistent: !1 }, debounce_fn_default(() => {
      this.events.emit("change");
    }, { wait: 5e3 }));
  }
  _migrate(migrations, versionToMigrate, beforeEachMigration) {
    let previousMigratedVersion = this._get(MIGRATION_KEY, "0.0.0"), newerVersions = Object.keys(migrations).filter((candidateVersion) => this._shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate)), storeBackup = { ...this.store };
    for (let version of newerVersions)
      try {
        beforeEachMigration && beforeEachMigration(this, {
          fromVersion: previousMigratedVersion,
          toVersion: version,
          finalVersion: versionToMigrate,
          versions: newerVersions
        });
        let migration = migrations[version];
        migration?.(this), this._set(MIGRATION_KEY, version), previousMigratedVersion = version, storeBackup = { ...this.store };
      } catch (error) {
        throw this.store = storeBackup, new Error(`Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${error}`);
      }
    (this._isVersionInRangeFormat(previousMigratedVersion) || !import_semver.default.eq(previousMigratedVersion, versionToMigrate)) && this._set(MIGRATION_KEY, versionToMigrate);
  }
  _containsReservedKey(key) {
    return typeof key == "object" && Object.keys(key)[0] === INTERNAL_KEY ? !0 : typeof key != "string" ? !1 : __classPrivateFieldGet(this, _Conf_options, "f").accessPropertiesByDotNotation ? !!key.startsWith(`${INTERNAL_KEY}.`) : !1;
  }
  _isVersionInRangeFormat(version) {
    return import_semver.default.clean(version) === null;
  }
  _shouldPerformMigration(candidateVersion, previousMigratedVersion, versionToMigrate) {
    return this._isVersionInRangeFormat(candidateVersion) ? previousMigratedVersion !== "0.0.0" && import_semver.default.satisfies(previousMigratedVersion, candidateVersion) ? !1 : import_semver.default.satisfies(versionToMigrate, candidateVersion) : !(import_semver.default.lte(candidateVersion, previousMigratedVersion) || import_semver.default.gt(candidateVersion, versionToMigrate));
  }
  _get(key, defaultValue) {
    return getProperty(this.store, key, defaultValue);
  }
  _set(key, value) {
    let { store } = this;
    setProperty(store, key, value), this.store = store;
  }
};

// ../cli-kit/dist/public/node/local-storage.js
var LocalStorage = class {
  constructor(options) {
    this.config = new Conf(options);
  }
  /**
   * Get a value from the local storage.
   *
   * @param key - The key to get.
   * @returns The value.
   */
  get(key) {
    return this.config.get(key);
  }
  /**
   * Set a value in the local storage.
   *
   * @param key - The key to set.
   * @param value - The value to set.
   */
  set(key, value) {
    this.config.set(key, value);
  }
  /**
   * Delete a value from the local storage.
   *
   * @param key - The key to delete.
   */
  delete(key) {
    this.config.delete(key);
  }
  /**
   * Clear the local storage (delete all values).
   */
  clear() {
    this.config.clear();
  }
};

// ../cli-kit/dist/private/node/conf-store.js
var _instance;
function cliKitStore() {
  return _instance || (_instance = new LocalStorage({ projectName: `shopify-cli-kit${isUnitTest() ? "-test" : ""}` })), _instance;
}
function getSessions(config = cliKitStore()) {
  return outputDebug(outputContent`Getting session store...`), config.get("sessionStore");
}
function setSessions(session, config = cliKitStore()) {
  outputDebug(outputContent`Setting session store...`), config.set("sessionStore", session);
}
function removeSessions(config = cliKitStore()) {
  outputDebug(outputContent`Removing session store...`), config.delete("sessionStore");
}
function getCurrentSessionId(config = cliKitStore()) {
  return outputDebug(outputContent`Getting current session ID...`), config.get("currentSessionId");
}
function setCurrentSessionId(sessionId, config = cliKitStore()) {
  outputDebug(outputContent`Setting current session ID...`), config.set("currentSessionId", sessionId);
}
function removeCurrentSessionId(config = cliKitStore()) {
  outputDebug(outputContent`Removing current session ID...`), config.delete("currentSessionId");
}
async function cacheRetrieveOrRepopulate(key, fn, timeout, config = cliKitStore()) {
  let cached = cacheRetrieve(key, config);
  if (cached?.value !== void 0 && (timeout === void 0 || Date.now() - cached.timestamp < timeout))
    return cached.value;
  let value = await fn();
  return cacheStore(key, value, config), value;
}
function cacheStore(key, value, config = cliKitStore()) {
  let cache = config.get("cache") ?? {};
  cache[key] = { value, timestamp: Date.now() }, config.set("cache", cache);
}
function cacheRetrieve(key, config = cliKitStore()) {
  return (config.get("cache") ?? {})[key];
}
function cacheClear(config = cliKitStore()) {
  config.delete("cache");
}
function timeIntervalToMilliseconds({ days = 0, hours = 0, minutes = 0, seconds = 0 }) {
  return (days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60 + seconds) * 1e3;
}
async function runAtMinimumInterval(key, timeout, task, config = cliKitStore()) {
  let cache = config.get("cache") ?? {}, cacheKey = `most-recent-occurrence-${key}`, cached = cache[cacheKey];
  return cached?.value !== void 0 && Date.now() - cached.timestamp < timeIntervalToMilliseconds(timeout) ? !1 : (await task(), cache[cacheKey] = { value: !0, timestamp: Date.now() }, config.set("cache", cache), !0);
}
async function runWithRateLimit(options, config = cliKitStore()) {
  let { key, limit, timeout, task } = options, cache = config.get("cache") ?? {}, cacheKey = `rate-limited-occurrences-${key}`, cached = cache[cacheKey], now = Date.now();
  if (cached?.value) {
    let windowStart = now - timeIntervalToMilliseconds(timeout), occurrences = cached.value.filter((occurrence) => occurrence >= windowStart);
    if (occurrences.length >= limit)
      return cache[cacheKey] = { value: occurrences, timestamp: Date.now() }, config.set("cache", cache), !1;
    await task(), cache[cacheKey] = { value: [...occurrences, now], timestamp: now };
  } else
    await task(), cache[cacheKey] = { value: [now], timestamp: now };
  return config.set("cache", cache), !0;
}

// ../../node_modules/.pnpm/latest-version@7.0.0/node_modules/latest-version/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/package-json@8.1.1/node_modules/package-json/index.js
init_cjs_shims();
import { Agent as HttpAgent } from "node:http";
import { Agent as HttpsAgent } from "node:https";

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/create.js
init_cjs_shims();

// ../../node_modules/.pnpm/@sindresorhus+is@5.6.0/node_modules/@sindresorhus/is/dist/index.js
init_cjs_shims();
var typedArrayTypeNames = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function isTypedArrayName(name) {
  return typedArrayTypeNames.includes(name);
}
var objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Blob",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "WeakRef",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "FormData",
  "URLSearchParams",
  "HTMLElement",
  "NaN",
  ...typedArrayTypeNames
];
function isObjectTypeName(name) {
  return objectTypeNames.includes(name);
}
var primitiveTypeNames = [
  "null",
  "undefined",
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol"
];
function isPrimitiveTypeName(name) {
  return primitiveTypeNames.includes(name);
}
function isOfType(type) {
  return (value) => typeof value === type;
}
var { toString } = Object.prototype, getObjectType = (value) => {
  let objectTypeName = toString.call(value).slice(8, -1);
  if (/HTML\w+Element/.test(objectTypeName) && is.domElement(value))
    return "HTMLElement";
  if (isObjectTypeName(objectTypeName))
    return objectTypeName;
}, isObjectOfType = (type) => (value) => getObjectType(value) === type;
function is(value) {
  if (value === null)
    return "null";
  switch (typeof value) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(value) ? "NaN" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "Function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    default:
  }
  if (is.observable(value))
    return "Observable";
  if (is.array(value))
    return "Array";
  if (is.buffer(value))
    return "Buffer";
  let tagType = getObjectType(value);
  if (tagType)
    return tagType;
  if (value instanceof String || value instanceof Boolean || value instanceof Number)
    throw new TypeError("Please don't use object wrappers for primitive types");
  return "Object";
}
is.undefined = isOfType("undefined");
is.string = isOfType("string");
var isNumberType = isOfType("number");
is.number = (value) => isNumberType(value) && !is.nan(value);
is.positiveNumber = (value) => is.number(value) && value > 0;
is.negativeNumber = (value) => is.number(value) && value < 0;
is.bigint = isOfType("bigint");
is.function_ = isOfType("function");
is.null_ = (value) => value === null;
is.class_ = (value) => is.function_(value) && value.toString().startsWith("class ");
is.boolean = (value) => value === !0 || value === !1;
is.symbol = isOfType("symbol");
is.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));
is.array = (value, assertion) => Array.isArray(value) ? is.function_(assertion) ? value.every((element) => assertion(element)) : !0 : !1;
is.buffer = (value) => value?.constructor?.isBuffer?.(value) ?? !1;
is.blob = (value) => isObjectOfType("Blob")(value);
is.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);
is.object = (value) => !is.null_(value) && (typeof value == "object" || is.function_(value));
is.iterable = (value) => is.function_(value?.[Symbol.iterator]);
is.asyncIterable = (value) => is.function_(value?.[Symbol.asyncIterator]);
is.generator = (value) => is.iterable(value) && is.function_(value?.next) && is.function_(value?.throw);
is.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);
is.nativePromise = (value) => isObjectOfType("Promise")(value);
var hasPromiseApi = (value) => is.function_(value?.then) && is.function_(value?.catch);
is.promise = (value) => is.nativePromise(value) || hasPromiseApi(value);
is.generatorFunction = isObjectOfType("GeneratorFunction");
is.asyncGeneratorFunction = (value) => getObjectType(value) === "AsyncGeneratorFunction";
is.asyncFunction = (value) => getObjectType(value) === "AsyncFunction";
is.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty("prototype");
is.regExp = isObjectOfType("RegExp");
is.date = isObjectOfType("Date");
is.error = isObjectOfType("Error");
is.map = (value) => isObjectOfType("Map")(value);
is.set = (value) => isObjectOfType("Set")(value);
is.weakMap = (value) => isObjectOfType("WeakMap")(value);
is.weakSet = (value) => isObjectOfType("WeakSet")(value);
is.weakRef = (value) => isObjectOfType("WeakRef")(value);
is.int8Array = isObjectOfType("Int8Array");
is.uint8Array = isObjectOfType("Uint8Array");
is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
is.int16Array = isObjectOfType("Int16Array");
is.uint16Array = isObjectOfType("Uint16Array");
is.int32Array = isObjectOfType("Int32Array");
is.uint32Array = isObjectOfType("Uint32Array");
is.float32Array = isObjectOfType("Float32Array");
is.float64Array = isObjectOfType("Float64Array");
is.bigInt64Array = isObjectOfType("BigInt64Array");
is.bigUint64Array = isObjectOfType("BigUint64Array");
is.arrayBuffer = isObjectOfType("ArrayBuffer");
is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
is.dataView = isObjectOfType("DataView");
is.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);
is.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;
is.urlInstance = (value) => isObjectOfType("URL")(value);
is.urlString = (value) => {
  if (!is.string(value))
    return !1;
  try {
    return new URL(value), !0;
  } catch {
    return !1;
  }
};
is.truthy = (value) => !!value;
is.falsy = (value) => !value;
is.nan = (value) => Number.isNaN(value);
is.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);
is.integer = (value) => Number.isInteger(value);
is.safeInteger = (value) => Number.isSafeInteger(value);
is.plainObject = (value) => {
  if (typeof value != "object" || value === null)
    return !1;
  let prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
};
is.typedArray = (value) => isTypedArrayName(getObjectType(value));
var isValidLength = (value) => is.safeInteger(value) && value >= 0;
is.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);
is.tupleLike = (value, guards) => is.array(guards) && is.array(value) && guards.length === value.length ? guards.every((guard, index) => guard(value[index])) : !1;
is.inRange = (value, range) => {
  if (is.number(range))
    return value >= Math.min(0, range) && value <= Math.max(range, 0);
  if (is.array(range) && range.length === 2)
    return value >= Math.min(...range) && value <= Math.max(...range);
  throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
};
var NODE_TYPE_ELEMENT = 1, DOM_PROPERTIES_TO_CHECK = [
  "innerHTML",
  "ownerDocument",
  "style",
  "attributes",
  "nodeValue"
];
is.domElement = (value) => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
is.observable = (value) => value ? value === value[Symbol.observable]?.() || value === value["@@observable"]?.() : !1;
is.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);
is.infinite = (value) => value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY;
var isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;
is.evenInteger = isAbsoluteMod2(0);
is.oddInteger = isAbsoluteMod2(1);
is.emptyArray = (value) => is.array(value) && value.length === 0;
is.nonEmptyArray = (value) => is.array(value) && value.length > 0;
is.emptyString = (value) => is.string(value) && value.length === 0;
var isWhiteSpaceString = (value) => is.string(value) && !/\S/.test(value);
is.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);
is.nonEmptyString = (value) => is.string(value) && value.length > 0;
is.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);
is.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;
is.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;
is.emptySet = (value) => is.set(value) && value.size === 0;
is.nonEmptySet = (value) => is.set(value) && value.size > 0;
is.emptyMap = (value) => is.map(value) && value.size === 0;
is.nonEmptyMap = (value) => is.map(value) && value.size > 0;
is.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);
is.formData = (value) => isObjectOfType("FormData")(value);
is.urlSearchParams = (value) => isObjectOfType("URLSearchParams")(value);
var predicateOnArray = (method, predicate, values) => {
  if (!is.function_(predicate))
    throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
  if (values.length === 0)
    throw new TypeError("Invalid number of values");
  return method.call(values, predicate);
};
is.any = (predicate, ...values) => (is.array(predicate) ? predicate : [predicate]).some((singlePredicate) => predicateOnArray(Array.prototype.some, singlePredicate, values));
is.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
var assertType = (condition, description, value, options = {}) => {
  if (!condition) {
    let { multipleValues } = options, valuesMessage = multipleValues ? `received values of types ${[
      ...new Set(value.map((singleValue) => `\`${is(singleValue)}\``))
    ].join(", ")}` : `received value of type \`${is(value)}\``;
    throw new TypeError(`Expected value which is \`${description}\`, ${valuesMessage}.`);
  }
}, assert2 = {
  // Unknowns.
  undefined: (value) => assertType(is.undefined(value), "undefined", value),
  string: (value) => assertType(is.string(value), "string", value),
  number: (value) => assertType(is.number(value), "number", value),
  positiveNumber: (value) => assertType(is.positiveNumber(value), "positive number", value),
  negativeNumber: (value) => assertType(is.negativeNumber(value), "negative number", value),
  bigint: (value) => assertType(is.bigint(value), "bigint", value),
  // eslint-disable-next-line @typescript-eslint/ban-types
  function_: (value) => assertType(is.function_(value), "Function", value),
  null_: (value) => assertType(is.null_(value), "null", value),
  class_: (value) => assertType(is.class_(value), "Class", value),
  boolean: (value) => assertType(is.boolean(value), "boolean", value),
  symbol: (value) => assertType(is.symbol(value), "symbol", value),
  numericString: (value) => assertType(is.numericString(value), "string with a number", value),
  array: (value, assertion) => {
    assertType(is.array(value), "Array", value), assertion && value.forEach(assertion);
  },
  buffer: (value) => assertType(is.buffer(value), "Buffer", value),
  blob: (value) => assertType(is.blob(value), "Blob", value),
  nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), "null or undefined", value),
  object: (value) => assertType(is.object(value), "Object", value),
  iterable: (value) => assertType(is.iterable(value), "Iterable", value),
  asyncIterable: (value) => assertType(is.asyncIterable(value), "AsyncIterable", value),
  generator: (value) => assertType(is.generator(value), "Generator", value),
  asyncGenerator: (value) => assertType(is.asyncGenerator(value), "AsyncGenerator", value),
  nativePromise: (value) => assertType(is.nativePromise(value), "native Promise", value),
  promise: (value) => assertType(is.promise(value), "Promise", value),
  generatorFunction: (value) => assertType(is.generatorFunction(value), "GeneratorFunction", value),
  asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), "AsyncGeneratorFunction", value),
  // eslint-disable-next-line @typescript-eslint/ban-types
  asyncFunction: (value) => assertType(is.asyncFunction(value), "AsyncFunction", value),
  // eslint-disable-next-line @typescript-eslint/ban-types
  boundFunction: (value) => assertType(is.boundFunction(value), "Function", value),
  regExp: (value) => assertType(is.regExp(value), "RegExp", value),
  date: (value) => assertType(is.date(value), "Date", value),
  error: (value) => assertType(is.error(value), "Error", value),
  map: (value) => assertType(is.map(value), "Map", value),
  set: (value) => assertType(is.set(value), "Set", value),
  weakMap: (value) => assertType(is.weakMap(value), "WeakMap", value),
  weakSet: (value) => assertType(is.weakSet(value), "WeakSet", value),
  weakRef: (value) => assertType(is.weakRef(value), "WeakRef", value),
  int8Array: (value) => assertType(is.int8Array(value), "Int8Array", value),
  uint8Array: (value) => assertType(is.uint8Array(value), "Uint8Array", value),
  uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), "Uint8ClampedArray", value),
  int16Array: (value) => assertType(is.int16Array(value), "Int16Array", value),
  uint16Array: (value) => assertType(is.uint16Array(value), "Uint16Array", value),
  int32Array: (value) => assertType(is.int32Array(value), "Int32Array", value),
  uint32Array: (value) => assertType(is.uint32Array(value), "Uint32Array", value),
  float32Array: (value) => assertType(is.float32Array(value), "Float32Array", value),
  float64Array: (value) => assertType(is.float64Array(value), "Float64Array", value),
  bigInt64Array: (value) => assertType(is.bigInt64Array(value), "BigInt64Array", value),
  bigUint64Array: (value) => assertType(is.bigUint64Array(value), "BigUint64Array", value),
  arrayBuffer: (value) => assertType(is.arrayBuffer(value), "ArrayBuffer", value),
  sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), "SharedArrayBuffer", value),
  dataView: (value) => assertType(is.dataView(value), "DataView", value),
  enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), "EnumCase", value),
  urlInstance: (value) => assertType(is.urlInstance(value), "URL", value),
  urlString: (value) => assertType(is.urlString(value), "string with a URL", value),
  truthy: (value) => assertType(is.truthy(value), "truthy", value),
  falsy: (value) => assertType(is.falsy(value), "falsy", value),
  nan: (value) => assertType(is.nan(value), "NaN", value),
  primitive: (value) => assertType(is.primitive(value), "primitive", value),
  integer: (value) => assertType(is.integer(value), "integer", value),
  safeInteger: (value) => assertType(is.safeInteger(value), "integer", value),
  plainObject: (value) => assertType(is.plainObject(value), "plain object", value),
  typedArray: (value) => assertType(is.typedArray(value), "TypedArray", value),
  arrayLike: (value) => assertType(is.arrayLike(value), "array-like", value),
  tupleLike: (value, guards) => assertType(is.tupleLike(value, guards), "tuple-like", value),
  domElement: (value) => assertType(is.domElement(value), "HTMLElement", value),
  observable: (value) => assertType(is.observable(value), "Observable", value),
  nodeStream: (value) => assertType(is.nodeStream(value), "Node.js Stream", value),
  infinite: (value) => assertType(is.infinite(value), "infinite number", value),
  emptyArray: (value) => assertType(is.emptyArray(value), "empty array", value),
  nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), "non-empty array", value),
  emptyString: (value) => assertType(is.emptyString(value), "empty string", value),
  emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), "empty string or whitespace", value),
  nonEmptyString: (value) => assertType(is.nonEmptyString(value), "non-empty string", value),
  nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), "non-empty string and not whitespace", value),
  emptyObject: (value) => assertType(is.emptyObject(value), "empty object", value),
  nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), "non-empty object", value),
  emptySet: (value) => assertType(is.emptySet(value), "empty set", value),
  nonEmptySet: (value) => assertType(is.nonEmptySet(value), "non-empty set", value),
  emptyMap: (value) => assertType(is.emptyMap(value), "empty map", value),
  nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), "non-empty map", value),
  propertyKey: (value) => assertType(is.propertyKey(value), "PropertyKey", value),
  formData: (value) => assertType(is.formData(value), "FormData", value),
  urlSearchParams: (value) => assertType(is.urlSearchParams(value), "URLSearchParams", value),
  // Numbers.
  evenInteger: (value) => assertType(is.evenInteger(value), "even integer", value),
  oddInteger: (value) => assertType(is.oddInteger(value), "odd integer", value),
  // Two arguments.
  directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), "T", instance),
  inRange: (value, range) => assertType(is.inRange(value, range), "in range", value),
  // Variadic functions.
  any: (predicate, ...values) => assertType(is.any(predicate, ...values), "predicate returns truthy for any value", values, { multipleValues: !0 }),
  all: (predicate, ...values) => assertType(is.all(predicate, ...values), "predicate returns truthy for all values", values, { multipleValues: !0 })
};
Object.defineProperties(is, {
  class: {
    value: is.class_
  },
  function: {
    value: is.function_
  },
  null: {
    value: is.null_
  }
});
Object.defineProperties(assert2, {
  class: {
    value: assert2.class_
  },
  function: {
    value: assert2.function_
  },
  null: {
    value: assert2.null_
  }
});
var dist_default2 = is;

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/as-promise/index.js
init_cjs_shims();
import { EventEmitter as EventEmitter3 } from "node:events";

// ../../node_modules/.pnpm/p-cancelable@3.0.0/node_modules/p-cancelable/index.js
init_cjs_shims();
var CancelError = class extends Error {
  constructor(reason) {
    super(reason || "Promise was canceled"), this.name = "CancelError";
  }
  get isCanceled() {
    return !0;
  }
}, PCancelable = class _PCancelable {
  static fn(userFunction) {
    return (...arguments_) => new _PCancelable((resolve, reject, onCancel) => {
      arguments_.push(onCancel), userFunction(...arguments_).then(resolve, reject);
    });
  }
  constructor(executor) {
    this._cancelHandlers = [], this._isPending = !0, this._isCanceled = !1, this._rejectOnCancel = !0, this._promise = new Promise((resolve, reject) => {
      this._reject = reject;
      let onResolve = (value) => {
        (!this._isCanceled || !onCancel.shouldReject) && (this._isPending = !1, resolve(value));
      }, onReject = (error) => {
        this._isPending = !1, reject(error);
      }, onCancel = (handler) => {
        if (!this._isPending)
          throw new Error("The `onCancel` handler was attached after the promise settled.");
        this._cancelHandlers.push(handler);
      };
      Object.defineProperties(onCancel, {
        shouldReject: {
          get: () => this._rejectOnCancel,
          set: (boolean) => {
            this._rejectOnCancel = boolean;
          }
        }
      }), executor(onResolve, onReject, onCancel);
    });
  }
  then(onFulfilled, onRejected) {
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    return this._promise.catch(onRejected);
  }
  finally(onFinally) {
    return this._promise.finally(onFinally);
  }
  cancel(reason) {
    if (!(!this._isPending || this._isCanceled)) {
      if (this._isCanceled = !0, this._cancelHandlers.length > 0)
        try {
          for (let handler of this._cancelHandlers)
            handler();
        } catch (error) {
          this._reject(error);
          return;
        }
      this._rejectOnCancel && this._reject(new CancelError(reason));
    }
  }
  get isCanceled() {
    return this._isCanceled;
  }
};
Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/errors.js
init_cjs_shims();
function isRequest(x) {
  return dist_default2.object(x) && "_onResponse" in x;
}
var RequestError = class extends Error {
  constructor(message, error, self) {
    if (super(message), Object.defineProperty(this, "input", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "stack", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "response", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "timings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Error.captureStackTrace(this, this.constructor), this.name = "RequestError", this.code = error.code ?? "ERR_GOT_REQUEST_ERROR", this.input = error.input, isRequest(self) ? (Object.defineProperty(this, "request", {
      enumerable: !1,
      value: self
    }), Object.defineProperty(this, "response", {
      enumerable: !1,
      value: self.response
    }), this.options = self.options) : this.options = self, this.timings = this.request?.timings, dist_default2.string(error.stack) && dist_default2.string(this.stack)) {
      let indexOfMessage = this.stack.indexOf(this.message) + this.message.length, thisStackTrace = this.stack.slice(indexOfMessage).split(`
`).reverse(), errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split(`
`).reverse();
      for (; errorStackTrace.length > 0 && errorStackTrace[0] === thisStackTrace[0]; )
        thisStackTrace.shift();
      this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join(`
`)}${errorStackTrace.reverse().join(`
`)}`;
    }
  }
}, MaxRedirectsError = class extends RequestError {
  constructor(request) {
    super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request), this.name = "MaxRedirectsError", this.code = "ERR_TOO_MANY_REDIRECTS";
  }
}, HTTPError = class extends RequestError {
  constructor(response) {
    super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request), this.name = "HTTPError", this.code = "ERR_NON_2XX_3XX_RESPONSE";
  }
}, CacheError = class extends RequestError {
  constructor(error, request) {
    super(error.message, error, request), this.name = "CacheError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
  }
}, UploadError = class extends RequestError {
  constructor(error, request) {
    super(error.message, error, request), this.name = "UploadError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
  }
}, TimeoutError = class extends RequestError {
  constructor(error, timings, request) {
    super(error.message, error, request), Object.defineProperty(this, "timings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TimeoutError", this.event = error.event, this.timings = timings;
  }
}, ReadError = class extends RequestError {
  constructor(error, request) {
    super(error.message, error, request), this.name = "ReadError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code;
  }
}, RetryError = class extends RequestError {
  constructor(request) {
    super("Retrying", {}, request), this.name = "RetryError", this.code = "ERR_RETRYING";
  }
}, AbortError2 = class extends RequestError {
  constructor(request) {
    super("This operation was aborted.", {}, request), this.code = "ERR_ABORTED", this.name = "AbortError";
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/index.js
init_cjs_shims();
import process8 from "node:process";
import { Buffer as Buffer4 } from "node:buffer";
import { Duplex } from "node:stream";
import { URL as URL3, URLSearchParams as URLSearchParams2 } from "node:url";
import http2, { ServerResponse } from "node:http";

// ../../node_modules/.pnpm/@szmarczak+http-timer@5.0.1/node_modules/@szmarczak/http-timer/dist/source/index.js
init_cjs_shims();
var import_defer_to_connect = __toESM(require_source(), 1);
import { errorMonitor } from "events";
import { types } from "util";
var timer = (request) => {
  if (request.timings)
    return request.timings;
  let timings = {
    start: Date.now(),
    socket: void 0,
    lookup: void 0,
    connect: void 0,
    secureConnect: void 0,
    upload: void 0,
    response: void 0,
    end: void 0,
    error: void 0,
    abort: void 0,
    phases: {
      wait: void 0,
      dns: void 0,
      tcp: void 0,
      tls: void 0,
      request: void 0,
      firstByte: void 0,
      download: void 0,
      total: void 0
    }
  };
  request.timings = timings;
  let handleError = (origin) => {
    origin.once(errorMonitor, () => {
      timings.error = Date.now(), timings.phases.total = timings.error - timings.start;
    });
  };
  handleError(request);
  let onAbort = () => {
    timings.abort = Date.now(), timings.phases.total = timings.abort - timings.start;
  };
  request.prependOnceListener("abort", onAbort);
  let onSocket = (socket) => {
    if (timings.socket = Date.now(), timings.phases.wait = timings.socket - timings.start, types.isProxy(socket))
      return;
    let lookupListener = () => {
      timings.lookup = Date.now(), timings.phases.dns = timings.lookup - timings.socket;
    };
    socket.prependOnceListener("lookup", lookupListener), (0, import_defer_to_connect.default)(socket, {
      connect: () => {
        timings.connect = Date.now(), timings.lookup === void 0 && (socket.removeListener("lookup", lookupListener), timings.lookup = timings.connect, timings.phases.dns = timings.lookup - timings.socket), timings.phases.tcp = timings.connect - timings.lookup;
      },
      secureConnect: () => {
        timings.secureConnect = Date.now(), timings.phases.tls = timings.secureConnect - timings.connect;
      }
    });
  };
  request.socket ? onSocket(request.socket) : request.prependOnceListener("socket", onSocket);
  let onUpload = () => {
    timings.upload = Date.now(), timings.phases.request = timings.upload - (timings.secureConnect ?? timings.connect);
  };
  return request.writableFinished ? onUpload() : request.prependOnceListener("finish", onUpload), request.prependOnceListener("response", (response) => {
    timings.response = Date.now(), timings.phases.firstByte = timings.response - timings.upload, response.timings = timings, handleError(response), response.prependOnceListener("end", () => {
      request.off("abort", onAbort), response.off("aborted", onAbort), !timings.phases.total && (timings.end = Date.now(), timings.phases.download = timings.end - timings.response, timings.phases.total = timings.end - timings.start);
    }), response.prependOnceListener("aborted", onAbort);
  }), timings;
}, source_default = timer;

// ../../node_modules/.pnpm/cacheable-request@10.2.14/node_modules/cacheable-request/dist/index.js
init_cjs_shims();
import EventEmitter2 from "node:events";
import urlLib from "node:url";
import crypto2 from "node:crypto";
import stream, { PassThrough as PassThroughStream } from "node:stream";

// ../../node_modules/.pnpm/normalize-url@8.1.0/node_modules/normalize-url/index.js
init_cjs_shims();
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain", DATA_URL_DEFAULT_CHARSET = "us-ascii", testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name), supportedProtocols = /* @__PURE__ */ new Set([
  "https:",
  "http:",
  "file:"
]), hasCustomProtocol = (urlString) => {
  try {
    let { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !protocol.includes(".") && !supportedProtocols.has(protocol);
  } catch {
    return !1;
  }
}, normalizeDataURL = (urlString, { stripHash }) => {
  let match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match)
    throw new Error(`Invalid URL: ${urlString}`);
  let { type, data, hash } = match.groups, mediaType = type.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = !1;
  mediaType[mediaType.length - 1] === "base64" && (mediaType.pop(), isBase64 = !0);
  let mimeType = mediaType.shift()?.toLowerCase() ?? "", normalizedMediaType = [
    ...mediaType.map((attribute) => {
      let [key, value = ""] = attribute.split("=").map((string) => string.trim());
      return key === "charset" && (value = value.toLowerCase(), value === DATA_URL_DEFAULT_CHARSET) ? "" : `${key}${value ? `=${value}` : ""}`;
    }).filter(Boolean)
  ];
  return isBase64 && normalizedMediaType.push("base64"), (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) && normalizedMediaType.unshift(mimeType), `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options) {
  if (options = {
    defaultProtocol: "http",
    normalizeProtocol: !0,
    forceHttp: !1,
    forceHttps: !1,
    stripAuthentication: !0,
    stripHash: !1,
    stripTextFragment: !0,
    stripWWW: !0,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: !0,
    removeSingleSlash: !0,
    removeDirectoryIndex: !1,
    removeExplicitPort: !1,
    sortQueryParameters: !0,
    removePath: !1,
    transformPath: !1,
    ...options
  }, typeof options.defaultProtocol == "string" && !options.defaultProtocol.endsWith(":") && (options.defaultProtocol = `${options.defaultProtocol}:`), urlString = urlString.trim(), /^data:/i.test(urlString))
    return normalizeDataURL(urlString, options);
  if (hasCustomProtocol(urlString))
    return urlString;
  let hasRelativeProtocol = urlString.startsWith("//");
  !hasRelativeProtocol && /^\.*\//.test(urlString) || (urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol));
  let urlObject = new URL(urlString);
  if (options.forceHttp && options.forceHttps)
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  if (options.forceHttp && urlObject.protocol === "https:" && (urlObject.protocol = "http:"), options.forceHttps && urlObject.protocol === "http:" && (urlObject.protocol = "https:"), options.stripAuthentication && (urlObject.username = "", urlObject.password = ""), options.stripHash ? urlObject.hash = "" : options.stripTextFragment && (urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "")), urlObject.pathname) {
    let protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g, lastIndex = 0, result = "";
    for (; ; ) {
      let match = protocolRegex.exec(urlObject.pathname);
      if (!match)
        break;
      let protocol = match[0], protocolAtIndex = match.index, intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/"), result += protocol, lastIndex = protocolAtIndex + protocol.length;
    }
    let remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/"), urlObject.pathname = result;
  }
  if (urlObject.pathname)
    try {
      urlObject.pathname = decodeURI(urlObject.pathname).replace(/\\/g, "%5C");
    } catch {
    }
  if (options.removeDirectoryIndex === !0 && (options.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/"), lastComponent = pathComponents[pathComponents.length - 1];
    testParameter(lastComponent, options.removeDirectoryIndex) && (pathComponents = pathComponents.slice(0, -1), urlObject.pathname = pathComponents.slice(1).join("/") + "/");
  }
  if (options.removePath && (urlObject.pathname = "/"), options.transformPath && typeof options.transformPath == "function") {
    let pathComponents = urlObject.pathname.split("/").filter(Boolean), newComponents = options.transformPath(pathComponents);
    urlObject.pathname = newComponents?.length > 0 ? `/${newComponents.join("/")}` : "/";
  }
  if (urlObject.hostname && (urlObject.hostname = urlObject.hostname.replace(/\.$/, ""), options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname) && (urlObject.hostname = urlObject.hostname.replace(/^www\./, ""))), Array.isArray(options.removeQueryParameters))
    for (let key of [...urlObject.searchParams.keys()])
      testParameter(key, options.removeQueryParameters) && urlObject.searchParams.delete(key);
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === !0 && (urlObject.search = ""), Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0)
    for (let key of [...urlObject.searchParams.keys()])
      testParameter(key, options.keepQueryParameters) || urlObject.searchParams.delete(key);
  if (options.sortQueryParameters) {
    let originalSearch = urlObject.search;
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
    let partsWithoutEquals = originalSearch.slice(1).split("&").filter((p) => p && !p.includes("="));
    for (let part of partsWithoutEquals) {
      let decoded = decodeURIComponent(part);
      urlObject.search = urlObject.search.replace(`?${decoded}=`, `?${decoded}`).replace(`&${decoded}=`, `&${decoded}`);
    }
  }
  options.removeTrailingSlash && (urlObject.pathname = urlObject.pathname.replace(/\/$/, "")), options.removeExplicitPort && urlObject.port && (urlObject.port = "");
  let oldUrlString = urlString;
  return urlString = urlObject.toString(), !options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "" && (urlString = urlString.replace(/\/$/, "")), (options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash && (urlString = urlString.replace(/\/$/, "")), hasRelativeProtocol && !options.normalizeProtocol && (urlString = urlString.replace(/^http:\/\//, "//")), options.stripProtocol && (urlString = urlString.replace(/^(?:https?:)?\/\//, "")), urlString;
}

// ../../node_modules/.pnpm/cacheable-request@10.2.14/node_modules/cacheable-request/dist/index.js
var import_get_stream = __toESM(require_get_stream(), 1), import_http_cache_semantics = __toESM(require_http_cache_semantics(), 1);

// ../../node_modules/.pnpm/responselike@3.0.0/node_modules/responselike/index.js
init_cjs_shims();
import { Readable as ReadableStream } from "node:stream";

// ../../node_modules/.pnpm/lowercase-keys@3.0.0/node_modules/lowercase-keys/index.js
init_cjs_shims();
function lowercaseKeys(object) {
  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key.toLowerCase(), value]));
}

// ../../node_modules/.pnpm/responselike@3.0.0/node_modules/responselike/index.js
var Response = class extends ReadableStream {
  statusCode;
  headers;
  body;
  url;
  constructor({ statusCode, headers, body, url }) {
    if (typeof statusCode != "number")
      throw new TypeError("Argument `statusCode` should be a number");
    if (typeof headers != "object")
      throw new TypeError("Argument `headers` should be an object");
    if (!(body instanceof Uint8Array))
      throw new TypeError("Argument `body` should be a buffer");
    if (typeof url != "string")
      throw new TypeError("Argument `url` should be a string");
    super({
      read() {
        this.push(body), this.push(null);
      }
    }), this.statusCode = statusCode, this.headers = lowercaseKeys(headers), this.body = body, this.url = url;
  }
};

// ../../node_modules/.pnpm/cacheable-request@10.2.14/node_modules/cacheable-request/dist/index.js
var import_keyv = __toESM(require_src(), 1);

// ../../node_modules/.pnpm/mimic-response@4.0.0/node_modules/mimic-response/index.js
init_cjs_shims();
var knownProperties = [
  "aborted",
  "complete",
  "headers",
  "httpVersion",
  "httpVersionMinor",
  "httpVersionMajor",
  "method",
  "rawHeaders",
  "rawTrailers",
  "setTimeout",
  "socket",
  "statusCode",
  "statusMessage",
  "trailers",
  "url"
];
function mimicResponse(fromStream, toStream) {
  if (toStream._readableState.autoDestroy)
    throw new Error("The second stream must have the `autoDestroy` option set to `false`");
  let fromProperties = /* @__PURE__ */ new Set([...Object.keys(fromStream), ...knownProperties]), properties = {};
  for (let property of fromProperties)
    property in toStream || (properties[property] = {
      get() {
        let value = fromStream[property];
        return typeof value == "function" ? value.bind(fromStream) : value;
      },
      set(value) {
        fromStream[property] = value;
      },
      enumerable: !0,
      configurable: !1
    });
  return Object.defineProperties(toStream, properties), fromStream.once("aborted", () => {
    toStream.destroy(), toStream.emit("aborted");
  }), fromStream.once("close", () => {
    fromStream.complete && toStream.readable ? toStream.once("end", () => {
      toStream.emit("close");
    }) : toStream.emit("close");
  }), toStream;
}

// ../../node_modules/.pnpm/cacheable-request@10.2.14/node_modules/cacheable-request/dist/types.js
init_cjs_shims();
var RequestError2 = class extends Error {
  constructor(error) {
    super(error.message), Object.assign(this, error);
  }
}, CacheError2 = class extends Error {
  constructor(error) {
    super(error.message), Object.assign(this, error);
  }
};

// ../../node_modules/.pnpm/cacheable-request@10.2.14/node_modules/cacheable-request/dist/index.js
var CacheableRequest = class {
  constructor(cacheRequest, cacheAdapter) {
    this.hooks = /* @__PURE__ */ new Map(), this.request = () => (options, cb) => {
      let url;
      if (typeof options == "string")
        url = normalizeUrlObject(urlLib.parse(options)), options = {};
      else if (options instanceof urlLib.URL)
        url = normalizeUrlObject(urlLib.parse(options.toString())), options = {};
      else {
        let [pathname, ...searchParts] = (options.path ?? "").split("?"), search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
        url = normalizeUrlObject({ ...options, pathname, search });
      }
      options = {
        headers: {},
        method: "GET",
        cache: !0,
        strictTtl: !1,
        automaticFailover: !1,
        ...options,
        ...urlObjectToRequestOptions(url)
      }, options.headers = Object.fromEntries(entries(options.headers).map(([key2, value]) => [key2.toLowerCase(), value]));
      let ee = new EventEmitter2(), normalizedUrlString = normalizeUrl(urlLib.format(url), {
        stripWWW: !1,
        removeTrailingSlash: !1,
        stripAuthentication: !1
      }), key = `${options.method}:${normalizedUrlString}`;
      options.body && options.method !== void 0 && ["POST", "PATCH", "PUT"].includes(options.method) && (options.body instanceof stream.Readable ? options.cache = !1 : key += `:${crypto2.createHash("md5").update(options.body).digest("hex")}`);
      let revalidate = !1, madeRequest = !1, makeRequest = (options_) => {
        madeRequest = !0;
        let requestErrored = !1, requestErrorCallback = () => {
        }, requestErrorPromise = new Promise((resolve) => {
          requestErrorCallback = () => {
            requestErrored || (requestErrored = !0, resolve());
          };
        }), handler = async (response) => {
          if (revalidate) {
            response.status = response.statusCode;
            let revalidatedPolicy = import_http_cache_semantics.default.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);
            if (!revalidatedPolicy.modified) {
              response.resume(), await new Promise((resolve) => {
                response.once("end", resolve);
              });
              let headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());
              response = new Response({ statusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url }), response.cachePolicy = revalidatedPolicy.policy, response.fromCache = !0;
            }
          }
          response.fromCache || (response.cachePolicy = new import_http_cache_semantics.default(options_, response, options_), response.fromCache = !1);
          let clonedResponse;
          options_.cache && response.cachePolicy.storable() ? (clonedResponse = cloneResponse(response), (async () => {
            try {
              let bodyPromise = import_get_stream.default.buffer(response);
              await Promise.race([
                requestErrorPromise,
                new Promise((resolve) => response.once("end", resolve)),
                new Promise((resolve) => response.once("close", resolve))
                // eslint-disable-line no-promise-executor-return
              ]);
              let body = await bodyPromise, value = {
                url: response.url,
                statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                body,
                cachePolicy: response.cachePolicy.toObject()
              }, ttl2 = options_.strictTtl ? response.cachePolicy.timeToLive() : void 0;
              if (options_.maxTtl && (ttl2 = ttl2 ? Math.min(ttl2, options_.maxTtl) : options_.maxTtl), this.hooks.size > 0)
                for (let key_ of this.hooks.keys())
                  value = await this.runHook(key_, value, response);
              await this.cache.set(key, value, ttl2);
            } catch (error) {
              ee.emit("error", new CacheError2(error));
            }
          })()) : options_.cache && revalidate && (async () => {
            try {
              await this.cache.delete(key);
            } catch (error) {
              ee.emit("error", new CacheError2(error));
            }
          })(), ee.emit("response", clonedResponse ?? response), typeof cb == "function" && cb(clonedResponse ?? response);
        };
        try {
          let request_ = this.cacheRequest(options_, handler);
          request_.once("error", requestErrorCallback), request_.once("abort", requestErrorCallback), request_.once("destroy", requestErrorCallback), ee.emit("request", request_);
        } catch (error) {
          ee.emit("error", new RequestError2(error));
        }
      };
      return (async () => {
        let get = async (options_) => {
          await Promise.resolve();
          let cacheEntry = options_.cache ? await this.cache.get(key) : void 0;
          if (cacheEntry === void 0 && !options_.forceRefresh) {
            makeRequest(options_);
            return;
          }
          let policy = import_http_cache_semantics.default.fromObject(cacheEntry.cachePolicy);
          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {
            let headers = convertHeaders(policy.responseHeaders()), response = new Response({ statusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url });
            response.cachePolicy = policy, response.fromCache = !0, ee.emit("response", response), typeof cb == "function" && cb(response);
          } else policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh ? (await this.cache.delete(key), options_.headers = policy.revalidationHeaders(options_), makeRequest(options_)) : (revalidate = cacheEntry, options_.headers = policy.revalidationHeaders(options_), makeRequest(options_));
        }, errorHandler = (error) => ee.emit("error", new CacheError2(error));
        if (this.cache instanceof import_keyv.default) {
          let cachek = this.cache;
          cachek.once("error", errorHandler), ee.on("error", () => cachek.removeListener("error", errorHandler)), ee.on("response", () => cachek.removeListener("error", errorHandler));
        }
        try {
          await get(options);
        } catch (error) {
          options.automaticFailover && !madeRequest && makeRequest(options), ee.emit("error", new CacheError2(error));
        }
      })(), ee;
    }, this.addHook = (name, fn) => {
      this.hooks.has(name) || this.hooks.set(name, fn);
    }, this.removeHook = (name) => this.hooks.delete(name), this.getHook = (name) => this.hooks.get(name), this.runHook = async (name, ...args) => this.hooks.get(name)?.(...args), cacheAdapter instanceof import_keyv.default ? this.cache = cacheAdapter : typeof cacheAdapter == "string" ? this.cache = new import_keyv.default({
      uri: cacheAdapter,
      namespace: "cacheable-request"
    }) : this.cache = new import_keyv.default({
      store: cacheAdapter,
      namespace: "cacheable-request"
    }), this.request = this.request.bind(this), this.cacheRequest = cacheRequest;
  }
}, entries = Object.entries, cloneResponse = (response) => {
  let clone = new PassThroughStream({ autoDestroy: !1 });
  return mimicResponse(response, clone), response.pipe(clone);
}, urlObjectToRequestOptions = (url) => {
  let options = { ...url };
  return options.path = `${url.pathname || "/"}${url.search || ""}`, delete options.pathname, delete options.search, options;
}, normalizeUrlObject = (url) => (
  // If url was parsed by url.parse or new URL:
  // - hostname will be set
  // - host will be hostname[:port]
  // - port will be set if it was explicit in the parsed string
  // Otherwise, url was from request options:
  // - hostname or host may be set
  // - host shall not have port encoded
  {
    protocol: url.protocol,
    auth: url.auth,
    hostname: url.hostname || url.host || "localhost",
    port: url.port,
    pathname: url.pathname,
    search: url.search
  }
), convertHeaders = (headers) => {
  let result = [];
  for (let name of Object.keys(headers))
    result[name.toLowerCase()] = headers[name];
  return result;
}, dist_default3 = CacheableRequest;

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/index.js
var import_decompress_response = __toESM(require_decompress_response(), 1);
var import_get_stream2 = __toESM(require_get_stream(), 1);

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/FormDataEncoder.js
init_cjs_shims();

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/getStreamIterator.js
init_cjs_shims();

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/isFunction.js
init_cjs_shims();
var isFunction2 = (value) => typeof value == "function";

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/getStreamIterator.js
var isAsyncIterable = (value) => isFunction2(value[Symbol.asyncIterator]);
async function* readStream(readable) {
  let reader = readable.getReader();
  for (; ; ) {
    let { done, value } = await reader.read();
    if (done)
      break;
    yield value;
  }
}
var getStreamIterator = (source) => {
  if (isAsyncIterable(source))
    return source;
  if (isFunction2(source.getReader))
    return readStream(source);
  throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
};

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/createBoundary.js
init_cjs_shims();
var alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
  let size = 16, res = "";
  for (; size--; )
    res += alphabet[Math.random() * alphabet.length << 0];
  return res;
}

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/normalizeValue.js
init_cjs_shims();
var normalizeValue = (value) => String(value).replace(/\r|\n/g, (match, i, str) => match === "\r" && str[i + 1] !== `
` || match === `
` && str[i - 1] !== "\r" ? `\r
` : match);

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/isPlainObject.js
init_cjs_shims();
var getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
function isPlainObject(value) {
  if (getType(value) !== "object")
    return !1;
  let pp = Object.getPrototypeOf(value);
  return pp == null ? !0 : (pp.constructor && pp.constructor.toString()) === Object.toString();
}

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/proxyHeaders.js
init_cjs_shims();
function getProperty2(target, prop) {
  if (typeof prop == "string") {
    for (let [name, value] of Object.entries(target))
      if (prop.toLowerCase() === name.toLowerCase())
        return value;
  }
}
var proxyHeaders = (object) => new Proxy(object, {
  get: (target, prop) => getProperty2(target, prop),
  has: (target, prop) => getProperty2(target, prop) !== void 0
});

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/isFormData.js
init_cjs_shims();
var isFormData = (value) => !!(value && isFunction2(value.constructor) && value[Symbol.toStringTag] === "FormData" && isFunction2(value.append) && isFunction2(value.getAll) && isFunction2(value.entries) && isFunction2(value[Symbol.iterator]));

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/escapeName.js
init_cjs_shims();
var escapeName = (name) => String(name).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22");

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/util/isFile.js
init_cjs_shims();
var isFile = (value) => !!(value && typeof value == "object" && isFunction2(value.constructor) && value[Symbol.toStringTag] === "File" && isFunction2(value.stream) && value.name != null);

// ../../node_modules/.pnpm/form-data-encoder@2.1.4/node_modules/form-data-encoder/lib/FormDataEncoder.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}, __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}, _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader, _FormDataEncoder_getContentLength, defaultOptions = {
  enableAdditionalHeaders: !1
}, readonlyProp = { writable: !1, configurable: !1 }, FormDataEncoder = class {
  constructor(form, boundaryOrOptions, options) {
    if (_FormDataEncoder_instances.add(this), _FormDataEncoder_CRLF.set(this, `\r
`), _FormDataEncoder_CRLF_BYTES.set(this, void 0), _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0), _FormDataEncoder_DASHES.set(this, "-".repeat(2)), _FormDataEncoder_encoder.set(this, new TextEncoder()), _FormDataEncoder_footer.set(this, void 0), _FormDataEncoder_form.set(this, void 0), _FormDataEncoder_options.set(this, void 0), !isFormData(form))
      throw new TypeError("Expected first argument to be a FormData instance.");
    let boundary;
    if (isPlainObject(boundaryOrOptions) ? options = boundaryOrOptions : boundary = boundaryOrOptions, boundary || (boundary = createBoundary()), typeof boundary != "string")
      throw new TypeError("Expected boundary argument to be a string.");
    if (options && !isPlainObject(options))
      throw new TypeError("Expected options argument to be an object.");
    __classPrivateFieldSet2(this, _FormDataEncoder_form, Array.from(form.entries()), "f"), __classPrivateFieldSet2(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f"), __classPrivateFieldSet2(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet2(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet2(this, _FormDataEncoder_CRLF, "f")), "f"), __classPrivateFieldSet2(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet2(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f"), this.boundary = `form-data-boundary-${boundary}`, this.contentType = `multipart/form-data; boundary=${this.boundary}`, __classPrivateFieldSet2(this, _FormDataEncoder_footer, __classPrivateFieldGet2(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet2(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet2(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet2(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
    let headers = {
      "Content-Type": this.contentType
    }, contentLength = __classPrivateFieldGet2(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getContentLength).call(this);
    contentLength && (this.contentLength = contentLength, headers["Content-Length"] = contentLength), this.headers = proxyHeaders(Object.freeze(headers)), Object.defineProperties(this, {
      boundary: readonlyProp,
      contentType: readonlyProp,
      contentLength: readonlyProp,
      headers: readonlyProp
    });
  }
  getContentLength() {
    return this.contentLength == null ? void 0 : Number(this.contentLength);
  }
  *values() {
    for (let [name, raw] of __classPrivateFieldGet2(this, _FormDataEncoder_form, "f")) {
      let value = isFile(raw) ? raw : __classPrivateFieldGet2(this, _FormDataEncoder_encoder, "f").encode(normalizeValue(raw));
      yield __classPrivateFieldGet2(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value), yield value, yield __classPrivateFieldGet2(this, _FormDataEncoder_CRLF_BYTES, "f");
    }
    yield __classPrivateFieldGet2(this, _FormDataEncoder_footer, "f");
  }
  async *encode() {
    for (let part of this.values())
      isFile(part) ? yield* getStreamIterator(part.stream()) : yield part;
  }
  [(_FormDataEncoder_CRLF = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_DASHES = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_encoder = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_footer = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_form = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_options = /* @__PURE__ */ new WeakMap(), _FormDataEncoder_instances = /* @__PURE__ */ new WeakSet(), _FormDataEncoder_getFieldHeader = function(name, value) {
    let header = "";
    header += `${__classPrivateFieldGet2(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet2(this, _FormDataEncoder_CRLF, "f")}`, header += `Content-Disposition: form-data; name="${escapeName(name)}"`, isFile(value) && (header += `; filename="${escapeName(value.name)}"${__classPrivateFieldGet2(this, _FormDataEncoder_CRLF, "f")}`, header += `Content-Type: ${value.type || "application/octet-stream"}`);
    let size = isFile(value) ? value.size : value.byteLength;
    return __classPrivateFieldGet2(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === !0 && size != null && !isNaN(size) && (header += `${__classPrivateFieldGet2(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${isFile(value) ? value.size : value.byteLength}`), __classPrivateFieldGet2(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet2(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
  }, _FormDataEncoder_getContentLength = function() {
    let length = 0;
    for (let [name, raw] of __classPrivateFieldGet2(this, _FormDataEncoder_form, "f")) {
      let value = isFile(raw) ? raw : __classPrivateFieldGet2(this, _FormDataEncoder_encoder, "f").encode(normalizeValue(raw)), size = isFile(value) ? value.size : value.byteLength;
      if (size == null || isNaN(size))
        return;
      length += __classPrivateFieldGet2(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength, length += size, length += __classPrivateFieldGet2(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
    }
    return String(length + __classPrivateFieldGet2(this, _FormDataEncoder_footer, "f").byteLength);
  }, Symbol.iterator)]() {
    return this.values();
  }
  [Symbol.asyncIterator]() {
    return this.encode();
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/get-body-size.js
init_cjs_shims();
import { Buffer as Buffer3 } from "node:buffer";
import { promisify as promisify2 } from "node:util";

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/is-form-data.js
init_cjs_shims();
function isFormData2(body) {
  return dist_default2.nodeStream(body) && dist_default2.function_(body.getBoundary);
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/get-body-size.js
async function getBodySize(body, headers) {
  if (headers && "content-length" in headers)
    return Number(headers["content-length"]);
  if (!body)
    return 0;
  if (dist_default2.string(body))
    return Buffer3.byteLength(body);
  if (dist_default2.buffer(body))
    return body.length;
  if (isFormData2(body))
    return promisify2(body.getLength.bind(body))();
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/proxy-events.js
init_cjs_shims();
function proxyEvents(from, to, events) {
  let eventFunctions = {};
  for (let event of events) {
    let eventFunction = (...args) => {
      to.emit(event, ...args);
    };
    eventFunctions[event] = eventFunction, from.on(event, eventFunction);
  }
  return () => {
    for (let [event, eventFunction] of Object.entries(eventFunctions))
      from.off(event, eventFunction);
  };
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/timed-out.js
init_cjs_shims();
import net from "node:net";

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/unhandle.js
init_cjs_shims();
function unhandle() {
  let handlers = [];
  return {
    once(origin, event, fn) {
      origin.once(event, fn), handlers.push({ origin, event, fn });
    },
    unhandleAll() {
      for (let handler of handlers) {
        let { origin, event, fn } = handler;
        origin.removeListener(event, fn);
      }
      handlers.length = 0;
    }
  };
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/timed-out.js
var reentry = Symbol("reentry"), noop = () => {
}, TimeoutError2 = class extends Error {
  constructor(threshold, event) {
    super(`Timeout awaiting '${event}' for ${threshold}ms`), Object.defineProperty(this, "event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: event
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = "TimeoutError", this.code = "ETIMEDOUT";
  }
};
function timedOut(request, delays, options) {
  if (reentry in request)
    return noop;
  request[reentry] = !0;
  let cancelers = [], { once, unhandleAll } = unhandle(), addTimeout = (delay2, callback, event) => {
    let timeout = setTimeout(callback, delay2, delay2, event);
    timeout.unref?.();
    let cancel = () => {
      clearTimeout(timeout);
    };
    return cancelers.push(cancel), cancel;
  }, { host, hostname } = options, timeoutHandler = (delay2, event) => {
    request.destroy(new TimeoutError2(delay2, event));
  }, cancelTimeouts = () => {
    for (let cancel of cancelers)
      cancel();
    unhandleAll();
  };
  if (request.once("error", (error) => {
    if (cancelTimeouts(), request.listenerCount("error") === 0)
      throw error;
  }), typeof delays.request < "u") {
    let cancelTimeout = addTimeout(delays.request, timeoutHandler, "request");
    once(request, "response", (response) => {
      once(response, "end", cancelTimeout);
    });
  }
  if (typeof delays.socket < "u") {
    let { socket } = delays, socketTimeoutHandler = () => {
      timeoutHandler(socket, "socket");
    };
    request.setTimeout(socket, socketTimeoutHandler), cancelers.push(() => {
      request.removeListener("timeout", socketTimeoutHandler);
    });
  }
  let hasLookup = typeof delays.lookup < "u", hasConnect = typeof delays.connect < "u", hasSecureConnect = typeof delays.secureConnect < "u", hasSend = typeof delays.send < "u";
  return (hasLookup || hasConnect || hasSecureConnect || hasSend) && once(request, "socket", (socket) => {
    let { socketPath } = request;
    if (socket.connecting) {
      let hasPath = !!(socketPath ?? net.isIP(hostname ?? host ?? "") !== 0);
      if (hasLookup && !hasPath && typeof socket.address().address > "u") {
        let cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
        once(socket, "lookup", cancelTimeout);
      }
      if (hasConnect) {
        let timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
        hasPath ? once(socket, "connect", timeConnect()) : once(socket, "lookup", (error) => {
          error === null && once(socket, "connect", timeConnect());
        });
      }
      hasSecureConnect && options.protocol === "https:" && once(socket, "connect", () => {
        let cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
        once(socket, "secureConnect", cancelTimeout);
      });
    }
    if (hasSend) {
      let timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
      socket.connecting ? once(socket, "connect", () => {
        once(request, "upload-complete", timeRequest());
      }) : once(request, "upload-complete", timeRequest());
    }
  }), typeof delays.response < "u" && once(request, "upload-complete", () => {
    let cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
    once(request, "response", cancelTimeout);
  }), typeof delays.read < "u" && once(request, "response", (response) => {
    let cancelTimeout = addTimeout(delays.read, timeoutHandler, "read");
    once(response, "end", cancelTimeout);
  }), cancelTimeouts;
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/url-to-options.js
init_cjs_shims();
function urlToOptions(url) {
  url = url;
  let options = {
    protocol: url.protocol,
    hostname: dist_default2.string(url.hostname) && url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
    host: url.host,
    hash: url.hash,
    search: url.search,
    pathname: url.pathname,
    href: url.href,
    path: `${url.pathname || ""}${url.search || ""}`
  };
  return dist_default2.string(url.port) && url.port.length > 0 && (options.port = Number(url.port)), (url.username || url.password) && (options.auth = `${url.username || ""}:${url.password || ""}`), options;
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/weakable-map.js
init_cjs_shims();
var WeakableMap = class {
  constructor() {
    Object.defineProperty(this, "weakMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "map", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.weakMap = /* @__PURE__ */ new WeakMap(), this.map = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    typeof key == "object" ? this.weakMap.set(key, value) : this.map.set(key, value);
  }
  get(key) {
    return typeof key == "object" ? this.weakMap.get(key) : this.map.get(key);
  }
  has(key) {
    return typeof key == "object" ? this.weakMap.has(key) : this.map.has(key);
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/calculate-retry-delay.js
init_cjs_shims();
var calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter, computedValue }) => {
  if (error.name === "RetryError")
    return 1;
  if (attemptCount > retryOptions.limit)
    return 0;
  let hasMethod = retryOptions.methods.includes(error.options.method), hasErrorCode = retryOptions.errorCodes.includes(error.code), hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);
  if (!hasMethod || !hasErrorCode && !hasStatusCode)
    return 0;
  if (error.response) {
    if (retryAfter)
      return retryAfter > computedValue ? 0 : retryAfter;
    if (error.response.statusCode === 413)
      return 0;
  }
  let noise = Math.random() * retryOptions.noise;
  return Math.min(2 ** (attemptCount - 1) * 1e3, retryOptions.backoffLimit) + noise;
}, calculate_retry_delay_default = calculateRetryDelay;

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/options.js
init_cjs_shims();
import process7 from "node:process";
import { promisify as promisify4, inspect } from "node:util";
import { URL as URL2, URLSearchParams } from "node:url";
import { checkServerIdentity } from "node:tls";
import http from "node:http";
import https from "node:https";

// ../../node_modules/.pnpm/cacheable-lookup@7.0.0/node_modules/cacheable-lookup/source/index.js
init_cjs_shims();
import {
  V4MAPPED,
  ADDRCONFIG,
  ALL,
  promises as dnsPromises,
  lookup as dnsLookup
} from "node:dns";
import { promisify as promisify3 } from "node:util";
import os2 from "node:os";
var { Resolver: AsyncResolver } = dnsPromises, kCacheableLookupCreateConnection = Symbol("cacheableLookupCreateConnection"), kCacheableLookupInstance = Symbol("cacheableLookupInstance"), kExpires = Symbol("expires"), supportsALL = typeof ALL == "number", verifyAgent = (agent) => {
  if (!(agent && typeof agent.createConnection == "function"))
    throw new Error("Expected an Agent instance as the first argument");
}, map4to6 = (entries2) => {
  for (let entry of entries2)
    entry.family !== 6 && (entry.address = `::ffff:${entry.address}`, entry.family = 6);
}, getIfaceInfo = () => {
  let has4 = !1, has6 = !1;
  for (let device of Object.values(os2.networkInterfaces()))
    for (let iface of device)
      if (!iface.internal && (iface.family === "IPv6" ? has6 = !0 : has4 = !0, has4 && has6))
        return { has4, has6 };
  return { has4, has6 };
}, isIterable = (map) => Symbol.iterator in map, ignoreNoResultErrors = (dnsPromise) => dnsPromise.catch((error) => {
  if (error.code === "ENODATA" || error.code === "ENOTFOUND" || error.code === "ENOENT")
    return [];
  throw error;
}), ttl = { ttl: !0 }, all = { all: !0 }, all4 = { all: !0, family: 4 }, all6 = { all: !0, family: 6 }, CacheableLookup = class {
  constructor({
    cache = /* @__PURE__ */ new Map(),
    maxTtl = 1 / 0,
    fallbackDuration = 3600,
    errorTtl = 0.15,
    resolver = new AsyncResolver(),
    lookup = dnsLookup
  } = {}) {
    if (this.maxTtl = maxTtl, this.errorTtl = errorTtl, this._cache = cache, this._resolver = resolver, this._dnsLookup = lookup && promisify3(lookup), this.stats = {
      cache: 0,
      query: 0
    }, this._resolver instanceof AsyncResolver ? (this._resolve4 = this._resolver.resolve4.bind(this._resolver), this._resolve6 = this._resolver.resolve6.bind(this._resolver)) : (this._resolve4 = promisify3(this._resolver.resolve4.bind(this._resolver)), this._resolve6 = promisify3(this._resolver.resolve6.bind(this._resolver))), this._iface = getIfaceInfo(), this._pending = {}, this._nextRemovalTime = !1, this._hostnamesToFallback = /* @__PURE__ */ new Set(), this.fallbackDuration = fallbackDuration, fallbackDuration > 0) {
      let interval = setInterval(() => {
        this._hostnamesToFallback.clear();
      }, fallbackDuration * 1e3);
      interval.unref && interval.unref(), this._fallbackInterval = interval;
    }
    this.lookup = this.lookup.bind(this), this.lookupAsync = this.lookupAsync.bind(this);
  }
  set servers(servers) {
    this.clear(), this._resolver.setServers(servers);
  }
  get servers() {
    return this._resolver.getServers();
  }
  lookup(hostname, options, callback) {
    if (typeof options == "function" ? (callback = options, options = {}) : typeof options == "number" && (options = {
      family: options
    }), !callback)
      throw new Error("Callback must be a function.");
    this.lookupAsync(hostname, options).then((result) => {
      options.all ? callback(null, result) : callback(null, result.address, result.family, result.expires, result.ttl, result.source);
    }, callback);
  }
  async lookupAsync(hostname, options = {}) {
    typeof options == "number" && (options = {
      family: options
    });
    let cached = await this.query(hostname);
    if (options.family === 6) {
      let filtered = cached.filter((entry) => entry.family === 6);
      options.hints & V4MAPPED && (supportsALL && options.hints & ALL || filtered.length === 0) ? map4to6(cached) : cached = filtered;
    } else options.family === 4 && (cached = cached.filter((entry) => entry.family === 4));
    if (options.hints & ADDRCONFIG) {
      let { _iface } = this;
      cached = cached.filter((entry) => entry.family === 6 ? _iface.has6 : _iface.has4);
    }
    if (cached.length === 0) {
      let error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);
      throw error.code = "ENOTFOUND", error.hostname = hostname, error;
    }
    return options.all ? cached : cached[0];
  }
  async query(hostname) {
    let source = "cache", cached = await this._cache.get(hostname);
    if (cached && this.stats.cache++, !cached) {
      let pending = this._pending[hostname];
      if (pending)
        this.stats.cache++, cached = await pending;
      else {
        source = "query";
        let newPromise = this.queryAndCache(hostname);
        this._pending[hostname] = newPromise, this.stats.query++;
        try {
          cached = await newPromise;
        } finally {
          delete this._pending[hostname];
        }
      }
    }
    return cached = cached.map((entry) => ({ ...entry, source })), cached;
  }
  async _resolve(hostname) {
    let [A, AAAA] = await Promise.all([
      ignoreNoResultErrors(this._resolve4(hostname, ttl)),
      ignoreNoResultErrors(this._resolve6(hostname, ttl))
    ]), aTtl = 0, aaaaTtl = 0, cacheTtl = 0, now = Date.now();
    for (let entry of A)
      entry.family = 4, entry.expires = now + entry.ttl * 1e3, aTtl = Math.max(aTtl, entry.ttl);
    for (let entry of AAAA)
      entry.family = 6, entry.expires = now + entry.ttl * 1e3, aaaaTtl = Math.max(aaaaTtl, entry.ttl);
    return A.length > 0 ? AAAA.length > 0 ? cacheTtl = Math.min(aTtl, aaaaTtl) : cacheTtl = aTtl : cacheTtl = aaaaTtl, {
      entries: [
        ...A,
        ...AAAA
      ],
      cacheTtl
    };
  }
  async _lookup(hostname) {
    try {
      let [A, AAAA] = await Promise.all([
        // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
        // See https://github.com/szmarczak/cacheable-lookup/issues/42
        ignoreNoResultErrors(this._dnsLookup(hostname, all4)),
        ignoreNoResultErrors(this._dnsLookup(hostname, all6))
      ]);
      return {
        entries: [
          ...A,
          ...AAAA
        ],
        cacheTtl: 0
      };
    } catch {
      return {
        entries: [],
        cacheTtl: 0
      };
    }
  }
  async _set(hostname, data, cacheTtl) {
    if (this.maxTtl > 0 && cacheTtl > 0) {
      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1e3, data[kExpires] = Date.now() + cacheTtl;
      try {
        await this._cache.set(hostname, data, cacheTtl);
      } catch (error) {
        this.lookupAsync = async () => {
          let cacheError = new Error("Cache Error. Please recreate the CacheableLookup instance.");
          throw cacheError.cause = error, cacheError;
        };
      }
      isIterable(this._cache) && this._tick(cacheTtl);
    }
  }
  async queryAndCache(hostname) {
    if (this._hostnamesToFallback.has(hostname))
      return this._dnsLookup(hostname, all);
    let query = await this._resolve(hostname);
    query.entries.length === 0 && this._dnsLookup && (query = await this._lookup(hostname), query.entries.length !== 0 && this.fallbackDuration > 0 && this._hostnamesToFallback.add(hostname));
    let cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;
    return await this._set(hostname, query.entries, cacheTtl), query.entries;
  }
  _tick(ms) {
    let nextRemovalTime = this._nextRemovalTime;
    (!nextRemovalTime || ms < nextRemovalTime) && (clearTimeout(this._removalTimeout), this._nextRemovalTime = ms, this._removalTimeout = setTimeout(() => {
      this._nextRemovalTime = !1;
      let nextExpiry = 1 / 0, now = Date.now();
      for (let [hostname, entries2] of this._cache) {
        let expires = entries2[kExpires];
        now >= expires ? this._cache.delete(hostname) : expires < nextExpiry && (nextExpiry = expires);
      }
      nextExpiry !== 1 / 0 && this._tick(nextExpiry - now);
    }, ms), this._removalTimeout.unref && this._removalTimeout.unref());
  }
  install(agent) {
    if (verifyAgent(agent), kCacheableLookupCreateConnection in agent)
      throw new Error("CacheableLookup has been already installed");
    agent[kCacheableLookupCreateConnection] = agent.createConnection, agent[kCacheableLookupInstance] = this, agent.createConnection = (options, callback) => ("lookup" in options || (options.lookup = this.lookup), agent[kCacheableLookupCreateConnection](options, callback));
  }
  uninstall(agent) {
    if (verifyAgent(agent), agent[kCacheableLookupCreateConnection]) {
      if (agent[kCacheableLookupInstance] !== this)
        throw new Error("The agent is not owned by this CacheableLookup instance");
      agent.createConnection = agent[kCacheableLookupCreateConnection], delete agent[kCacheableLookupCreateConnection], delete agent[kCacheableLookupInstance];
    }
  }
  updateInterfaceInfo() {
    let { _iface } = this;
    this._iface = getIfaceInfo(), (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) && this._cache.clear();
  }
  clear(hostname) {
    if (hostname) {
      this._cache.delete(hostname);
      return;
    }
    this._cache.clear();
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/options.js
var import_http2_wrapper = __toESM(require_source2(), 1);

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/parse-link-header.js
init_cjs_shims();
function parseLinkHeader(link) {
  let parsed = [], items = link.split(",");
  for (let item of items) {
    let [rawUriReference, ...rawLinkParameters] = item.split(";"), trimmedUriReference = rawUriReference.trim();
    if (trimmedUriReference[0] !== "<" || trimmedUriReference[trimmedUriReference.length - 1] !== ">")
      throw new Error(`Invalid format of the Link header reference: ${trimmedUriReference}`);
    let reference = trimmedUriReference.slice(1, -1), parameters = {};
    if (rawLinkParameters.length === 0)
      throw new Error(`Unexpected end of Link header parameters: ${rawLinkParameters.join(";")}`);
    for (let rawParameter of rawLinkParameters) {
      let trimmedRawParameter = rawParameter.trim(), center = trimmedRawParameter.indexOf("=");
      if (center === -1)
        throw new Error(`Failed to parse Link header: ${link}`);
      let name = trimmedRawParameter.slice(0, center).trim(), value = trimmedRawParameter.slice(center + 1).trim();
      parameters[name] = value;
    }
    parsed.push({
      reference,
      parameters
    });
  }
  return parsed;
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/options.js
var [major, minor] = process7.versions.node.split(".").map(Number);
function validateSearchParameters(searchParameters) {
  for (let key in searchParameters) {
    let value = searchParameters[key];
    assert2.any([dist_default2.string, dist_default2.number, dist_default2.boolean, dist_default2.null_, dist_default2.undefined], value);
  }
}
var globalCache = /* @__PURE__ */ new Map(), globalDnsCache, getGlobalDnsCache = () => globalDnsCache || (globalDnsCache = new CacheableLookup(), globalDnsCache), defaultInternals = {
  request: void 0,
  agent: {
    http: void 0,
    https: void 0,
    http2: void 0
  },
  h2session: void 0,
  decompress: !0,
  timeout: {
    connect: void 0,
    lookup: void 0,
    read: void 0,
    request: void 0,
    response: void 0,
    secureConnect: void 0,
    send: void 0,
    socket: void 0
  },
  prefixUrl: "",
  body: void 0,
  form: void 0,
  json: void 0,
  cookieJar: void 0,
  ignoreInvalidCookies: !1,
  searchParams: void 0,
  dnsLookup: void 0,
  dnsCache: void 0,
  context: {},
  hooks: {
    init: [],
    beforeRequest: [],
    beforeError: [],
    beforeRedirect: [],
    beforeRetry: [],
    afterResponse: []
  },
  followRedirect: !0,
  maxRedirects: 10,
  cache: void 0,
  throwHttpErrors: !0,
  username: "",
  password: "",
  http2: !1,
  allowGetBody: !1,
  headers: {
    "user-agent": "got (https://github.com/sindresorhus/got)"
  },
  methodRewriting: !1,
  dnsLookupIpVersion: void 0,
  parseJson: JSON.parse,
  stringifyJson: JSON.stringify,
  retry: {
    limit: 2,
    methods: [
      "GET",
      "PUT",
      "HEAD",
      "DELETE",
      "OPTIONS",
      "TRACE"
    ],
    statusCodes: [
      408,
      413,
      429,
      500,
      502,
      503,
      504,
      521,
      522,
      524
    ],
    errorCodes: [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ECONNREFUSED",
      "EPIPE",
      "ENOTFOUND",
      "ENETUNREACH",
      "EAI_AGAIN"
    ],
    maxRetryAfter: void 0,
    calculateDelay: ({ computedValue }) => computedValue,
    backoffLimit: Number.POSITIVE_INFINITY,
    noise: 100
  },
  localAddress: void 0,
  method: "GET",
  createConnection: void 0,
  cacheOptions: {
    shared: void 0,
    cacheHeuristic: void 0,
    immutableMinTimeToLive: void 0,
    ignoreCargoCult: void 0
  },
  https: {
    alpnProtocols: void 0,
    rejectUnauthorized: void 0,
    checkServerIdentity: void 0,
    certificateAuthority: void 0,
    key: void 0,
    certificate: void 0,
    passphrase: void 0,
    pfx: void 0,
    ciphers: void 0,
    honorCipherOrder: void 0,
    minVersion: void 0,
    maxVersion: void 0,
    signatureAlgorithms: void 0,
    tlsSessionLifetime: void 0,
    dhparam: void 0,
    ecdhCurve: void 0,
    certificateRevocationLists: void 0
  },
  encoding: void 0,
  resolveBodyOnly: !1,
  isStream: !1,
  responseType: "text",
  url: void 0,
  pagination: {
    transform(response) {
      return response.request.options.responseType === "json" ? response.body : JSON.parse(response.body);
    },
    paginate({ response }) {
      let rawLinkHeader = response.headers.link;
      if (typeof rawLinkHeader != "string" || rawLinkHeader.trim() === "")
        return !1;
      let next = parseLinkHeader(rawLinkHeader).find((entry) => entry.parameters.rel === "next" || entry.parameters.rel === '"next"');
      return next ? {
        url: new URL2(next.reference, response.url)
      } : !1;
    },
    filter: () => !0,
    shouldContinue: () => !0,
    countLimit: Number.POSITIVE_INFINITY,
    backoff: 0,
    requestLimit: 1e4,
    stackAllItems: !1
  },
  setHost: !0,
  maxHeaderSize: void 0,
  signal: void 0,
  enableUnixSockets: !0
}, cloneInternals = (internals) => {
  let { hooks, retry } = internals, result = {
    ...internals,
    context: { ...internals.context },
    cacheOptions: { ...internals.cacheOptions },
    https: { ...internals.https },
    agent: { ...internals.agent },
    headers: { ...internals.headers },
    retry: {
      ...retry,
      errorCodes: [...retry.errorCodes],
      methods: [...retry.methods],
      statusCodes: [...retry.statusCodes]
    },
    timeout: { ...internals.timeout },
    hooks: {
      init: [...hooks.init],
      beforeRequest: [...hooks.beforeRequest],
      beforeError: [...hooks.beforeError],
      beforeRedirect: [...hooks.beforeRedirect],
      beforeRetry: [...hooks.beforeRetry],
      afterResponse: [...hooks.afterResponse]
    },
    searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : void 0,
    pagination: { ...internals.pagination }
  };
  return result.url !== void 0 && (result.prefixUrl = ""), result;
}, cloneRaw = (raw) => {
  let { hooks, retry } = raw, result = { ...raw };
  return dist_default2.object(raw.context) && (result.context = { ...raw.context }), dist_default2.object(raw.cacheOptions) && (result.cacheOptions = { ...raw.cacheOptions }), dist_default2.object(raw.https) && (result.https = { ...raw.https }), dist_default2.object(raw.cacheOptions) && (result.cacheOptions = { ...result.cacheOptions }), dist_default2.object(raw.agent) && (result.agent = { ...raw.agent }), dist_default2.object(raw.headers) && (result.headers = { ...raw.headers }), dist_default2.object(retry) && (result.retry = { ...retry }, dist_default2.array(retry.errorCodes) && (result.retry.errorCodes = [...retry.errorCodes]), dist_default2.array(retry.methods) && (result.retry.methods = [...retry.methods]), dist_default2.array(retry.statusCodes) && (result.retry.statusCodes = [...retry.statusCodes])), dist_default2.object(raw.timeout) && (result.timeout = { ...raw.timeout }), dist_default2.object(hooks) && (result.hooks = {
    ...hooks
  }, dist_default2.array(hooks.init) && (result.hooks.init = [...hooks.init]), dist_default2.array(hooks.beforeRequest) && (result.hooks.beforeRequest = [...hooks.beforeRequest]), dist_default2.array(hooks.beforeError) && (result.hooks.beforeError = [...hooks.beforeError]), dist_default2.array(hooks.beforeRedirect) && (result.hooks.beforeRedirect = [...hooks.beforeRedirect]), dist_default2.array(hooks.beforeRetry) && (result.hooks.beforeRetry = [...hooks.beforeRetry]), dist_default2.array(hooks.afterResponse) && (result.hooks.afterResponse = [...hooks.afterResponse])), dist_default2.object(raw.pagination) && (result.pagination = { ...raw.pagination }), result;
}, getHttp2TimeoutOption = (internals) => {
  let delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter((delay2) => typeof delay2 == "number");
  if (delays.length > 0)
    return Math.min(...delays);
}, init = (options, withOptions, self) => {
  let initHooks = options.hooks?.init;
  if (initHooks)
    for (let hook of initHooks)
      hook(withOptions, self);
}, Options = class _Options {
  constructor(input, options, defaults2) {
    if (Object.defineProperty(this, "_unixOptions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_internals", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_merging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_init", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), assert2.any([dist_default2.string, dist_default2.urlInstance, dist_default2.object, dist_default2.undefined], input), assert2.any([dist_default2.object, dist_default2.undefined], options), assert2.any([dist_default2.object, dist_default2.undefined], defaults2), input instanceof _Options || options instanceof _Options)
      throw new TypeError("The defaults must be passed as the third argument");
    this._internals = cloneInternals(defaults2?._internals ?? defaults2 ?? defaultInternals), this._init = [...defaults2?._init ?? []], this._merging = !1, this._unixOptions = void 0;
    try {
      if (dist_default2.plainObject(input))
        try {
          this.merge(input), this.merge(options);
        } finally {
          this.url = input.url;
        }
      else
        try {
          this.merge(options);
        } finally {
          if (options?.url !== void 0)
            if (input === void 0)
              this.url = options.url;
            else
              throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
          else input !== void 0 && (this.url = input);
        }
    } catch (error) {
      throw error.options = this, error;
    }
  }
  merge(options) {
    if (options) {
      if (options instanceof _Options) {
        for (let init2 of options._init)
          this.merge(init2);
        return;
      }
      options = cloneRaw(options), init(this, options, this), init(options, options, this), this._merging = !0, "isStream" in options && (this.isStream = options.isStream);
      try {
        let push = !1;
        for (let key in options)
          if (!(key === "mutableDefaults" || key === "handlers") && key !== "url") {
            if (!(key in this))
              throw new Error(`Unexpected option: ${key}`);
            this[key] = options[key], push = !0;
          }
        push && this._init.push(options);
      } finally {
        this._merging = !1;
      }
    }
  }
  /**
      Custom request function.
      The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).
  
      @default http.request | https.request
      */
  get request() {
    return this._internals.request;
  }
  set request(value) {
    assert2.any([dist_default2.function_, dist_default2.undefined], value), this._internals.request = value;
  }
  /**
      An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
      This is necessary because a request to one protocol might redirect to another.
      In such a scenario, Got will switch over to the right protocol agent for you.
  
      If a key is not present, it will default to a global agent.
  
      @example
      ```
      import got from 'got';
      import HttpAgent from 'agentkeepalive';
  
      const {HttpsAgent} = HttpAgent;
  
      await got('https://sindresorhus.com', {
          agent: {
              http: new HttpAgent(),
              https: new HttpsAgent()
          }
      });
      ```
      */
  get agent() {
    return this._internals.agent;
  }
  set agent(value) {
    assert2.plainObject(value);
    for (let key in value) {
      if (!(key in this._internals.agent))
        throw new TypeError(`Unexpected agent option: ${key}`);
      assert2.any([dist_default2.object, dist_default2.undefined], value[key]);
    }
    this._merging ? Object.assign(this._internals.agent, value) : this._internals.agent = { ...value };
  }
  get h2session() {
    return this._internals.h2session;
  }
  set h2session(value) {
    this._internals.h2session = value;
  }
  /**
      Decompress the response automatically.
  
      This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
  
      If this is disabled, a compressed response is returned as a `Buffer`.
      This may be useful if you want to handle decompression yourself or stream the raw compressed data.
  
      @default true
      */
  get decompress() {
    return this._internals.decompress;
  }
  set decompress(value) {
    assert2.boolean(value), this._internals.decompress = value;
  }
  /**
      Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
      By default, there's no timeout.
  
      This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
  
      - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
          Does not apply when using a Unix domain socket.
      - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
      - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
      - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
      - `response` starts when the request has been written to the socket and ends when the response headers are received.
      - `send` starts when the socket is connected and ends with the request has been written to the socket.
      - `request` starts when the request is initiated and ends when the response's end event fires.
      */
  get timeout() {
    return this._internals.timeout;
  }
  set timeout(value) {
    assert2.plainObject(value);
    for (let key in value) {
      if (!(key in this._internals.timeout))
        throw new Error(`Unexpected timeout option: ${key}`);
      assert2.any([dist_default2.number, dist_default2.undefined], value[key]);
    }
    this._merging ? Object.assign(this._internals.timeout, value) : this._internals.timeout = { ...value };
  }
  /**
      When specified, `prefixUrl` will be prepended to `url`.
      The prefix can be any valid URL, either relative or absolute.
      A trailing slash `/` is optional - one will be added automatically.
  
      __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
  
      __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
      For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
      The latter is used by browsers.
  
      __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
  
      __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
      If the URL doesn't include it anymore, it will throw.
  
      @example
      ```
      import got from 'got';
  
      await got('unicorn', {prefixUrl: 'https://cats.com'});
      //=> 'https://cats.com/unicorn'
  
      const instance = got.extend({
          prefixUrl: 'https://google.com'
      });
  
      await instance('unicorn', {
          hooks: {
              beforeRequest: [
                  options => {
                      options.prefixUrl = 'https://cats.com';
                  }
              ]
          }
      });
      //=> 'https://cats.com/unicorn'
      ```
      */
  get prefixUrl() {
    return this._internals.prefixUrl;
  }
  set prefixUrl(value) {
    if (assert2.any([dist_default2.string, dist_default2.urlInstance], value), value === "") {
      this._internals.prefixUrl = "";
      return;
    }
    if (value = value.toString(), value.endsWith("/") || (value += "/"), this._internals.prefixUrl && this._internals.url) {
      let { href } = this._internals.url;
      this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
    }
    this._internals.prefixUrl = value;
  }
  /**
      __Note #1__: The `body` option cannot be used with the `json` or `form` option.
  
      __Note #2__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.
  
      __Note #4__: This option is not enumerable and will not be merged with the instance defaults.
  
      The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.
  
      Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
      */
  get body() {
    return this._internals.body;
  }
  set body(value) {
    assert2.any([dist_default2.string, dist_default2.buffer, dist_default2.nodeStream, dist_default2.generator, dist_default2.asyncGenerator, isFormData, dist_default2.undefined], value), dist_default2.nodeStream(value) && assert2.truthy(value.readable), value !== void 0 && (assert2.undefined(this._internals.form), assert2.undefined(this._internals.json)), this._internals.body = value;
  }
  /**
      The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).
  
      If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get form() {
    return this._internals.form;
  }
  set form(value) {
    assert2.any([dist_default2.plainObject, dist_default2.undefined], value), value !== void 0 && (assert2.undefined(this._internals.body), assert2.undefined(this._internals.json)), this._internals.form = value;
  }
  /**
      JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.
  
      __Note #1__: If you provide this option, `got.stream()` will be read-only.
  
      __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
      */
  get json() {
    return this._internals.json;
  }
  set json(value) {
    value !== void 0 && (assert2.undefined(this._internals.body), assert2.undefined(this._internals.form)), this._internals.json = value;
  }
  /**
      The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).
  
      Properties from `options` will override properties in the parsed `url`.
  
      If no protocol is specified, it will throw a `TypeError`.
  
      __Note__: The query string is **not** parsed as search params.
  
      @example
      ```
      await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
      await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
  
      // The query string is overridden by `searchParams`
      await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
      ```
      */
  get url() {
    return this._internals.url;
  }
  set url(value) {
    if (assert2.any([dist_default2.string, dist_default2.urlInstance, dist_default2.undefined], value), value === void 0) {
      this._internals.url = void 0;
      return;
    }
    if (dist_default2.string(value) && value.startsWith("/"))
      throw new Error("`url` must not start with a slash");
    let urlString = `${this.prefixUrl}${value.toString()}`, url = new URL2(urlString);
    if (this._internals.url = url, url.protocol === "unix:" && (url.href = `http://unix${url.pathname}${url.search}`), url.protocol !== "http:" && url.protocol !== "https:") {
      let error = new Error(`Unsupported protocol: ${url.protocol}`);
      throw error.code = "ERR_UNSUPPORTED_PROTOCOL", error;
    }
    if (this._internals.username && (url.username = this._internals.username, this._internals.username = ""), this._internals.password && (url.password = this._internals.password, this._internals.password = ""), this._internals.searchParams && (url.search = this._internals.searchParams.toString(), this._internals.searchParams = void 0), url.hostname === "unix") {
      if (!this._internals.enableUnixSockets)
        throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
      let matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
      if (matches?.groups) {
        let { socketPath, path: path4 } = matches.groups;
        this._unixOptions = {
          socketPath,
          path: path4,
          host: ""
        };
      } else
        this._unixOptions = void 0;
      return;
    }
    this._unixOptions = void 0;
  }
  /**
      Cookie support. You don't have to care about parsing or how to store them.
  
      __Note__: If you provide this option, `options.headers.cookie` will be overridden.
      */
  get cookieJar() {
    return this._internals.cookieJar;
  }
  set cookieJar(value) {
    if (assert2.any([dist_default2.object, dist_default2.undefined], value), value === void 0) {
      this._internals.cookieJar = void 0;
      return;
    }
    let { setCookie, getCookieString } = value;
    assert2.function_(setCookie), assert2.function_(getCookieString), setCookie.length === 4 && getCookieString.length === 0 ? (setCookie = promisify4(setCookie.bind(value)), getCookieString = promisify4(getCookieString.bind(value)), this._internals.cookieJar = {
      setCookie,
      getCookieString
    }) : this._internals.cookieJar = value;
  }
  /**
      You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
  
      *Requires Node.js 16 or later.*
  
      @example
      ```
      import got from 'got';
  
      const abortController = new AbortController();
  
      const request = got('https://httpbin.org/anything', {
          signal: abortController.signal
      });
  
      setTimeout(() => {
          abortController.abort();
      }, 100);
      ```
      */
  // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
  get signal() {
    return this._internals.signal;
  }
  // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
  set signal(value) {
    assert2.object(value), this._internals.signal = value;
  }
  /**
      Ignore invalid cookies instead of throwing an error.
      Only useful when the `cookieJar` option has been set. Not recommended.
  
      @default false
      */
  get ignoreInvalidCookies() {
    return this._internals.ignoreInvalidCookies;
  }
  set ignoreInvalidCookies(value) {
    assert2.boolean(value), this._internals.ignoreInvalidCookies = value;
  }
  /**
      Query string that will be added to the request URL.
      This will override the query string in `url`.
  
      If you need to pass in an array, you can do it using a `URLSearchParams` instance.
  
      @example
      ```
      import got from 'got';
  
      const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);
  
      await got('https://example.com', {searchParams});
  
      console.log(searchParams.toString());
      //=> 'key=a&key=b'
      ```
      */
  get searchParams() {
    return this._internals.url ? this._internals.url.searchParams : (this._internals.searchParams === void 0 && (this._internals.searchParams = new URLSearchParams()), this._internals.searchParams);
  }
  set searchParams(value) {
    assert2.any([dist_default2.string, dist_default2.object, dist_default2.undefined], value);
    let url = this._internals.url;
    if (value === void 0) {
      this._internals.searchParams = void 0, url && (url.search = "");
      return;
    }
    let searchParameters = this.searchParams, updated;
    if (dist_default2.string(value))
      updated = new URLSearchParams(value);
    else if (value instanceof URLSearchParams)
      updated = value;
    else {
      validateSearchParameters(value), updated = new URLSearchParams();
      for (let key in value) {
        let entry = value[key];
        entry === null ? updated.append(key, "") : entry === void 0 ? searchParameters.delete(key) : updated.append(key, entry);
      }
    }
    if (this._merging) {
      for (let key of updated.keys())
        searchParameters.delete(key);
      for (let [key, value2] of updated)
        searchParameters.append(key, value2);
    } else url ? url.search = searchParameters.toString() : this._internals.searchParams = searchParameters;
  }
  get searchParameters() {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  set searchParameters(_value) {
    throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
  }
  get dnsLookup() {
    return this._internals.dnsLookup;
  }
  set dnsLookup(value) {
    assert2.any([dist_default2.function_, dist_default2.undefined], value), this._internals.dnsLookup = value;
  }
  /**
      An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
      Useful when making lots of requests to different *public* hostnames.
  
      `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
  
      __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
  
      @default false
      */
  get dnsCache() {
    return this._internals.dnsCache;
  }
  set dnsCache(value) {
    assert2.any([dist_default2.object, dist_default2.boolean, dist_default2.undefined], value), value === !0 ? this._internals.dnsCache = getGlobalDnsCache() : value === !1 ? this._internals.dnsCache = void 0 : this._internals.dnsCache = value;
  }
  /**
      User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
  
      @example
      ```
      import got from 'got';
  
      const instance = got.extend({
          hooks: {
              beforeRequest: [
                  options => {
                      if (!options.context || !options.context.token) {
                          throw new Error('Token required');
                      }
  
                      options.headers.token = options.context.token;
                  }
              ]
          }
      });
  
      const context = {
          token: 'secret'
      };
  
      const response = await instance('https://httpbin.org/headers', {context});
  
      // Let's see the headers
      console.log(response.body);
      ```
      */
  get context() {
    return this._internals.context;
  }
  set context(value) {
    assert2.object(value), this._merging ? Object.assign(this._internals.context, value) : this._internals.context = { ...value };
  }
  /**
  Hooks allow modifications during the request lifecycle.
  Hook functions may be async and are run serially.
  */
  get hooks() {
    return this._internals.hooks;
  }
  set hooks(value) {
    assert2.object(value);
    for (let knownHookEvent in value) {
      if (!(knownHookEvent in this._internals.hooks))
        throw new Error(`Unexpected hook event: ${knownHookEvent}`);
      let typedKnownHookEvent = knownHookEvent, hooks = value[typedKnownHookEvent];
      if (assert2.any([dist_default2.array, dist_default2.undefined], hooks), hooks)
        for (let hook of hooks)
          assert2.function_(hook);
      if (this._merging)
        hooks && this._internals.hooks[typedKnownHookEvent].push(...hooks);
      else {
        if (!hooks)
          throw new Error(`Missing hook event: ${knownHookEvent}`);
        this._internals.hooks[knownHookEvent] = [...hooks];
      }
    }
  }
  /**
      Defines if redirect responses should be followed automatically.
  
      Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
      This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
  
      @default true
      */
  get followRedirect() {
    return this._internals.followRedirect;
  }
  set followRedirect(value) {
    assert2.boolean(value), this._internals.followRedirect = value;
  }
  get followRedirects() {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  set followRedirects(_value) {
    throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
  }
  /**
      If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
  
      @default 10
      */
  get maxRedirects() {
    return this._internals.maxRedirects;
  }
  set maxRedirects(value) {
    assert2.number(value), this._internals.maxRedirects = value;
  }
  /**
      A cache adapter instance for storing cached response data.
  
      @default false
      */
  get cache() {
    return this._internals.cache;
  }
  set cache(value) {
    assert2.any([dist_default2.object, dist_default2.string, dist_default2.boolean, dist_default2.undefined], value), value === !0 ? this._internals.cache = globalCache : value === !1 ? this._internals.cache = void 0 : this._internals.cache = value;
  }
  /**
      Determines if a `got.HTTPError` is thrown for unsuccessful responses.
  
      If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
      This may be useful if you are checking for resource availability and are expecting error responses.
  
      @default true
      */
  get throwHttpErrors() {
    return this._internals.throwHttpErrors;
  }
  set throwHttpErrors(value) {
    assert2.boolean(value), this._internals.throwHttpErrors = value;
  }
  get username() {
    let url = this._internals.url, value = url ? url.username : this._internals.username;
    return decodeURIComponent(value);
  }
  set username(value) {
    assert2.string(value);
    let url = this._internals.url, fixedValue = encodeURIComponent(value);
    url ? url.username = fixedValue : this._internals.username = fixedValue;
  }
  get password() {
    let url = this._internals.url, value = url ? url.password : this._internals.password;
    return decodeURIComponent(value);
  }
  set password(value) {
    assert2.string(value);
    let url = this._internals.url, fixedValue = encodeURIComponent(value);
    url ? url.password = fixedValue : this._internals.password = fixedValue;
  }
  /**
      If set to `true`, Got will additionally accept HTTP2 requests.
  
      It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
  
      __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
  
      __Note__: Overriding `options.request` will disable HTTP2 support.
  
      @default false
  
      @example
      ```
      import got from 'got';
  
      const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});
  
      console.log(headers.via);
      //=> '2 nghttpx'
      ```
      */
  get http2() {
    return this._internals.http2;
  }
  set http2(value) {
    assert2.boolean(value), this._internals.http2 = value;
  }
  /**
      Set this to `true` to allow sending body for the `GET` method.
      However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
      This option is only meant to interact with non-compliant servers when you have no other choice.
  
      __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
  
      @default false
      */
  get allowGetBody() {
    return this._internals.allowGetBody;
  }
  set allowGetBody(value) {
    assert2.boolean(value), this._internals.allowGetBody = value;
  }
  /**
      Request headers.
  
      Existing headers will be overwritten. Headers set to `undefined` will be omitted.
  
      @default {}
      */
  get headers() {
    return this._internals.headers;
  }
  set headers(value) {
    assert2.plainObject(value), this._merging ? Object.assign(this._internals.headers, lowercaseKeys(value)) : this._internals.headers = lowercaseKeys(value);
  }
  /**
      Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
  
      As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
      Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
  
      __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
  
      @default false
      */
  get methodRewriting() {
    return this._internals.methodRewriting;
  }
  set methodRewriting(value) {
    assert2.boolean(value), this._internals.methodRewriting = value;
  }
  /**
      Indicates which DNS record family to use.
  
      Values:
      - `undefined`: IPv4 (if present) or IPv6
      - `4`: Only IPv4
      - `6`: Only IPv6
  
      @default undefined
      */
  get dnsLookupIpVersion() {
    return this._internals.dnsLookupIpVersion;
  }
  set dnsLookupIpVersion(value) {
    if (value !== void 0 && value !== 4 && value !== 6)
      throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
    this._internals.dnsLookupIpVersion = value;
  }
  /**
      A function used to parse JSON responses.
  
      @example
      ```
      import got from 'got';
      import Bourne from '@hapi/bourne';
  
      const parsed = await got('https://example.com', {
          parseJson: text => Bourne.parse(text)
      }).json();
  
      console.log(parsed);
      ```
      */
  get parseJson() {
    return this._internals.parseJson;
  }
  set parseJson(value) {
    assert2.function_(value), this._internals.parseJson = value;
  }
  /**
      A function used to stringify the body of JSON requests.
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (key.startsWith('_')) {
                  return;
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              _ignoreMe: 1234
          }
      });
      ```
  
      @example
      ```
      import got from 'got';
  
      await got.post('https://example.com', {
          stringifyJson: object => JSON.stringify(object, (key, value) => {
              if (typeof value === 'number') {
                  return value.toString();
              }
  
              return value;
          }),
          json: {
              some: 'payload',
              number: 1
          }
      });
      ```
      */
  get stringifyJson() {
    return this._internals.stringifyJson;
  }
  set stringifyJson(value) {
    assert2.function_(value), this._internals.stringifyJson = value;
  }
  /**
      An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
  
      Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
  
      The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
      The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
  
      By default, it retries *only* on the specified methods, status codes, and on these network errors:
  
      - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
      - `ECONNRESET`: Connection was forcibly closed by a peer.
      - `EADDRINUSE`: Could not bind to any free port.
      - `ECONNREFUSED`: Connection was refused by the server.
      - `EPIPE`: The remote side of the stream being written has been closed.
      - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
      - `ENETUNREACH`: No internet connection.
      - `EAI_AGAIN`: DNS lookup timed out.
  
      __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
      __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
      */
  get retry() {
    return this._internals.retry;
  }
  set retry(value) {
    if (assert2.plainObject(value), assert2.any([dist_default2.function_, dist_default2.undefined], value.calculateDelay), assert2.any([dist_default2.number, dist_default2.undefined], value.maxRetryAfter), assert2.any([dist_default2.number, dist_default2.undefined], value.limit), assert2.any([dist_default2.array, dist_default2.undefined], value.methods), assert2.any([dist_default2.array, dist_default2.undefined], value.statusCodes), assert2.any([dist_default2.array, dist_default2.undefined], value.errorCodes), assert2.any([dist_default2.number, dist_default2.undefined], value.noise), value.noise && Math.abs(value.noise) > 100)
      throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${value.noise}`);
    for (let key in value)
      if (!(key in this._internals.retry))
        throw new Error(`Unexpected retry option: ${key}`);
    this._merging ? Object.assign(this._internals.retry, value) : this._internals.retry = { ...value };
    let { retry } = this._internals;
    retry.methods = [...new Set(retry.methods.map((method) => method.toUpperCase()))], retry.statusCodes = [...new Set(retry.statusCodes)], retry.errorCodes = [...new Set(retry.errorCodes)];
  }
  /**
      From `http.RequestOptions`.
  
      The IP address used to send the request from.
      */
  get localAddress() {
    return this._internals.localAddress;
  }
  set localAddress(value) {
    assert2.any([dist_default2.string, dist_default2.undefined], value), this._internals.localAddress = value;
  }
  /**
      The HTTP method used to make the request.
  
      @default 'GET'
      */
  get method() {
    return this._internals.method;
  }
  set method(value) {
    assert2.string(value), this._internals.method = value.toUpperCase();
  }
  get createConnection() {
    return this._internals.createConnection;
  }
  set createConnection(value) {
    assert2.any([dist_default2.function_, dist_default2.undefined], value), this._internals.createConnection = value;
  }
  /**
      From `http-cache-semantics`
  
      @default {}
      */
  get cacheOptions() {
    return this._internals.cacheOptions;
  }
  set cacheOptions(value) {
    assert2.plainObject(value), assert2.any([dist_default2.boolean, dist_default2.undefined], value.shared), assert2.any([dist_default2.number, dist_default2.undefined], value.cacheHeuristic), assert2.any([dist_default2.number, dist_default2.undefined], value.immutableMinTimeToLive), assert2.any([dist_default2.boolean, dist_default2.undefined], value.ignoreCargoCult);
    for (let key in value)
      if (!(key in this._internals.cacheOptions))
        throw new Error(`Cache option \`${key}\` does not exist`);
    this._merging ? Object.assign(this._internals.cacheOptions, value) : this._internals.cacheOptions = { ...value };
  }
  /**
  Options for the advanced HTTPS API.
  */
  get https() {
    return this._internals.https;
  }
  set https(value) {
    assert2.plainObject(value), assert2.any([dist_default2.boolean, dist_default2.undefined], value.rejectUnauthorized), assert2.any([dist_default2.function_, dist_default2.undefined], value.checkServerIdentity), assert2.any([dist_default2.string, dist_default2.object, dist_default2.array, dist_default2.undefined], value.certificateAuthority), assert2.any([dist_default2.string, dist_default2.object, dist_default2.array, dist_default2.undefined], value.key), assert2.any([dist_default2.string, dist_default2.object, dist_default2.array, dist_default2.undefined], value.certificate), assert2.any([dist_default2.string, dist_default2.undefined], value.passphrase), assert2.any([dist_default2.string, dist_default2.buffer, dist_default2.array, dist_default2.undefined], value.pfx), assert2.any([dist_default2.array, dist_default2.undefined], value.alpnProtocols), assert2.any([dist_default2.string, dist_default2.undefined], value.ciphers), assert2.any([dist_default2.string, dist_default2.buffer, dist_default2.undefined], value.dhparam), assert2.any([dist_default2.string, dist_default2.undefined], value.signatureAlgorithms), assert2.any([dist_default2.string, dist_default2.undefined], value.minVersion), assert2.any([dist_default2.string, dist_default2.undefined], value.maxVersion), assert2.any([dist_default2.boolean, dist_default2.undefined], value.honorCipherOrder), assert2.any([dist_default2.number, dist_default2.undefined], value.tlsSessionLifetime), assert2.any([dist_default2.string, dist_default2.undefined], value.ecdhCurve), assert2.any([dist_default2.string, dist_default2.buffer, dist_default2.array, dist_default2.undefined], value.certificateRevocationLists);
    for (let key in value)
      if (!(key in this._internals.https))
        throw new Error(`HTTPS option \`${key}\` does not exist`);
    this._merging ? Object.assign(this._internals.https, value) : this._internals.https = { ...value };
  }
  /**
      [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
  
      To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
      Don't set this option to `null`.
  
      __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
  
      @default 'utf-8'
      */
  get encoding() {
    return this._internals.encoding;
  }
  set encoding(value) {
    if (value === null)
      throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
    assert2.any([dist_default2.string, dist_default2.undefined], value), this._internals.encoding = value;
  }
  /**
      When set to `true` the promise will return the Response body instead of the Response object.
  
      @default false
      */
  get resolveBodyOnly() {
    return this._internals.resolveBodyOnly;
  }
  set resolveBodyOnly(value) {
    assert2.boolean(value), this._internals.resolveBodyOnly = value;
  }
  /**
      Returns a `Stream` instead of a `Promise`.
      This is equivalent to calling `got.stream(url, options?)`.
  
      @default false
      */
  get isStream() {
    return this._internals.isStream;
  }
  set isStream(value) {
    assert2.boolean(value), this._internals.isStream = value;
  }
  /**
      The parsing method.
  
      The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
  
      It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
  
      __Note__: When using streams, this option is ignored.
  
      @example
      ```
      const responsePromise = got(url);
      const bufferPromise = responsePromise.buffer();
      const jsonPromise = responsePromise.json();
  
      const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
      // `response` is an instance of Got Response
      // `buffer` is an instance of Buffer
      // `json` is an object
      ```
  
      @example
      ```
      // This
      const body = await got(url).json();
  
      // is semantically the same as this
      const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
      ```
      */
  get responseType() {
    return this._internals.responseType;
  }
  set responseType(value) {
    if (value === void 0) {
      this._internals.responseType = "text";
      return;
    }
    if (value !== "text" && value !== "buffer" && value !== "json")
      throw new Error(`Invalid \`responseType\` option: ${value}`);
    this._internals.responseType = value;
  }
  get pagination() {
    return this._internals.pagination;
  }
  set pagination(value) {
    assert2.object(value), this._merging ? Object.assign(this._internals.pagination, value) : this._internals.pagination = value;
  }
  get auth() {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  set auth(_value) {
    throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
  }
  get setHost() {
    return this._internals.setHost;
  }
  set setHost(value) {
    assert2.boolean(value), this._internals.setHost = value;
  }
  get maxHeaderSize() {
    return this._internals.maxHeaderSize;
  }
  set maxHeaderSize(value) {
    assert2.any([dist_default2.number, dist_default2.undefined], value), this._internals.maxHeaderSize = value;
  }
  get enableUnixSockets() {
    return this._internals.enableUnixSockets;
  }
  set enableUnixSockets(value) {
    assert2.boolean(value), this._internals.enableUnixSockets = value;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  toJSON() {
    return { ...this._internals };
  }
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options) {
    return inspect(this._internals, options);
  }
  createNativeRequestOptions() {
    let internals = this._internals, url = internals.url, agent;
    url.protocol === "https:" ? agent = internals.http2 ? internals.agent : internals.agent.https : agent = internals.agent.http;
    let { https: https2 } = internals, { pfx } = https2;
    return dist_default2.array(pfx) && dist_default2.plainObject(pfx[0]) && (pfx = pfx.map((object) => ({
      buf: object.buffer,
      passphrase: object.passphrase
    }))), {
      ...internals.cacheOptions,
      ...this._unixOptions,
      // HTTPS options
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ALPNProtocols: https2.alpnProtocols,
      ca: https2.certificateAuthority,
      cert: https2.certificate,
      key: https2.key,
      passphrase: https2.passphrase,
      pfx: https2.pfx,
      rejectUnauthorized: https2.rejectUnauthorized,
      checkServerIdentity: https2.checkServerIdentity ?? checkServerIdentity,
      ciphers: https2.ciphers,
      honorCipherOrder: https2.honorCipherOrder,
      minVersion: https2.minVersion,
      maxVersion: https2.maxVersion,
      sigalgs: https2.signatureAlgorithms,
      sessionTimeout: https2.tlsSessionLifetime,
      dhparam: https2.dhparam,
      ecdhCurve: https2.ecdhCurve,
      crl: https2.certificateRevocationLists,
      // HTTP options
      lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
      family: internals.dnsLookupIpVersion,
      agent,
      setHost: internals.setHost,
      method: internals.method,
      maxHeaderSize: internals.maxHeaderSize,
      localAddress: internals.localAddress,
      headers: internals.headers,
      createConnection: internals.createConnection,
      timeout: internals.http2 ? getHttp2TimeoutOption(internals) : void 0,
      // HTTP/2 options
      h2session: internals.h2session
    };
  }
  getRequestFunction() {
    let url = this._internals.url, { request } = this._internals;
    return !request && url ? this.getFallbackRequestFunction() : request;
  }
  getFallbackRequestFunction() {
    let url = this._internals.url;
    if (url) {
      if (url.protocol === "https:") {
        if (this._internals.http2) {
          if (major < 15 || major === 15 && minor < 10) {
            let error = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
            throw error.code = "EUNSUPPORTED", error;
          }
          return import_http2_wrapper.default.auto;
        }
        return https.request;
      }
      return http.request;
    }
  }
  freeze() {
    let options = this._internals;
    Object.freeze(options), Object.freeze(options.hooks), Object.freeze(options.hooks.afterResponse), Object.freeze(options.hooks.beforeError), Object.freeze(options.hooks.beforeRedirect), Object.freeze(options.hooks.beforeRequest), Object.freeze(options.hooks.beforeRetry), Object.freeze(options.hooks.init), Object.freeze(options.https), Object.freeze(options.cacheOptions), Object.freeze(options.agent), Object.freeze(options.headers), Object.freeze(options.timeout), Object.freeze(options.retry), Object.freeze(options.retry.errorCodes), Object.freeze(options.retry.methods), Object.freeze(options.retry.statusCodes);
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/response.js
init_cjs_shims();
var isResponseOk = (response) => {
  let { statusCode } = response, limitStatusCode = response.request.options.followRedirect ? 299 : 399;
  return statusCode >= 200 && statusCode <= limitStatusCode || statusCode === 304;
}, ParseError = class extends RequestError {
  constructor(error, response) {
    let { options } = response.request;
    super(`${error.message} in "${options.url.toString()}"`, error, response.request), this.name = "ParseError", this.code = "ERR_BODY_PARSE_FAILURE";
  }
}, parseBody = (response, responseType, parseJson, encoding) => {
  let { rawBody } = response;
  try {
    if (responseType === "text")
      return rawBody.toString(encoding);
    if (responseType === "json")
      return rawBody.length === 0 ? "" : parseJson(rawBody.toString(encoding));
    if (responseType === "buffer")
      return rawBody;
  } catch (error) {
    throw new ParseError(error, response);
  }
  throw new ParseError({
    message: `Unknown body type '${responseType}'`,
    name: "Error"
  }, response);
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/is-client-request.js
init_cjs_shims();
function isClientRequest(clientRequest) {
  return clientRequest.writable && !clientRequest.writableEnded;
}
var is_client_request_default = isClientRequest;

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/utils/is-unix-socket-url.js
init_cjs_shims();
function isUnixSocketURL(url) {
  return url.protocol === "unix:" || url.hostname === "unix";
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/core/index.js
var { buffer: getBuffer } = import_get_stream2.default, supportsBrotli = dist_default2.string(process8.versions.brotli), methodsWithoutBody = /* @__PURE__ */ new Set(["GET", "HEAD"]), cacheableStore = new WeakableMap(), redirectCodes = /* @__PURE__ */ new Set([300, 301, 302, 303, 304, 307, 308]), proxiedRequestEvents = [
  "socket",
  "connect",
  "continue",
  "information",
  "upgrade"
], noop2 = () => {
}, Request = class _Request extends Duplex {
  constructor(url, options, defaults2) {
    super({
      // Don't destroy immediately, as the error may be emitted on unsuccessful retry
      autoDestroy: !1,
      // It needs to be zero because we're just proxying the data to another stream
      highWaterMark: 0
    }), Object.defineProperty(this, "constructor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_noPipe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "response", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "requestUrl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "redirectUrls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "retryCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_stopRetry", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downloadedSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_uploadedSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_stopReading", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_pipedServerResponses", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_request", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_responseSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_bodySize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_unproxyEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isFromCache", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_cannotHaveBody", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_triggerRead", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_cancelTimeouts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_removeListeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_nativeResponse", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_flushed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_aborted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_requestInitialized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._downloadedSize = 0, this._uploadedSize = 0, this._stopReading = !1, this._pipedServerResponses = /* @__PURE__ */ new Set(), this._cannotHaveBody = !1, this._unproxyEvents = noop2, this._triggerRead = !1, this._cancelTimeouts = noop2, this._removeListeners = noop2, this._jobs = [], this._flushed = !1, this._requestInitialized = !1, this._aborted = !1, this.redirectUrls = [], this.retryCount = 0, this._stopRetry = noop2, this.on("pipe", (source) => {
      source?.headers && Object.assign(this.options.headers, source.headers);
    }), this.on("newListener", (event) => {
      if (event === "retry" && this.listenerCount("retry") > 0)
        throw new Error("A retry listener has been attached already.");
    });
    try {
      if (this.options = new Options(url, options, defaults2), !this.options.url) {
        if (this.options.prefixUrl === "")
          throw new TypeError("Missing `url` property");
        this.options.url = "";
      }
      this.requestUrl = this.options.url;
    } catch (error) {
      let { options: options2 } = error;
      options2 && (this.options = options2), this.flush = async () => {
        this.flush = async () => {
        }, this.destroy(error);
      };
      return;
    }
    let { body } = this.options;
    if (dist_default2.nodeStream(body) && body.once("error", (error) => {
      this._flushed ? this._beforeError(new UploadError(error, this)) : this.flush = async () => {
        this.flush = async () => {
        }, this._beforeError(new UploadError(error, this));
      };
    }), this.options.signal) {
      let abort = () => {
        this.destroy(new AbortError2(this));
      };
      this.options.signal.aborted ? abort() : (this.options.signal.addEventListener("abort", abort), this._removeListeners = () => {
        this.options.signal.removeEventListener("abort", abort);
      });
    }
  }
  async flush() {
    if (!this._flushed) {
      this._flushed = !0;
      try {
        if (await this._finalizeBody(), this.destroyed)
          return;
        if (await this._makeRequest(), this.destroyed) {
          this._request?.destroy();
          return;
        }
        for (let job of this._jobs)
          job();
        this._jobs.length = 0, this._requestInitialized = !0;
      } catch (error) {
        this._beforeError(error);
      }
    }
  }
  _beforeError(error) {
    if (this._stopReading)
      return;
    let { response, options } = this, attemptCount = this.retryCount + (error.name === "RetryError" ? 0 : 1);
    this._stopReading = !0, error instanceof RequestError || (error = new RequestError(error.message, error, this));
    let typedError = error;
    (async () => {
      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed && (response.setEncoding(this.readableEncoding), await this._setRawBody(response) && (response.body = response.rawBody.toString())), this.listenerCount("retry") !== 0) {
        let backoff;
        try {
          let retryAfter;
          response && "retry-after" in response.headers && (retryAfter = Number(response.headers["retry-after"]), Number.isNaN(retryAfter) ? (retryAfter = Date.parse(response.headers["retry-after"]) - Date.now(), retryAfter <= 0 && (retryAfter = 1)) : retryAfter *= 1e3);
          let retryOptions = options.retry;
          backoff = await retryOptions.calculateDelay({
            attemptCount,
            retryOptions,
            error: typedError,
            retryAfter,
            computedValue: calculate_retry_delay_default({
              attemptCount,
              retryOptions,
              error: typedError,
              retryAfter,
              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY
            })
          });
        } catch (error_) {
          this._error(new RequestError(error_.message, error_, this));
          return;
        }
        if (backoff) {
          if (await new Promise((resolve) => {
            let timeout = setTimeout(resolve, backoff);
            this._stopRetry = () => {
              clearTimeout(timeout), resolve();
            };
          }), this.destroyed)
            return;
          try {
            for (let hook of this.options.hooks.beforeRetry)
              await hook(typedError, this.retryCount + 1);
          } catch (error_) {
            this._error(new RequestError(error_.message, error, this));
            return;
          }
          if (this.destroyed)
            return;
          this.destroy(), this.emit("retry", this.retryCount + 1, error, (updatedOptions) => {
            let request = new _Request(options.url, updatedOptions, options);
            return request.retryCount = this.retryCount + 1, process8.nextTick(() => {
              request.flush();
            }), request;
          });
          return;
        }
      }
      this._error(typedError);
    })();
  }
  _read() {
    this._triggerRead = !0;
    let { response } = this;
    if (response && !this._stopReading) {
      response.readableLength && (this._triggerRead = !1);
      let data;
      for (; (data = response.read()) !== null; ) {
        this._downloadedSize += data.length;
        let progress = this.downloadProgress;
        progress.percent < 1 && this.emit("downloadProgress", progress), this.push(data);
      }
    }
  }
  _write(chunk, encoding, callback) {
    let write = () => {
      this._writeRequest(chunk, encoding, callback);
    };
    this._requestInitialized ? write() : this._jobs.push(write);
  }
  _final(callback) {
    let endRequest = () => {
      if (!this._request || this._request.destroyed) {
        callback();
        return;
      }
      this._request.end((error) => {
        this._request._writableState?.errored || (error || (this._bodySize = this._uploadedSize, this.emit("uploadProgress", this.uploadProgress), this._request.emit("upload-complete")), callback(error));
      });
    };
    this._requestInitialized ? endRequest() : this._jobs.push(endRequest);
  }
  _destroy(error, callback) {
    if (this._stopReading = !0, this.flush = async () => {
    }, this._stopRetry(), this._cancelTimeouts(), this._removeListeners(), this.options) {
      let { body } = this.options;
      dist_default2.nodeStream(body) && body.destroy();
    }
    this._request && this._request.destroy(), error !== null && !dist_default2.undefined(error) && !(error instanceof RequestError) && (error = new RequestError(error.message, error, this)), callback(error);
  }
  pipe(destination, options) {
    return destination instanceof ServerResponse && this._pipedServerResponses.add(destination), super.pipe(destination, options);
  }
  unpipe(destination) {
    return destination instanceof ServerResponse && this._pipedServerResponses.delete(destination), super.unpipe(destination), this;
  }
  async _finalizeBody() {
    let { options } = this, { headers } = options, isForm = !dist_default2.undefined(options.form), isJSON = !dist_default2.undefined(options.json), isBody = !dist_default2.undefined(options.body), cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === "GET" && options.allowGetBody);
    if (this._cannotHaveBody = cannotHaveBody, isForm || isJSON || isBody) {
      if (cannotHaveBody)
        throw new TypeError(`The \`${options.method}\` method cannot be used with a body`);
      let noContentType = !dist_default2.string(headers["content-type"]);
      if (isBody) {
        if (isFormData(options.body)) {
          let encoder = new FormDataEncoder(options.body);
          noContentType && (headers["content-type"] = encoder.headers["Content-Type"]), "Content-Length" in encoder.headers && (headers["content-length"] = encoder.headers["Content-Length"]), options.body = encoder.encode();
        }
        isFormData2(options.body) && noContentType && (headers["content-type"] = `multipart/form-data; boundary=${options.body.getBoundary()}`);
      } else if (isForm) {
        noContentType && (headers["content-type"] = "application/x-www-form-urlencoded");
        let { form } = options;
        options.form = void 0, options.body = new URLSearchParams2(form).toString();
      } else {
        noContentType && (headers["content-type"] = "application/json");
        let { json } = options;
        options.json = void 0, options.body = options.stringifyJson(json);
      }
      let uploadBodySize = await getBodySize(options.body, options.headers);
      dist_default2.undefined(headers["content-length"]) && dist_default2.undefined(headers["transfer-encoding"]) && !cannotHaveBody && !dist_default2.undefined(uploadBodySize) && (headers["content-length"] = String(uploadBodySize));
    }
    options.responseType === "json" && !("accept" in options.headers) && (options.headers.accept = "application/json"), this._bodySize = Number(headers["content-length"]) || void 0;
  }
  async _onResponseBase(response) {
    if (this.isAborted)
      return;
    let { options } = this, { url } = options;
    this._nativeResponse = response, options.decompress && (response = (0, import_decompress_response.default)(response));
    let statusCode = response.statusCode, typedResponse = response;
    typedResponse.statusMessage = typedResponse.statusMessage ?? http2.STATUS_CODES[statusCode], typedResponse.url = options.url.toString(), typedResponse.requestUrl = this.requestUrl, typedResponse.redirectUrls = this.redirectUrls, typedResponse.request = this, typedResponse.isFromCache = this._nativeResponse.fromCache ?? !1, typedResponse.ip = this.ip, typedResponse.retryCount = this.retryCount, typedResponse.ok = isResponseOk(typedResponse), this._isFromCache = typedResponse.isFromCache, this._responseSize = Number(response.headers["content-length"]) || void 0, this.response = typedResponse, response.once("end", () => {
      this._responseSize = this._downloadedSize, this.emit("downloadProgress", this.downloadProgress);
    }), response.once("error", (error) => {
      this._aborted = !0, response.destroy(), this._beforeError(new ReadError(error, this));
    }), response.once("aborted", () => {
      this._aborted = !0, this._beforeError(new ReadError({
        name: "Error",
        message: "The server aborted pending request",
        code: "ECONNRESET"
      }, this));
    }), this.emit("downloadProgress", this.downloadProgress);
    let rawCookies = response.headers["set-cookie"];
    if (dist_default2.object(options.cookieJar) && rawCookies) {
      let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
      options.ignoreInvalidCookies && (promises = promises.map(async (promise) => {
        try {
          await promise;
        } catch {
        }
      }));
      try {
        await Promise.all(promises);
      } catch (error) {
        this._beforeError(error);
        return;
      }
    }
    if (!this.isAborted) {
      if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {
        if (response.resume(), this._cancelTimeouts(), this._unproxyEvents(), this.redirectUrls.length >= options.maxRedirects) {
          this._beforeError(new MaxRedirectsError(this));
          return;
        }
        this._request = void 0;
        let updatedOptions = new Options(void 0, void 0, this.options), serverRequestedGet = statusCode === 303 && updatedOptions.method !== "GET" && updatedOptions.method !== "HEAD", canRewrite = statusCode !== 307 && statusCode !== 308, userRequestedGet = updatedOptions.methodRewriting && canRewrite;
        (serverRequestedGet || userRequestedGet) && (updatedOptions.method = "GET", updatedOptions.body = void 0, updatedOptions.json = void 0, updatedOptions.form = void 0, delete updatedOptions.headers["content-length"]);
        try {
          let redirectBuffer = Buffer4.from(response.headers.location, "binary").toString(), redirectUrl = new URL3(redirectBuffer, url);
          if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
            this._beforeError(new RequestError("Cannot redirect to UNIX socket", {}, this));
            return;
          }
          redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port ? ("host" in updatedOptions.headers && delete updatedOptions.headers.host, "cookie" in updatedOptions.headers && delete updatedOptions.headers.cookie, "authorization" in updatedOptions.headers && delete updatedOptions.headers.authorization, (updatedOptions.username || updatedOptions.password) && (updatedOptions.username = "", updatedOptions.password = "")) : (redirectUrl.username = updatedOptions.username, redirectUrl.password = updatedOptions.password), this.redirectUrls.push(redirectUrl), updatedOptions.prefixUrl = "", updatedOptions.url = redirectUrl;
          for (let hook of updatedOptions.hooks.beforeRedirect)
            await hook(updatedOptions, typedResponse);
          this.emit("redirect", updatedOptions, typedResponse), this.options = updatedOptions, await this._makeRequest();
        } catch (error) {
          this._beforeError(error);
          return;
        }
        return;
      }
      if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {
        this._beforeError(new HTTPError(typedResponse));
        return;
      }
      if (response.on("readable", () => {
        this._triggerRead && this._read();
      }), this.on("resume", () => {
        response.resume();
      }), this.on("pause", () => {
        response.pause();
      }), response.once("end", () => {
        this.push(null);
      }), this._noPipe) {
        await this._setRawBody() && this.emit("response", response);
        return;
      }
      this.emit("response", response);
      for (let destination of this._pipedServerResponses)
        if (!destination.headersSent) {
          for (let key in response.headers) {
            let isAllowed = options.decompress ? key !== "content-encoding" : !0, value = response.headers[key];
            isAllowed && destination.setHeader(key, value);
          }
          destination.statusCode = statusCode;
        }
    }
  }
  async _setRawBody(from = this) {
    if (from.readableEnded)
      return !1;
    try {
      let rawBody = await getBuffer(from);
      if (!this.isAborted)
        return this.response.rawBody = rawBody, !0;
    } catch {
    }
    return !1;
  }
  async _onResponse(response) {
    try {
      await this._onResponseBase(response);
    } catch (error) {
      this._beforeError(error);
    }
  }
  _onRequest(request) {
    let { options } = this, { timeout, url } = options;
    source_default(request), this.options.http2 && request.setTimeout(0), this._cancelTimeouts = timedOut(request, timeout, url);
    let responseEventName = options.cache ? "cacheableResponse" : "response";
    request.once(responseEventName, (response) => {
      this._onResponse(response);
    }), request.once("error", (error) => {
      this._aborted = !0, request.destroy(), error = error instanceof TimeoutError2 ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this), this._beforeError(error);
    }), this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents), this._request = request, this.emit("uploadProgress", this.uploadProgress), this._sendBody(), this.emit("request", request);
  }
  async _asyncWrite(chunk) {
    return new Promise((resolve, reject) => {
      super.write(chunk, (error) => {
        if (error) {
          reject(error);
          return;
        }
        resolve();
      });
    });
  }
  _sendBody() {
    let { body } = this.options, currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
    dist_default2.nodeStream(body) ? body.pipe(currentRequest) : dist_default2.generator(body) || dist_default2.asyncGenerator(body) ? (async () => {
      try {
        for await (let chunk of body)
          await this._asyncWrite(chunk);
        super.end();
      } catch (error) {
        this._beforeError(error);
      }
    })() : dist_default2.undefined(body) ? (this._cannotHaveBody || this._noPipe) && currentRequest.end() : (this._writeRequest(body, void 0, () => {
    }), currentRequest.end());
  }
  _prepareCache(cache) {
    if (!cacheableStore.has(cache)) {
      let cacheableRequest = new dist_default3((requestOptions, handler) => {
        let result = requestOptions._request(requestOptions, handler);
        return dist_default2.promise(result) && (result.once = (event, handler2) => {
          if (event === "error")
            (async () => {
              try {
                await result;
              } catch (error) {
                handler2(error);
              }
            })();
          else if (event === "abort")
            (async () => {
              try {
                (await result).once("abort", handler2);
              } catch {
              }
            })();
          else
            throw new Error(`Unknown HTTP2 promise event: ${event}`);
          return result;
        }), result;
      }, cache);
      cacheableStore.set(cache, cacheableRequest.request());
    }
  }
  async _createCacheableRequest(url, options) {
    return new Promise((resolve, reject) => {
      Object.assign(options, urlToOptions(url));
      let request, cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
        if (response._readableState.autoDestroy = !1, request) {
          let fix = () => {
            response.req && (response.complete = response.req.res.complete);
          };
          response.prependOnceListener("end", fix), fix(), (await request).emit("cacheableResponse", response);
        }
        resolve(response);
      });
      cacheRequest.once("error", reject), cacheRequest.once("request", async (requestOrPromise) => {
        request = requestOrPromise, resolve(request);
      });
    });
  }
  async _makeRequest() {
    let { options } = this, { headers, username, password } = options, cookieJar = options.cookieJar;
    for (let key in headers)
      if (dist_default2.undefined(headers[key]))
        delete headers[key];
      else if (dist_default2.null_(headers[key]))
        throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
    if (options.decompress && dist_default2.undefined(headers["accept-encoding"]) && (headers["accept-encoding"] = supportsBrotli ? "gzip, deflate, br" : "gzip, deflate"), username || password) {
      let credentials = Buffer4.from(`${username}:${password}`).toString("base64");
      headers.authorization = `Basic ${credentials}`;
    }
    if (cookieJar) {
      let cookieString = await cookieJar.getCookieString(options.url.toString());
      dist_default2.nonEmptyString(cookieString) && (headers.cookie = cookieString);
    }
    options.prefixUrl = "";
    let request;
    for (let hook of options.hooks.beforeRequest) {
      let result = await hook(options);
      if (!dist_default2.undefined(result)) {
        request = () => result;
        break;
      }
    }
    request || (request = options.getRequestFunction());
    let url = options.url;
    this._requestOptions = options.createNativeRequestOptions(), options.cache && (this._requestOptions._request = request, this._requestOptions.cache = options.cache, this._requestOptions.body = options.body, this._prepareCache(options.cache));
    let fn = options.cache ? this._createCacheableRequest : request;
    try {
      let requestOrResponse = fn(url, this._requestOptions);
      dist_default2.promise(requestOrResponse) && (requestOrResponse = await requestOrResponse), dist_default2.undefined(requestOrResponse) && (requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions), dist_default2.promise(requestOrResponse) && (requestOrResponse = await requestOrResponse)), is_client_request_default(requestOrResponse) ? this._onRequest(requestOrResponse) : this.writable ? (this.once("finish", () => {
        this._onResponse(requestOrResponse);
      }), this._sendBody()) : this._onResponse(requestOrResponse);
    } catch (error) {
      throw error instanceof CacheError2 ? new CacheError(error, this) : error;
    }
  }
  async _error(error) {
    try {
      if (!(error instanceof HTTPError && !this.options.throwHttpErrors))
        for (let hook of this.options.hooks.beforeError)
          error = await hook(error);
    } catch (error_) {
      error = new RequestError(error_.message, error_, this);
    }
    this.destroy(error);
  }
  _writeRequest(chunk, encoding, callback) {
    !this._request || this._request.destroyed || this._request.write(chunk, encoding, (error) => {
      if (!error && !this._request.destroyed) {
        this._uploadedSize += Buffer4.byteLength(chunk, encoding);
        let progress = this.uploadProgress;
        progress.percent < 1 && this.emit("uploadProgress", progress);
      }
      callback(error);
    });
  }
  /**
  The remote IP address.
  */
  get ip() {
    return this.socket?.remoteAddress;
  }
  /**
  Indicates whether the request has been aborted or not.
  */
  get isAborted() {
    return this._aborted;
  }
  get socket() {
    return this._request?.socket ?? void 0;
  }
  /**
  Progress event for downloading (receiving a response).
  */
  get downloadProgress() {
    let percent;
    return this._responseSize ? percent = this._downloadedSize / this._responseSize : this._responseSize === this._downloadedSize ? percent = 1 : percent = 0, {
      percent,
      transferred: this._downloadedSize,
      total: this._responseSize
    };
  }
  /**
  Progress event for uploading (sending a request).
  */
  get uploadProgress() {
    let percent;
    return this._bodySize ? percent = this._uploadedSize / this._bodySize : this._bodySize === this._uploadedSize ? percent = 1 : percent = 0, {
      percent,
      transferred: this._uploadedSize,
      total: this._bodySize
    };
  }
  /**
      The object contains the following properties:
  
      - `start` - Time when the request started.
      - `socket` - Time when a socket was assigned to the request.
      - `lookup` - Time when the DNS lookup finished.
      - `connect` - Time when the socket successfully connected.
      - `secureConnect` - Time when the socket securely connected.
      - `upload` - Time when the request finished uploading.
      - `response` - Time when the request fired `response` event.
      - `end` - Time when the response fired `end` event.
      - `error` - Time when the request fired `error` event.
      - `abort` - Time when the request fired `abort` event.
      - `phases`
          - `wait` - `timings.socket - timings.start`
          - `dns` - `timings.lookup - timings.socket`
          - `tcp` - `timings.connect - timings.lookup`
          - `tls` - `timings.secureConnect - timings.connect`
          - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
          - `firstByte` - `timings.response - timings.upload`
          - `download` - `timings.end - timings.response`
          - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
  
      If something has not been measured yet, it will be `undefined`.
  
      __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
      */
  get timings() {
    return this._request?.timings;
  }
  /**
  Whether the response was retrieved from the cache.
  */
  get isFromCache() {
    return this._isFromCache;
  }
  get reusedSocket() {
    return this._request?.reusedSocket;
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/as-promise/types.js
init_cjs_shims();
var CancelError2 = class extends RequestError {
  constructor(request) {
    super("Promise was canceled", {}, request), this.name = "CancelError", this.code = "ERR_CANCELED";
  }
  /**
  Whether the promise is canceled.
  */
  get isCanceled() {
    return !0;
  }
};

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/as-promise/index.js
var proxiedRequestEvents2 = [
  "request",
  "response",
  "redirect",
  "uploadProgress",
  "downloadProgress"
];
function asPromise(firstRequest) {
  let globalRequest, globalResponse, normalizedOptions, emitter = new EventEmitter3(), promise = new PCancelable((resolve, reject, onCancel) => {
    onCancel(() => {
      globalRequest.destroy();
    }), onCancel.shouldReject = !1, onCancel(() => {
      reject(new CancelError2(globalRequest));
    });
    let makeRequest = (retryCount) => {
      onCancel(() => {
      });
      let request = firstRequest ?? new Request(void 0, void 0, normalizedOptions);
      request.retryCount = retryCount, request._noPipe = !0, globalRequest = request, request.once("response", async (response) => {
        let contentEncoding = (response.headers["content-encoding"] ?? "").toLowerCase(), isCompressed = contentEncoding === "gzip" || contentEncoding === "deflate" || contentEncoding === "br", { options } = request;
        if (isCompressed && !options.decompress)
          response.body = response.rawBody;
        else
          try {
            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);
          } catch (error) {
            if (response.body = response.rawBody.toString(), isResponseOk(response)) {
              request._beforeError(error);
              return;
            }
          }
        try {
          let hooks = options.hooks.afterResponse;
          for (let [index, hook] of hooks.entries())
            if (response = await hook(response, async (updatedOptions) => {
              throw options.merge(updatedOptions), options.prefixUrl = "", updatedOptions.url && (options.url = updatedOptions.url), options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index), new RetryError(request);
            }), !(dist_default2.object(response) && dist_default2.number(response.statusCode) && !dist_default2.nullOrUndefined(response.body)))
              throw new TypeError("The `afterResponse` hook returned an invalid value");
        } catch (error) {
          request._beforeError(error);
          return;
        }
        if (globalResponse = response, !isResponseOk(response)) {
          request._beforeError(new HTTPError(response));
          return;
        }
        request.destroy(), resolve(request.options.resolveBodyOnly ? response.body : response);
      });
      let onError = (error) => {
        if (promise.isCanceled)
          return;
        let { options } = request;
        if (error instanceof HTTPError && !options.throwHttpErrors) {
          let { response } = error;
          request.destroy(), resolve(request.options.resolveBodyOnly ? response.body : response);
          return;
        }
        reject(error);
      };
      request.once("error", onError);
      let previousBody = request.options?.body;
      request.once("retry", (newRetryCount, error) => {
        firstRequest = void 0;
        let newBody = request.options.body;
        if (previousBody === newBody && dist_default2.nodeStream(newBody)) {
          error.message = "Cannot retry with consumed body stream", onError(error);
          return;
        }
        normalizedOptions = request.options, makeRequest(newRetryCount);
      }), proxyEvents(request, emitter, proxiedRequestEvents2), dist_default2.undefined(firstRequest) && request.flush();
    };
    makeRequest(0);
  });
  promise.on = (event, fn) => (emitter.on(event, fn), promise), promise.off = (event, fn) => (emitter.off(event, fn), promise);
  let shortcut = (responseType) => {
    let newPromise = (async () => {
      await promise;
      let { options } = globalResponse.request;
      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);
    })();
    return Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise)), newPromise;
  };
  return promise.json = () => {
    if (globalRequest.options) {
      let { headers } = globalRequest.options;
      !globalRequest.writableFinished && !("accept" in headers) && (headers.accept = "application/json");
    }
    return shortcut("json");
  }, promise.buffer = () => shortcut("buffer"), promise.text = () => shortcut("text"), promise;
}

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/create.js
var delay = async (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
}), isGotInstance = (value) => dist_default2.function_(value), aliases = [
  "get",
  "post",
  "put",
  "patch",
  "head",
  "delete"
], create = (defaults2) => {
  defaults2 = {
    options: new Options(void 0, void 0, defaults2.options),
    handlers: [...defaults2.handlers],
    mutableDefaults: defaults2.mutableDefaults
  }, Object.defineProperty(defaults2, "mutableDefaults", {
    enumerable: !0,
    configurable: !1,
    writable: !1
  });
  let got2 = (url, options, defaultOptions2 = defaults2.options) => {
    let request = new Request(url, options, defaultOptions2), promise, lastHandler = (normalized) => (request.options = normalized, request._noPipe = !normalized.isStream, request.flush(), normalized.isStream ? request : (promise || (promise = asPromise(request)), promise)), iteration = 0, iterateHandlers = (newOptions) => {
      let result = (defaults2.handlers[iteration++] ?? lastHandler)(newOptions, iterateHandlers);
      if (dist_default2.promise(result) && !request.options.isStream && (promise || (promise = asPromise(request)), result !== promise)) {
        let descriptors = Object.getOwnPropertyDescriptors(promise);
        for (let key in descriptors)
          key in result && delete descriptors[key];
        Object.defineProperties(result, descriptors), result.cancel = promise.cancel;
      }
      return result;
    };
    return iterateHandlers(request.options);
  };
  got2.extend = (...instancesOrOptions) => {
    let options = new Options(void 0, void 0, defaults2.options), handlers = [...defaults2.handlers], mutableDefaults;
    for (let value of instancesOrOptions)
      isGotInstance(value) ? (options.merge(value.defaults.options), handlers.push(...value.defaults.handlers), mutableDefaults = value.defaults.mutableDefaults) : (options.merge(value), value.handlers && handlers.push(...value.handlers), mutableDefaults = value.mutableDefaults);
    return create({
      options,
      handlers,
      mutableDefaults: !!mutableDefaults
    });
  };
  let paginateEach = async function* (url, options) {
    let normalizedOptions = new Options(url, options, defaults2.options);
    normalizedOptions.resolveBodyOnly = !1;
    let { pagination } = normalizedOptions;
    assert2.function_(pagination.transform), assert2.function_(pagination.shouldContinue), assert2.function_(pagination.filter), assert2.function_(pagination.paginate), assert2.number(pagination.countLimit), assert2.number(pagination.requestLimit), assert2.number(pagination.backoff);
    let allItems = [], { countLimit } = pagination, numberOfRequests = 0;
    for (; numberOfRequests < pagination.requestLimit; ) {
      numberOfRequests !== 0 && await delay(pagination.backoff);
      let response = await got2(void 0, void 0, normalizedOptions), parsed = await pagination.transform(response), currentItems = [];
      assert2.array(parsed);
      for (let item of parsed)
        if (pagination.filter({ item, currentItems, allItems }) && (!pagination.shouldContinue({ item, currentItems, allItems }) || (yield item, pagination.stackAllItems && allItems.push(item), currentItems.push(item), --countLimit <= 0)))
          return;
      let optionsToMerge = pagination.paginate({
        response,
        currentItems,
        allItems
      });
      if (optionsToMerge === !1)
        return;
      optionsToMerge === response.request.options ? normalizedOptions = response.request.options : (normalizedOptions.merge(optionsToMerge), assert2.any([dist_default2.urlInstance, dist_default2.undefined], optionsToMerge.url), optionsToMerge.url !== void 0 && (normalizedOptions.prefixUrl = "", normalizedOptions.url = optionsToMerge.url)), numberOfRequests++;
    }
  };
  got2.paginate = paginateEach, got2.paginate.all = async (url, options) => {
    let results = [];
    for await (let item of paginateEach(url, options))
      results.push(item);
    return results;
  }, got2.paginate.each = paginateEach, got2.stream = (url, options) => got2(url, { ...options, isStream: !0 });
  for (let method of aliases)
    got2[method] = (url, options) => got2(url, { ...options, method }), got2.stream[method] = (url, options) => got2(url, { ...options, method, isStream: !0 });
  return defaults2.mutableDefaults || (Object.freeze(defaults2.handlers), defaults2.options.freeze()), Object.defineProperty(got2, "defaults", {
    value: defaults2,
    writable: !1,
    configurable: !1,
    enumerable: !0
  }), got2;
}, create_default = create;

// ../../node_modules/.pnpm/got@12.6.1/node_modules/got/dist/source/index.js
var defaults = {
  options: new Options(),
  handlers: [],
  mutableDefaults: !1
}, got = create_default(defaults), source_default2 = got;

// ../../node_modules/.pnpm/registry-url@6.0.1/node_modules/registry-url/index.js
init_cjs_shims();
var import_rc = __toESM(require_rc(), 1);
function registryUrl(scope) {
  let result = (0, import_rc.default)("npm", { registry: "https://registry.npmjs.org/" }), url = result[`${scope}:registry`] || result.config_registry || result.registry;
  return url.slice(-1) === "/" ? url : `${url}/`;
}

// ../../node_modules/.pnpm/package-json@8.1.1/node_modules/package-json/index.js
var import_registry_auth_token = __toESM(require_registry_auth_token(), 1), import_semver2 = __toESM(require_semver(), 1), agentOptions = {
  keepAlive: !0,
  maxSockets: 50
}, httpAgent = new HttpAgent(agentOptions), httpsAgent = new HttpsAgent(agentOptions), PackageNotFoundError = class extends Error {
  constructor(packageName) {
    super(`Package \`${packageName}\` could not be found`), this.name = "PackageNotFoundError";
  }
}, VersionNotFoundError = class extends Error {
  constructor(packageName, version) {
    super(`Version \`${version}\` for package \`${packageName}\` could not be found`), this.name = "VersionNotFoundError";
  }
};
async function packageJson(packageName, options) {
  options = {
    version: "latest",
    ...options
  };
  let scope = packageName.split("/")[0], registryUrl_ = options.registryUrl || registryUrl(scope), packageUrl = new URL(encodeURIComponent(packageName).replace(/^%40/, "@"), registryUrl_), authInfo = (0, import_registry_auth_token.default)(registryUrl_.toString(), { recursive: !0 }), headers = {
    accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
  };
  options.fullMetadata && delete headers.accept, authInfo && (headers.authorization = `${authInfo.type} ${authInfo.token}`);
  let gotOptions = {
    headers,
    agent: {
      http: httpAgent,
      https: httpsAgent
    }
  };
  options.agent && (gotOptions.agent = options.agent);
  let data;
  try {
    data = await source_default2(packageUrl, gotOptions).json();
  } catch (error) {
    throw error?.response?.statusCode === 404 ? new PackageNotFoundError(packageName) : error;
  }
  if (options.allVersions)
    return data;
  let { version } = options, versionError = new VersionNotFoundError(packageName, version);
  if (data["dist-tags"][version]) {
    let time = data.time;
    data = data.versions[data["dist-tags"][version]], data.time = time;
  } else if (version) {
    if (!data.versions[version]) {
      let versions = Object.keys(data.versions);
      if (version = import_semver2.default.maxSatisfying(versions, version), !version)
        throw versionError;
    }
    let time = data.time;
    if (data = data.versions[version], data.time = time, !data)
      throw versionError;
  }
  return data;
}

// ../../node_modules/.pnpm/latest-version@7.0.0/node_modules/latest-version/index.js
async function latestVersion(packageName, options) {
  let { version } = await packageJson(packageName.toLowerCase(), options);
  return version;
}

// ../cli-kit/dist/public/node/node-package-manager.js
var import_semver3 = __toESM(require_semver()), yarnLockfile = "yarn.lock", npmLockfile = "package-lock.json", pnpmLockfile = "pnpm-lock.yaml", bunLockfile = "bun.lockb", pnpmWorkspaceFile = "pnpm-workspace.yaml", lockfiles = [yarnLockfile, pnpmLockfile, npmLockfile, bunLockfile], lockfilesByManager = {
  yarn: yarnLockfile,
  npm: npmLockfile,
  pnpm: pnpmLockfile,
  bun: bunLockfile,
  unknown: void 0
}, packageManager = ["yarn", "npm", "pnpm", "bun", "unknown"], UnknownPackageManagerError = class extends AbortError {
  constructor() {
    super("Unknown package manager");
  }
}, PackageJsonNotFoundError = class extends AbortError {
  constructor(directory) {
    super(outputContent`The directory ${outputToken.path(directory)} doesn't have a package.json.`);
  }
}, FindUpAndReadPackageJsonNotFoundError = class extends BugError {
  constructor(directory) {
    super(outputContent`Couldn't find a a package.json traversing directories from ${outputToken.path(directory)}`);
  }
};
function packageManagerFromUserAgent(env = process.env) {
  return env.npm_config_user_agent?.includes("yarn") ? "yarn" : env.npm_config_user_agent?.includes("pnpm") ? "pnpm" : env.npm_config_user_agent?.includes("bun") ? "bun" : env.npm_config_user_agent?.includes("npm") ? "npm" : "unknown";
}
async function getPackageManager(fromDirectory) {
  let directory, packageJson2;
  try {
    directory = await captureOutput("npm", ["prefix"], { cwd: fromDirectory }), outputDebug(outputContent`Obtaining the dependency manager in directory ${outputToken.path(directory)}...`), packageJson2 = joinPath(directory, "package.json");
  } catch {
  }
  if (!directory || !packageJson2 || !await fileExists(packageJson2))
    return packageManagerFromUserAgent();
  let yarnLockPath = joinPath(directory, yarnLockfile), pnpmLockPath = joinPath(directory, pnpmLockfile), bunLockPath = joinPath(directory, bunLockfile);
  return await fileExists(yarnLockPath) ? "yarn" : await fileExists(pnpmLockPath) ? "pnpm" : await fileExists(bunLockPath) ? "bun" : "npm";
}
async function installNPMDependenciesRecursively(options) {
  let packageJsons = await glob(joinPath(options.directory, "**/package.json"), {
    ignore: [joinPath(options.directory, "node_modules/**/package.json")],
    cwd: options.directory,
    onlyFiles: !0,
    deep: options.deep
  }), abortController = new AbortController();
  try {
    await Promise.all(packageJsons.map(async (packageJsonPath) => {
      let directory = dirname(packageJsonPath);
      await installNodeModules({
        directory,
        packageManager: options.packageManager,
        stdout: void 0,
        stderr: void 0,
        signal: abortController.signal,
        args: []
      });
    }));
  } catch (error) {
    throw abortController.abort(), error;
  }
}
async function installNodeModules(options) {
  let execOptions = {
    cwd: options.directory,
    stdin: void 0,
    stdout: options.stdout,
    stderr: options.stderr,
    signal: options.signal
  }, args = ["install"];
  options.args && (args = args.concat(options.args)), await runWithTimer("cmd_all_timing_network_ms")(async () => {
    await exec(options.packageManager, args, execOptions);
  });
}
async function getPackageName(packageJsonPath) {
  return (await readAndParsePackageJson(packageJsonPath)).name;
}
async function getPackageVersion(packageJsonPath) {
  return (await readAndParsePackageJson(packageJsonPath)).version;
}
async function getDependencies(packageJsonPath) {
  let packageJsonContent = await readAndParsePackageJson(packageJsonPath), dependencies = packageJsonContent.dependencies ?? {}, devDependencies = packageJsonContent.devDependencies ?? {};
  return { ...dependencies, ...devDependencies };
}
async function usesWorkspaces(appDirectory) {
  let packageJsonPath = joinPath(appDirectory, "package.json"), packageJsonContent = await readAndParsePackageJson(packageJsonPath), pnpmWorkspacePath = joinPath(appDirectory, pnpmWorkspaceFile);
  return !!packageJsonContent.workspaces || fileExists(pnpmWorkspacePath);
}
async function checkForNewVersion(dependency, currentVersion, { cacheExpiryInHours = 0 } = {}) {
  let getLatestVersion = async () => (outputDebug(outputContent`Checking if there's a version of ${dependency} newer than ${currentVersion}`), getLatestNPMPackageVersion(dependency)), cacheKey = `npm-package-${dependency}`, lastVersion;
  try {
    lastVersion = await cacheRetrieveOrRepopulate(cacheKey, getLatestVersion, cacheExpiryInHours * 3600 * 1e3);
  } catch {
    return;
  }
  if (lastVersion && new import_semver3.SemVer(currentVersion).compare(lastVersion) < 0)
    return lastVersion;
}
function checkForCachedNewVersion(dependency, currentVersion) {
  let cacheKey = `npm-package-${dependency}`, lastVersion = cacheRetrieve(cacheKey)?.value;
  if (lastVersion && new import_semver3.SemVer(currentVersion).compare(lastVersion) < 0)
    return lastVersion;
}
function versionSatisfies(version, requirements) {
  return (0, import_semver3.satisfies)(version, requirements);
}
async function readAndParsePackageJson(packageJsonPath) {
  if (!await fileExists(packageJsonPath))
    throw new PackageJsonNotFoundError(dirname(packageJsonPath));
  return JSON.parse(await readFile(packageJsonPath));
}
async function addNPMDependenciesIfNeeded(dependencies, options) {
  outputDebug(outputContent`Adding the following dependencies if needed:
${outputToken.json(dependencies)}
With options:
${outputToken.json(options)}
  `);
  let packageJsonPath = joinPath(options.directory, "package.json");
  if (!await fileExists(packageJsonPath))
    throw new PackageJsonNotFoundError(options.directory);
  let existingDependencies = Object.keys(await getDependencies(packageJsonPath)), dependenciesToAdd = dependencies.filter((dep) => !existingDependencies.includes(dep.name));
  dependenciesToAdd.length !== 0 && await addNPMDependencies(dependenciesToAdd, options);
}
async function addNPMDependencies(dependencies, options) {
  let dependenciesWithVersion = dependencies.map((dep) => dep.version ? `${dep.name}@${dep.version}` : dep.name);
  switch (options.stdout?.write(`Installing ${[dependenciesWithVersion].join(" ")} with ${options.packageManager}`), options.packageManager) {
    case "npm":
      for (let dep of dependenciesWithVersion)
        await installDependencies(options, argumentsToAddDependenciesWithNPM(dep, options.type));
      break;
    case "yarn":
      await installDependencies(options, argumentsToAddDependenciesWithYarn(dependenciesWithVersion, options.type, !!options.addToRootDirectory));
      break;
    case "pnpm":
      await installDependencies(options, argumentsToAddDependenciesWithPNPM(dependenciesWithVersion, options.type, !!options.addToRootDirectory));
      break;
    case "bun":
      await installDependencies(options, argumentsToAddDependenciesWithBun(dependenciesWithVersion, options.type)), await installDependencies(options, ["install"]);
      break;
    case "unknown":
      throw new UnknownPackageManagerError();
  }
}
async function installDependencies(options, args) {
  return runWithTimer("cmd_all_timing_network_ms")(async () => exec(options.packageManager, args, {
    cwd: options.directory,
    stdout: options.stdout,
    stderr: options.stderr,
    signal: options.signal
  }));
}
async function addNPMDependenciesWithoutVersionIfNeeded(dependencies, options) {
  await addNPMDependenciesIfNeeded(dependencies.map((dependency) => ({ name: dependency, version: void 0 })), options);
}
function argumentsToAddDependenciesWithNPM(dependency, type) {
  let command = ["install"];
  switch (command = command.concat(dependency), type) {
    case "dev":
      command.push("--save-dev");
      break;
    case "peer":
      command.push("--save-peer");
      break;
    case "prod":
      command.push("--save-prod");
      break;
  }
  return dependency.match(/@\d/g) && command.push("--save-exact"), command;
}
function argumentsToAddDependenciesWithYarn(dependencies, type, addAtRoot = !1) {
  let command = ["add"];
  switch (addAtRoot && command.push("-W"), command = command.concat(dependencies), type) {
    case "dev":
      command.push("--dev");
      break;
    case "peer":
      command.push("--peer");
      break;
    case "prod":
      command.push("--prod");
      break;
  }
  return command;
}
function argumentsToAddDependenciesWithPNPM(dependencies, type, addAtRoot = !1) {
  let command = ["add"];
  switch (addAtRoot && command.push("-w"), command = command.concat(dependencies), type) {
    case "dev":
      command.push("--save-dev");
      break;
    case "peer":
      command.push("--save-peer");
      break;
    case "prod":
      command.push("--save-prod");
      break;
  }
  return command;
}
function argumentsToAddDependenciesWithBun(dependencies, type) {
  let command = ["add"];
  switch (command = command.concat(dependencies), type) {
    case "dev":
      command.push("--development");
      break;
    case "peer":
      command.push("--optional");
      break;
    case "prod":
      break;
  }
  return command;
}
async function findUpAndReadPackageJson(fromDirectory) {
  let packageJsonPath = await findPathUp("package.json", { cwd: fromDirectory, type: "file" });
  if (packageJsonPath) {
    let packageJson2 = JSON.parse(await readFile(packageJsonPath));
    return { path: packageJsonPath, content: packageJson2 };
  } else
    throw new FindUpAndReadPackageJsonNotFoundError(fromDirectory);
}
async function addResolutionOrOverride(directory, dependencies) {
  let packageManager2 = await getPackageManager(directory), packageJsonPath = joinPath(directory, "package.json"), packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  packageManager2 === "yarn" && (packageJsonContent.resolutions = packageJsonContent.resolutions ? { ...packageJsonContent.resolutions, ...dependencies } : dependencies), (packageManager2 === "npm" || packageManager2 === "pnpm" || packageManager2 === "bun") && (packageJsonContent.overrides = packageJsonContent.overrides ? { ...packageJsonContent.overrides, ...dependencies } : dependencies), await writeFile(packageJsonPath, JSON.stringify(packageJsonContent, null, 2));
}
async function getLatestNPMPackageVersion(name) {
  return outputDebug(outputContent`Getting the latest version of NPM package: ${outputToken.raw(name)}`), runWithTimer("cmd_all_timing_network_ms")(() => latestVersion(name));
}
async function writePackageJSON(directory, packageJSON) {
  outputDebug(outputContent`JSON-encoding and writing content to package.json at ${outputToken.path(directory)}...`);
  let packagePath = joinPath(directory, "package.json");
  await writeFile(packagePath, JSON.stringify(packageJSON, null, 2));
}
function inferPackageManager(optionsPackageManager, env = process.env) {
  if (optionsPackageManager && packageManager.includes(optionsPackageManager))
    return optionsPackageManager;
  let usedPackageManager = packageManagerFromUserAgent(env);
  if (usedPackageManager !== "unknown")
    return usedPackageManager;
  let globalPackageManager = inferPackageManagerForGlobalCLI();
  return globalPackageManager !== "unknown" ? globalPackageManager : "npm";
}

export {
  require_ajv,
  LocalStorage,
  getSessions,
  setSessions,
  removeSessions,
  getCurrentSessionId,
  setCurrentSessionId,
  removeCurrentSessionId,
  cacheRetrieveOrRepopulate,
  cacheStore,
  cacheRetrieve,
  cacheClear,
  timeIntervalToMilliseconds,
  runAtMinimumInterval,
  runWithRateLimit,
  yarnLockfile,
  npmLockfile,
  pnpmLockfile,
  bunLockfile,
  pnpmWorkspaceFile,
  lockfiles,
  lockfilesByManager,
  packageManager,
  UnknownPackageManagerError,
  PackageJsonNotFoundError,
  FindUpAndReadPackageJsonNotFoundError,
  packageManagerFromUserAgent,
  getPackageManager,
  installNPMDependenciesRecursively,
  installNodeModules,
  getPackageName,
  getPackageVersion,
  getDependencies,
  usesWorkspaces,
  checkForNewVersion,
  checkForCachedNewVersion,
  versionSatisfies,
  readAndParsePackageJson,
  addNPMDependenciesIfNeeded,
  addNPMDependencies,
  addNPMDependenciesWithoutVersionIfNeeded,
  findUpAndReadPackageJson,
  addResolutionOrOverride,
  writePackageJSON,
  inferPackageManager,
  node_package_manager_exports
};
/*! Bundled license information:

deep-extend/lib/deep-extend.js:
  (*!
   * @description Recursive object extending
   * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
   * @license MIT
   *
   * The MIT License (MIT)
   *
   * Copyright (c) 2013-2018 Viacheslav Lotsmanov
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)
*/
//# sourceMappingURL=chunk-UTGZE4KZ.js.map
