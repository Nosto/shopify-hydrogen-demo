import {
  require_ansi_styles,
  require_brace_expansion,
  require_lib,
  require_semver
} from "./chunk-F7F4BQYW.js";
import {
  require_has_flag
} from "./chunk-UMUTXITN.js";
import {
  require_source_map
} from "./chunk-UATXMR5F.js";
import {
  require_lib as require_lib2
} from "./chunk-B5EXYCV3.js";
import {
  require_graceful_fs
} from "./chunk-75LV6AQS.js";
import {
  cwd,
  delimiter,
  dirname,
  joinPath,
  normalizePath,
  relativizePath,
  sniffForPath
} from "./chunk-Y2JP6WFP.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports, module) {
    init_cjs_shims();
    function listCacheClear() {
      this.__data__ = [], this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
var require_eq = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports, module) {
    init_cjs_shims();
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports, module) {
    init_cjs_shims();
    var eq = require_eq();
    function assocIndexOf(array, key) {
      for (var length = array.length; length--; )
        if (eq(array[length][0], key))
          return length;
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports, module) {
    init_cjs_shims();
    var assocIndexOf = require_assocIndexOf(), arrayProto = Array.prototype, splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0)
        return !1;
      var lastIndex = data.length - 1;
      return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
    }
    module.exports = listCacheDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports, module) {
    init_cjs_shims();
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports, module) {
    init_cjs_shims();
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports, module) {
    init_cjs_shims();
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this;
    }
    module.exports = listCacheSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports, module) {
    init_cjs_shims();
    var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype.delete = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports, module) {
    init_cjs_shims();
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache(), this.size = 0;
    }
    module.exports = stackClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports, module) {
    init_cjs_shims();
    function stackDelete(key) {
      var data = this.__data__, result = data.delete(key);
      return this.size = data.size, result;
    }
    module.exports = stackDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports, module) {
    init_cjs_shims();
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports, module) {
    init_cjs_shims();
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module) {
    init_cjs_shims();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module) {
    init_cjs_shims();
    var freeGlobal = require_freeGlobal(), freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module) {
    init_cjs_shims();
    var root = require_root(), Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module) {
    init_cjs_shims();
    var Symbol2 = require_Symbol(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = !0;
      } catch {
      }
      var result = nativeObjectToString.call(value);
      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
    }
    module.exports = getRawTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module) {
    init_cjs_shims();
    var objectProto = Object.prototype, nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module) {
    init_cjs_shims();
    var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString(), nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module) {
    init_cjs_shims();
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports, module) {
    init_cjs_shims();
    var baseGetTag = require_baseGetTag(), isObject = require_isObject(), asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value))
        return !1;
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports, module) {
    init_cjs_shims();
    var root = require_root(), coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports, module) {
    init_cjs_shims();
    var coreJsData = require_coreJsData(), maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports, module) {
    init_cjs_shims();
    var funcProto = Function.prototype, funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch {
        }
        try {
          return func + "";
        } catch {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports, module) {
    init_cjs_shims();
    var isFunction = require_isFunction(), isMasked = require_isMasked(), isObject = require_isObject(), toSource = require_toSource(), reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value))
        return !1;
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports, module) {
    init_cjs_shims();
    function getValue(object, key) {
      return object?.[key];
    }
    module.exports = getValue;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports, module) {
    init_cjs_shims();
    var baseIsNative = require_baseIsNative(), getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), root = require_root(), Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports, module) {
    init_cjs_shims();
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
    }
    module.exports = hashClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports, module) {
    init_cjs_shims();
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      return this.size -= result ? 1 : 0, result;
    }
    module.exports = hashDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports, module) {
    init_cjs_shims();
    var nativeCreate = require_nativeCreate(), HASH_UNDEFINED = "__lodash_hash_undefined__", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports, module) {
    init_cjs_shims();
    var nativeCreate = require_nativeCreate(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports, module) {
    init_cjs_shims();
    var nativeCreate = require_nativeCreate(), HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value, this;
    }
    module.exports = hashSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports, module) {
    init_cjs_shims();
    var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype.delete = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports, module) {
    init_cjs_shims();
    var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0, this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports, module) {
    init_cjs_shims();
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports, module) {
    init_cjs_shims();
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    init_cjs_shims();
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key).delete(key);
      return this.size -= result ? 1 : 0, result;
    }
    module.exports = mapCacheDelete;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports, module) {
    init_cjs_shims();
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports, module) {
    init_cjs_shims();
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports, module) {
    init_cjs_shims();
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
    }
    module.exports = mapCacheSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports, module) {
    init_cjs_shims();
    var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      for (this.clear(); ++index < length; ) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype.delete = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports, module) {
    init_cjs_shims();
    var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache(), LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1)
          return pairs.push([key, value]), this.size = ++data.size, this;
        data = this.__data__ = new MapCache(pairs);
      }
      return data.set(key, value), this.size = data.size, this;
    }
    module.exports = stackSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports, module) {
    init_cjs_shims();
    var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype.delete = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports, module) {
    init_cjs_shims();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      return this.__data__.set(value, HASH_UNDEFINED), this;
    }
    module.exports = setCacheAdd;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports, module) {
    init_cjs_shims();
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports, module) {
    init_cjs_shims();
    var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      for (this.__data__ = new MapCache(); ++index < length; )
        this.add(values[index]);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports, module) {
    init_cjs_shims();
    function arraySome(array, predicate) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
        if (predicate(array[index], index, array))
          return !0;
      return !1;
    }
    module.exports = arraySome;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports, module) {
    init_cjs_shims();
    function cacheHas(cache3, key) {
      return cache3.has(key);
    }
    module.exports = cacheHas;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports, module) {
    init_cjs_shims();
    var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas(), COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength))
        return !1;
      var arrStacked = stack.get(array), othStacked = stack.get(other);
      if (arrStacked && othStacked)
        return arrStacked == other && othStacked == array;
      var index = -1, result = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
        var arrValue = array[index], othValue = other[index];
        if (customizer)
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        if (compared !== void 0) {
          if (compared)
            continue;
          result = !1;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack)))
              return seen.push(othIndex);
          })) {
            result = !1;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = !1;
          break;
        }
      }
      return stack.delete(array), stack.delete(other), result;
    }
    module.exports = equalArrays;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports, module) {
    init_cjs_shims();
    var root = require_root(), Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports, module) {
    init_cjs_shims();
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      return map.forEach(function(value, key) {
        result[++index] = [key, value];
      }), result;
    }
    module.exports = mapToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports, module) {
    init_cjs_shims();
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      return set.forEach(function(value) {
        result[++index] = value;
      }), result;
    }
    module.exports = setToArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports, module) {
    init_cjs_shims();
    var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = require_eq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray(), COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
            return !1;
          object = object.buffer, other = other.buffer;
        case arrayBufferTag:
          return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other)));
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          if (convert || (convert = setToArray), object.size != other.size && !isPartial)
            return !1;
          var stacked = stack.get(object);
          if (stacked)
            return stacked == other;
          bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          return stack.delete(object), result;
        case symbolTag:
          if (symbolValueOf)
            return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
      return !1;
    }
    module.exports = equalByTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports, module) {
    init_cjs_shims();
    function arrayPush(array, values) {
      for (var index = -1, length = values.length, offset = array.length; ++index < length; )
        array[offset + index] = values[index];
      return array;
    }
    module.exports = arrayPush;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports, module) {
    init_cjs_shims();
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    init_cjs_shims();
    var arrayPush = require_arrayPush(), isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports, module) {
    init_cjs_shims();
    function arrayFilter(array, predicate) {
      for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index];
        predicate(value, index, array) && (result[resIndex++] = value);
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports, module) {
    init_cjs_shims();
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports, module) {
    init_cjs_shims();
    var arrayFilter = require_arrayFilter(), stubArray = require_stubArray(), objectProto = Object.prototype, propertyIsEnumerable = objectProto.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(object) {
      return object == null ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      }));
    } : stubArray;
    module.exports = getSymbols;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports, module) {
    init_cjs_shims();
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; )
        result[index] = iteratee(index);
      return result;
    }
    module.exports = baseTimes;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module) {
    init_cjs_shims();
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports, module) {
    init_cjs_shims();
    var baseGetTag = require_baseGetTag(), isObjectLike = require_isObjectLike(), argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports, module) {
    init_cjs_shims();
    var baseIsArguments = require_baseIsArguments(), isObjectLike = require_isObjectLike(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, propertyIsEnumerable = objectProto.propertyIsEnumerable, isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports, module) {
    init_cjs_shims();
    function stubFalse() {
      return !1;
    }
    module.exports = stubFalse;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports, module) {
    init_cjs_shims();
    var root = require_root(), stubFalse = require_stubFalse(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer5 = moduleExports ? root.Buffer : void 0, nativeIsBuffer = Buffer5 ? Buffer5.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports, module) {
    init_cjs_shims();
    var MAX_SAFE_INTEGER = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      return length = length ?? MAX_SAFE_INTEGER, !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    module.exports = isIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports, module) {
    init_cjs_shims();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    init_cjs_shims();
    var baseGetTag = require_baseGetTag(), isLength = require_isLength(), isObjectLike = require_isObjectLike(), argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports, module) {
    init_cjs_shims();
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports, module) {
    init_cjs_shims();
    var freeGlobal = require_freeGlobal(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        return types2 || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch {
      }
    }();
    module.exports = nodeUtil;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports, module) {
    init_cjs_shims();
    var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    init_cjs_shims();
    var baseTimes = require_baseTimes(), isArguments = require_isArguments(), isArray = require_isArray(), isBuffer = require_isBuffer(), isIndex = require_isIndex(), isTypedArray = require_isTypedArray(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value)
        (inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length))) && result.push(key);
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports, module) {
    init_cjs_shims();
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto2;
    }
    module.exports = isPrototype;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports, module) {
    init_cjs_shims();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports, module) {
    init_cjs_shims();
    var overArg = require_overArg(), nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports, module) {
    init_cjs_shims();
    var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object))
        return nativeKeys(object);
      var result = [];
      for (var key in Object(object))
        hasOwnProperty.call(object, key) && key != "constructor" && result.push(key);
      return result;
    }
    module.exports = baseKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports, module) {
    init_cjs_shims();
    var isFunction = require_isFunction(), isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module.exports = isArrayLike;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports, module) {
    init_cjs_shims();
    var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports, module) {
    init_cjs_shims();
    var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports, module) {
    init_cjs_shims();
    var getAllKeys = require_getAllKeys(), COMPARE_PARTIAL_FLAG = 1, objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial)
        return !1;
      for (var index = objLength; index--; ) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key)))
          return !1;
      }
      var objStacked = stack.get(object), othStacked = stack.get(other);
      if (objStacked && othStacked)
        return objStacked == other && othStacked == object;
      var result = !0;
      stack.set(object, other), stack.set(other, object);
      for (var skipCtor = isPartial; ++index < objLength; ) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer)
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = !1;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result = !1);
      }
      return stack.delete(object), stack.delete(other), result;
    }
    module.exports = equalObjects;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), root = require_root(), DataView = getNative(root, "DataView");
    module.exports = DataView;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), root = require_root(), Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), root = require_root(), Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), root = require_root(), WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports, module) {
    init_cjs_shims();
    var DataView = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource(), mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag = "[object DataView]", dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2), getTag = baseGetTag;
    (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) && (getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString)
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      return result;
    });
    module.exports = getTag;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    init_cjs_shims();
    var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray = require_isArray(), isBuffer = require_isBuffer(), isTypedArray = require_isTypedArray(), COMPARE_PARTIAL_FLAG = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other))
          return !1;
        objIsArr = !0, objIsObj = !1;
      }
      if (isSameTag && !objIsObj)
        return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      return isSameTag ? (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack)) : !1;
    }
    module.exports = baseIsEqualDeep;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports, module) {
    init_cjs_shims();
    var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      return value === other ? !0 : value == null || other == null || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports, module) {
    init_cjs_shims();
    var Stack = require_Stack(), baseIsEqual = require_baseIsEqual(), COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null)
        return !length;
      for (object = Object(object); index--; ) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))
          return !1;
      }
      for (; ++index < length; ) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object))
            return !1;
        } else {
          var stack = new Stack();
          if (customizer)
            var result = customizer(objValue, srcValue, key, object, source, stack);
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result))
            return !1;
        }
      }
      return !0;
    }
    module.exports = baseIsMatch;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports, module) {
    init_cjs_shims();
    var isObject = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    module.exports = isStrictComparable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports, module) {
    init_cjs_shims();
    var isStrictComparable = require_isStrictComparable(), keys = require_keys();
    function getMatchData(object) {
      for (var result = keys(object), length = result.length; length--; ) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    init_cjs_shims();
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        return object == null ? !1 : object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports, module) {
    init_cjs_shims();
    var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      return matchData.length == 1 && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports, module) {
    init_cjs_shims();
    var baseGetTag = require_baseGetTag(), isObjectLike = require_isObjectLike(), symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports, module) {
    init_cjs_shims();
    var isArray = require_isArray(), isSymbol = require_isSymbol(), reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value))
        return !1;
      var type = typeof value;
      return type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    module.exports = isKey;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports, module) {
    init_cjs_shims();
    var MapCache = require_MapCache(), FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function")
        throw new TypeError(FUNC_ERROR_TEXT);
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache3 = memoized.cache;
        if (cache3.has(key))
          return cache3.get(key);
        var result = func.apply(this, args);
        return memoized.cache = cache3.set(key, result) || cache3, result;
      };
      return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports, module) {
    init_cjs_shims();
    var memoize = require_memoize(), MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        return cache3.size === MAX_MEMOIZE_SIZE && cache3.clear(), key;
      }), cache3 = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports, module) {
    init_cjs_shims();
    var memoizeCapped = require_memoizeCapped(), rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped(function(string) {
      var result = [];
      return string.charCodeAt(0) === 46 && result.push(""), string.replace(rePropName, function(match2, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
      }), result;
    });
    module.exports = stringToPath;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports, module) {
    init_cjs_shims();
    function arrayMap(array, iteratee) {
      for (var index = -1, length = array == null ? 0 : array.length, result = Array(length); ++index < length; )
        result[index] = iteratee(array[index], index, array);
      return result;
    }
    module.exports = arrayMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports, module) {
    init_cjs_shims();
    var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray = require_isArray(), isSymbol = require_isSymbol(), INFINITY = 1 / 0, symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string")
        return value;
      if (isArray(value))
        return arrayMap(value, baseToString) + "";
      if (isSymbol(value))
        return symbolToString ? symbolToString.call(value) : "";
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
var require_toString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports, module) {
    init_cjs_shims();
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports, module) {
    init_cjs_shims();
    var isArray = require_isArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = require_toString();
    function castPath(value, object) {
      return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    module.exports = castPath;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports, module) {
    init_cjs_shims();
    var isSymbol = require_isSymbol(), INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value))
        return value;
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports, module) {
    init_cjs_shims();
    var castPath = require_castPath(), toKey = require_toKey();
    function baseGet(object, path8) {
      path8 = castPath(path8, object);
      for (var index = 0, length = path8.length; object != null && index < length; )
        object = object[toKey(path8[index++])];
      return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
var require_get = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports, module) {
    init_cjs_shims();
    var baseGet = require_baseGet();
    function get(object, path8, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path8);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports, module) {
    init_cjs_shims();
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module.exports = baseHasIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports, module) {
    init_cjs_shims();
    var castPath = require_castPath(), isArguments = require_isArguments(), isArray = require_isArray(), isIndex = require_isIndex(), isLength = require_isLength(), toKey = require_toKey();
    function hasPath(object, path8, hasFunc) {
      path8 = castPath(path8, object);
      for (var index = -1, length = path8.length, result = !1; ++index < length; ) {
        var key = toKey(path8[index]);
        if (!(result = object != null && hasFunc(object, key)))
          break;
        object = object[key];
      }
      return result || ++index != length ? result : (length = object == null ? 0 : object.length, !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object)));
    }
    module.exports = hasPath;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports, module) {
    init_cjs_shims();
    var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
    function hasIn(object, path8) {
      return object != null && hasPath(object, path8, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    init_cjs_shims();
    var baseIsEqual = require_baseIsEqual(), get = require_get(), hasIn = require_hasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey(), COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path8, srcValue) {
      return isKey(path8) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path8), srcValue) : function(object) {
        var objValue = get(object, path8);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path8) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
var require_identity = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports, module) {
    init_cjs_shims();
    function identity(value) {
      return value;
    }
    module.exports = identity;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports, module) {
    init_cjs_shims();
    function baseProperty(key) {
      return function(object) {
        return object?.[key];
      };
    }
    module.exports = baseProperty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    init_cjs_shims();
    var baseGet = require_baseGet();
    function basePropertyDeep(path8) {
      return function(object) {
        return baseGet(object, path8);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
var require_property = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports, module) {
    init_cjs_shims();
    var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
    function property(path8) {
      return isKey(path8) ? baseProperty(toKey(path8)) : basePropertyDeep(path8);
    }
    module.exports = property;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports, module) {
    init_cjs_shims();
    var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity = require_identity(), isArray = require_isArray(), property = require_property();
    function baseIteratee(value) {
      return typeof value == "function" ? value : value == null ? identity : typeof value == "object" ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
    }
    module.exports = baseIteratee;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js"(exports, module) {
    init_cjs_shims();
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
        if (predicate(array[index], index, array))
          return index;
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js"(exports, module) {
    init_cjs_shims();
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js"(exports, module) {
    init_cjs_shims();
    function strictIndexOf(array, value, fromIndex) {
      for (var index = fromIndex - 1, length = array.length; ++index < length; )
        if (array[index] === value)
          return index;
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js"(exports, module) {
    init_cjs_shims();
    var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js"(exports, module) {
    init_cjs_shims();
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    init_cjs_shims();
    function arrayIncludesWith(array, value, comparator) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
        if (comparator(value, array[index]))
          return !0;
      return !1;
    }
    module.exports = arrayIncludesWith;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js
var require_noop = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js"(exports, module) {
    init_cjs_shims();
    function noop4() {
    }
    module.exports = noop4;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js"(exports, module) {
    init_cjs_shims();
    var Set2 = require_Set(), noop4 = require_noop(), setToArray = require_setToArray(), INFINITY = 1 / 0, createSet = Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY ? function(values) {
      return new Set2(values);
    } : noop4;
    module.exports = createSet;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js"(exports, module) {
    init_cjs_shims();
    var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray(), LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
      if (comparator)
        isCommon = !1, includes = arrayIncludesWith;
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set)
          return setToArray(set);
        isCommon = !1, includes = cacheHas, seen = new SetCache();
      } else
        seen = iteratee ? [] : result;
      outer:
        for (; ++index < length; ) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
            for (var seenIndex = seen.length; seenIndex--; )
              if (seen[seenIndex] === computed)
                continue outer;
            iteratee && seen.push(computed), result.push(value);
          } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), result.push(value));
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniqBy.js
var require_uniqBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniqBy.js"(exports, module) {
    init_cjs_shims();
    var baseIteratee = require_baseIteratee(), baseUniq = require_baseUniq();
    function uniqBy2(array, iteratee) {
      return array && array.length ? baseUniq(array, baseIteratee(iteratee, 2)) : [];
    }
    module.exports = uniqBy2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"(exports, module) {
    init_cjs_shims();
    var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), arrayMap = require_arrayMap(), baseUnary = require_baseUnary(), cacheHas = require_cacheHas(), LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
      if (!length)
        return result;
      iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith, isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1, values = new SetCache(values));
      outer:
        for (; ++index < length; ) {
          var value = array[index], computed = iteratee == null ? value : iteratee(value);
          if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
            for (var valuesIndex = valuesLength; valuesIndex--; )
              if (values[valuesIndex] === computed)
                continue outer;
            result.push(value);
          } else includes(values, computed, comparator) || result.push(value);
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js"(exports, module) {
    init_cjs_shims();
    var Symbol2 = require_Symbol(), isArguments = require_isArguments(), isArray = require_isArray(), spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"(exports, module) {
    init_cjs_shims();
    var arrayPush = require_arrayPush(), isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length; ) {
        var value = array[index];
        depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js"(exports, module) {
    init_cjs_shims();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js"(exports, module) {
    init_cjs_shims();
    var apply = require_apply(), nativeMax = Math.max;
    function overRest(func, start, transform) {
      return start = nativeMax(start === void 0 ? func.length - 1 : start, 0), function() {
        for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; )
          array[index] = args[start + index];
        index = -1;
        for (var otherArgs = Array(start + 1); ++index < start; )
          otherArgs[index] = args[index];
        return otherArgs[start] = transform(array), apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js
var require_constant = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js"(exports, module) {
    init_cjs_shims();
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports, module) {
    init_cjs_shims();
    var getNative = require_getNative(), defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        return func({}, "", {}), func;
      } catch {
      }
    }();
    module.exports = defineProperty;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js"(exports, module) {
    init_cjs_shims();
    var constant = require_constant(), defineProperty = require_defineProperty(), identity = require_identity(), baseSetToString = defineProperty ? function(func, string) {
      return defineProperty(func, "toString", {
        configurable: !0,
        enumerable: !1,
        value: constant(string),
        writable: !0
      });
    } : identity;
    module.exports = baseSetToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js"(exports, module) {
    init_cjs_shims();
    var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        if (lastCalled = stamp, remaining > 0) {
          if (++count >= HOT_COUNT)
            return arguments[0];
        } else
          count = 0;
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js"(exports, module) {
    init_cjs_shims();
    var baseSetToString = require_baseSetToString(), shortOut = require_shortOut(), setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"(exports, module) {
    init_cjs_shims();
    var identity = require_identity(), overRest = require_overRest(), setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    module.exports = baseRest;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    init_cjs_shims();
    var isArrayLike = require_isArrayLike(), isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js
var require_difference = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js"(exports, module) {
    init_cjs_shims();
    var baseDifference = require_baseDifference(), baseFlatten = require_baseFlatten(), baseRest = require_baseRest(), isArrayLikeObject = require_isArrayLikeObject(), difference2 = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : [];
    });
    module.exports = difference2;
  }
});

// ../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b != "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f != "function") throw new TypeError("Function expected");
    return f;
  }
  for (var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _2, done = !1, i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result != "object") throw new TypeError("Object expected");
      (_2 = accept(result.get)) && (descriptor.get = _2), (_2 = accept(result.set)) && (descriptor.set = _2), (_2 = accept(result.init)) && initializers.unshift(_2);
    } else (_2 = accept(result)) && (kind === "field" ? initializers.unshift(_2) : descriptor[key] = _2);
  }
  target && Object.defineProperty(target, contextIn.name, descriptor), done = !0;
}
function __runInitializers(thisArg, initializers, value) {
  for (var useValue = arguments.length > 2, i = 0; i < initializers.length; i++)
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x == "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  return typeof name == "symbol" && (name = name.description ? "[".concat(name.description, "]") : ""), Object.defineProperty(f, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g.throw = verb(1), g.return = verb(2), typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; g && (g = 0, op[0] && (_2 = 0)), _2; ) try {
      if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          return _2.label++, { value: op[1], done: !1 };
        case 5:
          _2.label++, y = op[1], op = [0];
          continue;
        case 7:
          op = _2.ops.pop(), _2.trys.pop();
          continue;
        default:
          if (t = _2.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1], t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2], _2.ops.push(op);
            break;
          }
          t[2] && _2.ops.pop(), _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e) {
      op = [6, e], y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: !0 };
  }
}
function __exportStar(m, o) {
  for (var p in m) p !== "default" && !Object.prototype.hasOwnProperty.call(o, p) && __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length == "number") return {
    next: function() {
      return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol == "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      r && !r.done && (m = i.return) && m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++)
    (ar || !(i in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    g[n] && (i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    }, f && (i[n] = f(i[n])));
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    f(v), q.shift(), q.length && resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values == "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) k[i] !== "default" && __createBinding(result, mod, k[i]);
  return __setModuleDefault(result, mod), result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state == "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver != "object" && typeof receiver != "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state == "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env3, value, async) {
  if (value != null) {
    if (typeof value != "object" && typeof value != "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose], async && (inner = dispose);
    }
    if (typeof dispose != "function") throw new TypeError("Object not disposable.");
    inner && (dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    }), env3.stack.push({ value, dispose, async });
  } else async && env3.stack.push({ async: !0 });
  return value;
}
function __disposeResources(env3) {
  function fail(e) {
    env3.error = env3.hasError ? new _SuppressedError(e, env3.error, "An error was suppressed during disposal.") : e, env3.hasError = !0;
  }
  var r, s = 0;
  function next() {
    for (; r = env3.stack.pop(); )
      try {
        if (!r.async && s === 1) return s = 0, env3.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            return fail(e), next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    if (s === 1) return env3.hasError ? Promise.reject(env3.error) : Promise.resolve();
    if (env3.hasError) throw env3.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path8, preserveJsx) {
  return typeof path8 == "string" && /^\.\.?\//.test(path8) ? path8.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext2, cm) {
    return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext2 || !cm) ? m : d + ext2 + "." + cm.toLowerCase() + "js";
  }) : path8;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default, init_tslib_es6 = __esm({
  "../../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs"() {
    init_cjs_shims();
    extendStatics = function(d, b) {
      return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
      }, extendStatics(d, b);
    };
    __assign = function() {
      return __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k);
      var desc = Object.getOwnPropertyDescriptor(m, k);
      (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) && (desc = { enumerable: !0, get: function() {
        return m[k];
      } }), Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }, ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) Object.prototype.hasOwnProperty.call(o2, k) && (ar[ar.length] = k);
        return ar;
      }, ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError == "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// ../../node_modules/.pnpm/lower-case@2.0.2/node_modules/lower-case/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/lower-case@2.0.2/node_modules/lower-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.lowerCase = exports.localeLowerCase = void 0;
    var SUPPORTED_LOCALE = {
      tr: {
        regexp: /\u0130|\u0049|\u0049\u0307/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      az: {
        regexp: /\u0130/g,
        map: {
          \u0130: "i",
          I: "\u0131",
          I\u0307: "i"
        }
      },
      lt: {
        regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
        map: {
          I: "i\u0307",
          J: "j\u0307",
          \u012E: "\u012F\u0307",
          \u00CC: "i\u0307\u0300",
          \u00CD: "i\u0307\u0301",
          \u0128: "i\u0307\u0303"
        }
      }
    };
    function localeLowerCase(str, locale) {
      var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
      return lowerCase(lang ? str.replace(lang.regexp, function(m) {
        return lang.map[m];
      }) : str);
    }
    exports.localeLowerCase = localeLowerCase;
    function lowerCase(str) {
      return str.toLowerCase();
    }
    exports.lowerCase = lowerCase;
  }
});

// ../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/.pnpm/no-case@3.0.4/node_modules/no-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.noCase = void 0;
    var lower_case_1 = require_dist(), DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g], DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
    function noCase(input, options) {
      options === void 0 && (options = {});
      for (var _a = options.splitRegexp, splitRegexp = _a === void 0 ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === void 0 ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === void 0 ? lower_case_1.lowerCase : _c, _d = options.delimiter, delimiter2 = _d === void 0 ? " " : _d, result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0"), start = 0, end = result.length; result.charAt(start) === "\0"; )
        start++;
      for (; result.charAt(end - 1) === "\0"; )
        end--;
      return result.slice(start, end).split("\0").map(transform).join(delimiter2);
    }
    exports.noCase = noCase;
    function replace(input, re, value) {
      return re instanceof RegExp ? input.replace(re, value) : re.reduce(function(input2, re2) {
        return input2.replace(re2, value);
      }, input);
    }
  }
});

// ../../node_modules/.pnpm/pascal-case@3.1.2/node_modules/pascal-case/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/.pnpm/pascal-case@3.1.2/node_modules/pascal-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.pascalCase = exports.pascalCaseTransformMerge = exports.pascalCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), no_case_1 = require_dist2();
    function pascalCaseTransform(input, index) {
      var firstChar = input.charAt(0), lowerChars = input.substr(1).toLowerCase();
      return index > 0 && firstChar >= "0" && firstChar <= "9" ? "_" + firstChar + lowerChars : "" + firstChar.toUpperCase() + lowerChars;
    }
    exports.pascalCaseTransform = pascalCaseTransform;
    function pascalCaseTransformMerge(input) {
      return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
    }
    exports.pascalCaseTransformMerge = pascalCaseTransformMerge;
    function pascalCase2(input, options) {
      return options === void 0 && (options = {}), no_case_1.noCase(input, tslib_1.__assign({ delimiter: "", transform: pascalCaseTransform }, options));
    }
    exports.pascalCase = pascalCase2;
  }
});

// ../../node_modules/.pnpm/camel-case@4.1.2/node_modules/camel-case/dist/index.js
var require_dist4 = __commonJS({
  "../../node_modules/.pnpm/camel-case@4.1.2/node_modules/camel-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.camelCase = exports.camelCaseTransformMerge = exports.camelCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), pascal_case_1 = require_dist3();
    function camelCaseTransform(input, index) {
      return index === 0 ? input.toLowerCase() : pascal_case_1.pascalCaseTransform(input, index);
    }
    exports.camelCaseTransform = camelCaseTransform;
    function camelCaseTransformMerge(input, index) {
      return index === 0 ? input.toLowerCase() : pascal_case_1.pascalCaseTransformMerge(input);
    }
    exports.camelCaseTransformMerge = camelCaseTransformMerge;
    function camelCase2(input, options) {
      return options === void 0 && (options = {}), pascal_case_1.pascalCase(input, tslib_1.__assign({ transform: camelCaseTransform }, options));
    }
    exports.camelCase = camelCase2;
  }
});

// ../../node_modules/.pnpm/upper-case-first@2.0.2/node_modules/upper-case-first/dist/index.js
var require_dist5 = __commonJS({
  "../../node_modules/.pnpm/upper-case-first@2.0.2/node_modules/upper-case-first/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.upperCaseFirst = void 0;
    function upperCaseFirst(input) {
      return input.charAt(0).toUpperCase() + input.substr(1);
    }
    exports.upperCaseFirst = upperCaseFirst;
  }
});

// ../../node_modules/.pnpm/capital-case@1.0.4/node_modules/capital-case/dist/index.js
var require_dist6 = __commonJS({
  "../../node_modules/.pnpm/capital-case@1.0.4/node_modules/capital-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.capitalCase = exports.capitalCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), no_case_1 = require_dist2(), upper_case_first_1 = require_dist5();
    function capitalCaseTransform(input) {
      return upper_case_first_1.upperCaseFirst(input.toLowerCase());
    }
    exports.capitalCaseTransform = capitalCaseTransform;
    function capitalCase(input, options) {
      return options === void 0 && (options = {}), no_case_1.noCase(input, tslib_1.__assign({ delimiter: " ", transform: capitalCaseTransform }, options));
    }
    exports.capitalCase = capitalCase;
  }
});

// ../../node_modules/.pnpm/upper-case@2.0.2/node_modules/upper-case/dist/index.js
var require_dist7 = __commonJS({
  "../../node_modules/.pnpm/upper-case@2.0.2/node_modules/upper-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.upperCase = exports.localeUpperCase = void 0;
    var SUPPORTED_LOCALE = {
      tr: {
        regexp: /[\u0069]/g,
        map: {
          i: "\u0130"
        }
      },
      az: {
        regexp: /[\u0069]/g,
        map: {
          i: "\u0130"
        }
      },
      lt: {
        regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
        map: {
          i\u0307: "I",
          j\u0307: "J",
          \u012F\u0307: "\u012E",
          i\u0307\u0300: "\xCC",
          i\u0307\u0301: "\xCD",
          i\u0307\u0303: "\u0128"
        }
      }
    };
    function localeUpperCase(str, locale) {
      var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
      return upperCase(lang ? str.replace(lang.regexp, function(m) {
        return lang.map[m];
      }) : str);
    }
    exports.localeUpperCase = localeUpperCase;
    function upperCase(str) {
      return str.toUpperCase();
    }
    exports.upperCase = upperCase;
  }
});

// ../../node_modules/.pnpm/constant-case@3.0.4/node_modules/constant-case/dist/index.js
var require_dist8 = __commonJS({
  "../../node_modules/.pnpm/constant-case@3.0.4/node_modules/constant-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.constantCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), no_case_1 = require_dist2(), upper_case_1 = require_dist7();
    function constantCase2(input, options) {
      return options === void 0 && (options = {}), no_case_1.noCase(input, tslib_1.__assign({ delimiter: "_", transform: upper_case_1.upperCase }, options));
    }
    exports.constantCase = constantCase2;
  }
});

// ../../node_modules/.pnpm/dot-case@3.0.4/node_modules/dot-case/dist/index.js
var require_dist9 = __commonJS({
  "../../node_modules/.pnpm/dot-case@3.0.4/node_modules/dot-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.dotCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), no_case_1 = require_dist2();
    function dotCase(input, options) {
      return options === void 0 && (options = {}), no_case_1.noCase(input, tslib_1.__assign({ delimiter: "." }, options));
    }
    exports.dotCase = dotCase;
  }
});

// ../../node_modules/.pnpm/header-case@2.0.4/node_modules/header-case/dist/index.js
var require_dist10 = __commonJS({
  "../../node_modules/.pnpm/header-case@2.0.4/node_modules/header-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.headerCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), capital_case_1 = require_dist6();
    function headerCase(input, options) {
      return options === void 0 && (options = {}), capital_case_1.capitalCase(input, tslib_1.__assign({ delimiter: "-" }, options));
    }
    exports.headerCase = headerCase;
  }
});

// ../../node_modules/.pnpm/param-case@3.0.4/node_modules/param-case/dist/index.js
var require_dist11 = __commonJS({
  "../../node_modules/.pnpm/param-case@3.0.4/node_modules/param-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.paramCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), dot_case_1 = require_dist9();
    function paramCase2(input, options) {
      return options === void 0 && (options = {}), dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "-" }, options));
    }
    exports.paramCase = paramCase2;
  }
});

// ../../node_modules/.pnpm/path-case@3.0.4/node_modules/path-case/dist/index.js
var require_dist12 = __commonJS({
  "../../node_modules/.pnpm/path-case@3.0.4/node_modules/path-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.pathCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), dot_case_1 = require_dist9();
    function pathCase(input, options) {
      return options === void 0 && (options = {}), dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "/" }, options));
    }
    exports.pathCase = pathCase;
  }
});

// ../../node_modules/.pnpm/sentence-case@3.0.4/node_modules/sentence-case/dist/index.js
var require_dist13 = __commonJS({
  "../../node_modules/.pnpm/sentence-case@3.0.4/node_modules/sentence-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.sentenceCase = exports.sentenceCaseTransform = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), no_case_1 = require_dist2(), upper_case_first_1 = require_dist5();
    function sentenceCaseTransform(input, index) {
      var result = input.toLowerCase();
      return index === 0 ? upper_case_first_1.upperCaseFirst(result) : result;
    }
    exports.sentenceCaseTransform = sentenceCaseTransform;
    function sentenceCase(input, options) {
      return options === void 0 && (options = {}), no_case_1.noCase(input, tslib_1.__assign({ delimiter: " ", transform: sentenceCaseTransform }, options));
    }
    exports.sentenceCase = sentenceCase;
  }
});

// ../../node_modules/.pnpm/snake-case@3.0.4/node_modules/snake-case/dist/index.js
var require_dist14 = __commonJS({
  "../../node_modules/.pnpm/snake-case@3.0.4/node_modules/snake-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.snakeCase = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)), dot_case_1 = require_dist9();
    function snakeCase2(input, options) {
      return options === void 0 && (options = {}), dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "_" }, options));
    }
    exports.snakeCase = snakeCase2;
  }
});

// ../../node_modules/.pnpm/change-case@4.1.2/node_modules/change-case/dist/index.js
var require_dist15 = __commonJS({
  "../../node_modules/.pnpm/change-case@4.1.2/node_modules/change-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_dist4(), exports);
    tslib_1.__exportStar(require_dist6(), exports);
    tslib_1.__exportStar(require_dist8(), exports);
    tslib_1.__exportStar(require_dist9(), exports);
    tslib_1.__exportStar(require_dist10(), exports);
    tslib_1.__exportStar(require_dist2(), exports);
    tslib_1.__exportStar(require_dist11(), exports);
    tslib_1.__exportStar(require_dist3(), exports);
    tslib_1.__exportStar(require_dist12(), exports);
    tslib_1.__exportStar(require_dist13(), exports);
    tslib_1.__exportStar(require_dist14(), exports);
  }
});

// ../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] == "function") fn.apply(this, args);
        else
          return new Promise((resolve, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve(res)), fn.apply(this, args);
          });
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        let cb = args[args.length - 1];
        if (typeof cb != "function") return fn.apply(this, args);
        args.pop(), fn.apply(this, args).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback, fs5 = require_graceful_fs(), api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => typeof fs5[key] == "function");
    Object.assign(exports, fs5);
    api.forEach((method) => {
      exports[method] = u(fs5[method]);
    });
    exports.exists = function(filename, callback) {
      return typeof callback == "function" ? fs5.exists(filename, callback) : new Promise((resolve) => fs5.exists(filename, resolve));
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      return typeof callback == "function" ? fs5.read(fd, buffer, offset, length, position, callback) : new Promise((resolve, reject) => {
        fs5.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      return typeof args[args.length - 1] == "function" ? fs5.write(fd, buffer, ...args) : new Promise((resolve, reject) => {
        fs5.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      return typeof args[args.length - 1] == "function" ? fs5.readv(fd, buffers, ...args) : new Promise((resolve, reject) => {
        fs5.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      return typeof args[args.length - 1] == "function" ? fs5.writev(fd, buffers, ...args) : new Promise((resolve, reject) => {
        fs5.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    typeof fs5.realpath.native == "function" ? exports.realpath.native = u(fs5.realpath.native) : process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path8 = __require("path");
    module.exports.checkPath = function(pth) {
      if (process.platform === "win32" && /[<>:"|?*]/.test(pth.replace(path8.parse(pth).root, ""))) {
        let error = new Error(`Path contains invalid characters: ${pth}`);
        throw error.code = "EINVAL", error;
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_fs(), { checkPath } = require_utils(), getMode = (options) => {
      let defaults2 = { mode: 511 };
      return typeof options == "number" ? options : { ...defaults2, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => (checkPath(dir), fs5.mkdir(dir, {
      mode: getMode(options),
      recursive: !0
    }));
    module.exports.makeDirSync = (dir, options) => (checkPath(dir), fs5.mkdirSync(dir, {
      mode: getMode(options),
      recursive: !0
    }));
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromPromise, { makeDir: _makeDir, makeDirSync } = require_make_dir(), makeDir = u(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromPromise, fs5 = require_fs();
    function pathExists3(path8) {
      return fs5.access(path8).then(() => !0).catch(() => !1);
    }
    module.exports = {
      pathExists: u(pathExists3),
      pathExistsSync: fs5.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs();
    function utimesMillis(path8, atime, mtime, callback) {
      fs5.open(path8, "r+", (err, fd) => {
        if (err) return callback(err);
        fs5.futimes(fd, atime, mtime, (futimesErr) => {
          fs5.close(fd, (closeErr) => {
            callback && callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path8, atime, mtime) {
      let fd = fs5.openSync(path8, "r+");
      return fs5.futimesSync(fd, atime, mtime), fs5.closeSync(fd);
    }
    module.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/util/stat.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_fs(), path8 = __require("path"), util = __require("util");
    function getStats(src, dest, opts) {
      let statFunc = opts.dereference ? (file) => fs5.stat(file, { bigint: !0 }) : (file) => fs5.lstat(file, { bigint: !0 });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat, statFunc = opts.dereference ? (file) => fs5.statSync(file, { bigint: !0 }) : (file) => fs5.lstatSync(file, { bigint: !0 }), srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err) return cb(err);
        let { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            let srcBaseName = path8.basename(src), destBaseName = path8.basename(dest);
            return funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase() ? cb(null, { srcStat, destStat, isChangingCase: !0 }) : cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory())
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          if (!srcStat.isDirectory() && destStat.isDirectory())
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
        }
        return srcStat.isDirectory() && isSrcSubdir(src, dest) ? cb(new Error(errMsg(src, dest, funcName))) : cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      let { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          let srcBaseName = path8.basename(src), destBaseName = path8.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase())
            return { srcStat, destStat, isChangingCase: !0 };
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory())
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        if (!srcStat.isDirectory() && destStat.isDirectory())
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest))
        throw new Error(errMsg(src, dest, funcName));
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      let srcParent = path8.resolve(path8.dirname(src)), destParent = path8.resolve(path8.dirname(dest));
      if (destParent === srcParent || destParent === path8.parse(destParent).root) return cb();
      fs5.stat(destParent, { bigint: !0 }, (err, destStat) => err ? err.code === "ENOENT" ? cb() : cb(err) : areIdentical(srcStat, destStat) ? cb(new Error(errMsg(src, dest, funcName))) : checkParentPaths(src, srcStat, destParent, funcName, cb));
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      let srcParent = path8.resolve(path8.dirname(src)), destParent = path8.resolve(path8.dirname(dest));
      if (destParent === srcParent || destParent === path8.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs5.statSync(destParent, { bigint: !0 });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat))
        throw new Error(errMsg(src, dest, funcName));
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      let srcArr = path8.resolve(src).split(path8.sep).filter((i) => i), destArr = path8.resolve(dest).split(path8.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, !0);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs(), path8 = __require("path"), mkdirs2 = require_mkdirs().mkdirs, pathExists3 = require_path_exists().pathExists, utimesMillis = require_utimes().utimesMillis, stat = require_stat();
    function copy2(src, dest, opts, cb) {
      typeof opts == "function" && !cb ? (cb = opts, opts = {}) : typeof opts == "function" && (opts = { filter: opts }), cb = cb || function() {
      }, opts = opts || {}, opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0001"
      ), stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err) return cb(err);
        let { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2) return cb(err2);
          runFilter(src, dest, opts, (err3, include) => {
            if (err3) return cb(err3);
            if (!include) return cb();
            checkParentDir(destStat, src, dest, opts, cb);
          });
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      let destParent = path8.dirname(dest);
      pathExists3(destParent, (err, dirExists) => {
        if (err) return cb(err);
        if (dirExists) return getStats(destStat, src, dest, opts, cb);
        mkdirs2(destParent, (err2) => err2 ? cb(err2) : getStats(destStat, src, dest, opts, cb));
      });
    }
    function runFilter(src, dest, opts, cb) {
      if (!opts.filter) return cb(null, !0);
      Promise.resolve(opts.filter(src, dest)).then((include) => cb(null, include), (error) => cb(error));
    }
    function getStats(destStat, src, dest, opts, cb) {
      (opts.dereference ? fs5.stat : fs5.lstat)(src, (err, srcStat) => err ? cb(err) : srcStat.isDirectory() ? onDir(srcStat, destStat, src, dest, opts, cb) : srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice() ? onFile(srcStat, destStat, src, dest, opts, cb) : srcStat.isSymbolicLink() ? onLink(destStat, src, dest, opts, cb) : srcStat.isSocket() ? cb(new Error(`Cannot copy a socket file: ${src}`)) : srcStat.isFIFO() ? cb(new Error(`Cannot copy a FIFO pipe: ${src}`)) : cb(new Error(`Unknown file: ${src}`)));
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      return destStat ? mayCopyFile(srcStat, src, dest, opts, cb) : copyFile2(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite)
        fs5.unlink(dest, (err) => err ? cb(err) : copyFile2(srcStat, src, dest, opts, cb));
      else return opts.errorOnExist ? cb(new Error(`'${dest}' already exists`)) : cb();
    }
    function copyFile2(srcStat, src, dest, opts, cb) {
      fs5.copyFile(src, dest, (err) => err ? cb(err) : opts.preserveTimestamps ? handleTimestampsAndMode(srcStat.mode, src, dest, cb) : setDestMode(dest, srcStat.mode, cb));
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      return fileIsNotWritable(srcMode) ? makeFileWritable(dest, srcMode, (err) => err ? cb(err) : setDestTimestampsAndMode(srcMode, src, dest, cb)) : setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => err ? cb(err) : setDestMode(dest, srcMode, cb));
    }
    function setDestMode(dest, srcMode, cb) {
      return fs5.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs5.stat(src, (err, updatedSrcStat) => err ? cb(err) : utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb));
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      return destStat ? copyDir(src, dest, opts, cb) : mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs5.mkdir(dest, (err) => {
        if (err) return cb(err);
        copyDir(src, dest, opts, (err2) => err2 ? cb(err2) : setDestMode(dest, srcMode, cb));
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs5.readdir(src, (err, items) => err ? cb(err) : copyDirItems(items, src, dest, opts, cb));
    }
    function copyDirItems(items, src, dest, opts, cb) {
      let item = items.pop();
      return item ? copyDirItem(items, item, src, dest, opts, cb) : cb();
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      let srcItem = path8.join(src, item), destItem = path8.join(dest, item);
      runFilter(srcItem, destItem, opts, (err, include) => {
        if (err) return cb(err);
        if (!include) return copyDirItems(items, src, dest, opts, cb);
        stat.checkPaths(srcItem, destItem, "copy", opts, (err2, stats) => {
          if (err2) return cb(err2);
          let { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err3) => err3 ? cb(err3) : copyDirItems(items, src, dest, opts, cb));
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs5.readlink(src, (err, resolvedSrc) => {
        if (err) return cb(err);
        if (opts.dereference && (resolvedSrc = path8.resolve(process.cwd(), resolvedSrc)), destStat)
          fs5.readlink(dest, (err2, resolvedDest) => err2 ? err2.code === "EINVAL" || err2.code === "UNKNOWN" ? fs5.symlink(resolvedSrc, dest, cb) : cb(err2) : (opts.dereference && (resolvedDest = path8.resolve(process.cwd(), resolvedDest)), stat.isSrcSubdir(resolvedSrc, resolvedDest) ? cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)) : stat.isSrcSubdir(resolvedDest, resolvedSrc) ? cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)) : copyLink(resolvedSrc, dest, cb)));
        else
          return fs5.symlink(resolvedSrc, dest, cb);
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs5.unlink(dest, (err) => err ? cb(err) : fs5.symlink(resolvedSrc, dest, cb));
    }
    module.exports = copy2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs(), path8 = __require("path"), mkdirsSync2 = require_mkdirs().mkdirsSync, utimesMillisSync = require_utimes().utimesMillisSync, stat = require_stat();
    function copySync2(src, dest, opts) {
      typeof opts == "function" && (opts = { filter: opts }), opts = opts || {}, opts.clobber = "clobber" in opts ? !!opts.clobber : !0, opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber, opts.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0002"
      );
      let { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      if (stat.checkParentPathsSync(src, srcStat, dest, "copy"), opts.filter && !opts.filter(src, dest)) return;
      let destParent = path8.dirname(dest);
      return fs5.existsSync(destParent) || mkdirsSync2(destParent), getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      let srcStat = (opts.dereference ? fs5.statSync : fs5.lstatSync)(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      throw srcStat.isSocket() ? new Error(`Cannot copy a socket file: ${src}`) : srcStat.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${src}`) : new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      return destStat ? mayCopyFile(srcStat, src, dest, opts) : copyFile2(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite)
        return fs5.unlinkSync(dest), copyFile2(srcStat, src, dest, opts);
      if (opts.errorOnExist)
        throw new Error(`'${dest}' already exists`);
    }
    function copyFile2(srcStat, src, dest, opts) {
      return fs5.copyFileSync(src, dest), opts.preserveTimestamps && handleTimestamps(srcStat.mode, src, dest), setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      return fileIsNotWritable(srcMode) && makeFileWritable(dest, srcMode), setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs5.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      let updatedSrcStat = fs5.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      return destStat ? copyDir(src, dest, opts) : mkDirAndCopy(srcStat.mode, src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      return fs5.mkdirSync(dest), copyDir(src, dest, opts), setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs5.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      let srcItem = path8.join(src, item), destItem = path8.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      let { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs5.readlinkSync(src);
      if (opts.dereference && (resolvedSrc = path8.resolve(process.cwd(), resolvedSrc)), destStat) {
        let resolvedDest;
        try {
          resolvedDest = fs5.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs5.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference && (resolvedDest = path8.resolve(process.cwd(), resolvedDest)), stat.isSrcSubdir(resolvedSrc, resolvedDest))
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc))
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        return copyLink(resolvedSrc, dest);
      } else
        return fs5.symlinkSync(resolvedSrc, dest);
    }
    function copyLink(resolvedSrc, dest) {
      return fs5.unlinkSync(dest), fs5.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback;
    module.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs(), u = require_universalify().fromCallback;
    function remove2(path8, callback) {
      fs5.rm(path8, { recursive: !0, force: !0 }, callback);
    }
    function removeSync2(path8) {
      fs5.rmSync(path8, { recursive: !0, force: !0 });
    }
    module.exports = {
      remove: u(remove2),
      removeSync: removeSync2
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromPromise, fs5 = require_fs(), path8 = __require("path"), mkdir2 = require_mkdirs(), remove2 = require_remove(), emptyDir2 = u(async function(dir) {
      let items;
      try {
        items = await fs5.readdir(dir);
      } catch {
        return mkdir2.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove2.remove(path8.join(dir, item))));
    });
    function emptyDirSync2(dir) {
      let items;
      try {
        items = fs5.readdirSync(dir);
      } catch {
        return mkdir2.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path8.join(dir, item), remove2.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync: emptyDirSync2,
      emptydirSync: emptyDirSync2,
      emptyDir: emptyDir2,
      emptydir: emptyDir2
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback, path8 = __require("path"), fs5 = require_graceful_fs(), mkdir2 = require_mkdirs();
    function createFile2(file, callback) {
      function makeFile() {
        fs5.writeFile(file, "", (err) => {
          if (err) return callback(err);
          callback();
        });
      }
      fs5.stat(file, (err, stats) => {
        if (!err && stats.isFile()) return callback();
        let dir = path8.dirname(file);
        fs5.stat(dir, (err2, stats2) => {
          if (err2)
            return err2.code === "ENOENT" ? mkdir2.mkdirs(dir, (err3) => {
              if (err3) return callback(err3);
              makeFile();
            }) : callback(err2);
          stats2.isDirectory() ? makeFile() : fs5.readdir(dir, (err3) => {
            if (err3) return callback(err3);
          });
        });
      });
    }
    function createFileSync2(file) {
      let stats;
      try {
        stats = fs5.statSync(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      let dir = path8.dirname(file);
      try {
        fs5.statSync(dir).isDirectory() || fs5.readdirSync(dir);
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir2.mkdirsSync(dir);
        else throw err;
      }
      fs5.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u(createFile2),
      createFileSync: createFileSync2
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback, path8 = __require("path"), fs5 = require_graceful_fs(), mkdir2 = require_mkdirs(), pathExists3 = require_path_exists().pathExists, { areIdentical } = require_stat();
    function createLink2(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs5.link(srcpath2, dstpath2, (err) => {
          if (err) return callback(err);
          callback(null);
        });
      }
      fs5.lstat(dstpath, (_2, dstStat) => {
        fs5.lstat(srcpath, (err, srcStat) => {
          if (err)
            return err.message = err.message.replace("lstat", "ensureLink"), callback(err);
          if (dstStat && areIdentical(srcStat, dstStat)) return callback(null);
          let dir = path8.dirname(dstpath);
          pathExists3(dir, (err2, dirExists) => {
            if (err2) return callback(err2);
            if (dirExists) return makeLink(srcpath, dstpath);
            mkdir2.mkdirs(dir, (err3) => {
              if (err3) return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync2(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs5.lstatSync(dstpath);
      } catch {
      }
      try {
        let srcStat = fs5.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        throw err.message = err.message.replace("lstat", "ensureLink"), err;
      }
      let dir = path8.dirname(dstpath);
      return fs5.existsSync(dir) || mkdir2.mkdirsSync(dir), fs5.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink2),
      createLinkSync: createLinkSync2
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path8 = __require("path"), fs5 = require_graceful_fs(), pathExists3 = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path8.isAbsolute(srcpath))
        return fs5.lstat(srcpath, (err) => err ? (err.message = err.message.replace("lstat", "ensureSymlink"), callback(err)) : callback(null, {
          toCwd: srcpath,
          toDst: srcpath
        }));
      {
        let dstdir = path8.dirname(dstpath), relativeToDst = path8.join(dstdir, srcpath);
        return pathExists3(relativeToDst, (err, exists) => err ? callback(err) : exists ? callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        }) : fs5.lstat(srcpath, (err2) => err2 ? (err2.message = err2.message.replace("lstat", "ensureSymlink"), callback(err2)) : callback(null, {
          toCwd: srcpath,
          toDst: path8.relative(dstdir, srcpath)
        })));
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path8.isAbsolute(srcpath)) {
        if (exists = fs5.existsSync(srcpath), !exists) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        let dstdir = path8.dirname(dstpath), relativeToDst = path8.join(dstdir, srcpath);
        if (exists = fs5.existsSync(relativeToDst), exists)
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        if (exists = fs5.existsSync(srcpath), !exists) throw new Error("relative srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: path8.relative(dstdir, srcpath)
        };
      }
    }
    module.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      if (callback = typeof type == "function" ? type : callback, type = typeof type == "function" ? !1 : type, type) return callback(null, type);
      fs5.lstat(srcpath, (err, stats) => {
        if (err) return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file", callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type) return type;
      try {
        stats = fs5.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback, path8 = __require("path"), fs5 = require_fs(), _mkdirs2 = require_mkdirs(), mkdirs2 = _mkdirs2.mkdirs, mkdirsSync2 = _mkdirs2.mkdirsSync, _symlinkPaths = require_symlink_paths(), symlinkPaths = _symlinkPaths.symlinkPaths, symlinkPathsSync = _symlinkPaths.symlinkPathsSync, _symlinkType = require_symlink_type(), symlinkType = _symlinkType.symlinkType, symlinkTypeSync = _symlinkType.symlinkTypeSync, pathExists3 = require_path_exists().pathExists, { areIdentical } = require_stat();
    function createSymlink2(srcpath, dstpath, type, callback) {
      callback = typeof type == "function" ? type : callback, type = typeof type == "function" ? !1 : type, fs5.lstat(dstpath, (err, stats) => {
        !err && stats.isSymbolicLink() ? Promise.all([
          fs5.stat(srcpath),
          fs5.stat(dstpath)
        ]).then(([srcStat, dstStat]) => {
          if (areIdentical(srcStat, dstStat)) return callback(null);
          _createSymlink(srcpath, dstpath, type, callback);
        }) : _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err) return callback(err);
        srcpath = relative.toDst, symlinkType(relative.toCwd, type, (err2, type2) => {
          if (err2) return callback(err2);
          let dir = path8.dirname(dstpath);
          pathExists3(dir, (err3, dirExists) => {
            if (err3) return callback(err3);
            if (dirExists) return fs5.symlink(srcpath, dstpath, type2, callback);
            mkdirs2(dir, (err4) => {
              if (err4) return callback(err4);
              fs5.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync2(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs5.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        let srcStat = fs5.statSync(srcpath), dstStat = fs5.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      let relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst, type = symlinkTypeSync(relative.toCwd, type);
      let dir = path8.dirname(dstpath);
      return fs5.existsSync(dir) || mkdirsSync2(dir), fs5.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink2),
      createSymlinkSync: createSymlinkSync2
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { createFile: createFile2, createFileSync: createFileSync2 } = require_file(), { createLink: createLink2, createLinkSync: createLinkSync2 } = require_link(), { createSymlink: createSymlink2, createSymlinkSync: createSymlinkSync2 } = require_symlink();
    module.exports = {
      // file
      createFile: createFile2,
      createFileSync: createFileSync2,
      ensureFile: createFile2,
      ensureFileSync: createFileSync2,
      // link
      createLink: createLink2,
      createLinkSync: createLinkSync2,
      ensureLink: createLink2,
      ensureLinkSync: createLinkSync2,
      // symlink
      createSymlink: createSymlink2,
      createSymlinkSync: createSymlinkSync2,
      ensureSymlink: createSymlink2,
      ensureSymlinkSync: createSymlinkSync2
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports, module) {
    init_cjs_shims();
    function stringify(obj, { EOL = `
`, finalEOL = !0, replacer = null, spaces } = {}) {
      let EOF = finalEOL ? EOL : "";
      return JSON.stringify(obj, replacer, spaces).replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      return Buffer.isBuffer(content) && (content = content.toString("utf8")), content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports, module) {
    init_cjs_shims();
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch {
      _fs = __require("fs");
    }
    var universalify = require_universalify(), { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      typeof options == "string" && (options = { encoding: options });
      let fs5 = options.fs || _fs, shouldThrow = "throws" in options ? options.throws : !0, data = await universalify.fromCallback(fs5.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow)
          throw err.message = `${file}: ${err.message}`, err;
        return null;
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync4(file, options = {}) {
      typeof options == "string" && (options = { encoding: options });
      let fs5 = options.fs || _fs, shouldThrow = "throws" in options ? options.throws : !0;
      try {
        let content = fs5.readFileSync(file, options);
        return content = stripBom(content), JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow)
          throw err.message = `${file}: ${err.message}`, err;
        return null;
      }
    }
    async function _writeFile(file, obj, options = {}) {
      let fs5 = options.fs || _fs, str = stringify(obj, options);
      await universalify.fromCallback(fs5.writeFile)(file, str, options);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      let fs5 = options.fs || _fs, str = stringify(obj, options);
      return fs5.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync: readFileSync4,
      writeFile: writeFile2,
      writeFileSync: writeFileSync2
    };
    module.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/output-file/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback, fs5 = require_graceful_fs(), path8 = __require("path"), mkdir2 = require_mkdirs(), pathExists3 = require_path_exists().pathExists;
    function outputFile2(file, data, encoding, callback) {
      typeof encoding == "function" && (callback = encoding, encoding = "utf8");
      let dir = path8.dirname(file);
      pathExists3(dir, (err, itDoes) => {
        if (err) return callback(err);
        if (itDoes) return fs5.writeFile(file, data, encoding, callback);
        mkdir2.mkdirs(dir, (err2) => {
          if (err2) return callback(err2);
          fs5.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync2(file, ...args) {
      let dir = path8.dirname(file);
      if (fs5.existsSync(dir))
        return fs5.writeFileSync(file, ...args);
      mkdir2.mkdirsSync(dir), fs5.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u(outputFile2),
      outputFileSync: outputFileSync2
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { stringify } = require_utils2(), { outputFile: outputFile2 } = require_output_file();
    async function outputJson2(file, data, options = {}) {
      let str = stringify(data, options);
      await outputFile2(file, str, options);
    }
    module.exports = outputJson2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { stringify } = require_utils2(), { outputFileSync: outputFileSync2 } = require_output_file();
    function outputJsonSync2(file, data, options) {
      let str = stringify(data, options);
      outputFileSync2(file, str, options);
    }
    module.exports = outputJsonSync2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromPromise, jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/move/move.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs(), path8 = __require("path"), copy2 = require_copy2().copy, remove2 = require_remove().remove, mkdirp2 = require_mkdirs().mkdirp, pathExists3 = require_path_exists().pathExists, stat = require_stat();
    function move2(src, dest, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), opts = opts || {};
      let overwrite = opts.overwrite || opts.clobber || !1;
      stat.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err) return cb(err);
        let { srcStat, isChangingCase = !1 } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2) return cb(err2);
          if (isParentRoot(dest)) return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp2(path8.dirname(dest), (err3) => err3 ? cb(err3) : doRename(src, dest, overwrite, isChangingCase, cb));
        });
      });
    }
    function isParentRoot(dest) {
      let parent = path8.dirname(dest);
      return path8.parse(parent).root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase) return rename(src, dest, overwrite, cb);
      if (overwrite)
        return remove2(dest, (err) => err ? cb(err) : rename(src, dest, overwrite, cb));
      pathExists3(dest, (err, destExists) => err ? cb(err) : destExists ? cb(new Error("dest already exists.")) : rename(src, dest, overwrite, cb));
    }
    function rename(src, dest, overwrite, cb) {
      fs5.rename(src, dest, (err) => err ? err.code !== "EXDEV" ? cb(err) : moveAcrossDevice(src, dest, overwrite, cb) : cb());
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      copy2(src, dest, {
        overwrite,
        errorOnExist: !0
      }, (err) => err ? cb(err) : remove2(src, cb));
    }
    module.exports = move2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/move/move-sync.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = require_graceful_fs(), path8 = __require("path"), copySync2 = require_copy2().copySync, removeSync2 = require_remove().removeSync, mkdirpSync2 = require_mkdirs().mkdirpSync, stat = require_stat();
    function moveSync2(src, dest, opts) {
      opts = opts || {};
      let overwrite = opts.overwrite || opts.clobber || !1, { srcStat, isChangingCase = !1 } = stat.checkPathsSync(src, dest, "move", opts);
      return stat.checkParentPathsSync(src, srcStat, dest, "move"), isParentRoot(dest) || mkdirpSync2(path8.dirname(dest)), doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      let parent = path8.dirname(dest);
      return path8.parse(parent).root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename(src, dest, overwrite);
      if (overwrite)
        return removeSync2(dest), rename(src, dest, overwrite);
      if (fs5.existsSync(dest)) throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs5.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      return copySync2(src, dest, {
        overwrite,
        errorOnExist: !0
      }), removeSync2(src);
    }
    module.exports = moveSync2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var u = require_universalify().fromCallback;
    module.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
var require_windows = __commonJS({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports, module) {
    init_cjs_shims();
    module.exports = isexe;
    isexe.sync = sync;
    var fs5 = __require("fs");
    function checkPathExt(path8, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext || (pathext = pathext.split(";"), pathext.indexOf("") !== -1))
        return !0;
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path8.substr(-p.length).toLowerCase() === p)
          return !0;
      }
      return !1;
    }
    function checkStat(stat, path8, options) {
      return !stat.isSymbolicLink() && !stat.isFile() ? !1 : checkPathExt(path8, options);
    }
    function isexe(path8, options, cb) {
      fs5.stat(path8, function(er, stat) {
        cb(er, er ? !1 : checkStat(stat, path8, options));
      });
    }
    function sync(path8, options) {
      return checkStat(fs5.statSync(path8), path8, options);
    }
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
var require_mode = __commonJS({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports, module) {
    init_cjs_shims();
    module.exports = isexe;
    isexe.sync = sync;
    var fs5 = __require("fs");
    function isexe(path8, options, cb) {
      fs5.stat(path8, function(er, stat) {
        cb(er, er ? !1 : checkStat(stat, options));
      });
    }
    function sync(path8, options) {
      return checkStat(fs5.statSync(path8), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode, uid = stat.uid, gid = stat.gid, myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid(), myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid(), u = parseInt("100", 8), g = parseInt("010", 8), o = parseInt("001", 8), ug = u | g, ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
var require_isexe = __commonJS({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports, module) {
    init_cjs_shims();
    var fs5 = __require("fs"), core;
    process.platform === "win32" || global.TESTING_WINDOWS ? core = require_windows() : core = require_mode();
    module.exports = isexe;
    isexe.sync = sync;
    function isexe(path8, options, cb) {
      if (typeof options == "function" && (cb = options, options = {}), !cb) {
        if (typeof Promise != "function")
          throw new TypeError("callback not provided");
        return new Promise(function(resolve, reject) {
          isexe(path8, options || {}, function(er, is) {
            er ? reject(er) : resolve(is);
          });
        });
      }
      core(path8, options || {}, function(er, is) {
        er && (er.code === "EACCES" || options && options.ignoreErrors) && (er = null, is = !1), cb(er, is);
      });
    }
    function sync(path8, options) {
      try {
        return core.sync(path8, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES")
          return !1;
        throw er;
      }
    }
  }
});

// ../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports, module) {
    init_cjs_shims();
    var isWindows2 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path8 = __require("path"), COLON = isWindows2 ? ";" : ":", isexe = require_isexe(), getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" }), getPathInfo = (cmd, opt) => {
      let colon = opt.colon || COLON, pathEnv = cmd.match(/\//) || isWindows2 && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows2 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ], pathExtExe = isWindows2 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "", pathExt = isWindows2 ? pathExtExe.split(colon) : [""];
      return isWindows2 && cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift(""), {
        pathEnv,
        pathExt,
        pathExtExe
      };
    }, which3 = (cmd, opt, cb) => {
      typeof opt == "function" && (cb = opt, opt = {}), opt || (opt = {});
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [], step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        let ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path8.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      }), subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        let ext2 = pathExt[ii];
        isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is)
            if (opt.all)
              found.push(p + ext2);
            else
              return resolve(p + ext2);
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    }, whichSync = (cmd, opt) => {
      opt = opt || {};
      let { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt), found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        let ppRaw = pathEnv[i], pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw, pCmd = path8.join(pathPart, cmd), p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          let cur = p + pathExt[j];
          try {
            if (isexe.sync(cur, { pathExt: pathExtExe }))
              if (opt.all)
                found.push(cur);
              else
                return cur;
          } catch {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module.exports = which3;
    which3.sync = whichSync;
  }
});

// ../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var pathKey2 = (options = {}) => {
      let environment = options.env || process.env;
      return (options.platform || process.platform) !== "win32" ? "PATH" : Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module.exports = pathKey2;
    module.exports.default = pathKey2;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path8 = __require("path"), which3 = require_which(), getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      let env3 = parsed.options.env || process.env, cwd3 = process.cwd(), hasCustomCwd = parsed.options.cwd != null, shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd)
        try {
          process.chdir(parsed.options.cwd);
        } catch {
        }
      let resolved;
      try {
        resolved = which3.sync(parsed.command, {
          path: env3[getPathKey({ env: env3 })],
          pathExt: withoutPathExt ? path8.delimiter : void 0
        });
      } catch {
      } finally {
        shouldSwitchCwd && process.chdir(cwd3);
      }
      return resolved && (resolved = path8.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved)), resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, !0);
    }
    module.exports = resolveCommand;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      return arg = arg.replace(metaCharsRegExp, "^$1"), arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      return arg = `${arg}`, arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"'), arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1"), arg = `"${arg}"`, arg = arg.replace(metaCharsRegExp, "^$1"), doubleEscapeMetaChars && (arg = arg.replace(metaCharsRegExp, "^$1")), arg;
    }
    module.exports.command = escapeCommand;
    module.exports.argument = escapeArgument;
  }
});

// ../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = /^#!(.*)/;
  }
});

// ../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var shebangRegex = require_shebang_regex();
    module.exports = (string = "") => {
      let match2 = string.match(shebangRegex);
      if (!match2)
        return null;
      let [path8, argument] = match2[0].replace(/#! ?/, "").split(" "), binary = path8.split("/").pop();
      return binary === "env" ? argument : argument ? `${binary} ${argument}` : binary;
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs5 = __require("fs"), shebangCommand = require_shebang_command();
    function readShebang(command) {
      let buffer = Buffer.alloc(150), fd;
      try {
        fd = fs5.openSync(command, "r"), fs5.readSync(fd, buffer, 0, 150, 0), fs5.closeSync(fd);
      } catch {
      }
      return shebangCommand(buffer.toString());
    }
    module.exports = readShebang;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path8 = __require("path"), resolveCommand = require_resolveCommand(), escape3 = require_escape(), readShebang = require_readShebang(), isWin = process.platform === "win32", isExecutableRegExp = /\.(?:com|exe)$/i, isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      let shebang = parsed.file && readShebang(parsed.file);
      return shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, resolveCommand(parsed)) : parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin)
        return parsed;
      let commandFile = detectShebang(parsed), needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        let needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path8.normalize(parsed.command), parsed.command = escape3.command(parsed.command), parsed.args = parsed.args.map((arg) => escape3.argument(arg, needsDoubleEscapeMetaChars));
        let shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0;
      }
      return parsed;
    }
    function parse(command, args, options) {
      args && !Array.isArray(args) && (options = args, args = null), args = args ? args.slice(0) : [], options = Object.assign({}, options);
      let parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module.exports = parse;
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin)
        return;
      let originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          let err = verifyENOENT(arg1, parsed);
          if (err)
            return originalEmit.call(cp, "error", err);
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
    }
    function verifyENOENTSync(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawnSync") : null;
    }
    module.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var cp = __require("child_process"), parse = require_parse(), enoent = require_enoent();
    function spawn2(command, args, options) {
      let parsed = parse(command, args, options), spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      return enoent.hookChildProcess(spawned, parsed), spawned;
    }
    function spawnSync(command, args, options) {
      let parsed = parse(command, args, options), result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      return result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
    }
    module.exports = spawn2;
    module.exports.spawn = spawn2;
    module.exports.sync = spawnSync;
    module.exports._parse = parse;
    module.exports._enoent = enoent;
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports, module) {
    init_cjs_shims();
    module.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    process.platform !== "win32" && module.exports.push(
      "SIGVTALRM",
      "SIGXCPU",
      "SIGXFSZ",
      "SIGUSR2",
      "SIGTRAP",
      "SIGSYS",
      "SIGQUIT",
      "SIGIOT"
      // should detect profiler and enable/disable accordingly.
      // see #21
      // 'SIGPROF'
    );
    process.platform === "linux" && module.exports.push(
      "SIGIO",
      "SIGPOLL",
      "SIGPWR",
      "SIGSTKFLT",
      "SIGUNUSED"
    );
  }
});

// ../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports, module) {
    init_cjs_shims();
    var process21 = global.process, processOk = function(process22) {
      return process22 && typeof process22 == "object" && typeof process22.removeListener == "function" && typeof process22.emit == "function" && typeof process22.reallyExit == "function" && typeof process22.listeners == "function" && typeof process22.kill == "function" && typeof process22.pid == "number" && typeof process22.on == "function";
    };
    processOk(process21) ? (assert = __require("assert"), signals = require_signals(), isWin = /^win/i.test(process21.platform), EE = __require("events"), typeof EE != "function" && (EE = EE.EventEmitter), process21.__signal_exit_emitter__ ? emitter = process21.__signal_exit_emitter__ : (emitter = process21.__signal_exit_emitter__ = new EE(), emitter.count = 0, emitter.emitted = {}), emitter.infinite || (emitter.setMaxListeners(1 / 0), emitter.infinite = !0), module.exports = function(cb, opts) {
      if (!processOk(global.process))
        return function() {
        };
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler"), loaded === !1 && load();
      var ev = "exit";
      opts && opts.alwaysLast && (ev = "afterexit");
      var remove2 = function() {
        emitter.removeListener(ev, cb), emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0 && unload();
      };
      return emitter.on(ev, cb), remove2;
    }, unload = function() {
      !loaded || !processOk(global.process) || (loaded = !1, signals.forEach(function(sig) {
        try {
          process21.removeListener(sig, sigListeners[sig]);
        } catch {
        }
      }), process21.emit = originalProcessEmit, process21.reallyExit = originalProcessReallyExit, emitter.count -= 1);
    }, module.exports.unload = unload, emit = function(event, code, signal) {
      emitter.emitted[event] || (emitter.emitted[event] = !0, emitter.emit(event, code, signal));
    }, sigListeners = {}, signals.forEach(function(sig) {
      sigListeners[sig] = function() {
        if (processOk(global.process)) {
          var listeners = process21.listeners(sig);
          listeners.length === emitter.count && (unload(), emit("exit", null, sig), emit("afterexit", null, sig), isWin && sig === "SIGHUP" && (sig = "SIGINT"), process21.kill(process21.pid, sig));
        }
      };
    }), module.exports.signals = function() {
      return signals;
    }, loaded = !1, load = function() {
      loaded || !processOk(global.process) || (loaded = !0, emitter.count += 1, signals = signals.filter(function(sig) {
        try {
          return process21.on(sig, sigListeners[sig]), !0;
        } catch {
          return !1;
        }
      }), process21.emit = processEmit, process21.reallyExit = processReallyExit);
    }, module.exports.load = load, originalProcessReallyExit = process21.reallyExit, processReallyExit = function(code) {
      processOk(global.process) && (process21.exitCode = code || /* istanbul ignore next */
      0, emit("exit", process21.exitCode, null), emit("afterexit", process21.exitCode, null), originalProcessReallyExit.call(process21, process21.exitCode));
    }, originalProcessEmit = process21.emit, processEmit = function(ev, arg) {
      if (ev === "exit" && processOk(global.process)) {
        arg !== void 0 && (process21.exitCode = arg);
        var ret = originalProcessEmit.apply(this, arguments);
        return emit("exit", process21.exitCode, null), emit("afterexit", process21.exitCode, null), ret;
      } else
        return originalProcessEmit.apply(this, arguments);
    }) : module.exports = function() {
      return function() {
      };
    };
    var assert, signals, isWin, EE, emitter, unload, emit, sigListeners, loaded, load, originalProcessReallyExit, processReallyExit, originalProcessEmit, processEmit;
  }
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { PassThrough: PassThroughStream } = __require("stream");
    module.exports = (options) => {
      options = { ...options };
      let { array } = options, { encoding } = options, isBuffer = encoding === "buffer", objectMode = !1;
      array ? objectMode = !(encoding || isBuffer) : encoding = encoding || "utf8", isBuffer && (encoding = null);
      let stream2 = new PassThroughStream({ objectMode });
      encoding && stream2.setEncoding(encoding);
      let length = 0, chunks = [];
      return stream2.on("data", (chunk) => {
        chunks.push(chunk), objectMode ? length = chunks.length : length += chunk.length;
      }), stream2.getBufferedValue = () => array ? chunks : isBuffer ? Buffer.concat(chunks, length) : chunks.join(""), stream2.getBufferedLength = () => length, stream2;
    };
  }
});

// ../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { constants: BufferConstants } = __require("buffer"), stream2 = __require("stream"), { promisify: promisify3 } = __require("util"), bufferStream = require_buffer_stream(), streamPipelinePromisified = promisify3(stream2.pipeline), MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded"), this.name = "MaxBufferError";
      }
    };
    async function getStream2(inputStream, options) {
      if (!inputStream)
        throw new Error("Expected a stream");
      options = {
        maxBuffer: 1 / 0,
        ...options
      };
      let { maxBuffer } = options, stream3 = bufferStream(options);
      return await new Promise((resolve, reject) => {
        let rejectPromise = (error) => {
          error && stream3.getBufferedLength() <= BufferConstants.MAX_LENGTH && (error.bufferedData = stream3.getBufferedValue()), reject(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream3), resolve();
          } catch (error) {
            rejectPromise(error);
          }
        })(), stream3.on("data", () => {
          stream3.getBufferedLength() > maxBuffer && rejectPromise(new MaxBufferError());
        });
      }), stream3.getBufferedValue();
    }
    module.exports = getStream2;
    module.exports.buffer = (stream3, options) => getStream2(stream3, { ...options, encoding: "buffer" });
    module.exports.array = (stream3, options) => getStream2(stream3, { ...options, array: !0 });
    module.exports.MaxBufferError = MaxBufferError;
  }
});

// ../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
var require_merge_stream = __commonJS({
  "../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { PassThrough: PassThrough2 } = __require("stream");
    module.exports = function() {
      var sources = [], output2 = new PassThrough2({ objectMode: !0 });
      return output2.setMaxListeners(0), output2.add = add, output2.isEmpty = isEmpty, output2.on("unpipe", remove2), Array.prototype.slice.call(arguments).forEach(add), output2;
      function add(source) {
        return Array.isArray(source) ? (source.forEach(add), this) : (sources.push(source), source.once("end", remove2.bind(null, source)), source.once("error", output2.emit.bind(output2, "error")), source.pipe(output2, { end: !1 }), this);
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove2(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        }), !sources.length && output2.readable && output2.end();
      }
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/util.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var lib = {}, nextTick = process.nextTick || global.setImmediate || global.setTimeout;
    lib.nextTick = function(func) {
      nextTick(func);
    };
    lib.parallel = function(tasks, done) {
      var results = [], errs = [], length = 0, doneLength = 0;
      function doneIt(ix, err, result) {
        err ? errs[ix] = err : results[ix] = result, doneLength += 1, doneLength >= length && done((errs.length > 0, errs), results);
      }
      Object.keys(tasks).forEach(function(key) {
        length += 1;
        var task = tasks[key];
        lib.nextTick(function() {
          task(doneIt.bind(null, key), 1);
        });
      });
    };
    lib.promisify = function(func) {
      return new Promise(function(resolve, reject) {
        func(function(err, data) {
          if (err) {
            !err instanceof Error && (err = new Error(err)), reject(err);
            return;
          }
          resolve(data);
        });
      });
    };
    lib.iterate = function(args, func, callback) {
      var errors = [], f = function() {
        if (args.length === 0) {
          lib.nextTick(callback.bind(null, errors));
          return;
        }
        var arg = args.shift();
        if (typeof arg == "function") {
          arg(function(err, res) {
            if (err)
              errors.push(err);
            else
              for (; res.length > 0; )
                args.unshift(res.pop());
            f();
          });
          return;
        }
        func(arg, function(err, res) {
          err ? (errors.push(err), f()) : lib.nextTick(callback.bind(null, null, res));
        });
      };
      lib.nextTick(f);
    };
    module.exports = lib;
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getmacaddress_windows.js
var require_getmacaddress_windows = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getmacaddress_windows.js"(exports, module) {
    init_cjs_shims();
    var execFile = __require("child_process").execFile, regexRegex = /[-\/\\^$*+?.()|[\]{}]/g;
    function escape3(string) {
      return string.replace(regexRegex, "\\$&");
    }
    module.exports = function(iface, callback) {
      execFile("ipconfig", ["/all"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var match2 = new RegExp(escape3(iface)).exec(out);
        if (!match2) {
          callback("did not find interface in `ipconfig /all`", null);
          return;
        }
        if (out = out.substring(match2.index + iface.length), match2 = /[A-Fa-f0-9]{2}(\-[A-Fa-f0-9]{2}){5}/.exec(out), !match2) {
          callback("did not find a mac address", null);
          return;
        }
        callback(null, match2[0].toLowerCase().replace(/\-/g, ":"));
      });
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getmacaddress_linux.js
var require_getmacaddress_linux = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getmacaddress_linux.js"(exports, module) {
    init_cjs_shims();
    var execFile = __require("child_process").execFile;
    module.exports = function(iface, callback) {
      execFile("/bin/cat", ["/sys/class/net/" + iface + "/address"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        callback(null, out.trim().toLowerCase());
      });
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getmacaddress_unix.js
var require_getmacaddress_unix = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getmacaddress_unix.js"(exports, module) {
    init_cjs_shims();
    var execFile = __require("child_process").execFile;
    module.exports = function(iface, callback) {
      execFile("ifconfig", [iface], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        var match2 = /[a-f0-9]{2}(:[a-f0-9]{2}){5}/.exec(out.toLowerCase());
        if (!match2) {
          callback("did not find a mac address", null);
          return;
        }
        callback(null, match2[0].toLowerCase());
      });
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/getmacaddress.js
var require_getmacaddress = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/getmacaddress.js"(exports, module) {
    init_cjs_shims();
    var os5 = __require("os"), _getMacAddress, _validIfaceRegExp = "^[a-z0-9]+$";
    switch (os5.platform()) {
      case "win32":
        _validIfaceRegExp = "^[a-z0-9 -]+$", _getMacAddress = require_getmacaddress_windows();
        break;
      case "linux":
        _getMacAddress = require_getmacaddress_linux();
        break;
      case "darwin":
      case "sunos":
      case "freebsd":
        _getMacAddress = require_getmacaddress_unix();
        break;
      default:
        console.warn("node-macaddress: Unknown os.platform(), defaulting to 'unix'."), _getMacAddress = require_getmacaddress_unix();
        break;
    }
    var validIfaceRegExp = new RegExp(_validIfaceRegExp, "i");
    module.exports = function(iface, callback) {
      if (!validIfaceRegExp.test(iface)) {
        callback(new Error([
          "invalid iface: '",
          iface,
          "' (must conform to reg exp /",
          validIfaceRegExp,
          "/)"
        ].join("")), null);
        return;
      }
      _getMacAddress(iface, callback);
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getallinterfaces_windows.js
var require_getallinterfaces_windows = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getallinterfaces_windows.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var execFile = __require("child_process").execFile;
    module.exports = function(callback) {
      execFile("wmic", ["nic", "get", "NetConnectionID"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        for (var ifaces = out.trim().replace(/\s{2,}/g, `
`).split(`
`).slice(1), result = [], i = 0; i < ifaces.length; i += 1) {
          var iface = ifaces[i].trim();
          iface !== "" && result.push(iface);
        }
        callback(null, result);
      });
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getallinterfaces_linux.js
var require_getallinterfaces_linux = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getallinterfaces_linux.js"(exports, module) {
    init_cjs_shims();
    var execFile = __require("child_process").execFile;
    module.exports = function(callback) {
      execFile("/bin/ls", ["/sys/class/net"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        for (var ifaces = out.split(/[ \t\n]+/), result = [], i = 0; i < ifaces.length; i += 1) {
          var iface = ifaces[i].trim();
          iface !== "" && result.push(iface);
        }
        callback(null, result);
      });
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getallinterfaces_unix.js
var require_getallinterfaces_unix = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/platform/getallinterfaces_unix.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var execFile = __require("child_process").execFile;
    module.exports = function(callback) {
      execFile("/sbin/ifconfig", ["-l"], function(err, out) {
        if (err) {
          callback(err, null);
          return;
        }
        for (var ifaces = out.split(/[ \t]+/), result = [], i = 0; i < ifaces.length; i += 1) {
          var iface = ifaces[i].trim();
          iface !== "" && result.push(iface);
        }
        callback(null, result);
      });
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/getallinterfaces.js
var require_getallinterfaces = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/getallinterfaces.js"(exports, module) {
    init_cjs_shims();
    var os5 = __require("os"), _getAllInterfaces;
    switch (os5.platform()) {
      case "win32":
        _getAllInterfaces = require_getallinterfaces_windows();
        break;
      case "linux":
        _getAllInterfaces = require_getallinterfaces_linux();
        break;
      case "darwin":
      case "sunos":
      case "freebsd":
        _getAllInterfaces = require_getallinterfaces_unix();
        break;
      default:
        console.warn("node-macaddress: Unknown os.platform(), defaulting to 'unix'."), _getAllInterfaces = require_getallinterfaces_unix();
        break;
    }
    module.exports = _getAllInterfaces;
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/networkinterfaces.js
var require_networkinterfaces = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/lib/networkinterfaces.js"(exports, module) {
    init_cjs_shims();
    var os5 = __require("os");
    module.exports = function() {
      var allAddresses = {};
      try {
        var ifaces = os5.networkInterfaces();
      } catch (e) {
        if (e.syscall === "uv_interface_addresses")
          return allAddresses;
        throw e;
      }
      return Object.keys(ifaces).forEach(function(iface) {
        var addresses = {}, hasAddresses = !1;
        ifaces[iface].forEach(function(address) {
          if (!address.internal) {
            var family = typeof address.family == "number" ? "ipv" + address.family : (address.family || "").toLowerCase();
            addresses[family] = address.address, hasAddresses = !0, address.mac && address.mac !== "00:00:00:00:00:00" && (addresses.mac = address.mac);
          }
        }), hasAddresses && (allAddresses[iface] = addresses);
      }), allAddresses;
    };
  }
});

// ../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/index.js
var require_macaddress = __commonJS({
  "../../node_modules/.pnpm/macaddress@0.5.3/node_modules/macaddress/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var util = require_util(), lib = {};
    lib.getMacAddress = require_getmacaddress();
    lib.getAllInterfaces = require_getallinterfaces();
    lib.networkInterfaces = require_networkinterfaces();
    var goodIfaces = new RegExp("^((en|eth)[0-9]+|ethernet)$", "i"), badIfaces = new RegExp("^(vboxnet[0-9]+)$", "i");
    lib.one = function() {
      var iface = null, callback = null;
      if (arguments.length >= 1 && (typeof arguments[0] == "function" ? callback = arguments[0] : typeof arguments[0] == "string" && (iface = arguments[0]), arguments.length >= 2 && typeof arguments[1] == "function" && (callback = arguments[1])), !callback)
        return util.promisify(function(callback2) {
          lib.one(iface, callback2);
        });
      if (iface) {
        lib.getMacAddress(iface, callback);
        return;
      }
      var ifaces = lib.networkInterfaces(), addresses = {}, best = [], args = [];
      if (Object.keys(ifaces).forEach(function(name) {
        args.push(name);
        var score = 0, iface2 = ifaces[name];
        typeof iface2.mac == "string" && iface2.mac !== "00:00:00:00:00:00" && (addresses[name] = iface2.mac, iface2.ipv4 && (score += 1), iface2.ipv6 && (score += 1), goodIfaces.test(name) && (score += 2), badIfaces.test(name) && (score -= 3), best.push({
          name,
          score,
          mac: iface2.mac
        }));
      }), best.length > 0) {
        best.sort(function(left, right) {
          var comparison = right.score - left.score;
          return comparison !== 0 ? comparison : left.name < right.name ? -1 : left.name > right.name ? 1 : 0;
        }), util.nextTick(callback.bind(null, null, best[0].mac));
        return;
      }
      args.push(lib.getAllInterfaces);
      var getMacAddress = function(d, cb) {
        if (addresses[d]) {
          cb(null, addresses[d]);
          return;
        }
        lib.getMacAddress(d, cb);
      };
      util.iterate(args, getMacAddress, callback);
    };
    lib.all = function(callback) {
      if (typeof callback != "function")
        return util.promisify(lib.all);
      var ifaces = lib.networkInterfaces(), resolve = {};
      return Object.keys(ifaces).forEach(function(iface) {
        ifaces[iface].mac || (resolve[iface] = lib.getMacAddress.bind(null, iface));
      }), Object.keys(resolve).length === 0 ? (typeof callback == "function" && util.nextTick(callback.bind(null, null, ifaces)), ifaces) : (util.parallel(resolve, function(err, result) {
        Object.keys(result).forEach(function(iface) {
          ifaces[iface].mac = result[iface];
        }), typeof callback == "function" && callback(null, ifaces);
      }), null);
    };
    module.exports = lib;
  }
});

// ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var os5 = __require("os"), tty2 = __require("tty"), hasFlag2 = require_has_flag(), { env: env3 } = process, forceColor;
    hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never") ? forceColor = 0 : (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) && (forceColor = 1);
    "FORCE_COLOR" in env3 && (env3.FORCE_COLOR === "true" ? forceColor = 1 : env3.FORCE_COLOR === "false" ? forceColor = 0 : forceColor = env3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env3.FORCE_COLOR, 10), 3));
    function translateLevel2(level) {
      return level === 0 ? !1 : {
        level,
        hasBasic: !0,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor3(haveStream, streamIsTTY) {
      if (forceColor === 0)
        return 0;
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor"))
        return 3;
      if (hasFlag2("color=256"))
        return 2;
      if (haveStream && !streamIsTTY && forceColor === void 0)
        return 0;
      let min = forceColor || 0;
      if (env3.TERM === "dumb")
        return min;
      if (process.platform === "win32") {
        let osRelease = os5.release().split(".");
        return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in env3)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env3) || env3.CI_NAME === "codeship" ? 1 : min;
      if ("TEAMCITY_VERSION" in env3)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
      if (env3.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in env3) {
        let version = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env3.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(env3.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM) || "COLORTERM" in env3 ? 1 : min;
    }
    function getSupportLevel(stream2) {
      let level = supportsColor3(stream2, stream2 && stream2.isTTY);
      return translateLevel2(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel2(supportsColor3(!0, tty2.isatty(1))),
      stderr: translateLevel2(supportsColor3(!0, tty2.isatty(2)))
    };
  }
});

// ../../node_modules/.pnpm/supports-hyperlinks@3.1.0/node_modules/supports-hyperlinks/index.js
var require_supports_hyperlinks = __commonJS({
  "../../node_modules/.pnpm/supports-hyperlinks@3.1.0/node_modules/supports-hyperlinks/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var supportsColor3 = require_supports_color(), hasFlag2 = require_has_flag();
    function parseVersion(versionString) {
      if (/^\d{3,4}$/.test(versionString)) {
        let m = /(\d{1,2})(\d{2})/.exec(versionString) || [];
        return {
          major: 0,
          minor: parseInt(m[1], 10),
          patch: parseInt(m[2], 10)
        };
      }
      let versions = (versionString || "").split(".").map((n) => parseInt(n, 10));
      return {
        major: versions[0],
        minor: versions[1],
        patch: versions[2]
      };
    }
    function supportsHyperlink(stream2) {
      let {
        CI,
        FORCE_HYPERLINK,
        NETLIFY,
        TEAMCITY_VERSION,
        TERM_PROGRAM,
        TERM_PROGRAM_VERSION,
        VTE_VERSION
      } = process.env;
      if (FORCE_HYPERLINK)
        return !(FORCE_HYPERLINK.length > 0 && parseInt(FORCE_HYPERLINK, 10) === 0);
      if (hasFlag2("no-hyperlink") || hasFlag2("no-hyperlinks") || hasFlag2("hyperlink=false") || hasFlag2("hyperlink=never"))
        return !1;
      if (hasFlag2("hyperlink=true") || hasFlag2("hyperlink=always") || NETLIFY)
        return !0;
      if (!supportsColor3.supportsColor(stream2) || stream2 && !stream2.isTTY)
        return !1;
      if ("WT_SESSION" in process.env)
        return !0;
      if (process.platform === "win32" || CI || TEAMCITY_VERSION)
        return !1;
      if (TERM_PROGRAM) {
        let version = parseVersion(TERM_PROGRAM_VERSION || "");
        switch (TERM_PROGRAM) {
          case "iTerm.app":
            return version.major === 3 ? version.minor >= 1 : version.major > 3;
          case "WezTerm":
            return version.major >= 20200620;
          case "vscode":
            return version.major > 1 || version.major === 1 && version.minor >= 72;
        }
      }
      if (VTE_VERSION) {
        if (VTE_VERSION === "0.50.0")
          return !1;
        let version = parseVersion(VTE_VERSION);
        return version.major > 0 || version.minor >= 50;
      }
      return !1;
    }
    module.exports = {
      supportsHyperlink,
      stdout: supportsHyperlink(process.stdout),
      stderr: supportsHyperlink(process.stderr)
    };
  }
});

// ../../node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "../../node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    init_cjs_shims();
    var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
    function A(a) {
      return a === null || typeof a != "object" ? null : (a = z && a[z] || a["@@iterator"], typeof a == "function" ? a : null);
    }
    var B = { isMounted: function() {
      return !1;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C = Object.assign, D = {};
    function E2(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    E2.prototype.isReactComponent = {};
    E2.prototype.setState = function(a, b) {
      if (typeof a != "object" && typeof a != "function" && a != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E2.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E2.prototype;
    function G(a, b, e) {
      this.props = a, this.context = b, this.refs = D, this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E2.prototype);
    H.isPureReactComponent = !0;
    var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: !0, ref: !0, __self: !0, __source: !0 };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (b != null) for (d in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (g === 1) c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps) for (d in g = a.defaultProps, g) c[d] === void 0 && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return typeof a == "object" && a !== null && a.$$typeof === l;
    }
    function escape3(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return typeof a == "object" && a !== null && a.key != null ? escape3("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      (k === "undefined" || k === "boolean") && (a = null);
      var h = !1;
      if (a === null) h = !0;
      else switch (k) {
        case "string":
        case "number":
          h = !0;
          break;
        case "object":
          switch (a.$$typeof) {
            case l:
            case n:
              h = !0;
          }
      }
      if (h) return h = a, c = c(h), a = d === "" ? "." + Q(h, 0) : d, I(c) ? (e = "", a != null && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
        return a2;
      })) : c != null && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      if (h = 0, d = d === "" ? "." : d + ":", I(a)) for (var g = 0; g < a.length; g++) {
        k = a[g];
        var f = d + Q(k, g);
        h += R(k, b, e, f, c);
      }
      else if (f = A(a), typeof f == "function") for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if (k === "object") throw b = String(a), Error("Objects are not valid as a React child (found: " + (b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (a == null) return a;
      var d = [], c = 0;
      return R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      }), d;
    }
    function T(a) {
      if (a._status === -1) {
        var b = a._result;
        b = b(), b.then(function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 1, a._result = b2);
        }, function(b2) {
          (a._status === 0 || a._status === -1) && (a._status = 2, a._result = b2);
        }), a._status === -1 && (a._status = 0, a._result = b);
      }
      if (a._status === 1) return a._result.default;
      throw a._result;
    }
    var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    function X() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    exports.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      return S(a, function() {
        b++;
      }), b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E2;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.act = X;
    exports.cloneElement = function(a, b, e) {
      if (a == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (b != null) {
        if (b.ref !== void 0 && (k = b.ref, h = K.current), b.key !== void 0 && (c = "" + b.key), a.type && a.type.defaultProps) var g = a.type.defaultProps;
        for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (f === 1) d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function(a) {
      return a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a.Provider = { $$typeof: t, _context: a }, a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      return b.type = a, b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: b === void 0 ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = X;
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.3.1";
  }
});

// ../../node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "../../node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV !== "production" && function() {
      "use strict";
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var ReactVersion = "18.3.1", REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      var ReactCurrentDispatcher = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ReactCurrentBatchConfig = {
        transition: null
      }, ReactCurrentActQueue = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, ReactCurrentOwner = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ReactDebugCurrentFrame = {}, currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        currentExtraStackFrame = stack;
      }
      ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
        currentExtraStackFrame = stack;
      }, ReactDebugCurrentFrame.getCurrentStack = null, ReactDebugCurrentFrame.getStackAddendum = function() {
        var stack = "";
        currentExtraStackFrame && (stack += currentExtraStackFrame);
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        return impl && (stack += impl() || ""), stack;
      };
      var enableScopeAPI = !1, enableCacheElement = !1, enableTransitionTracing = !1, enableLegacyHidden = !1, enableDebugTracing = !1, ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame, ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      function warn(format) {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format, args);
        }
      }
      function error(format) {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format, args);
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor, componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass", warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey])
            return;
          error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName), didWarnStateUpdateForUnmountedComponent[warningKey] = !0;
        }
      }
      var ReactNoopUpdateQueue = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(publicInstance) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      function Component(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {}, Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState != "object" && typeof partialState != "function" && partialState != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      }, Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
            }
          });
        };
        for (var fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent2(props, context, updater) {
        this.props = props, this.context = context, this.refs = emptyObject, this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent2.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent2, assign(pureComponentPrototype, Component.prototype), pureComponentPrototype.isPureReactComponent = !0;
      function createRef() {
        var refObject = {
          current: null
        };
        return Object.seal(refObject), refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        if (willCoercionThrow(value))
          return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, RESERVED_PROPS = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      didWarnAboutStringRefs = {};
      function hasValidRef(config) {
        if (hasOwnProperty.call(config, "ref")) {
          var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config.ref !== void 0;
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning)
            return !1;
        }
        return config.key !== void 0;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingKey.isReactWarning = !0, Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: !0
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          specialPropRefWarningShown || (specialPropRefWarningShown = !0, error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName));
        };
        warnAboutAccessingRef.isReactWarning = !0, Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: !0
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        if (typeof config.ref == "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref), didWarnAboutStringRefs[componentName] = !0);
        }
      }
      var ReactElement = function(type, key, ref, self2, source, owner, props) {
        var element = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: REACT_ELEMENT_TYPE,
          // Built-in properties that belong on the element
          type,
          key,
          ref,
          props,
          // Record the component responsible for creating this element.
          _owner: owner
        };
        return element._store = {}, Object.defineProperty(element._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(element, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: self2
        }), Object.defineProperty(element, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: source
        }), Object.freeze && (Object.freeze(element.props), Object.freeze(element)), element;
      };
      function createElement(type, config, children) {
        var propName, props = {}, key = null, ref = null, self2 = null, source = null;
        if (config != null) {
          hasValidRef(config) && (ref = config.ref, warnIfStringRefCannotBeAutoConverted(config)), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), self2 = config.__self === void 0 ? null : config.__self, source = config.__source === void 0 ? null : config.__source;
          for (propName in config)
            hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (props[propName] = config[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          Object.freeze && Object.freeze(childArray), props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
        }
        if (key || ref) {
          var displayName = typeof type == "function" ? type.displayName || type.name || "Unknown" : type;
          key && defineKeyPropWarningGetter(props, displayName), ref && defineRefPropWarningGetter(props, displayName);
        }
        return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement2(element, config, children) {
        if (element == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        var propName, props = assign({}, element.props), key = element.key, ref = element.ref, self2 = element._self, source = element._source, owner = element._owner;
        if (config != null) {
          hasValidRef(config) && (ref = config.ref, owner = ReactCurrentOwner.current), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          var defaultProps;
          element.type && element.type.defaultProps && (defaultProps = element.type.defaultProps);
          for (propName in config)
            hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName) && (config[propName] === void 0 && defaultProps !== void 0 ? props[propName] = defaultProps[propName] : props[propName] = config[propName]);
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1)
          props.children = children;
        else if (childrenLength > 1) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self2, source, owner, props);
      }
      function isValidElement(object) {
        return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".", SUBSEPARATOR = ":";
      function escape3(key) {
        var escapeRegex = /[=:]/g, escaperLookup = {
          "=": "=0",
          ":": "=2"
        }, escapedString = key.replace(escapeRegex, function(match2) {
          return escaperLookup[match2];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = !1, userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        return typeof element == "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape3("" + element.key)) : index.toString(36);
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        (type === "undefined" || type === "boolean") && (children = null);
        var invokeCallback = !1;
        if (children === null)
          invokeCallback = !0;
        else
          switch (type) {
            case "string":
            case "number":
              invokeCallback = !0;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = !0;
              }
          }
        if (invokeCallback) {
          var _child = children, mappedChild = callback(_child), childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            childKey != null && (escapedChildKey = escapeUserProvidedKey(childKey) + "/"), mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
              return c;
            });
          } else mappedChild != null && (isValidElement(mappedChild) && (mappedChild.key && (!_child || _child.key !== mappedChild.key) && checkKeyStringCoercion(mappedChild.key), mappedChild = cloneAndReplaceKey(
            mappedChild,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              escapeUserProvidedKey("" + mappedChild.key) + "/"
            ) : "") + childKey
          )), array.push(mappedChild));
          return 1;
        }
        var child, nextName, subtreeCount = 0, nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children))
          for (var i = 0; i < children.length; i++)
            child = children[i], nextName = nextNamePrefix + getElementKey(child, i), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn == "function") {
            var iterableChildren = children;
            iteratorFn === iterableChildren.entries && (didWarnAboutMaps || warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            for (var iterator = iteratorFn.call(iterableChildren), step, ii = 0; !(step = iterator.next()).done; )
              child = step.value, nextName = nextNamePrefix + getElementKey(child, ii++), subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          } else if (type === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null)
          return children;
        var result = [], count = 0;
        return mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        }), result;
      }
      function countChildren(children) {
        var n = 0;
        return mapChildren(children, function() {
          n++;
        }), n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
      function createContext6(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = !1, hasWarnedAboutUsingConsumerProvider = !1, hasWarnedAboutDisplayNameOnConsumer = !1;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                return hasWarnedAboutUsingConsumerProvider || (hasWarnedAboutUsingConsumerProvider = !0, error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                return hasWarnedAboutUsingNestedContextConsumers || (hasWarnedAboutUsingNestedContextConsumers = !0, error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                hasWarnedAboutDisplayNameOnConsumer || (warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName), hasWarnedAboutDisplayNameOnConsumer = !0);
              }
            }
          }), context.Consumer = Consumer;
        }
        return context._currentRenderer = null, context._currentRenderer2 = null, context;
      }
      var Uninitialized = -1, Pending = 0, Resolved = 1, Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result, thenable = ctor();
          if (thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved, resolved._result = moduleObject2;
            }
          }, function(error2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected, rejected._result = error2;
            }
          }), payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending, pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          return moduleObject === void 0 && error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, moduleObject), "default" in moduleObject || error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, moduleObject), moduleObject.default;
        } else
          throw payload._result;
      }
      function lazy(ctor) {
        var payload = {
          // We use these fields to store the result.
          _status: Uninitialized,
          _result: ctor
        }, lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps, propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), defaultProps = newDefaultProps, Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), propTypes = newPropTypes, Object.defineProperty(lazyType, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef3(render3) {
        render3 != null && render3.$$typeof === REACT_MEMO_TYPE ? error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render3 != "function" ? error("forwardRef requires a render function but was given %s.", render3 === null ? "null" : typeof render3) : render3.length !== 0 && render3.length !== 2 && error("forwardRef render functions accept exactly two parameters: props and ref. %s", render3.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), render3 != null && (render3.defaultProps != null || render3.propTypes != null) && error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render: render3
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, !render3.name && !render3.displayName && (render3.displayName = name);
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      function isValidElementType(type) {
        return !!(typeof type == "string" || typeof type == "function" || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0));
      }
      function memo2(type, compare) {
        isValidElementType(type) || error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare === void 0 ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name, !type.name && !type.displayName && (type.displayName = name);
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        return dispatcher === null && error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), dispatcher;
      }
      function useContext9(Context) {
        var dispatcher = resolveDispatcher();
        if (Context._context !== void 0) {
          var realContext = Context._context;
          realContext.Consumer === Context ? error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : realContext.Provider === Context && error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return dispatcher.useContext(Context);
      }
      function useState15(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer2(reducer2, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer2, initialArg, init);
      }
      function useRef5(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect12(create2, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create2, deps);
      }
      function useInsertionEffect(create2, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create2, deps);
      }
      function useLayoutEffect6(create2, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create2, deps);
      }
      function useCallback10(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo5(create2, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create2, deps);
      }
      function useImperativeHandle(ref, create2, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create2, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match2 && match2[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher$1.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var loggedTypeFailures = {}, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          setExtraStackFrame(stack);
        } else
          setExtraStackFrame(null);
      }
      var propTypesMisspellWarningShown;
      propTypesMisspellWarningShown = !1;
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name)
            return `

Check the render method of \`` + name + "`.";
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== void 0) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, ""), lineNumber = source.lineNumber;
          return `

Check your code at ` + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        return elementProps != null ? getSourceInfoErrorAddendum(elementProps.__source) : "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType == "string" ? parentType : parentType.displayName || parentType.name;
          parentName && (info = `

Check the top-level render call using <` + parentName + ">.");
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!(!element._store || element._store.validated || element.key != null)) {
          element._store.validated = !0;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (!ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            ownerHasKeyUseWarning[currentComponentErrorInfo] = !0;
            var childOwner = "";
            element && element._owner && element._owner !== ReactCurrentOwner.current && (childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + "."), setCurrentlyValidatingElement$1(element), error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner), setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node == "object") {
          if (isArray(node))
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              isValidElement(child) && validateExplicitKey(child, parentType);
            }
          else if (isValidElement(node))
            node._store && (node._store.validated = !0);
          else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn == "function" && iteratorFn !== node.entries)
              for (var iterator = iteratorFn.call(node), step; !(step = iterator.next()).done; )
                isValidElement(step.value) && validateExplicitKey(step.value, parentType);
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type == null || typeof type == "string")
            return;
          var propTypes;
          if (typeof type == "function")
            propTypes = type.propTypes;
          else if (typeof type == "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          type.$$typeof === REACT_MEMO_TYPE))
            propTypes = type.propTypes;
          else
            return;
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = !0;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          typeof type.getDefaultProps == "function" && !type.getDefaultProps.isReactClassApproved && error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function validateFragmentProps(fragment) {
        {
          for (var keys = Object.keys(fragment.props), i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment), error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key), setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          fragment.ref !== null && (setCurrentlyValidatingElement$1(fragment), error("Invalid attribute `ref` supplied to `React.Fragment`."), setCurrentlyValidatingElement$1(null));
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          sourceInfo ? info += sourceInfo : info += getDeclarationErrorAddendum();
          var typeString;
          type === null ? typeString = "null" : isArray(type) ? typeString = "array" : type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", info = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type, error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
        }
        var element = createElement.apply(this, arguments);
        if (element == null)
          return element;
        if (validType)
          for (var i = 2; i < arguments.length; i++)
            validateChildKeys(arguments[i], type);
        return type === REACT_FRAGMENT_TYPE ? validateFragmentProps(element) : validatePropTypes(element), element;
      }
      var didWarnAboutDeprecatedCreateFactory = !1;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        return validatedFactory.type = type, didWarnAboutDeprecatedCreateFactory || (didWarnAboutDeprecatedCreateFactory = !0, warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(validatedFactory, "type", {
          enumerable: !1,
          get: function() {
            return warn("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: type
            }), type;
          }
        }), validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        for (var newElement = cloneElement2.apply(this, arguments), i = 2; i < arguments.length; i++)
          validateChildKeys(arguments[i], newElement.type);
        return validatePropTypes(newElement), newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          scope();
        } finally {
          if (ReactCurrentBatchConfig.transition = prevTransition, prevTransition === null && currentTransition._updatedFibers) {
            var updatedFibersCount = currentTransition._updatedFibers.size;
            updatedFibersCount > 10 && warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), currentTransition._updatedFibers.clear();
          }
        }
      }
      var didWarnAboutMessageChannel = !1, enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7), nodeRequire = module && module[requireString];
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
          } catch {
            enqueueTaskImpl = function(callback) {
              didWarnAboutMessageChannel === !1 && (didWarnAboutMessageChannel = !0, typeof MessageChannel > "u" && error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback, channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0, didWarnNoAwaitAct = !1;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++, ReactCurrentActQueue.current === null && (ReactCurrentActQueue.current = []);
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy, result;
          try {
            if (ReactCurrentActQueue.isBatchingLegacy = !0, result = callback(), !prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue = ReactCurrentActQueue.current;
              queue !== null && (ReactCurrentActQueue.didScheduleLegacyUpdate = !1, flushActQueue(queue));
            }
          } catch (error2) {
            throw popActScope(prevActScopeDepth), error2;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result !== null && typeof result == "object" && typeof result.then == "function") {
            var thenableResult = result, wasAwaited = !1, thenable = {
              then: function(resolve, reject) {
                wasAwaited = !0, thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth), actScopeDepth === 0 ? recursivelyFlushAsyncActWork(returnValue2, resolve, reject) : resolve(returnValue2);
                }, function(error2) {
                  popActScope(prevActScopeDepth), reject(error2);
                });
              }
            };
            return !didWarnNoAwaitAct && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              wasAwaited || (didWarnNoAwaitAct = !0, error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), thenable;
          } else {
            var returnValue = result;
            if (popActScope(prevActScopeDepth), actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              _queue !== null && (flushActQueue(_queue), ReactCurrentActQueue.current = null);
              var _thenable = {
                then: function(resolve, reject) {
                  ReactCurrentActQueue.current === null ? (ReactCurrentActQueue.current = [], recursivelyFlushAsyncActWork(returnValue, resolve, reject)) : resolve(returnValue);
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue = ReactCurrentActQueue.current;
          if (queue !== null)
            try {
              flushActQueue(queue), enqueueTask(function() {
                queue.length === 0 ? (ReactCurrentActQueue.current = null, resolve(returnValue)) : recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
            } catch (error2) {
              reject(error2);
            }
          else
            resolve(returnValue);
        }
      }
      var isFlushing = !1;
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = !0;
          var i = 0;
          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];
              do
                callback = callback(!0);
              while (callback !== null);
            }
            queue.length = 0;
          } catch (error2) {
            throw queue = queue.slice(i + 1), error2;
          } finally {
            isFlushing = !1;
          }
        }
      }
      var createElement$1 = createElementWithValidation, cloneElement$1 = cloneElementWithValidation, createFactory = createFactoryWithValidation, Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children, exports.Component = Component, exports.Fragment = REACT_FRAGMENT_TYPE, exports.Profiler = REACT_PROFILER_TYPE, exports.PureComponent = PureComponent2, exports.StrictMode = REACT_STRICT_MODE_TYPE, exports.Suspense = REACT_SUSPENSE_TYPE, exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals, exports.act = act, exports.cloneElement = cloneElement$1, exports.createContext = createContext6, exports.createElement = createElement$1, exports.createFactory = createFactory, exports.createRef = createRef, exports.forwardRef = forwardRef3, exports.isValidElement = isValidElement, exports.lazy = lazy, exports.memo = memo2, exports.startTransition = startTransition, exports.unstable_act = act, exports.useCallback = useCallback10, exports.useContext = useContext9, exports.useDebugValue = useDebugValue, exports.useDeferredValue = useDeferredValue, exports.useEffect = useEffect12, exports.useId = useId, exports.useImperativeHandle = useImperativeHandle, exports.useInsertionEffect = useInsertionEffect, exports.useLayoutEffect = useLayoutEffect6, exports.useMemo = useMemo5, exports.useReducer = useReducer2, exports.useRef = useRef5, exports.useState = useState15, exports.useSyncExternalStore = useSyncExternalStore, exports.useTransition = useTransition, exports.version = ReactVersion, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }
});

// ../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js
var require_react = __commonJS({
  "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV === "production" ? module.exports = require_react_production_min() : module.exports = require_react_development();
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js
var require_now = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js"(exports, module) {
    init_cjs_shims();
    var root = require_root(), now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    init_cjs_shims();
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); )
        ;
      return index;
    }
    module.exports = trimmedEndIndex;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports, module) {
    init_cjs_shims();
    var trimmedEndIndex = require_trimmedEndIndex(), reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string && string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "");
    }
    module.exports = baseTrim;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports, module) {
    init_cjs_shims();
    var baseTrim = require_baseTrim(), isObject = require_isObject(), isSymbol = require_isSymbol(), NAN = NaN, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number")
        return value;
      if (isSymbol(value))
        return NAN;
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string")
        return value === 0 ? value : +value;
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js"(exports, module) {
    init_cjs_shims();
    var isObject = require_isObject(), now = require_now(), toNumber = require_toNumber(), FUNC_ERROR_TEXT = "Expected a function", nativeMax = Math.max, nativeMin = Math.min;
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
      if (typeof func != "function")
        throw new TypeError(FUNC_ERROR_TEXT);
      wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing);
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args), result;
      }
      function leadingEdge(time) {
        return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time))
          return trailingEdge(time);
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result);
      }
      function cancel() {
        timerId !== void 0 && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
          if (timerId === void 0)
            return leadingEdge(lastCallTime);
          if (maxing)
            return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
        }
        return timerId === void 0 && (timerId = setTimeout(timerExpired, wait)), result;
      }
      return debounced.cancel = cancel, debounced.flush = flush, debounced;
    }
    module.exports = debounce2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js"(exports, module) {
    init_cjs_shims();
    var debounce2 = require_debounce(), isObject = require_isObject(), FUNC_ERROR_TEXT = "Expected a function";
    function throttle3(func, wait, options) {
      var leading = !0, trailing = !0;
      if (typeof func != "function")
        throw new TypeError(FUNC_ERROR_TEXT);
      return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce2(func, wait, {
        leading,
        maxWait: wait,
        trailing
      });
    }
    module.exports = throttle3;
  }
});

// ../../node_modules/.pnpm/ci-info@3.9.0/node_modules/ci-info/vendors.json
var require_vendors = __commonJS({
  "../../node_modules/.pnpm/ci-info@3.9.0/node_modules/ci-info/vendors.json"(exports, module) {
    module.exports = [
      {
        name: "Appcircle",
        constant: "APPCIRCLE",
        env: "AC_APPCIRCLE"
      },
      {
        name: "AppVeyor",
        constant: "APPVEYOR",
        env: "APPVEYOR",
        pr: "APPVEYOR_PULL_REQUEST_NUMBER"
      },
      {
        name: "AWS CodeBuild",
        constant: "CODEBUILD",
        env: "CODEBUILD_BUILD_ARN"
      },
      {
        name: "Azure Pipelines",
        constant: "AZURE_PIPELINES",
        env: "TF_BUILD",
        pr: {
          BUILD_REASON: "PullRequest"
        }
      },
      {
        name: "Bamboo",
        constant: "BAMBOO",
        env: "bamboo_planKey"
      },
      {
        name: "Bitbucket Pipelines",
        constant: "BITBUCKET",
        env: "BITBUCKET_COMMIT",
        pr: "BITBUCKET_PR_ID"
      },
      {
        name: "Bitrise",
        constant: "BITRISE",
        env: "BITRISE_IO",
        pr: "BITRISE_PULL_REQUEST"
      },
      {
        name: "Buddy",
        constant: "BUDDY",
        env: "BUDDY_WORKSPACE_ID",
        pr: "BUDDY_EXECUTION_PULL_REQUEST_ID"
      },
      {
        name: "Buildkite",
        constant: "BUILDKITE",
        env: "BUILDKITE",
        pr: {
          env: "BUILDKITE_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "CircleCI",
        constant: "CIRCLE",
        env: "CIRCLECI",
        pr: "CIRCLE_PULL_REQUEST"
      },
      {
        name: "Cirrus CI",
        constant: "CIRRUS",
        env: "CIRRUS_CI",
        pr: "CIRRUS_PR"
      },
      {
        name: "Codefresh",
        constant: "CODEFRESH",
        env: "CF_BUILD_ID",
        pr: {
          any: [
            "CF_PULL_REQUEST_NUMBER",
            "CF_PULL_REQUEST_ID"
          ]
        }
      },
      {
        name: "Codemagic",
        constant: "CODEMAGIC",
        env: "CM_BUILD_ID",
        pr: "CM_PULL_REQUEST"
      },
      {
        name: "Codeship",
        constant: "CODESHIP",
        env: {
          CI_NAME: "codeship"
        }
      },
      {
        name: "Drone",
        constant: "DRONE",
        env: "DRONE",
        pr: {
          DRONE_BUILD_EVENT: "pull_request"
        }
      },
      {
        name: "dsari",
        constant: "DSARI",
        env: "DSARI"
      },
      {
        name: "Expo Application Services",
        constant: "EAS",
        env: "EAS_BUILD"
      },
      {
        name: "Gerrit",
        constant: "GERRIT",
        env: "GERRIT_PROJECT"
      },
      {
        name: "GitHub Actions",
        constant: "GITHUB_ACTIONS",
        env: "GITHUB_ACTIONS",
        pr: {
          GITHUB_EVENT_NAME: "pull_request"
        }
      },
      {
        name: "GitLab CI",
        constant: "GITLAB",
        env: "GITLAB_CI",
        pr: "CI_MERGE_REQUEST_ID"
      },
      {
        name: "GoCD",
        constant: "GOCD",
        env: "GO_PIPELINE_LABEL"
      },
      {
        name: "Google Cloud Build",
        constant: "GOOGLE_CLOUD_BUILD",
        env: "BUILDER_OUTPUT"
      },
      {
        name: "Harness CI",
        constant: "HARNESS",
        env: "HARNESS_BUILD_ID"
      },
      {
        name: "Heroku",
        constant: "HEROKU",
        env: {
          env: "NODE",
          includes: "/app/.heroku/node/bin/node"
        }
      },
      {
        name: "Hudson",
        constant: "HUDSON",
        env: "HUDSON_URL"
      },
      {
        name: "Jenkins",
        constant: "JENKINS",
        env: [
          "JENKINS_URL",
          "BUILD_ID"
        ],
        pr: {
          any: [
            "ghprbPullId",
            "CHANGE_ID"
          ]
        }
      },
      {
        name: "LayerCI",
        constant: "LAYERCI",
        env: "LAYERCI",
        pr: "LAYERCI_PULL_REQUEST"
      },
      {
        name: "Magnum CI",
        constant: "MAGNUM",
        env: "MAGNUM"
      },
      {
        name: "Netlify CI",
        constant: "NETLIFY",
        env: "NETLIFY",
        pr: {
          env: "PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Nevercode",
        constant: "NEVERCODE",
        env: "NEVERCODE",
        pr: {
          env: "NEVERCODE_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "ReleaseHub",
        constant: "RELEASEHUB",
        env: "RELEASE_BUILD_ID"
      },
      {
        name: "Render",
        constant: "RENDER",
        env: "RENDER",
        pr: {
          IS_PULL_REQUEST: "true"
        }
      },
      {
        name: "Sail CI",
        constant: "SAIL",
        env: "SAILCI",
        pr: "SAIL_PULL_REQUEST_NUMBER"
      },
      {
        name: "Screwdriver",
        constant: "SCREWDRIVER",
        env: "SCREWDRIVER",
        pr: {
          env: "SD_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Semaphore",
        constant: "SEMAPHORE",
        env: "SEMAPHORE",
        pr: "PULL_REQUEST_NUMBER"
      },
      {
        name: "Shippable",
        constant: "SHIPPABLE",
        env: "SHIPPABLE",
        pr: {
          IS_PULL_REQUEST: "true"
        }
      },
      {
        name: "Solano CI",
        constant: "SOLANO",
        env: "TDDIUM",
        pr: "TDDIUM_PR_ID"
      },
      {
        name: "Sourcehut",
        constant: "SOURCEHUT",
        env: {
          CI_NAME: "sourcehut"
        }
      },
      {
        name: "Strider CD",
        constant: "STRIDER",
        env: "STRIDER"
      },
      {
        name: "TaskCluster",
        constant: "TASKCLUSTER",
        env: [
          "TASK_ID",
          "RUN_ID"
        ]
      },
      {
        name: "TeamCity",
        constant: "TEAMCITY",
        env: "TEAMCITY_VERSION"
      },
      {
        name: "Travis CI",
        constant: "TRAVIS",
        env: "TRAVIS",
        pr: {
          env: "TRAVIS_PULL_REQUEST",
          ne: "false"
        }
      },
      {
        name: "Vercel",
        constant: "VERCEL",
        env: {
          any: [
            "NOW_BUILDER",
            "VERCEL"
          ]
        },
        pr: "VERCEL_GIT_PULL_REQUEST_ID"
      },
      {
        name: "Visual Studio App Center",
        constant: "APPCENTER",
        env: "APPCENTER_BUILD_ID"
      },
      {
        name: "Woodpecker",
        constant: "WOODPECKER",
        env: {
          CI: "woodpecker"
        },
        pr: {
          CI_BUILD_EVENT: "pull_request"
        }
      },
      {
        name: "Xcode Cloud",
        constant: "XCODE_CLOUD",
        env: "CI_XCODE_PROJECT",
        pr: "CI_PULL_REQUEST_NUMBER"
      },
      {
        name: "Xcode Server",
        constant: "XCODE_SERVER",
        env: "XCS"
      }
    ];
  }
});

// ../../node_modules/.pnpm/ci-info@3.9.0/node_modules/ci-info/index.js
var require_ci_info = __commonJS({
  "../../node_modules/.pnpm/ci-info@3.9.0/node_modules/ci-info/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var vendors = require_vendors(), env3 = process.env;
    Object.defineProperty(exports, "_vendors", {
      value: vendors.map(function(v) {
        return v.constant;
      })
    });
    exports.name = null;
    exports.isPR = null;
    vendors.forEach(function(vendor) {
      let isCI2 = (Array.isArray(vendor.env) ? vendor.env : [vendor.env]).every(function(obj) {
        return checkEnv(obj);
      });
      if (exports[vendor.constant] = isCI2, !!isCI2)
        switch (exports.name = vendor.name, typeof vendor.pr) {
          case "string":
            exports.isPR = !!env3[vendor.pr];
            break;
          case "object":
            "env" in vendor.pr ? exports.isPR = vendor.pr.env in env3 && env3[vendor.pr.env] !== vendor.pr.ne : "any" in vendor.pr ? exports.isPR = vendor.pr.any.some(function(key) {
              return !!env3[key];
            }) : exports.isPR = checkEnv(vendor.pr);
            break;
          default:
            exports.isPR = null;
        }
    });
    exports.isCI = !!(env3.CI !== "false" && // Bypass all checks if CI env is explicitly set to 'false'
    (env3.BUILD_ID || // Jenkins, Cloudbees
    env3.BUILD_NUMBER || // Jenkins, TeamCity
    env3.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari
    env3.CI_APP_ID || // Appflow
    env3.CI_BUILD_ID || // Appflow
    env3.CI_BUILD_NUMBER || // Appflow
    env3.CI_NAME || // Codeship and others
    env3.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI
    env3.RUN_ID || // TaskCluster, dsari
    exports.name));
    function checkEnv(obj) {
      return typeof obj == "string" ? !!env3[obj] : "env" in obj ? env3[obj.env] && env3[obj.env].includes(obj.includes) : "any" in obj ? obj.any.some(function(k) {
        return !!env3[k];
      }) : Object.keys(obj).every(function(k) {
        return env3[k] === obj[k];
      });
    }
  }
});

// ../../node_modules/.pnpm/is-ci@3.0.1/node_modules/is-ci/index.js
var require_is_ci = __commonJS({
  "../../node_modules/.pnpm/is-ci@3.0.1/node_modules/is-ci/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = require_ci_info().isCI;
  }
});

// ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.production.min.js
var require_scheduler_production_min = __commonJS({
  "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
    "use strict";
    init_cjs_shims();
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h(a) {
      return a.length === 0 ? null : a[0];
    }
    function k(a) {
      if (a.length === 0) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
          var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
          else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return c !== 0 ? c : a.id - b.id;
    }
    typeof performance == "object" && typeof performance.now == "function" ? (l = performance, exports.unstable_now = function() {
      return l.now();
    }) : (p = Date, q = p.now(), exports.unstable_now = function() {
      return p.now() - q;
    });
    var l, p, q, r = [], t = [], u = 1, v = null, y = 3, z = !1, A = !1, B = !1, D = typeof setTimeout == "function" ? setTimeout : null, E2 = typeof clearTimeout == "function" ? clearTimeout : null, F = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); b !== null; ) {
        if (b.callback === null) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
        else break;
        b = h(t);
      }
    }
    function H(a) {
      if (B = !1, G(a), !A) if (h(r) !== null) A = !0, I(J);
      else {
        var b = h(t);
        b !== null && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = !1, B && (B = !1, E2(L), L = -1), z = !0;
      var c = y;
      try {
        for (G(b), v = h(r); v !== null && (!(v.expirationTime > b) || a && !M()); ) {
          var d = v.callback;
          if (typeof d == "function") {
            v.callback = null, y = v.priorityLevel;
            var e = d(v.expirationTime <= b);
            b = exports.unstable_now(), typeof e == "function" ? v.callback = e : v === h(r) && k(r), G(b);
          } else k(r);
          v = h(r);
        }
        if (v !== null) var w = !0;
        else {
          var m = h(t);
          m !== null && K(H, m.startTime - b), w = !1;
        }
        return w;
      } finally {
        v = null, y = c, z = !1;
      }
    }
    var N = !1, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return !(exports.unstable_now() - Q < P);
    }
    function R() {
      if (O !== null) {
        var a = exports.unstable_now();
        Q = a;
        var b = !0;
        try {
          b = O(!0, a);
        } finally {
          b ? S() : (N = !1, O = null);
        }
      } else N = !1;
    }
    var S;
    typeof F == "function" ? S = function() {
      F(R);
    } : typeof MessageChannel < "u" ? (T = new MessageChannel(), U = T.port2, T.port1.onmessage = R, S = function() {
      U.postMessage(null);
    }) : S = function() {
      D(R, 0);
    };
    var T, U;
    function I(a) {
      O = a, N || (N = !0, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = !0, I(J));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r);
    };
    exports.unstable_next = function(a) {
      switch (y) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y;
      }
      var c = y;
      y = b;
      try {
        return a();
      } finally {
        y = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y;
      y = a;
      try {
        return b();
      } finally {
        y = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      switch (typeof c == "object" && c !== null ? (c = c.delay, c = typeof c == "number" && 0 < c ? d + c : d) : c = d, a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      return e = c + e, a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 }, c > d ? (a.sortIndex = c, f(t, a), h(r) === null && a === h(t) && (B ? (E2(L), L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, I(J))), a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a) {
      var b = y;
      return function() {
        var c = y;
        y = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y = c;
        }
      };
    };
  }
});

// ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV !== "production" && function() {
      "use strict";
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var enableSchedulerDebugging = !1, enableProfiling = !1, frameYieldMs = 5;
      function push(heap, node) {
        var index = heap.length;
        heap.push(node), siftUp(heap, node, index);
      }
      function peek(heap) {
        return heap.length === 0 ? null : heap[0];
      }
      function pop(heap) {
        if (heap.length === 0)
          return null;
        var first = heap[0], last = heap.pop();
        return last !== first && (heap[0] = last, siftDown(heap, last, 0)), first;
      }
      function siftUp(heap, node, i) {
        for (var index = i; index > 0; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (compare(parent, node) > 0)
            heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
          else
            return;
        }
      }
      function siftDown(heap, node, i) {
        for (var index = i, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
          var leftIndex = (index + 1) * 2 - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (compare(left, node) < 0)
            rightIndex < length && compare(right, left) < 0 ? (heap[index] = right, heap[rightIndex] = node, index = rightIndex) : (heap[index] = left, heap[leftIndex] = node, index = leftIndex);
          else if (rightIndex < length && compare(right, node) < 0)
            heap[index] = right, heap[rightIndex] = node, index = rightIndex;
          else
            return;
        }
      }
      function compare(a, b) {
        var diff2 = a.sortIndex - b.sortIndex;
        return diff2 !== 0 ? diff2 : a.id - b.id;
      }
      var ImmediatePriority = 1, UserBlockingPriority = 2, NormalPriority = 3, LowPriority = 4, IdlePriority = 5;
      function markTaskErrored(task, ms) {
      }
      var hasPerformanceNow = typeof performance == "object" && typeof performance.now == "function";
      if (hasPerformanceNow) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var maxSigned31BitInt = 1073741823, IMMEDIATE_PRIORITY_TIMEOUT = -1, USER_BLOCKING_PRIORITY_TIMEOUT = 250, NORMAL_PRIORITY_TIMEOUT = 5e3, LOW_PRIORITY_TIMEOUT = 1e4, IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt, taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = NormalPriority, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, localSetTimeout = typeof setTimeout == "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout == "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate < "u" ? setImmediate : null, isInputPending = typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
      function advanceTimers(currentTime2) {
        for (var timer = peek(timerQueue); timer !== null; ) {
          if (timer.callback === null)
            pop(timerQueue);
          else if (timer.startTime <= currentTime2)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else
            return;
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime2) {
        if (isHostTimeoutScheduled = !1, advanceTimers(currentTime2), !isHostCallbackScheduled)
          if (peek(taskQueue) !== null)
            isHostCallbackScheduled = !0, requestHostCallback(flushWork);
          else {
            var firstTimer = peek(timerQueue);
            firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime2);
          }
      }
      function flushWork(hasTimeRemaining, initialTime2) {
        isHostCallbackScheduled = !1, isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, cancelHostTimeout()), isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          if (enableProfiling)
            try {
              return workLoop(hasTimeRemaining, initialTime2);
            } catch (error) {
              if (currentTask !== null) {
                var currentTime2 = exports.unstable_now();
                currentTask.isQueued = !1;
              }
              throw error;
            }
          else
            return workLoop(hasTimeRemaining, initialTime2);
        } finally {
          currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
        }
      }
      function workLoop(hasTimeRemaining, initialTime2) {
        var currentTime2 = initialTime2;
        for (advanceTimers(currentTime2), currentTask = peek(taskQueue); currentTask !== null && !enableSchedulerDebugging && !(currentTask.expirationTime > currentTime2 && (!hasTimeRemaining || shouldYieldToHost())); ) {
          var callback = currentTask.callback;
          if (typeof callback == "function") {
            currentTask.callback = null, currentPriorityLevel = currentTask.priorityLevel;
            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime2, continuationCallback = callback(didUserCallbackTimeout);
            currentTime2 = exports.unstable_now(), typeof continuationCallback == "function" ? currentTask.callback = continuationCallback : currentTask === peek(taskQueue) && pop(taskQueue), advanceTimers(currentTime2);
          } else
            pop(taskQueue);
          currentTask = peek(taskQueue);
        }
        if (currentTask !== null)
          return !0;
        var firstTimer = peek(timerQueue);
        return firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime2), !1;
      }
      function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
          case LowPriority:
          case IdlePriority:
            break;
          default:
            priorityLevel = NormalPriority;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_next(eventHandler) {
        var priorityLevel;
        switch (currentPriorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
            priorityLevel = NormalPriority;
            break;
          default:
            priorityLevel = currentPriorityLevel;
            break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      }
      function unstable_scheduleCallback(priorityLevel, callback, options) {
        var currentTime2 = exports.unstable_now(), startTime2;
        if (typeof options == "object" && options !== null) {
          var delay = options.delay;
          typeof delay == "number" && delay > 0 ? startTime2 = currentTime2 + delay : startTime2 = currentTime2;
        } else
          startTime2 = currentTime2;
        var timeout;
        switch (priorityLevel) {
          case ImmediatePriority:
            timeout = IMMEDIATE_PRIORITY_TIMEOUT;
            break;
          case UserBlockingPriority:
            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
            break;
          case IdlePriority:
            timeout = IDLE_PRIORITY_TIMEOUT;
            break;
          case LowPriority:
            timeout = LOW_PRIORITY_TIMEOUT;
            break;
          case NormalPriority:
          default:
            timeout = NORMAL_PRIORITY_TIMEOUT;
            break;
        }
        var expirationTime = startTime2 + timeout, newTask = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: startTime2,
          expirationTime,
          sortIndex: -1
        };
        return startTime2 > currentTime2 ? (newTask.sortIndex = startTime2, push(timerQueue, newTask), peek(taskQueue) === null && newTask === peek(timerQueue) && (isHostTimeoutScheduled ? cancelHostTimeout() : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, startTime2 - currentTime2))) : (newTask.sortIndex = expirationTime, push(taskQueue, newTask), !isHostCallbackScheduled && !isPerformingWork && (isHostCallbackScheduled = !0, requestHostCallback(flushWork))), newTask;
      }
      function unstable_pauseExecution() {
      }
      function unstable_continueExecution() {
        !isHostCallbackScheduled && !isPerformingWork && (isHostCallbackScheduled = !0, requestHostCallback(flushWork));
      }
      function unstable_getFirstCallbackNode() {
        return peek(taskQueue);
      }
      function unstable_cancelCallback(task) {
        task.callback = null;
      }
      function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
      }
      var isMessageLoopRunning = !1, scheduledHostCallback = null, taskTimeoutID = -1, frameInterval = frameYieldMs, startTime = -1;
      function shouldYieldToHost() {
        var timeElapsed = exports.unstable_now() - startTime;
        return !(timeElapsed < frameInterval);
      }
      function requestPaint() {
      }
      function forceFrameRate(fps) {
        if (fps < 0 || fps > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        fps > 0 ? frameInterval = Math.floor(1e3 / fps) : frameInterval = frameYieldMs;
      }
      var performWorkUntilDeadline = function() {
        if (scheduledHostCallback !== null) {
          var currentTime2 = exports.unstable_now();
          startTime = currentTime2;
          var hasTimeRemaining = !0, hasMoreWork = !0;
          try {
            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime2);
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : (isMessageLoopRunning = !1, scheduledHostCallback = null);
          }
        } else
          isMessageLoopRunning = !1;
      }, schedulePerformWorkUntilDeadline;
      if (typeof localSetImmediate == "function")
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if (typeof MessageChannel < "u") {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline, schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostCallback(callback) {
        scheduledHostCallback = callback, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      function cancelHostTimeout() {
        localClearTimeout(taskTimeoutID), taskTimeoutID = -1;
      }
      var unstable_requestPaint = requestPaint, unstable_Profiling = null;
      exports.unstable_IdlePriority = IdlePriority, exports.unstable_ImmediatePriority = ImmediatePriority, exports.unstable_LowPriority = LowPriority, exports.unstable_NormalPriority = NormalPriority, exports.unstable_Profiling = unstable_Profiling, exports.unstable_UserBlockingPriority = UserBlockingPriority, exports.unstable_cancelCallback = unstable_cancelCallback, exports.unstable_continueExecution = unstable_continueExecution, exports.unstable_forceFrameRate = forceFrameRate, exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel, exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode, exports.unstable_next = unstable_next, exports.unstable_pauseExecution = unstable_pauseExecution, exports.unstable_requestPaint = unstable_requestPaint, exports.unstable_runWithPriority = unstable_runWithPriority, exports.unstable_scheduleCallback = unstable_scheduleCallback, exports.unstable_shouldYield = shouldYieldToHost, exports.unstable_wrapCallback = unstable_wrapCallback, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }
});

// ../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../../node_modules/.pnpm/scheduler@0.23.2/node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV === "production" ? module.exports = require_scheduler_production_min() : module.exports = require_scheduler_development();
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler.production.min.js
var require_react_reconciler_production_min = __commonJS({
  "../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler.production.min.js"(exports, module) {
    init_cjs_shims();
    module.exports = function($$$hostConfig) {
      var exports2 = {}, aa = require_react(), ba = require_scheduler(), ca = Object.assign;
      function n(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ea = Symbol.for("react.element"), fa = Symbol.for("react.portal"), ha = Symbol.for("react.fragment"), ia = Symbol.for("react.strict_mode"), ja = Symbol.for("react.profiler"), ka = Symbol.for("react.provider"), la = Symbol.for("react.context"), ma = Symbol.for("react.forward_ref"), na = Symbol.for("react.suspense"), oa = Symbol.for("react.suspense_list"), pa = Symbol.for("react.memo"), qa = Symbol.for("react.lazy");
      Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
      var ra = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
      var sa = Symbol.iterator;
      function ta(a) {
        return a === null || typeof a != "object" ? null : (a = sa && a[sa] || a["@@iterator"], typeof a == "function" ? a : null);
      }
      function ua(a) {
        if (a == null) return null;
        if (typeof a == "function") return a.displayName || a.name || null;
        if (typeof a == "string") return a;
        switch (a) {
          case ha:
            return "Fragment";
          case fa:
            return "Portal";
          case ja:
            return "Profiler";
          case ia:
            return "StrictMode";
          case na:
            return "Suspense";
          case oa:
            return "SuspenseList";
        }
        if (typeof a == "object") switch (a.$$typeof) {
          case la:
            return (a.displayName || "Context") + ".Consumer";
          case ka:
            return (a._context.displayName || "Context") + ".Provider";
          case ma:
            var b = a.render;
            return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
          case pa:
            return b = a.displayName || null, b !== null ? b : ua(a.type) || "Memo";
          case qa:
            b = a._payload, a = a._init;
            try {
              return ua(a(b));
            } catch {
            }
        }
        return null;
      }
      function va(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return ua(b);
          case 8:
            return b === ia ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if (typeof b == "function") return b.displayName || b.name || null;
            if (typeof b == "string") return b;
        }
        return null;
      }
      function wa(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, (b.flags & 4098) !== 0 && (c = b.return), a = b.return;
          while (a);
        }
        return b.tag === 3 ? c : null;
      }
      function xa(a) {
        if (wa(a) !== a) throw Error(n(188));
      }
      function za(a) {
        var b = a.alternate;
        if (!b) {
          if (b = wa(a), b === null) throw Error(n(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (e === null) break;
          var f = e.alternate;
          if (f === null) {
            if (d = e.return, d !== null) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return xa(e), a;
              if (f === d) return xa(e), b;
              f = f.sibling;
            }
            throw Error(n(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = !1, h = e.child; h; ) {
              if (h === c) {
                g = !0, c = e, d = f;
                break;
              }
              if (h === d) {
                g = !0, d = e, c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = !0, c = f, d = e;
                  break;
                }
                if (h === d) {
                  g = !0, d = f, c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(n(189));
            }
          }
          if (c.alternate !== d) throw Error(n(190));
        }
        if (c.tag !== 3) throw Error(n(188));
        return c.stateNode.current === c ? a : b;
      }
      function Aa(a) {
        return a = za(a), a !== null ? Ba(a) : null;
      }
      function Ba(a) {
        if (a.tag === 5 || a.tag === 6) return a;
        for (a = a.child; a !== null; ) {
          var b = Ba(a);
          if (b !== null) return b;
          a = a.sibling;
        }
        return null;
      }
      function Ca(a) {
        if (a.tag === 5 || a.tag === 6) return a;
        for (a = a.child; a !== null; ) {
          if (a.tag !== 4) {
            var b = Ca(a);
            if (b !== null) return b;
          }
          a = a.sibling;
        }
        return null;
      }
      var Da = Array.isArray, Ea = $$$hostConfig.getPublicInstance, Fa = $$$hostConfig.getRootHostContext, Ga = $$$hostConfig.getChildHostContext, Ha = $$$hostConfig.prepareForCommit, Ia = $$$hostConfig.resetAfterCommit, Ja = $$$hostConfig.createInstance, Ka = $$$hostConfig.appendInitialChild, La = $$$hostConfig.finalizeInitialChildren, Ma = $$$hostConfig.prepareUpdate, Na = $$$hostConfig.shouldSetTextContent, Oa = $$$hostConfig.createTextInstance, Pa = $$$hostConfig.scheduleTimeout, Qa = $$$hostConfig.cancelTimeout, Ra = $$$hostConfig.noTimeout, Sa = $$$hostConfig.isPrimaryRenderer, Ta = $$$hostConfig.supportsMutation, Ua = $$$hostConfig.supportsPersistence, Va = $$$hostConfig.supportsHydration, Wa = $$$hostConfig.getInstanceFromNode, Xa = $$$hostConfig.preparePortalMount, Ya = $$$hostConfig.getCurrentEventPriority, Za = $$$hostConfig.detachDeletedInstance, $a = $$$hostConfig.supportsMicrotasks, ab = $$$hostConfig.scheduleMicrotask, bb = $$$hostConfig.supportsTestSelectors, cb = $$$hostConfig.findFiberRoot, db = $$$hostConfig.getBoundingRect, eb = $$$hostConfig.getTextContent, fb = $$$hostConfig.isHiddenSubtree, gb = $$$hostConfig.matchAccessibilityRole, hb = $$$hostConfig.setFocusIfFocusable, ib = $$$hostConfig.setupIntersectionObserver, jb = $$$hostConfig.appendChild, kb = $$$hostConfig.appendChildToContainer, lb = $$$hostConfig.commitTextUpdate, mb = $$$hostConfig.commitMount, nb = $$$hostConfig.commitUpdate, ob = $$$hostConfig.insertBefore, pb = $$$hostConfig.insertInContainerBefore, qb = $$$hostConfig.removeChild, rb = $$$hostConfig.removeChildFromContainer, sb = $$$hostConfig.resetTextContent, tb = $$$hostConfig.hideInstance, ub = $$$hostConfig.hideTextInstance, vb = $$$hostConfig.unhideInstance, wb = $$$hostConfig.unhideTextInstance, xb = $$$hostConfig.clearContainer, yb = $$$hostConfig.cloneInstance, zb = $$$hostConfig.createContainerChildSet, Ab = $$$hostConfig.appendChildToContainerChildSet, Bb = $$$hostConfig.finalizeContainerChildren, Cb = $$$hostConfig.replaceContainerChildren, Eb = $$$hostConfig.cloneHiddenInstance, Fb = $$$hostConfig.cloneHiddenTextInstance, Gb = $$$hostConfig.canHydrateInstance, Hb = $$$hostConfig.canHydrateTextInstance, Ib = $$$hostConfig.canHydrateSuspenseInstance, Jb = $$$hostConfig.isSuspenseInstancePending, Kb = $$$hostConfig.isSuspenseInstanceFallback, Lb = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails, Mb = $$$hostConfig.registerSuspenseInstanceRetry, Nb = $$$hostConfig.getNextHydratableSibling, Ob = $$$hostConfig.getFirstHydratableChild, Pb = $$$hostConfig.getFirstHydratableChildWithinContainer, Qb = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance, Rb = $$$hostConfig.hydrateInstance, Sb = $$$hostConfig.hydrateTextInstance, Tb = $$$hostConfig.hydrateSuspenseInstance, Ub = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, Vb = $$$hostConfig.commitHydratedContainer, Wb = $$$hostConfig.commitHydratedSuspenseInstance, Xb = $$$hostConfig.clearSuspenseBoundary, Yb = $$$hostConfig.clearSuspenseBoundaryFromContainer, Zb = $$$hostConfig.shouldDeleteUnhydratedTailInstances, $b = $$$hostConfig.didNotMatchHydratedContainerTextInstance, ac = $$$hostConfig.didNotMatchHydratedTextInstance, bc;
      function cc(a) {
        if (bc === void 0) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          bc = b && b[1] || "";
        }
        return `
` + bc + a;
      }
      var dc = !1;
      function ec(a, b) {
        if (!a || dc) return "";
        dc = !0;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && typeof l.stack == "string") {
            for (var e = l.stack.split(`
`), f = d.stack.split(`
`), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (g !== 1 || h !== 1)
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = `
` + e[g].replace(" at new ", " at ");
                    return a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName)), k;
                  }
                while (1 <= g && 0 <= h);
              break;
            }
          }
        } finally {
          dc = !1, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? cc(a) : "";
      }
      var fc = Object.prototype.hasOwnProperty, gc = [], hc = -1;
      function ic(a) {
        return { current: a };
      }
      function q(a) {
        0 > hc || (a.current = gc[hc], gc[hc] = null, hc--);
      }
      function v(a, b) {
        hc++, gc[hc] = a.current, a.current = b;
      }
      var jc = {}, x = ic(jc), z = ic(!1), kc = jc;
      function mc(a, b) {
        var c = a.type.contextTypes;
        if (!c) return jc;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        return d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e), e;
      }
      function A(a) {
        return a = a.childContextTypes, a != null;
      }
      function nc() {
        q(z), q(x);
      }
      function oc(a, b, c) {
        if (x.current !== jc) throw Error(n(168));
        v(x, b), v(z, c);
      }
      function pc(a, b, c) {
        var d = a.stateNode;
        if (b = b.childContextTypes, typeof d.getChildContext != "function") return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(n(108, va(a) || "Unknown", e));
        return ca({}, c, d);
      }
      function qc(a) {
        return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || jc, kc = x.current, v(x, a), v(z, z.current), !0;
      }
      function rc(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(n(169));
        c ? (a = pc(a, b, kc), d.__reactInternalMemoizedMergedChildContext = a, q(z), q(x), v(x, a)) : q(z), v(z, c);
      }
      var tc = Math.clz32 ? Math.clz32 : sc, uc = Math.log, vc = Math.LN2;
      function sc(a) {
        return a >>>= 0, a === 0 ? 32 : 31 - (uc(a) / vc | 0) | 0;
      }
      var wc = 64, xc = 4194304;
      function yc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function zc(a, b) {
        var c = a.pendingLanes;
        if (c === 0) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (g !== 0) {
          var h = g & ~e;
          h !== 0 ? d = yc(h) : (f &= g, f !== 0 && (d = yc(f)));
        } else g = c & ~e, g !== 0 ? d = yc(g) : f !== 0 && (d = yc(f));
        if (d === 0) return 0;
        if (b !== 0 && b !== d && (b & e) === 0 && (e = d & -d, f = b & -b, e >= f || e === 16 && (f & 4194240) !== 0)) return b;
        if ((d & 4) !== 0 && (d |= c & 16), b = a.entangledLanes, b !== 0) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - tc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function Ac(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function Bc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - tc(f), h = 1 << g, k = e[g];
          k === -1 ? ((h & c) === 0 || (h & d) !== 0) && (e[g] = Ac(h, b)) : k <= b && (a.expiredLanes |= h), f &= ~h;
        }
      }
      function Cc(a) {
        return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function Dc() {
        var a = wc;
        return wc <<= 1, (wc & 4194240) === 0 && (wc = 64), a;
      }
      function Ec(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Fc(a, b, c) {
        a.pendingLanes |= b, b !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, b = 31 - tc(b), a[b] = c;
      }
      function Gc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= b, a.mutableReadLanes &= b, a.entangledLanes &= b, b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - tc(c), f = 1 << e;
          b[e] = 0, d[e] = -1, a[e] = -1, c &= ~f;
        }
      }
      function Hc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - tc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b), c &= ~e;
        }
      }
      var C = 0;
      function Ic(a) {
        return a &= -a, 1 < a ? 4 < a ? (a & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
      }
      var Jc = ba.unstable_scheduleCallback, Kc = ba.unstable_cancelCallback, Lc = ba.unstable_shouldYield, Mc = ba.unstable_requestPaint, D = ba.unstable_now, Nc = ba.unstable_ImmediatePriority, Oc = ba.unstable_UserBlockingPriority, Pc = ba.unstable_NormalPriority, Qc = ba.unstable_IdlePriority, Rc = null, Sc = null;
      function Tc(a) {
        if (Sc && typeof Sc.onCommitFiberRoot == "function") try {
          Sc.onCommitFiberRoot(Rc, a, void 0, (a.current.flags & 128) === 128);
        } catch {
        }
      }
      function Uc(a, b) {
        return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var Vc = typeof Object.is == "function" ? Object.is : Uc, Wc = null, Xc = !1, Yc = !1;
      function Zc(a) {
        Wc === null ? Wc = [a] : Wc.push(a);
      }
      function $c(a) {
        Xc = !0, Zc(a);
      }
      function ad() {
        if (!Yc && Wc !== null) {
          Yc = !0;
          var a = 0, b = C;
          try {
            var c = Wc;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(!0);
              while (d !== null);
            }
            Wc = null, Xc = !1;
          } catch (e) {
            throw Wc !== null && (Wc = Wc.slice(a + 1)), Jc(Nc, ad), e;
          } finally {
            C = b, Yc = !1;
          }
        }
        return null;
      }
      var bd = [], cd = 0, dd = null, ed = 0, fd = [], gd = 0, hd = null, id = 1, jd = "";
      function kd(a, b) {
        bd[cd++] = ed, bd[cd++] = dd, dd = a, ed = b;
      }
      function ld(a, b, c) {
        fd[gd++] = id, fd[gd++] = jd, fd[gd++] = hd, hd = a;
        var d = id;
        a = jd;
        var e = 32 - tc(d) - 1;
        d &= ~(1 << e), c += 1;
        var f = 32 - tc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32), d >>= g, e -= g, id = 1 << 32 - tc(b) + e | c << e | d, jd = f + a;
        } else id = 1 << f | c << e | d, jd = a;
      }
      function md(a) {
        a.return !== null && (kd(a, 1), ld(a, 1, 0));
      }
      function nd(a) {
        for (; a === dd; ) dd = bd[--cd], bd[cd] = null, ed = bd[--cd], bd[cd] = null;
        for (; a === hd; ) hd = fd[--gd], fd[gd] = null, jd = fd[--gd], fd[gd] = null, id = fd[--gd], fd[gd] = null;
      }
      var od = null, pd = null, F = !1, qd = !1, rd = null;
      function sd(a, b) {
        var c = td(5, null, null, 0);
        c.elementType = "DELETED", c.stateNode = b, c.return = a, b = a.deletions, b === null ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function ud(a, b) {
        switch (a.tag) {
          case 5:
            return b = Gb(b, a.type, a.pendingProps), b !== null ? (a.stateNode = b, od = a, pd = Ob(b), !0) : !1;
          case 6:
            return b = Hb(b, a.pendingProps), b !== null ? (a.stateNode = b, od = a, pd = null, !0) : !1;
          case 13:
            if (b = Ib(b), b !== null) {
              var c = hd !== null ? { id, overflow: jd } : null;
              return a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = td(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, od = a, pd = null, !0;
            }
            return !1;
          default:
            return !1;
        }
      }
      function vd(a) {
        return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
      }
      function wd(a) {
        if (F) {
          var b = pd;
          if (b) {
            var c = b;
            if (!ud(a, b)) {
              if (vd(a)) throw Error(n(418));
              b = Nb(c);
              var d = od;
              b && ud(a, b) ? sd(d, c) : (a.flags = a.flags & -4097 | 2, F = !1, od = a);
            }
          } else {
            if (vd(a)) throw Error(n(418));
            a.flags = a.flags & -4097 | 2, F = !1, od = a;
          }
        }
      }
      function xd(a) {
        for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; ) a = a.return;
        od = a;
      }
      function yd(a) {
        if (!Va || a !== od) return !1;
        if (!F) return xd(a), F = !0, !1;
        if (a.tag !== 3 && (a.tag !== 5 || Zb(a.type) && !Na(a.type, a.memoizedProps))) {
          var b = pd;
          if (b) {
            if (vd(a)) throw zd(), Error(n(418));
            for (; b; ) sd(a, b), b = Nb(b);
          }
        }
        if (xd(a), a.tag === 13) {
          if (!Va) throw Error(n(316));
          if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(n(317));
          pd = Ub(a);
        } else pd = od ? Nb(a.stateNode) : null;
        return !0;
      }
      function zd() {
        for (var a = pd; a; ) a = Nb(a);
      }
      function Ad() {
        Va && (pd = od = null, qd = F = !1);
      }
      function Bd(a) {
        rd === null ? rd = [a] : rd.push(a);
      }
      var Cd = da.ReactCurrentBatchConfig;
      function Dd(a, b) {
        if (Vc(a, b)) return !0;
        if (typeof a != "object" || a === null || typeof b != "object" || b === null) return !1;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return !1;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!fc.call(b, e) || !Vc(a[e], b[e])) return !1;
        }
        return !0;
      }
      function Ed(a) {
        switch (a.tag) {
          case 5:
            return cc(a.type);
          case 16:
            return cc("Lazy");
          case 13:
            return cc("Suspense");
          case 19:
            return cc("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = ec(a.type, !1), a;
          case 11:
            return a = ec(a.type.render, !1), a;
          case 1:
            return a = ec(a.type, !0), a;
          default:
            return "";
        }
      }
      function Fd(a, b, c) {
        if (a = c.ref, a !== null && typeof a != "function" && typeof a != "object") {
          if (c._owner) {
            if (c = c._owner, c) {
              if (c.tag !== 1) throw Error(n(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(n(147, a));
            var e = d, f = "" + a;
            return b !== null && b.ref !== null && typeof b.ref == "function" && b.ref._stringRef === f ? b.ref : (b = function(a2) {
              var b2 = e.refs;
              a2 === null ? delete b2[f] : b2[f] = a2;
            }, b._stringRef = f, b);
          }
          if (typeof a != "string") throw Error(n(284));
          if (!c._owner) throw Error(n(290, a));
        }
        return a;
      }
      function Gd(a, b) {
        throw a = Object.prototype.toString.call(b), Error(n(31, a === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Hd(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Id(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            d2 === null ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; d2 !== null; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); b2 !== null; ) b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          return a2 = Jd(a2, b2), a2.index = 0, a2.sibling = null, a2;
        }
        function f(b2, c2, d2) {
          return b2.index = d2, a ? (d2 = b2.alternate, d2 !== null ? (d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2) : (b2.flags |= 2, c2)) : (b2.flags |= 1048576, c2);
        }
        function g(b2) {
          return a && b2.alternate === null && (b2.flags |= 2), b2;
        }
        function h(a2, b2, c2, d2) {
          return b2 === null || b2.tag !== 6 ? (b2 = Kd(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          return f2 === ha ? m(a2, b2, c2.props.children, d2, c2.key) : b2 !== null && (b2.elementType === f2 || typeof f2 == "object" && f2 !== null && f2.$$typeof === qa && Hd(f2) === b2.type) ? (d2 = e(b2, c2.props), d2.ref = Fd(a2, b2, c2), d2.return = a2, d2) : (d2 = Ld(c2.type, c2.key, c2.props, null, a2.mode, d2), d2.ref = Fd(a2, b2, c2), d2.return = a2, d2);
        }
        function l(a2, b2, c2, d2) {
          return b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation ? (b2 = Md(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2.children || []), b2.return = a2, b2);
        }
        function m(a2, b2, c2, d2, f2) {
          return b2 === null || b2.tag !== 7 ? (b2 = Nd(c2, a2.mode, d2, f2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
        }
        function r(a2, b2, c2) {
          if (typeof b2 == "string" && b2 !== "" || typeof b2 == "number") return b2 = Kd("" + b2, a2.mode, c2), b2.return = a2, b2;
          if (typeof b2 == "object" && b2 !== null) {
            switch (b2.$$typeof) {
              case ea:
                return c2 = Ld(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Fd(a2, null, b2), c2.return = a2, c2;
              case fa:
                return b2 = Md(b2, a2.mode, c2), b2.return = a2, b2;
              case qa:
                var d2 = b2._init;
                return r(a2, d2(b2._payload), c2);
            }
            if (Da(b2) || ta(b2)) return b2 = Nd(b2, a2.mode, c2, null), b2.return = a2, b2;
            Gd(a2, b2);
          }
          return null;
        }
        function p(a2, b2, c2, d2) {
          var e2 = b2 !== null ? b2.key : null;
          if (typeof c2 == "string" && c2 !== "" || typeof c2 == "number") return e2 !== null ? null : h(a2, b2, "" + c2, d2);
          if (typeof c2 == "object" && c2 !== null) {
            switch (c2.$$typeof) {
              case ea:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case fa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case qa:
                return e2 = c2._init, p(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (Da(c2) || ta(c2)) return e2 !== null ? null : m(a2, b2, c2, d2, null);
            Gd(a2, c2);
          }
          return null;
        }
        function B(a2, b2, c2, d2, e2) {
          if (typeof d2 == "string" && d2 !== "" || typeof d2 == "number") return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if (typeof d2 == "object" && d2 !== null) {
            switch (d2.$$typeof) {
              case ea:
                return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case fa:
                return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case qa:
                var f2 = d2._init;
                return B(a2, b2, c2, f2(d2._payload), e2);
            }
            if (Da(d2) || ta(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Gd(b2, d2);
          }
          return null;
        }
        function w(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, t = g2 = 0, E2 = null; u !== null && t < h2.length; t++) {
            u.index > t ? (E2 = u, u = null) : E2 = u.sibling;
            var y = p(e2, u, h2[t], k2);
            if (y === null) {
              u === null && (u = E2);
              break;
            }
            a && u && y.alternate === null && b(e2, u), g2 = f(y, g2, t), m2 === null ? l2 = y : m2.sibling = y, m2 = y, u = E2;
          }
          if (t === h2.length) return c(e2, u), F && kd(e2, t), l2;
          if (u === null) {
            for (; t < h2.length; t++) u = r(e2, h2[t], k2), u !== null && (g2 = f(u, g2, t), m2 === null ? l2 = u : m2.sibling = u, m2 = u);
            return F && kd(e2, t), l2;
          }
          for (u = d(e2, u); t < h2.length; t++) E2 = B(u, e2, t, h2[t], k2), E2 !== null && (a && E2.alternate !== null && u.delete(E2.key === null ? t : E2.key), g2 = f(E2, g2, t), m2 === null ? l2 = E2 : m2.sibling = E2, m2 = E2);
          return a && u.forEach(function(a2) {
            return b(e2, a2);
          }), F && kd(e2, t), l2;
        }
        function Y(e2, g2, h2, k2) {
          var l2 = ta(h2);
          if (typeof l2 != "function") throw Error(n(150));
          if (h2 = l2.call(h2), h2 == null) throw Error(n(151));
          for (var u = l2 = null, m2 = g2, t = g2 = 0, E2 = null, y = h2.next(); m2 !== null && !y.done; t++, y = h2.next()) {
            m2.index > t ? (E2 = m2, m2 = null) : E2 = m2.sibling;
            var w2 = p(e2, m2, y.value, k2);
            if (w2 === null) {
              m2 === null && (m2 = E2);
              break;
            }
            a && m2 && w2.alternate === null && b(e2, m2), g2 = f(w2, g2, t), u === null ? l2 = w2 : u.sibling = w2, u = w2, m2 = E2;
          }
          if (y.done) return c(
            e2,
            m2
          ), F && kd(e2, t), l2;
          if (m2 === null) {
            for (; !y.done; t++, y = h2.next()) y = r(e2, y.value, k2), y !== null && (g2 = f(y, g2, t), u === null ? l2 = y : u.sibling = y, u = y);
            return F && kd(e2, t), l2;
          }
          for (m2 = d(e2, m2); !y.done; t++, y = h2.next()) y = B(m2, e2, t, y.value, k2), y !== null && (a && y.alternate !== null && m2.delete(y.key === null ? t : y.key), g2 = f(y, g2, t), u === null ? l2 = y : u.sibling = y, u = y);
          return a && m2.forEach(function(a2) {
            return b(e2, a2);
          }), F && kd(e2, t), l2;
        }
        function ya(a2, d2, f2, h2) {
          if (typeof f2 == "object" && f2 !== null && f2.type === ha && f2.key === null && (f2 = f2.props.children), typeof f2 == "object" && f2 !== null) {
            switch (f2.$$typeof) {
              case ea:
                a: {
                  for (var k2 = f2.key, l2 = d2; l2 !== null; ) {
                    if (l2.key === k2) {
                      if (k2 = f2.type, k2 === ha) {
                        if (l2.tag === 7) {
                          c(a2, l2.sibling), d2 = e(l2, f2.props.children), d2.return = a2, a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || typeof k2 == "object" && k2 !== null && k2.$$typeof === qa && Hd(k2) === l2.type) {
                        c(a2, l2.sibling), d2 = e(l2, f2.props), d2.ref = Fd(a2, l2, f2), d2.return = a2, a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ha ? (d2 = Nd(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Ld(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Fd(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case fa:
                a: {
                  for (l2 = f2.key; d2 !== null; ) {
                    if (d2.key === l2) if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling), d2 = e(d2, f2.children || []), d2.return = a2, a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Md(f2, a2.mode, h2), d2.return = a2, a2 = d2;
                }
                return g(a2);
              case qa:
                return l2 = f2._init, ya(a2, d2, l2(f2._payload), h2);
            }
            if (Da(f2)) return w(a2, d2, f2, h2);
            if (ta(f2)) return Y(a2, d2, f2, h2);
            Gd(a2, f2);
          }
          return typeof f2 == "string" && f2 !== "" || typeof f2 == "number" ? (f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Kd(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return ya;
      }
      var Od = Id(!0), Pd = Id(!1), Qd = ic(null), Rd = null, Sd = null, Td = null;
      function Ud() {
        Td = Sd = Rd = null;
      }
      function Vd(a, b, c) {
        Sa ? (v(Qd, b._currentValue), b._currentValue = c) : (v(Qd, b._currentValue2), b._currentValue2 = c);
      }
      function Wd(a) {
        var b = Qd.current;
        q(Qd), Sa ? a._currentValue = b : a._currentValue2 = b;
      }
      function Xd(a, b, c) {
        for (; a !== null; ) {
          var d = a.alternate;
          if ((a.childLanes & b) !== b ? (a.childLanes |= b, d !== null && (d.childLanes |= b)) : d !== null && (d.childLanes & b) !== b && (d.childLanes |= b), a === c) break;
          a = a.return;
        }
      }
      function Yd(a, b) {
        Rd = a, Td = Sd = null, a = a.dependencies, a !== null && a.firstContext !== null && ((a.lanes & b) !== 0 && (G = !0), a.firstContext = null);
      }
      function Zd(a) {
        var b = Sa ? a._currentValue : a._currentValue2;
        if (Td !== a) if (a = { context: a, memoizedValue: b, next: null }, Sd === null) {
          if (Rd === null) throw Error(n(308));
          Sd = a, Rd.dependencies = { lanes: 0, firstContext: a };
        } else Sd = Sd.next = a;
        return b;
      }
      var $d = null;
      function ae(a) {
        $d === null ? $d = [a] : $d.push(a);
      }
      function be(a, b, c, d) {
        var e = b.interleaved;
        return e === null ? (c.next = c, ae(b)) : (c.next = e.next, e.next = c), b.interleaved = c, ce(a, d);
      }
      function ce(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        for (c !== null && (c.lanes |= b), c = a, a = a.return; a !== null; ) a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
        return c.tag === 3 ? c.stateNode : null;
      }
      var de = !1;
      function ee(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function fe(a, b) {
        a = a.updateQueue, b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function ge(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function he(a, b, c) {
        var d = a.updateQueue;
        if (d === null) return null;
        if (d = d.shared, (H & 2) !== 0) {
          var e = d.pending;
          return e === null ? b.next = b : (b.next = e.next, e.next = b), d.pending = b, ce(a, c);
        }
        return e = d.interleaved, e === null ? (b.next = b, ae(d)) : (b.next = e.next, e.next = b), d.interleaved = b, ce(a, c);
      }
      function ie(a, b, c) {
        if (b = b.updateQueue, b !== null && (b = b.shared, (c & 4194240) !== 0)) {
          var d = b.lanes;
          d &= a.pendingLanes, c |= d, b.lanes = c, Hc(a, c);
        }
      }
      function je(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (d !== null && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          if (c = c.firstBaseUpdate, c !== null) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              f === null ? e = f = g : f = f.next = g, c = c.next;
            } while (c !== null);
            f === null ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects }, a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate, a === null ? c.firstBaseUpdate = b : a.next = b, c.lastBaseUpdate = b;
      }
      function ke(a, b, c, d) {
        var e = a.updateQueue;
        de = !1;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (h !== null) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null, g === null ? f = l : g.next = l, g = k;
          var m = a.alternate;
          m !== null && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (h === null ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (f !== null) {
          var r = e.baseState;
          g = 0, m = l = k = null, h = f;
          do {
            var p = h.lane, B = h.eventTime;
            if ((d & p) === p) {
              m !== null && (m = m.next = {
                eventTime: B,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var w = a, Y = h;
                switch (p = b, B = c, Y.tag) {
                  case 1:
                    if (w = Y.payload, typeof w == "function") {
                      r = w.call(B, r, p);
                      break a;
                    }
                    r = w;
                    break a;
                  case 3:
                    w.flags = w.flags & -65537 | 128;
                  case 0:
                    if (w = Y.payload, p = typeof w == "function" ? w.call(B, r, p) : w, p == null) break a;
                    r = ca({}, r, p);
                    break a;
                  case 2:
                    de = !0;
                }
              }
              h.callback !== null && h.lane !== 0 && (a.flags |= 64, p = e.effects, p === null ? e.effects = [h] : p.push(h));
            } else B = { eventTime: B, lane: p, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, m === null ? (l = m = B, k = r) : m = m.next = B, g |= p;
            if (h = h.next, h === null) {
              if (h = e.shared.pending, h === null) break;
              p = h, h = p.next, p.next = null, e.lastBaseUpdate = p, e.shared.pending = null;
            }
          } while (!0);
          if (m === null && (k = r), e.baseState = k, e.firstBaseUpdate = l, e.lastBaseUpdate = m, b = e.shared.interleaved, b !== null) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else f === null && (e.shared.lanes = 0);
          le |= g, a.lanes = g, a.memoizedState = r;
        }
      }
      function me(a, b, c) {
        if (a = b.effects, b.effects = null, a !== null) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (e !== null) {
            if (d.callback = null, d = c, typeof e != "function") throw Error(n(191, e));
            e.call(d);
          }
        }
      }
      var ne = {}, oe = ic(ne), pe = ic(ne), qe = ic(ne);
      function re(a) {
        if (a === ne) throw Error(n(174));
        return a;
      }
      function se(a, b) {
        v(qe, b), v(pe, a), v(oe, ne), a = Fa(b), q(oe), v(oe, a);
      }
      function te() {
        q(oe), q(pe), q(qe);
      }
      function ue(a) {
        var b = re(qe.current), c = re(oe.current);
        b = Ga(c, a.type, b), c !== b && (v(pe, a), v(oe, b));
      }
      function ve(a) {
        pe.current === a && (q(oe), q(pe));
      }
      var I = ic(0);
      function we(a) {
        for (var b = a; b !== null; ) {
          if (b.tag === 13) {
            var c = b.memoizedState;
            if (c !== null && (c = c.dehydrated, c === null || Jb(c) || Kb(c))) return b;
          } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
            if ((b.flags & 128) !== 0) return b;
          } else if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
          if (b === a) break;
          for (; b.sibling === null; ) {
            if (b.return === null || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return, b = b.sibling;
        }
        return null;
      }
      var xe = [];
      function ye() {
        for (var a = 0; a < xe.length; a++) {
          var b = xe[a];
          Sa ? b._workInProgressVersionPrimary = null : b._workInProgressVersionSecondary = null;
        }
        xe.length = 0;
      }
      var ze = da.ReactCurrentDispatcher, Ae = da.ReactCurrentBatchConfig, Be = 0, J = null, K = null, L = null, Ce = !1, De = !1, Ee = 0, Fe = 0;
      function M() {
        throw Error(n(321));
      }
      function Ge(a, b) {
        if (b === null) return !1;
        for (var c = 0; c < b.length && c < a.length; c++) if (!Vc(a[c], b[c])) return !1;
        return !0;
      }
      function He(a, b, c, d, e, f) {
        if (Be = f, J = b, b.memoizedState = null, b.updateQueue = null, b.lanes = 0, ze.current = a === null || a.memoizedState === null ? Ie : Je, a = c(d, e), De) {
          f = 0;
          do {
            if (De = !1, Ee = 0, 25 <= f) throw Error(n(301));
            f += 1, L = K = null, b.updateQueue = null, ze.current = Ke, a = c(d, e);
          } while (De);
        }
        if (ze.current = Le, b = K !== null && K.next !== null, Be = 0, L = K = J = null, Ce = !1, b) throw Error(n(300));
        return a;
      }
      function Me() {
        var a = Ee !== 0;
        return Ee = 0, a;
      }
      function Ne() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        return L === null ? J.memoizedState = L = a : L = L.next = a, L;
      }
      function Oe() {
        if (K === null) {
          var a = J.alternate;
          a = a !== null ? a.memoizedState : null;
        } else a = K.next;
        var b = L === null ? J.memoizedState : L.next;
        if (b !== null) L = b, K = a;
        else {
          if (a === null) throw Error(n(310));
          K = a, a = { memoizedState: K.memoizedState, baseState: K.baseState, baseQueue: K.baseQueue, queue: K.queue, next: null }, L === null ? J.memoizedState = L = a : L = L.next = a;
        }
        return L;
      }
      function Pe(a, b) {
        return typeof b == "function" ? b(a) : b;
      }
      function Qe(a) {
        var b = Oe(), c = b.queue;
        if (c === null) throw Error(n(311));
        c.lastRenderedReducer = a;
        var d = K, e = d.baseQueue, f = c.pending;
        if (f !== null) {
          if (e !== null) {
            var g = e.next;
            e.next = f.next, f.next = g;
          }
          d.baseQueue = e = f, c.pending = null;
        }
        if (e !== null) {
          f = e.next, d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Be & m) === m) k !== null && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var r = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              k === null ? (h = k = r, g = d) : k = k.next = r, J.lanes |= m, le |= m;
            }
            l = l.next;
          } while (l !== null && l !== f);
          k === null ? g = d : k.next = h, Vc(d, b.memoizedState) || (G = !0), b.memoizedState = d, b.baseState = g, b.baseQueue = k, c.lastRenderedState = d;
        }
        if (a = c.interleaved, a !== null) {
          e = a;
          do
            f = e.lane, J.lanes |= f, le |= f, e = e.next;
          while (e !== a);
        } else e === null && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Re(a) {
        var b = Oe(), c = b.queue;
        if (c === null) throw Error(n(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (e !== null) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          Vc(f, b.memoizedState) || (G = !0), b.memoizedState = f, b.baseQueue === null && (b.baseState = f), c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Se() {
      }
      function Te(a, b) {
        var c = J, d = Oe(), e = b(), f = !Vc(d.memoizedState, e);
        if (f && (d.memoizedState = e, G = !0), d = d.queue, Ue(Ve.bind(null, c, d, a), [a]), d.getSnapshot !== b || f || L !== null && L.memoizedState.tag & 1) {
          if (c.flags |= 2048, We(9, Xe.bind(null, c, d, e, b), void 0, null), N === null) throw Error(n(349));
          (Be & 30) !== 0 || Ye(c, b, e);
        }
        return e;
      }
      function Ye(a, b, c) {
        a.flags |= 16384, a = { getSnapshot: b, value: c }, b = J.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, J.updateQueue = b, b.stores = [a]) : (c = b.stores, c === null ? b.stores = [a] : c.push(a));
      }
      function Xe(a, b, c, d) {
        b.value = c, b.getSnapshot = d, Ze(b) && $e(a);
      }
      function Ve(a, b, c) {
        return c(function() {
          Ze(b) && $e(a);
        });
      }
      function Ze(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !Vc(a, c);
        } catch {
          return !0;
        }
      }
      function $e(a) {
        var b = ce(a, 1);
        b !== null && af(b, a, 1, -1);
      }
      function bf(a) {
        var b = Ne();
        return typeof a == "function" && (a = a()), b.memoizedState = b.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Pe, lastRenderedState: a }, b.queue = a, a = a.dispatch = cf.bind(null, J, a), [b.memoizedState, a];
      }
      function We(a, b, c, d) {
        return a = { tag: a, create: b, destroy: c, deps: d, next: null }, b = J.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, J.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a)), a;
      }
      function df() {
        return Oe().memoizedState;
      }
      function ef(a, b, c, d) {
        var e = Ne();
        J.flags |= a, e.memoizedState = We(1 | b, c, void 0, d === void 0 ? null : d);
      }
      function ff(a, b, c, d) {
        var e = Oe();
        d = d === void 0 ? null : d;
        var f = void 0;
        if (K !== null) {
          var g = K.memoizedState;
          if (f = g.destroy, d !== null && Ge(d, g.deps)) {
            e.memoizedState = We(b, c, f, d);
            return;
          }
        }
        J.flags |= a, e.memoizedState = We(1 | b, c, f, d);
      }
      function gf(a, b) {
        return ef(8390656, 8, a, b);
      }
      function Ue(a, b) {
        return ff(2048, 8, a, b);
      }
      function hf(a, b) {
        return ff(4, 2, a, b);
      }
      function jf(a, b) {
        return ff(4, 4, a, b);
      }
      function kf(a, b) {
        if (typeof b == "function") return a = a(), b(a), function() {
          b(null);
        };
        if (b != null) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function lf(a, b, c) {
        return c = c != null ? c.concat([a]) : null, ff(4, 4, kf.bind(null, b, a), c);
      }
      function mf() {
      }
      function nf(a, b) {
        var c = Oe();
        b = b === void 0 ? null : b;
        var d = c.memoizedState;
        return d !== null && b !== null && Ge(b, d[1]) ? d[0] : (c.memoizedState = [a, b], a);
      }
      function of(a, b) {
        var c = Oe();
        b = b === void 0 ? null : b;
        var d = c.memoizedState;
        return d !== null && b !== null && Ge(b, d[1]) ? d[0] : (a = a(), c.memoizedState = [a, b], a);
      }
      function pf(a, b, c) {
        return (Be & 21) === 0 ? (a.baseState && (a.baseState = !1, G = !0), a.memoizedState = c) : (Vc(c, b) || (c = Dc(), J.lanes |= c, le |= c, a.baseState = !0), b);
      }
      function qf(a, b) {
        var c = C;
        C = c !== 0 && 4 > c ? c : 4, a(!0);
        var d = Ae.transition;
        Ae.transition = {};
        try {
          a(!1), b();
        } finally {
          C = c, Ae.transition = d;
        }
      }
      function rf() {
        return Oe().memoizedState;
      }
      function sf(a, b, c) {
        var d = tf(a);
        if (c = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null }, uf(a)) vf(b, c);
        else if (c = be(a, b, c, d), c !== null) {
          var e = O();
          af(c, a, d, e), wf(c, b, d);
        }
      }
      function cf(a, b, c) {
        var d = tf(a), e = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null };
        if (uf(a)) vf(b, e);
        else {
          var f = a.alternate;
          if (a.lanes === 0 && (f === null || f.lanes === 0) && (f = b.lastRenderedReducer, f !== null)) try {
            var g = b.lastRenderedState, h = f(g, c);
            if (e.hasEagerState = !0, e.eagerState = h, Vc(h, g)) {
              var k = b.interleaved;
              k === null ? (e.next = e, ae(b)) : (e.next = k.next, k.next = e), b.interleaved = e;
              return;
            }
          } catch {
          } finally {
          }
          c = be(a, b, e, d), c !== null && (e = O(), af(c, a, d, e), wf(c, b, d));
        }
      }
      function uf(a) {
        var b = a.alternate;
        return a === J || b !== null && b === J;
      }
      function vf(a, b) {
        De = Ce = !0;
        var c = a.pending;
        c === null ? b.next = b : (b.next = c.next, c.next = b), a.pending = b;
      }
      function wf(a, b, c) {
        if ((c & 4194240) !== 0) {
          var d = b.lanes;
          d &= a.pendingLanes, c |= d, b.lanes = c, Hc(a, c);
        }
      }
      var Le = { readContext: Zd, useCallback: M, useContext: M, useEffect: M, useImperativeHandle: M, useInsertionEffect: M, useLayoutEffect: M, useMemo: M, useReducer: M, useRef: M, useState: M, useDebugValue: M, useDeferredValue: M, useTransition: M, useMutableSource: M, useSyncExternalStore: M, useId: M, unstable_isNewReconciler: !1 }, Ie = { readContext: Zd, useCallback: function(a, b) {
        return Ne().memoizedState = [a, b === void 0 ? null : b], a;
      }, useContext: Zd, useEffect: gf, useImperativeHandle: function(a, b, c) {
        return c = c != null ? c.concat([a]) : null, ef(
          4194308,
          4,
          kf.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ef(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ef(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Ne();
        return b = b === void 0 ? null : b, a = a(), c.memoizedState = [a, b], a;
      }, useReducer: function(a, b, c) {
        var d = Ne();
        return b = c !== void 0 ? c(b) : b, d.memoizedState = d.baseState = b, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b }, d.queue = a, a = a.dispatch = sf.bind(null, J, a), [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Ne();
        return a = { current: a }, b.memoizedState = a;
      }, useState: bf, useDebugValue: mf, useDeferredValue: function(a) {
        return Ne().memoizedState = a;
      }, useTransition: function() {
        var a = bf(!1), b = a[0];
        return a = qf.bind(null, a[1]), Ne().memoizedState = a, [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = J, e = Ne();
        if (F) {
          if (c === void 0) throw Error(n(407));
          c = c();
        } else {
          if (c = b(), N === null) throw Error(n(349));
          (Be & 30) !== 0 || Ye(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        return e.queue = f, gf(Ve.bind(
          null,
          d,
          f,
          a
        ), [a]), d.flags |= 2048, We(9, Xe.bind(null, d, f, c, b), void 0, null), c;
      }, useId: function() {
        var a = Ne(), b = N.identifierPrefix;
        if (F) {
          var c = jd, d = id;
          c = (d & ~(1 << 32 - tc(d) - 1)).toString(32) + c, b = ":" + b + "R" + c, c = Ee++, 0 < c && (b += "H" + c.toString(32)), b += ":";
        } else c = Fe++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: !1 }, Je = {
        readContext: Zd,
        useCallback: nf,
        useContext: Zd,
        useEffect: Ue,
        useImperativeHandle: lf,
        useInsertionEffect: hf,
        useLayoutEffect: jf,
        useMemo: of,
        useReducer: Qe,
        useRef: df,
        useState: function() {
          return Qe(Pe);
        },
        useDebugValue: mf,
        useDeferredValue: function(a) {
          var b = Oe();
          return pf(b, K.memoizedState, a);
        },
        useTransition: function() {
          var a = Qe(Pe)[0], b = Oe().memoizedState;
          return [a, b];
        },
        useMutableSource: Se,
        useSyncExternalStore: Te,
        useId: rf,
        unstable_isNewReconciler: !1
      }, Ke = { readContext: Zd, useCallback: nf, useContext: Zd, useEffect: Ue, useImperativeHandle: lf, useInsertionEffect: hf, useLayoutEffect: jf, useMemo: of, useReducer: Re, useRef: df, useState: function() {
        return Re(Pe);
      }, useDebugValue: mf, useDeferredValue: function(a) {
        var b = Oe();
        return K === null ? b.memoizedState = a : pf(b, K.memoizedState, a);
      }, useTransition: function() {
        var a = Re(Pe)[0], b = Oe().memoizedState;
        return [a, b];
      }, useMutableSource: Se, useSyncExternalStore: Te, useId: rf, unstable_isNewReconciler: !1 };
      function xf(a, b) {
        if (a && a.defaultProps) {
          b = ca({}, b), a = a.defaultProps;
          for (var c in a) b[c] === void 0 && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function yf(a, b, c, d) {
        b = a.memoizedState, c = c(d, b), c = c == null ? b : ca({}, b, c), a.memoizedState = c, a.lanes === 0 && (a.updateQueue.baseState = c);
      }
      var zf = { isMounted: function(a) {
        return (a = a._reactInternals) ? wa(a) === a : !1;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = O(), e = tf(a), f = ge(d, e);
        f.payload = b, c != null && (f.callback = c), b = he(a, f, e), b !== null && (af(b, a, e, d), ie(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = O(), e = tf(a), f = ge(d, e);
        f.tag = 1, f.payload = b, c != null && (f.callback = c), b = he(a, f, e), b !== null && (af(b, a, e, d), ie(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = O(), d = tf(a), e = ge(c, d);
        e.tag = 2, b != null && (e.callback = b), b = he(a, e, d), b !== null && (af(b, a, d, c), ie(b, a, d));
      } };
      function Af(a, b, c, d, e, f, g) {
        return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Dd(c, d) || !Dd(e, f) : !0;
      }
      function Bf(a, b, c) {
        var d = !1, e = jc, f = b.contextType;
        return typeof f == "object" && f !== null ? f = Zd(f) : (e = A(b) ? kc : x.current, d = b.contextTypes, f = (d = d != null) ? mc(a, e) : jc), b = new b(c, f), a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null, b.updater = zf, a.stateNode = b, b._reactInternals = a, d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f), b;
      }
      function Cf(a, b, c, d) {
        a = b.state, typeof b.componentWillReceiveProps == "function" && b.componentWillReceiveProps(c, d), typeof b.UNSAFE_componentWillReceiveProps == "function" && b.UNSAFE_componentWillReceiveProps(c, d), b.state !== a && zf.enqueueReplaceState(b, b.state, null);
      }
      function Df(a, b, c, d) {
        var e = a.stateNode;
        e.props = c, e.state = a.memoizedState, e.refs = {}, ee(a);
        var f = b.contextType;
        typeof f == "object" && f !== null ? e.context = Zd(f) : (f = A(b) ? kc : x.current, e.context = mc(a, f)), e.state = a.memoizedState, f = b.getDerivedStateFromProps, typeof f == "function" && (yf(a, b, f, c), e.state = a.memoizedState), typeof b.getDerivedStateFromProps == "function" || typeof e.getSnapshotBeforeUpdate == "function" || typeof e.UNSAFE_componentWillMount != "function" && typeof e.componentWillMount != "function" || (b = e.state, typeof e.componentWillMount == "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount == "function" && e.UNSAFE_componentWillMount(), b !== e.state && zf.enqueueReplaceState(e, e.state, null), ke(a, c, e, d), e.state = a.memoizedState), typeof e.componentDidMount == "function" && (a.flags |= 4194308);
      }
      function Ef(a, b) {
        try {
          var c = "", d = b;
          do
            c += Ed(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = `
Error generating stack: ` + f.message + `
` + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ff(a, b, c) {
        return { value: a, source: null, stack: c ?? null, digest: b ?? null };
      }
      function Gf(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Hf = typeof WeakMap == "function" ? WeakMap : Map;
      function If(a, b, c) {
        c = ge(-1, c), c.tag = 3, c.payload = { element: null };
        var d = b.value;
        return c.callback = function() {
          Jf || (Jf = !0, Kf = d), Gf(a, b);
        }, c;
      }
      function Lf(a, b, c) {
        c = ge(-1, c), c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if (typeof d == "function") {
          var e = b.value;
          c.payload = function() {
            return d(e);
          }, c.callback = function() {
            Gf(a, b);
          };
        }
        var f = a.stateNode;
        return f !== null && typeof f.componentDidCatch == "function" && (c.callback = function() {
          Gf(a, b), typeof d != "function" && (Mf === null ? Mf = /* @__PURE__ */ new Set([this]) : Mf.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
        }), c;
      }
      function Nf(a, b, c) {
        var d = a.pingCache;
        if (d === null) {
          d = a.pingCache = new Hf();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), e === void 0 && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Of.bind(null, a, b, c), b.then(a, a));
      }
      function Pf(a) {
        do {
          var b;
          if ((b = a.tag === 13) && (b = a.memoizedState, b = b !== null ? b.dehydrated !== null : !0), b) return a;
          a = a.return;
        } while (a !== null);
        return null;
      }
      function Qf(a, b, c, d, e) {
        return (a.mode & 1) === 0 ? (a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (b = ge(-1, 1), b.tag = 2, he(c, b, 1))), c.lanes |= 1), a) : (a.flags |= 65536, a.lanes = e, a);
      }
      var Rf = da.ReactCurrentOwner, G = !1;
      function P(a, b, c, d) {
        b.child = a === null ? Pd(b, null, c, d) : Od(b, a.child, c, d);
      }
      function Sf(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        return Yd(b, e), d = He(a, b, c, d, f, e), c = Me(), a !== null && !G ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Tf(a, b, e)) : (F && c && md(b), b.flags |= 1, P(a, b, d, e), b.child);
      }
      function Uf(a, b, c, d, e) {
        if (a === null) {
          var f = c.type;
          return typeof f == "function" && !Vf(f) && f.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (b.tag = 15, b.type = f, Wf(a, b, f, d, e)) : (a = Ld(c.type, null, d, b, b.mode, e), a.ref = b.ref, a.return = b, b.child = a);
        }
        if (f = a.child, (a.lanes & e) === 0) {
          var g = f.memoizedProps;
          if (c = c.compare, c = c !== null ? c : Dd, c(g, d) && a.ref === b.ref) return Tf(a, b, e);
        }
        return b.flags |= 1, a = Jd(f, d), a.ref = b.ref, a.return = b, b.child = a;
      }
      function Wf(a, b, c, d, e) {
        if (a !== null) {
          var f = a.memoizedProps;
          if (Dd(f, d) && a.ref === b.ref) if (G = !1, b.pendingProps = d = f, (a.lanes & e) !== 0) (a.flags & 131072) !== 0 && (G = !0);
          else return b.lanes = a.lanes, Tf(a, b, e);
        }
        return Xf(a, b, c, d, e);
      }
      function Yf(a, b, c) {
        var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
        if (d.mode === "hidden") if ((b.mode & 1) === 0) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, v(Zf, $f), $f |= c;
        else {
          if ((c & 1073741824) === 0) return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, v(Zf, $f), $f |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = f !== null ? f.baseLanes : c, v(Zf, $f), $f |= d;
        }
        else f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, v(Zf, $f), $f |= d;
        return P(a, b, e, c), b.child;
      }
      function ag(a, b) {
        var c = b.ref;
        (a === null && c !== null || a !== null && a.ref !== c) && (b.flags |= 512, b.flags |= 2097152);
      }
      function Xf(a, b, c, d, e) {
        var f = A(c) ? kc : x.current;
        return f = mc(b, f), Yd(b, e), c = He(a, b, c, d, f, e), d = Me(), a !== null && !G ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Tf(a, b, e)) : (F && d && md(b), b.flags |= 1, P(a, b, c, e), b.child);
      }
      function bg(a, b, c, d, e) {
        if (A(c)) {
          var f = !0;
          qc(b);
        } else f = !1;
        if (Yd(b, e), b.stateNode === null) cg(a, b), Bf(b, c, d), Df(b, c, d, e), d = !0;
        else if (a === null) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          typeof l == "object" && l !== null ? l = Zd(l) : (l = A(c) ? kc : x.current, l = mc(b, l));
          var m = c.getDerivedStateFromProps, r = typeof m == "function" || typeof g.getSnapshotBeforeUpdate == "function";
          r || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (h !== d || k !== l) && Cf(b, g, d, l), de = !1;
          var p = b.memoizedState;
          g.state = p, ke(b, d, g, e), k = b.memoizedState, h !== d || p !== k || z.current || de ? (typeof m == "function" && (yf(b, c, m, d), k = b.memoizedState), (h = de || Af(b, c, h, d, p, k, l)) ? (r || typeof g.UNSAFE_componentWillMount != "function" && typeof g.componentWillMount != "function" || (typeof g.componentWillMount == "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount == "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount == "function" && (b.flags |= 4194308)) : (typeof g.componentDidMount == "function" && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : (typeof g.componentDidMount == "function" && (b.flags |= 4194308), d = !1);
        } else {
          g = b.stateNode, fe(a, b), h = b.memoizedProps, l = b.type === b.elementType ? h : xf(b.type, h), g.props = l, r = b.pendingProps, p = g.context, k = c.contextType, typeof k == "object" && k !== null ? k = Zd(k) : (k = A(c) ? kc : x.current, k = mc(b, k));
          var B = c.getDerivedStateFromProps;
          (m = typeof B == "function" || typeof g.getSnapshotBeforeUpdate == "function") || typeof g.UNSAFE_componentWillReceiveProps != "function" && typeof g.componentWillReceiveProps != "function" || (h !== r || p !== k) && Cf(b, g, d, k), de = !1, p = b.memoizedState, g.state = p, ke(b, d, g, e);
          var w = b.memoizedState;
          h !== r || p !== w || z.current || de ? (typeof B == "function" && (yf(b, c, B, d), w = b.memoizedState), (l = de || Af(b, c, l, d, p, w, k) || !1) ? (m || typeof g.UNSAFE_componentWillUpdate != "function" && typeof g.componentWillUpdate != "function" || (typeof g.componentWillUpdate == "function" && g.componentWillUpdate(d, w, k), typeof g.UNSAFE_componentWillUpdate == "function" && g.UNSAFE_componentWillUpdate(d, w, k)), typeof g.componentDidUpdate == "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate == "function" && (b.flags |= 1024)) : (typeof g.componentDidUpdate != "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = w), g.props = d, g.state = w, g.context = k, d = l) : (typeof g.componentDidUpdate != "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate != "function" || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 1024), d = !1);
        }
        return dg(a, b, c, d, f, e);
      }
      function dg(a, b, c, d, e, f) {
        ag(a, b);
        var g = (b.flags & 128) !== 0;
        if (!d && !g) return e && rc(b, c, !1), Tf(a, b, f);
        d = b.stateNode, Rf.current = b;
        var h = g && typeof c.getDerivedStateFromError != "function" ? null : d.render();
        return b.flags |= 1, a !== null && g ? (b.child = Od(b, a.child, null, f), b.child = Od(b, null, h, f)) : P(a, b, h, f), b.memoizedState = d.state, e && rc(b, c, !0), b.child;
      }
      function eg(a) {
        var b = a.stateNode;
        b.pendingContext ? oc(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oc(a, b.context, !1), se(a, b.containerInfo);
      }
      function fg(a, b, c, d, e) {
        return Ad(), Bd(e), b.flags |= 256, P(a, b, c, d), b.child;
      }
      var gg = { dehydrated: null, treeContext: null, retryLane: 0 };
      function hg(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function ig(a, b, c) {
        var d = b.pendingProps, e = I.current, f = !1, g = (b.flags & 128) !== 0, h;
        if ((h = g) || (h = a !== null && a.memoizedState === null ? !1 : (e & 2) !== 0), h ? (f = !0, b.flags &= -129) : (a === null || a.memoizedState !== null) && (e |= 1), v(I, e & 1), a === null)
          return wd(b), a = b.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? ((b.mode & 1) === 0 ? b.lanes = 1 : Kb(a) ? b.lanes = 8 : b.lanes = 1073741824, null) : (g = d.children, a = d.fallback, f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, (d & 1) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = g) : f = jg(g, d, 0, null), a = Nd(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = hg(c), b.memoizedState = gg, a) : kg(b, g));
        if (e = a.memoizedState, e !== null && (h = e.dehydrated, h !== null)) return lg(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback, g = b.mode, e = a.child, h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          return (g & 1) === 0 && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Jd(e, k), d.subtreeFlags = e.subtreeFlags & 14680064), h !== null ? f = Jd(h, f) : (f = Nd(f, g, c, null), f.flags |= 2), f.return = b, d.return = b, d.sibling = f, b.child = d, d = f, f = b.child, g = a.child.memoizedState, g = g === null ? hg(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions }, f.memoizedState = g, f.childLanes = a.childLanes & ~c, b.memoizedState = gg, d;
        }
        return f = a.child, a = f.sibling, d = Jd(f, { mode: "visible", children: d.children }), (b.mode & 1) === 0 && (d.lanes = c), d.return = b, d.sibling = null, a !== null && (c = b.deletions, c === null ? (b.deletions = [a], b.flags |= 16) : c.push(a)), b.child = d, b.memoizedState = null, d;
      }
      function kg(a, b) {
        return b = jg({ mode: "visible", children: b }, a.mode, 0, null), b.return = a, a.child = b;
      }
      function mg(a, b, c, d) {
        return d !== null && Bd(d), Od(b, a.child, null, c), a = kg(b, b.pendingProps.children), a.flags |= 2, b.memoizedState = null, a;
      }
      function lg(a, b, c, d, e, f, g) {
        if (c)
          return b.flags & 256 ? (b.flags &= -257, d = Ff(Error(n(422))), mg(a, b, g, d)) : b.memoizedState !== null ? (b.child = a.child, b.flags |= 128, null) : (f = d.fallback, e = b.mode, d = jg({ mode: "visible", children: d.children }, e, 0, null), f = Nd(f, e, g, null), f.flags |= 2, d.return = b, f.return = b, d.sibling = f, b.child = d, (b.mode & 1) !== 0 && Od(b, a.child, null, g), b.child.memoizedState = hg(g), b.memoizedState = gg, f);
        if ((b.mode & 1) === 0) return mg(a, b, g, null);
        if (Kb(e)) return d = Lb(e).digest, f = Error(n(419)), d = Ff(
          f,
          d,
          void 0
        ), mg(a, b, g, d);
        if (c = (g & a.childLanes) !== 0, G || c) {
          if (d = N, d !== null) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = (e & (d.suspendedLanes | g)) !== 0 ? 0 : e, e !== 0 && e !== f.retryLane && (f.retryLane = e, ce(a, e), af(
              d,
              a,
              e,
              -1
            ));
          }
          return ng(), d = Ff(Error(n(421))), mg(a, b, g, d);
        }
        return Jb(e) ? (b.flags |= 128, b.child = a.child, b = og.bind(null, a), Mb(e, b), null) : (a = f.treeContext, Va && (pd = Qb(e), od = b, F = !0, rd = null, qd = !1, a !== null && (fd[gd++] = id, fd[gd++] = jd, fd[gd++] = hd, id = a.id, jd = a.overflow, hd = b)), b = kg(b, d.children), b.flags |= 4096, b);
      }
      function pg(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        d !== null && (d.lanes |= b), Xd(a.return, b, c);
      }
      function qg(a, b, c, d, e) {
        var f = a.memoizedState;
        f === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function rg(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        if (P(a, b, d.children, c), d = I.current, (d & 2) !== 0) d = d & 1 | 2, b.flags |= 128;
        else {
          if (a !== null && (a.flags & 128) !== 0) a: for (a = b.child; a !== null; ) {
            if (a.tag === 13) a.memoizedState !== null && pg(a, c, b);
            else if (a.tag === 19) pg(a, c, b);
            else if (a.child !== null) {
              a.child.return = a, a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; a.sibling === null; ) {
              if (a.return === null || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return, a = a.sibling;
          }
          d &= 1;
        }
        if (v(I, d), (b.mode & 1) === 0) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            for (c = b.child, e = null; c !== null; ) a = c.alternate, a !== null && we(a) === null && (e = c), c = c.sibling;
            c = e, c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null), qg(b, !1, e, c, f);
            break;
          case "backwards":
            for (c = null, e = b.child, b.child = null; e !== null; ) {
              if (a = e.alternate, a !== null && we(a) === null) {
                b.child = e;
                break;
              }
              a = e.sibling, e.sibling = c, c = e, e = a;
            }
            qg(b, !0, c, null, f);
            break;
          case "together":
            qg(b, !1, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function cg(a, b) {
        (b.mode & 1) === 0 && a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Tf(a, b, c) {
        if (a !== null && (b.dependencies = a.dependencies), le |= b.lanes, (c & b.childLanes) === 0) return null;
        if (a !== null && b.child !== a.child) throw Error(n(153));
        if (b.child !== null) {
          for (a = b.child, c = Jd(a, a.pendingProps), b.child = c, c.return = b; a.sibling !== null; ) a = a.sibling, c = c.sibling = Jd(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function sg(a, b, c) {
        switch (b.tag) {
          case 3:
            eg(b), Ad();
            break;
          case 5:
            ue(b);
            break;
          case 1:
            A(b.type) && qc(b);
            break;
          case 4:
            se(b, b.stateNode.containerInfo);
            break;
          case 10:
            Vd(b, b.type._context, b.memoizedProps.value);
            break;
          case 13:
            var d = b.memoizedState;
            if (d !== null)
              return d.dehydrated !== null ? (v(I, I.current & 1), b.flags |= 128, null) : (c & b.child.childLanes) !== 0 ? ig(a, b, c) : (v(I, I.current & 1), a = Tf(a, b, c), a !== null ? a.sibling : null);
            v(I, I.current & 1);
            break;
          case 19:
            if (d = (c & b.childLanes) !== 0, (a.flags & 128) !== 0) {
              if (d) return rg(
                a,
                b,
                c
              );
              b.flags |= 128;
            }
            var e = b.memoizedState;
            if (e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null), v(I, I.current), d) break;
            return null;
          case 22:
          case 23:
            return b.lanes = 0, Yf(a, b, c);
        }
        return Tf(a, b, c);
      }
      function tg(a) {
        a.flags |= 4;
      }
      function ug(a, b) {
        if (a !== null && a.child === b.child) return !0;
        if ((b.flags & 16) !== 0) return !1;
        for (a = b.child; a !== null; ) {
          if ((a.flags & 12854) !== 0 || (a.subtreeFlags & 12854) !== 0) return !1;
          a = a.sibling;
        }
        return !0;
      }
      var vg, wg, xg, yg;
      if (Ta) vg = function(a, b) {
        for (var c = b.child; c !== null; ) {
          if (c.tag === 5 || c.tag === 6) Ka(a, c.stateNode);
          else if (c.tag !== 4 && c.child !== null) {
            c.child.return = c, c = c.child;
            continue;
          }
          if (c === b) break;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return, c = c.sibling;
        }
      }, wg = function() {
      }, xg = function(a, b, c, d, e) {
        if (a = a.memoizedProps, a !== d) {
          var f = b.stateNode, g = re(oe.current);
          c = Ma(f, c, a, d, e, g), (b.updateQueue = c) && tg(b);
        }
      }, yg = function(a, b, c, d) {
        c !== d && tg(b);
      };
      else if (Ua) {
        vg = function(a, b, c, d) {
          for (var e = b.child; e !== null; ) {
            if (e.tag === 5) {
              var f = e.stateNode;
              c && d && (f = Eb(f, e.type, e.memoizedProps, e)), Ka(a, f);
            } else if (e.tag === 6) f = e.stateNode, c && d && (f = Fb(f, e.memoizedProps, e)), Ka(a, f);
            else if (e.tag !== 4) {
              if (e.tag === 22 && e.memoizedState !== null) f = e.child, f !== null && (f.return = e), vg(a, e, !0, !0);
              else if (e.child !== null) {
                e.child.return = e, e = e.child;
                continue;
              }
            }
            if (e === b) break;
            for (; e.sibling === null; ) {
              if (e.return === null || e.return === b) return;
              e = e.return;
            }
            e.sibling.return = e.return, e = e.sibling;
          }
        };
        var zg = function(a, b, c, d) {
          for (var e = b.child; e !== null; ) {
            if (e.tag === 5) {
              var f = e.stateNode;
              c && d && (f = Eb(f, e.type, e.memoizedProps, e)), Ab(a, f);
            } else if (e.tag === 6) f = e.stateNode, c && d && (f = Fb(f, e.memoizedProps, e)), Ab(a, f);
            else if (e.tag !== 4) {
              if (e.tag === 22 && e.memoizedState !== null) f = e.child, f !== null && (f.return = e), zg(a, e, !0, !0);
              else if (e.child !== null) {
                e.child.return = e, e = e.child;
                continue;
              }
            }
            if (e === b) break;
            for (; e.sibling === null; ) {
              if (e.return === null || e.return === b) return;
              e = e.return;
            }
            e.sibling.return = e.return, e = e.sibling;
          }
        };
        wg = function(a, b) {
          var c = b.stateNode;
          if (!ug(a, b)) {
            a = c.containerInfo;
            var d = zb(a);
            zg(d, b, !1, !1), c.pendingChildren = d, tg(b), Bb(a, d);
          }
        }, xg = function(a, b, c, d, e) {
          var f = a.stateNode, g = a.memoizedProps;
          if ((a = ug(a, b)) && g === d) b.stateNode = f;
          else {
            var h = b.stateNode, k = re(oe.current), l = null;
            g !== d && (l = Ma(h, c, g, d, e, k)), a && l === null ? b.stateNode = f : (f = yb(f, l, c, g, d, b, a, h), La(f, c, d, e, k) && tg(b), b.stateNode = f, a ? tg(b) : vg(f, b, !1, !1));
          }
        }, yg = function(a, b, c, d) {
          c !== d ? (a = re(qe.current), c = re(oe.current), b.stateNode = Oa(d, a, c, b), tg(b)) : b.stateNode = a.stateNode;
        };
      } else wg = function() {
      }, xg = function() {
      }, yg = function() {
      };
      function Ag(a, b) {
        if (!F) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; b !== null; ) b.alternate !== null && (c = b), b = b.sibling;
            c === null ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; c !== null; ) c.alternate !== null && (d = c), c = c.sibling;
            d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function Q(a) {
        var b = a.alternate !== null && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; e !== null; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; e !== null; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        return a.subtreeFlags |= d, a.childLanes = c, b;
      }
      function Bg(a, b, c) {
        var d = b.pendingProps;
        switch (nd(b), b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return Q(b), null;
          case 1:
            return A(b.type) && nc(), Q(b), null;
          case 3:
            return c = b.stateNode, te(), q(z), q(x), ye(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (a === null || a.child === null) && (yd(b) ? tg(b) : a === null || a.memoizedState.isDehydrated && (b.flags & 256) === 0 || (b.flags |= 1024, rd !== null && (Cg(rd), rd = null))), wg(a, b), Q(b), null;
          case 5:
            ve(b), c = re(qe.current);
            var e = b.type;
            if (a !== null && b.stateNode != null) xg(a, b, e, d, c), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (b.stateNode === null) throw Error(n(166));
                return Q(b), null;
              }
              if (a = re(oe.current), yd(b)) {
                if (!Va) throw Error(n(175));
                a = Rb(b.stateNode, b.type, b.memoizedProps, c, a, b, !qd), b.updateQueue = a, a !== null && tg(b);
              } else {
                var f = Ja(e, d, c, a, b);
                vg(f, b, !1, !1), b.stateNode = f, La(f, e, d, c, a) && tg(b);
              }
              b.ref !== null && (b.flags |= 512, b.flags |= 2097152);
            }
            return Q(b), null;
          case 6:
            if (a && b.stateNode != null) yg(a, b, a.memoizedProps, d);
            else {
              if (typeof d != "string" && b.stateNode === null) throw Error(n(166));
              if (a = re(qe.current), c = re(oe.current), yd(b)) {
                if (!Va) throw Error(n(176));
                if (a = b.stateNode, c = b.memoizedProps, (d = Sb(a, c, b, !qd)) && (e = od, e !== null)) switch (e.tag) {
                  case 3:
                    $b(e.stateNode.containerInfo, a, c, (e.mode & 1) !== 0);
                    break;
                  case 5:
                    ac(e.type, e.memoizedProps, e.stateNode, a, c, (e.mode & 1) !== 0);
                }
                d && tg(b);
              } else b.stateNode = Oa(d, a, c, b);
            }
            return Q(b), null;
          case 13:
            if (q(I), d = b.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
              if (F && pd !== null && (b.mode & 1) !== 0 && (b.flags & 128) === 0) zd(), Ad(), b.flags |= 98560, e = !1;
              else if (e = yd(b), d !== null && d.dehydrated !== null) {
                if (a === null) {
                  if (!e) throw Error(n(318));
                  if (!Va) throw Error(n(344));
                  if (e = b.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(n(317));
                  Tb(e, b);
                } else Ad(), (b.flags & 128) === 0 && (b.memoizedState = null), b.flags |= 4;
                Q(b), e = !1;
              } else rd !== null && (Cg(rd), rd = null), e = !0;
              if (!e) return b.flags & 65536 ? b : null;
            }
            return (b.flags & 128) !== 0 ? (b.lanes = c, b) : (c = d !== null, c !== (a !== null && a.memoizedState !== null) && c && (b.child.flags |= 8192, (b.mode & 1) !== 0 && (a === null || (I.current & 1) !== 0 ? R === 0 && (R = 3) : ng())), b.updateQueue !== null && (b.flags |= 4), Q(b), null);
          case 4:
            return te(), wg(a, b), a === null && Xa(b.stateNode.containerInfo), Q(b), null;
          case 10:
            return Wd(b.type._context), Q(b), null;
          case 17:
            return A(b.type) && nc(), Q(b), null;
          case 19:
            if (q(I), e = b.memoizedState, e === null) return Q(b), null;
            if (d = (b.flags & 128) !== 0, f = e.rendering, f === null) if (d) Ag(e, !1);
            else {
              if (R !== 0 || a !== null && (a.flags & 128) !== 0) for (a = b.child; a !== null; ) {
                if (f = we(a), f !== null) {
                  for (b.flags |= 128, Ag(e, !1), a = f.updateQueue, a !== null && (b.updateQueue = a, b.flags |= 4), b.subtreeFlags = 0, a = c, c = b.child; c !== null; ) d = c, e = a, d.flags &= 14680066, f = d.alternate, f === null ? (d.childLanes = 0, d.lanes = e, d.child = null, d.subtreeFlags = 0, d.memoizedProps = null, d.memoizedState = null, d.updateQueue = null, d.dependencies = null, d.stateNode = null) : (d.childLanes = f.childLanes, d.lanes = f.lanes, d.child = f.child, d.subtreeFlags = 0, d.deletions = null, d.memoizedProps = f.memoizedProps, d.memoizedState = f.memoizedState, d.updateQueue = f.updateQueue, d.type = f.type, e = f.dependencies, d.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), c = c.sibling;
                  return v(I, I.current & 1 | 2), b.child;
                }
                a = a.sibling;
              }
              e.tail !== null && D() > Dg && (b.flags |= 128, d = !0, Ag(e, !1), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = we(f), a !== null) {
                if (b.flags |= 128, d = !0, a = a.updateQueue, a !== null && (b.updateQueue = a, b.flags |= 4), Ag(e, !0), e.tail === null && e.tailMode === "hidden" && !f.alternate && !F) return Q(b), null;
              } else 2 * D() - e.renderingStartTime > Dg && c !== 1073741824 && (b.flags |= 128, d = !0, Ag(e, !1), b.lanes = 4194304);
              e.isBackwards ? (f.sibling = b.child, b.child = f) : (a = e.last, a !== null ? a.sibling = f : b.child = f, e.last = f);
            }
            return e.tail !== null ? (b = e.tail, e.rendering = b, e.tail = b.sibling, e.renderingStartTime = D(), b.sibling = null, a = I.current, v(I, d ? a & 1 | 2 : a & 1), b) : (Q(b), null);
          case 22:
          case 23:
            return Eg(), c = b.memoizedState !== null, a !== null && a.memoizedState !== null !== c && (b.flags |= 8192), c && (b.mode & 1) !== 0 ? ($f & 1073741824) !== 0 && (Q(b), Ta && b.subtreeFlags & 6 && (b.flags |= 8192)) : Q(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(n(
          156,
          b.tag
        ));
      }
      function Fg(a, b) {
        switch (nd(b), b.tag) {
          case 1:
            return A(b.type) && nc(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return te(), q(z), q(x), ye(), a = b.flags, (a & 65536) !== 0 && (a & 128) === 0 ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return ve(b), null;
          case 13:
            if (q(I), a = b.memoizedState, a !== null && a.dehydrated !== null) {
              if (b.alternate === null) throw Error(n(340));
              Ad();
            }
            return a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return q(I), null;
          case 4:
            return te(), null;
          case 10:
            return Wd(b.type._context), null;
          case 22:
          case 23:
            return Eg(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Gg = !1, S = !1, Hg = typeof WeakSet == "function" ? WeakSet : Set, T = null;
      function Ig(a, b) {
        var c = a.ref;
        if (c !== null) if (typeof c == "function") try {
          c(null);
        } catch (d) {
          U(a, b, d);
        }
        else c.current = null;
      }
      function Jg(a, b, c) {
        try {
          c();
        } catch (d) {
          U(a, b, d);
        }
      }
      var Kg = !1;
      function Lg(a, b) {
        for (Ha(a.containerInfo), T = b; T !== null; ) if (a = T, b = a.child, (a.subtreeFlags & 1028) !== 0 && b !== null) b.return = a, T = b;
        else for (; T !== null; ) {
          a = T;
          try {
            var c = a.alternate;
            if ((a.flags & 1024) !== 0) switch (a.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (c !== null) {
                  var d = c.memoizedProps, e = c.memoizedState, f = a.stateNode, g = f.getSnapshotBeforeUpdate(a.elementType === a.type ? d : xf(a.type, d), e);
                  f.__reactInternalSnapshotBeforeUpdate = g;
                }
                break;
              case 3:
                Ta && xb(a.stateNode.containerInfo);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(n(163));
            }
          } catch (h) {
            U(a, a.return, h);
          }
          if (b = a.sibling, b !== null) {
            b.return = a.return, T = b;
            break;
          }
          T = a.return;
        }
        return c = Kg, Kg = !1, c;
      }
      function Mg(a, b, c) {
        var d = b.updateQueue;
        if (d = d !== null ? d.lastEffect : null, d !== null) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0, f !== void 0 && Jg(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Ng(a, b) {
        if (b = b.updateQueue, b = b !== null ? b.lastEffect : null, b !== null) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Og(a) {
        var b = a.ref;
        if (b !== null) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = Ea(c);
              break;
            default:
              a = c;
          }
          typeof b == "function" ? b(a) : b.current = a;
        }
      }
      function Pg(a) {
        var b = a.alternate;
        b !== null && (a.alternate = null, Pg(b)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (b = a.stateNode, b !== null && Za(b)), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
      }
      function Qg(a) {
        return a.tag === 5 || a.tag === 3 || a.tag === 4;
      }
      function Rg(a) {
        a: for (; ; ) {
          for (; a.sibling === null; ) {
            if (a.return === null || Qg(a.return)) return null;
            a = a.return;
          }
          for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
            if (a.flags & 2 || a.child === null || a.tag === 4) continue a;
            a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Sg(a, b, c) {
        var d = a.tag;
        if (d === 5 || d === 6) a = a.stateNode, b ? pb(c, a, b) : kb(c, a);
        else if (d !== 4 && (a = a.child, a !== null)) for (Sg(a, b, c), a = a.sibling; a !== null; ) Sg(a, b, c), a = a.sibling;
      }
      function Tg(a, b, c) {
        var d = a.tag;
        if (d === 5 || d === 6) a = a.stateNode, b ? ob(c, a, b) : jb(c, a);
        else if (d !== 4 && (a = a.child, a !== null)) for (Tg(a, b, c), a = a.sibling; a !== null; ) Tg(a, b, c), a = a.sibling;
      }
      var V = null, Ug = !1;
      function Vg(a, b, c) {
        for (c = c.child; c !== null; ) Wg(a, b, c), c = c.sibling;
      }
      function Wg(a, b, c) {
        if (Sc && typeof Sc.onCommitFiberUnmount == "function") try {
          Sc.onCommitFiberUnmount(Rc, c);
        } catch {
        }
        switch (c.tag) {
          case 5:
            S || Ig(c, b);
          case 6:
            if (Ta) {
              var d = V, e = Ug;
              V = null, Vg(a, b, c), V = d, Ug = e, V !== null && (Ug ? rb(V, c.stateNode) : qb(V, c.stateNode));
            } else Vg(a, b, c);
            break;
          case 18:
            Ta && V !== null && (Ug ? Yb(V, c.stateNode) : Xb(V, c.stateNode));
            break;
          case 4:
            Ta ? (d = V, e = Ug, V = c.stateNode.containerInfo, Ug = !0, Vg(a, b, c), V = d, Ug = e) : (Ua && (d = c.stateNode.containerInfo, e = zb(d), Cb(d, e)), Vg(a, b, c));
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!S && (d = c.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag, g !== void 0 && ((f & 2) !== 0 || (f & 4) !== 0) && Jg(c, b, g), e = e.next;
              } while (e !== d);
            }
            Vg(a, b, c);
            break;
          case 1:
            if (!S && (Ig(c, b), d = c.stateNode, typeof d.componentWillUnmount == "function")) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              U(c, b, h);
            }
            Vg(a, b, c);
            break;
          case 21:
            Vg(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (S = (d = S) || c.memoizedState !== null, Vg(a, b, c), S = d) : Vg(a, b, c);
            break;
          default:
            Vg(
              a,
              b,
              c
            );
        }
      }
      function Xg(a) {
        var b = a.updateQueue;
        if (b !== null) {
          a.updateQueue = null;
          var c = a.stateNode;
          c === null && (c = a.stateNode = new Hg()), b.forEach(function(b2) {
            var d = Yg.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function Zg(a, b) {
        var c = b.deletions;
        if (c !== null) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b;
            if (Ta) {
              var h = g;
              a: for (; h !== null; ) {
                switch (h.tag) {
                  case 5:
                    V = h.stateNode, Ug = !1;
                    break a;
                  case 3:
                    V = h.stateNode.containerInfo, Ug = !0;
                    break a;
                  case 4:
                    V = h.stateNode.containerInfo, Ug = !0;
                    break a;
                }
                h = h.return;
              }
              if (V === null) throw Error(n(160));
              Wg(f, g, e), V = null, Ug = !1;
            } else Wg(f, g, e);
            var k = e.alternate;
            k !== null && (k.return = null), e.return = null;
          } catch (l) {
            U(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; b !== null; ) $g(b, a), b = b.sibling;
      }
      function $g(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            if (Zg(b, a), ah(a), d & 4) {
              try {
                Mg(3, a, a.return), Ng(3, a);
              } catch (p) {
                U(a, a.return, p);
              }
              try {
                Mg(5, a, a.return);
              } catch (p) {
                U(a, a.return, p);
              }
            }
            break;
          case 1:
            Zg(b, a), ah(a), d & 512 && c !== null && Ig(c, c.return);
            break;
          case 5:
            if (Zg(b, a), ah(a), d & 512 && c !== null && Ig(c, c.return), Ta) {
              if (a.flags & 32) {
                var e = a.stateNode;
                try {
                  sb(e);
                } catch (p) {
                  U(a, a.return, p);
                }
              }
              if (d & 4 && (e = a.stateNode, e != null)) {
                var f = a.memoizedProps;
                if (c = c !== null ? c.memoizedProps : f, d = a.type, b = a.updateQueue, a.updateQueue = null, b !== null) try {
                  nb(e, b, d, c, f, a);
                } catch (p) {
                  U(a, a.return, p);
                }
              }
            }
            break;
          case 6:
            if (Zg(b, a), ah(a), d & 4 && Ta) {
              if (a.stateNode === null) throw Error(n(162));
              e = a.stateNode, f = a.memoizedProps, c = c !== null ? c.memoizedProps : f;
              try {
                lb(e, c, f);
              } catch (p) {
                U(a, a.return, p);
              }
            }
            break;
          case 3:
            if (Zg(b, a), ah(a), d & 4) {
              if (Ta && Va && c !== null && c.memoizedState.isDehydrated) try {
                Vb(b.containerInfo);
              } catch (p) {
                U(a, a.return, p);
              }
              if (Ua) {
                e = b.containerInfo, f = b.pendingChildren;
                try {
                  Cb(e, f);
                } catch (p) {
                  U(a, a.return, p);
                }
              }
            }
            break;
          case 4:
            if (Zg(
              b,
              a
            ), ah(a), d & 4 && Ua) {
              f = a.stateNode, e = f.containerInfo, f = f.pendingChildren;
              try {
                Cb(e, f);
              } catch (p) {
                U(a, a.return, p);
              }
            }
            break;
          case 13:
            Zg(b, a), ah(a), e = a.child, e.flags & 8192 && (f = e.memoizedState !== null, e.stateNode.isHidden = f, !f || e.alternate !== null && e.alternate.memoizedState !== null || (bh = D())), d & 4 && Xg(a);
            break;
          case 22:
            var g = c !== null && c.memoizedState !== null;
            if (a.mode & 1 ? (S = (c = S) || g, Zg(b, a), S = c) : Zg(b, a), ah(a), d & 8192) {
              if (c = a.memoizedState !== null, (a.stateNode.isHidden = c) && !g && (a.mode & 1) !== 0) for (T = a, d = a.child; d !== null; ) {
                for (b = T = d; T !== null; ) {
                  g = T;
                  var h = g.child;
                  switch (g.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Mg(4, g, g.return);
                      break;
                    case 1:
                      Ig(g, g.return);
                      var k = g.stateNode;
                      if (typeof k.componentWillUnmount == "function") {
                        var l = g, m = g.return;
                        try {
                          var r = l;
                          k.props = r.memoizedProps, k.state = r.memoizedState, k.componentWillUnmount();
                        } catch (p) {
                          U(l, m, p);
                        }
                      }
                      break;
                    case 5:
                      Ig(g, g.return);
                      break;
                    case 22:
                      if (g.memoizedState !== null) {
                        ch(b);
                        continue;
                      }
                  }
                  h !== null ? (h.return = g, T = h) : ch(b);
                }
                d = d.sibling;
              }
              if (Ta) {
                a: if (d = null, Ta) for (b = a; ; ) {
                  if (b.tag === 5) {
                    if (d === null) {
                      d = b;
                      try {
                        e = b.stateNode, c ? tb(e) : vb(b.stateNode, b.memoizedProps);
                      } catch (p) {
                        U(a, a.return, p);
                      }
                    }
                  } else if (b.tag === 6) {
                    if (d === null) try {
                      f = b.stateNode, c ? ub(f) : wb(f, b.memoizedProps);
                    } catch (p) {
                      U(a, a.return, p);
                    }
                  } else if ((b.tag !== 22 && b.tag !== 23 || b.memoizedState === null || b === a) && b.child !== null) {
                    b.child.return = b, b = b.child;
                    continue;
                  }
                  if (b === a) break a;
                  for (; b.sibling === null; ) {
                    if (b.return === null || b.return === a) break a;
                    d === b && (d = null), b = b.return;
                  }
                  d === b && (d = null), b.sibling.return = b.return, b = b.sibling;
                }
              }
            }
            break;
          case 19:
            Zg(b, a), ah(a), d & 4 && Xg(a);
            break;
          case 21:
            break;
          default:
            Zg(b, a), ah(a);
        }
      }
      function ah(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            if (Ta) {
              b: {
                for (var c = a.return; c !== null; ) {
                  if (Qg(c)) {
                    var d = c;
                    break b;
                  }
                  c = c.return;
                }
                throw Error(n(160));
              }
              switch (d.tag) {
                case 5:
                  var e = d.stateNode;
                  d.flags & 32 && (sb(e), d.flags &= -33);
                  var f = Rg(a);
                  Tg(a, f, e);
                  break;
                case 3:
                case 4:
                  var g = d.stateNode.containerInfo, h = Rg(a);
                  Sg(a, h, g);
                  break;
                default:
                  throw Error(n(161));
              }
            }
          } catch (k) {
            U(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function dh(a, b, c) {
        T = a, eh(a, b, c);
      }
      function eh(a, b, c) {
        for (var d = (a.mode & 1) !== 0; T !== null; ) {
          var e = T, f = e.child;
          if (e.tag === 22 && d) {
            var g = e.memoizedState !== null || Gg;
            if (!g) {
              var h = e.alternate, k = h !== null && h.memoizedState !== null || S;
              h = Gg;
              var l = S;
              if (Gg = g, (S = k) && !l) for (T = e; T !== null; ) g = T, k = g.child, g.tag === 22 && g.memoizedState !== null ? fh(e) : k !== null ? (k.return = g, T = k) : fh(e);
              for (; f !== null; ) T = f, eh(f, b, c), f = f.sibling;
              T = e, Gg = h, S = l;
            }
            gh(a, b, c);
          } else (e.subtreeFlags & 8772) !== 0 && f !== null ? (f.return = e, T = f) : gh(a, b, c);
        }
      }
      function gh(a) {
        for (; T !== null; ) {
          var b = T;
          if ((b.flags & 8772) !== 0) {
            var c = b.alternate;
            try {
              if ((b.flags & 8772) !== 0) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  S || Ng(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !S) if (c === null) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : xf(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  f !== null && me(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (g !== null) {
                    if (c = null, b.child !== null) switch (b.child.tag) {
                      case 5:
                        c = Ea(b.child.stateNode);
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    me(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  c === null && b.flags & 4 && mb(h, b.type, b.memoizedProps, b);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (Va && b.memoizedState === null) {
                    var k = b.alternate;
                    if (k !== null) {
                      var l = k.memoizedState;
                      if (l !== null) {
                        var m = l.dehydrated;
                        m !== null && Wb(m);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(n(163));
              }
              S || b.flags & 512 && Og(b);
            } catch (r) {
              U(b, b.return, r);
            }
          }
          if (b === a) {
            T = null;
            break;
          }
          if (c = b.sibling, c !== null) {
            c.return = b.return, T = c;
            break;
          }
          T = b.return;
        }
      }
      function ch(a) {
        for (; T !== null; ) {
          var b = T;
          if (b === a) {
            T = null;
            break;
          }
          var c = b.sibling;
          if (c !== null) {
            c.return = b.return, T = c;
            break;
          }
          T = b.return;
        }
      }
      function fh(a) {
        for (; T !== null; ) {
          var b = T;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Ng(4, b);
                } catch (k) {
                  U(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if (typeof d.componentDidMount == "function") {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    U(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Og(b);
                } catch (k) {
                  U(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Og(b);
                } catch (k) {
                  U(b, g, k);
                }
            }
          } catch (k) {
            U(b, b.return, k);
          }
          if (b === a) {
            T = null;
            break;
          }
          var h = b.sibling;
          if (h !== null) {
            h.return = b.return, T = h;
            break;
          }
          T = b.return;
        }
      }
      var hh = 0, ih = 1, jh = 2, kh = 3, lh = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var mh = Symbol.for;
        hh = mh("selector.component"), ih = mh("selector.has_pseudo_class"), jh = mh("selector.role"), kh = mh("selector.test_id"), lh = mh("selector.text");
      }
      function nh(a) {
        var b = Wa(a);
        if (b != null) {
          if (typeof b.memoizedProps["data-testname"] != "string") throw Error(n(364));
          return b;
        }
        if (a = cb(a), a === null) throw Error(n(362));
        return a.stateNode.current;
      }
      function oh(a, b) {
        switch (b.$$typeof) {
          case hh:
            if (a.type === b.value) return !0;
            break;
          case ih:
            a: {
              b = b.value, a = [a, 0];
              for (var c = 0; c < a.length; ) {
                var d = a[c++], e = a[c++], f = b[e];
                if (d.tag !== 5 || !fb(d)) {
                  for (; f != null && oh(d, f); ) e++, f = b[e];
                  if (e === b.length) {
                    b = !0;
                    break a;
                  } else for (d = d.child; d !== null; ) a.push(d, e), d = d.sibling;
                }
              }
              b = !1;
            }
            return b;
          case jh:
            if (a.tag === 5 && gb(a.stateNode, b.value)) return !0;
            break;
          case lh:
            if ((a.tag === 5 || a.tag === 6) && (a = eb(a), a !== null && 0 <= a.indexOf(b.value))) return !0;
            break;
          case kh:
            if (a.tag === 5 && (a = a.memoizedProps["data-testname"], typeof a == "string" && a.toLowerCase() === b.value.toLowerCase())) return !0;
            break;
          default:
            throw Error(n(365));
        }
        return !1;
      }
      function ph(a) {
        switch (a.$$typeof) {
          case hh:
            return "<" + (ua(a.value) || "Unknown") + ">";
          case ih:
            return ":has(" + (ph(a) || "") + ")";
          case jh:
            return '[role="' + a.value + '"]';
          case lh:
            return '"' + a.value + '"';
          case kh:
            return '[data-testname="' + a.value + '"]';
          default:
            throw Error(n(365));
        }
      }
      function qh(a, b) {
        var c = [];
        a = [a, 0];
        for (var d = 0; d < a.length; ) {
          var e = a[d++], f = a[d++], g = b[f];
          if (e.tag !== 5 || !fb(e)) {
            for (; g != null && oh(e, g); ) f++, g = b[f];
            if (f === b.length) c.push(e);
            else for (e = e.child; e !== null; ) a.push(e, f), e = e.sibling;
          }
        }
        return c;
      }
      function rh(a, b) {
        if (!bb) throw Error(n(363));
        a = nh(a), a = qh(a, b), b = [], a = Array.from(a);
        for (var c = 0; c < a.length; ) {
          var d = a[c++];
          if (d.tag === 5) fb(d) || b.push(d.stateNode);
          else for (d = d.child; d !== null; ) a.push(d), d = d.sibling;
        }
        return b;
      }
      var sh = Math.ceil, th = da.ReactCurrentDispatcher, uh = da.ReactCurrentOwner, W = da.ReactCurrentBatchConfig, H = 0, N = null, X = null, Z = 0, $f = 0, Zf = ic(0), R = 0, vh = null, le = 0, wh = 0, xh = 0, yh = null, zh = null, bh = 0, Dg = 1 / 0, Ah = null;
      function Bh() {
        Dg = D() + 500;
      }
      var Jf = !1, Kf = null, Mf = null, Ch = !1, Dh = null, Eh = 0, Fh = 0, Gh = null, Hh = -1, Ih = 0;
      function O() {
        return (H & 6) !== 0 ? D() : Hh !== -1 ? Hh : Hh = D();
      }
      function tf(a) {
        return (a.mode & 1) === 0 ? 1 : (H & 2) !== 0 && Z !== 0 ? Z & -Z : Cd.transition !== null ? (Ih === 0 && (Ih = Dc()), Ih) : (a = C, a !== 0 ? a : Ya());
      }
      function af(a, b, c, d) {
        if (50 < Fh) throw Fh = 0, Gh = null, Error(n(185));
        Fc(a, c, d), ((H & 2) === 0 || a !== N) && (a === N && ((H & 2) === 0 && (wh |= c), R === 4 && Jh(a, Z)), Kh(a, d), c === 1 && H === 0 && (b.mode & 1) === 0 && (Bh(), Xc && ad()));
      }
      function Kh(a, b) {
        var c = a.callbackNode;
        Bc(a, b);
        var d = zc(a, a === N ? Z : 0);
        if (d === 0) c !== null && Kc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          if (c != null && Kc(c), b === 1) a.tag === 0 ? $c(Lh.bind(null, a)) : Zc(Lh.bind(null, a)), $a ? ab(function() {
            (H & 6) === 0 && ad();
          }) : Jc(Nc, ad), c = null;
          else {
            switch (Ic(d)) {
              case 1:
                c = Nc;
                break;
              case 4:
                c = Oc;
                break;
              case 16:
                c = Pc;
                break;
              case 536870912:
                c = Qc;
                break;
              default:
                c = Pc;
            }
            c = Mh(c, Nh.bind(null, a));
          }
          a.callbackPriority = b, a.callbackNode = c;
        }
      }
      function Nh(a, b) {
        if (Hh = -1, Ih = 0, (H & 6) !== 0) throw Error(n(327));
        var c = a.callbackNode;
        if (Oh() && a.callbackNode !== c) return null;
        var d = zc(a, a === N ? Z : 0);
        if (d === 0) return null;
        if ((d & 30) !== 0 || (d & a.expiredLanes) !== 0 || b) b = Ph(a, d);
        else {
          b = d;
          var e = H;
          H |= 2;
          var f = Qh();
          (N !== a || Z !== b) && (Ah = null, Bh(), Rh(a, b));
          do
            try {
              Sh();
              break;
            } catch (h) {
              Th(a, h);
            }
          while (!0);
          Ud(), th.current = f, H = e, X !== null ? b = 0 : (N = null, Z = 0, b = R);
        }
        if (b !== 0) {
          if (b === 2 && (e = Cc(a), e !== 0 && (d = e, b = Uh(a, e))), b === 1) throw c = vh, Rh(a, 0), Jh(a, d), Kh(a, D()), c;
          if (b === 6) Jh(a, d);
          else {
            if (e = a.current.alternate, (d & 30) === 0 && !Vh(e) && (b = Ph(a, d), b === 2 && (f = Cc(a), f !== 0 && (d = f, b = Uh(a, f))), b === 1)) throw c = vh, Rh(a, 0), Jh(a, d), Kh(a, D()), c;
            switch (a.finishedWork = e, a.finishedLanes = d, b) {
              case 0:
              case 1:
                throw Error(n(345));
              case 2:
                Wh(a, zh, Ah);
                break;
              case 3:
                if (Jh(a, d), (d & 130023424) === d && (b = bh + 500 - D(), 10 < b)) {
                  if (zc(a, 0) !== 0) break;
                  if (e = a.suspendedLanes, (e & d) !== d) {
                    O(), a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Pa(Wh.bind(null, a, zh, Ah), b);
                  break;
                }
                Wh(a, zh, Ah);
                break;
              case 4:
                if (Jh(a, d), (d & 4194240) === d) break;
                for (b = a.eventTimes, e = -1; 0 < d; ) {
                  var g = 31 - tc(d);
                  f = 1 << g, g = b[g], g > e && (e = g), d &= ~f;
                }
                if (d = e, d = D() - d, d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * sh(d / 1960)) - d, 10 < d) {
                  a.timeoutHandle = Pa(Wh.bind(null, a, zh, Ah), d);
                  break;
                }
                Wh(a, zh, Ah);
                break;
              case 5:
                Wh(a, zh, Ah);
                break;
              default:
                throw Error(n(329));
            }
          }
        }
        return Kh(a, D()), a.callbackNode === c ? Nh.bind(null, a) : null;
      }
      function Uh(a, b) {
        var c = yh;
        return a.current.memoizedState.isDehydrated && (Rh(a, b).flags |= 256), a = Ph(a, b), a !== 2 && (b = zh, zh = c, b !== null && Cg(b)), a;
      }
      function Cg(a) {
        zh === null ? zh = a : zh.push.apply(zh, a);
      }
      function Vh(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (c !== null && (c = c.stores, c !== null)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!Vc(f(), e)) return !1;
              } catch {
                return !1;
              }
            }
          }
          if (c = b.child, b.subtreeFlags & 16384 && c !== null) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; b.sibling === null; ) {
              if (b.return === null || b.return === a) return !0;
              b = b.return;
            }
            b.sibling.return = b.return, b = b.sibling;
          }
        }
        return !0;
      }
      function Jh(a, b) {
        for (b &= ~xh, b &= ~wh, a.suspendedLanes |= b, a.pingedLanes &= ~b, a = a.expirationTimes; 0 < b; ) {
          var c = 31 - tc(b), d = 1 << c;
          a[c] = -1, b &= ~d;
        }
      }
      function Lh(a) {
        if ((H & 6) !== 0) throw Error(n(327));
        Oh();
        var b = zc(a, 0);
        if ((b & 1) === 0) return Kh(a, D()), null;
        var c = Ph(a, b);
        if (a.tag !== 0 && c === 2) {
          var d = Cc(a);
          d !== 0 && (b = d, c = Uh(a, d));
        }
        if (c === 1) throw c = vh, Rh(a, 0), Jh(a, b), Kh(a, D()), c;
        if (c === 6) throw Error(n(345));
        return a.finishedWork = a.current.alternate, a.finishedLanes = b, Wh(a, zh, Ah), Kh(a, D()), null;
      }
      function Xh(a) {
        Dh !== null && Dh.tag === 0 && (H & 6) === 0 && Oh();
        var b = H;
        H |= 1;
        var c = W.transition, d = C;
        try {
          if (W.transition = null, C = 1, a) return a();
        } finally {
          C = d, W.transition = c, H = b, (H & 6) === 0 && ad();
        }
      }
      function Eg() {
        $f = Zf.current, q(Zf);
      }
      function Rh(a, b) {
        a.finishedWork = null, a.finishedLanes = 0;
        var c = a.timeoutHandle;
        if (c !== Ra && (a.timeoutHandle = Ra, Qa(c)), X !== null) for (c = X.return; c !== null; ) {
          var d = c;
          switch (nd(d), d.tag) {
            case 1:
              d = d.type.childContextTypes, d != null && nc();
              break;
            case 3:
              te(), q(z), q(x), ye();
              break;
            case 5:
              ve(d);
              break;
            case 4:
              te();
              break;
            case 13:
              q(I);
              break;
            case 19:
              q(I);
              break;
            case 10:
              Wd(d.type._context);
              break;
            case 22:
            case 23:
              Eg();
          }
          c = c.return;
        }
        if (N = a, X = a = Jd(a.current, null), Z = $f = b, R = 0, vh = null, xh = wh = le = 0, zh = yh = null, $d !== null) {
          for (b = 0; b < $d.length; b++) if (c = $d[b], d = c.interleaved, d !== null) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (f !== null) {
              var g = f.next;
              f.next = e, d.next = g;
            }
            c.pending = d;
          }
          $d = null;
        }
        return a;
      }
      function Th(a, b) {
        do {
          var c = X;
          try {
            if (Ud(), ze.current = Le, Ce) {
              for (var d = J.memoizedState; d !== null; ) {
                var e = d.queue;
                e !== null && (e.pending = null), d = d.next;
              }
              Ce = !1;
            }
            if (Be = 0, L = K = J = null, De = !1, Ee = 0, uh.current = null, c === null || c.return === null) {
              R = 1, vh = b, X = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              if (b = Z, h.flags |= 32768, k !== null && typeof k == "object" && typeof k.then == "function") {
                var l = k, m = h, r = m.tag;
                if ((m.mode & 1) === 0 && (r === 0 || r === 11 || r === 15)) {
                  var p = m.alternate;
                  p ? (m.updateQueue = p.updateQueue, m.memoizedState = p.memoizedState, m.lanes = p.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var B = Pf(g);
                if (B !== null) {
                  B.flags &= -257, Qf(B, g, h, f, b), B.mode & 1 && Nf(f, l, b), b = B, k = l;
                  var w = b.updateQueue;
                  if (w === null) {
                    var Y = /* @__PURE__ */ new Set();
                    Y.add(k), b.updateQueue = Y;
                  } else w.add(k);
                  break a;
                } else {
                  if ((b & 1) === 0) {
                    Nf(f, l, b), ng();
                    break a;
                  }
                  k = Error(n(426));
                }
              } else if (F && h.mode & 1) {
                var ya = Pf(g);
                if (ya !== null) {
                  (ya.flags & 65536) === 0 && (ya.flags |= 256), Qf(ya, g, h, f, b), Bd(Ef(k, h));
                  break a;
                }
              }
              f = k = Ef(k, h), R !== 4 && (R = 2), yh === null ? yh = [f] : yh.push(f), f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536, b &= -b, f.lanes |= b;
                    var E2 = If(f, k, b);
                    je(f, E2);
                    break a;
                  case 1:
                    h = k;
                    var u = f.type, t = f.stateNode;
                    if ((f.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || t !== null && typeof t.componentDidCatch == "function" && (Mf === null || !Mf.has(t)))) {
                      f.flags |= 65536, b &= -b, f.lanes |= b;
                      var Db = Lf(f, h, b);
                      je(f, Db);
                      break a;
                    }
                }
                f = f.return;
              } while (f !== null);
            }
            Yh(c);
          } catch (lc) {
            b = lc, X === c && c !== null && (X = c = c.return);
            continue;
          }
          break;
        } while (!0);
      }
      function Qh() {
        var a = th.current;
        return th.current = Le, a === null ? Le : a;
      }
      function ng() {
        (R === 0 || R === 3 || R === 2) && (R = 4), N === null || (le & 268435455) === 0 && (wh & 268435455) === 0 || Jh(N, Z);
      }
      function Ph(a, b) {
        var c = H;
        H |= 2;
        var d = Qh();
        (N !== a || Z !== b) && (Ah = null, Rh(a, b));
        do
          try {
            Zh();
            break;
          } catch (e) {
            Th(a, e);
          }
        while (!0);
        if (Ud(), H = c, th.current = d, X !== null) throw Error(n(261));
        return N = null, Z = 0, R;
      }
      function Zh() {
        for (; X !== null; ) $h(X);
      }
      function Sh() {
        for (; X !== null && !Lc(); ) $h(X);
      }
      function $h(a) {
        var b = ai(a.alternate, a, $f);
        a.memoizedProps = a.pendingProps, b === null ? Yh(a) : X = b, uh.current = null;
      }
      function Yh(a) {
        var b = a;
        do {
          var c = b.alternate;
          if (a = b.return, (b.flags & 32768) === 0) {
            if (c = Bg(c, b, $f), c !== null) {
              X = c;
              return;
            }
          } else {
            if (c = Fg(c, b), c !== null) {
              c.flags &= 32767, X = c;
              return;
            }
            if (a !== null) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              R = 6, X = null;
              return;
            }
          }
          if (b = b.sibling, b !== null) {
            X = b;
            return;
          }
          X = b = a;
        } while (b !== null);
        R === 0 && (R = 5);
      }
      function Wh(a, b, c) {
        var d = C, e = W.transition;
        try {
          W.transition = null, C = 1, bi(a, b, c, d);
        } finally {
          W.transition = e, C = d;
        }
        return null;
      }
      function bi(a, b, c, d) {
        do
          Oh();
        while (Dh !== null);
        if ((H & 6) !== 0) throw Error(n(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (c === null) return null;
        if (a.finishedWork = null, a.finishedLanes = 0, c === a.current) throw Error(n(177));
        a.callbackNode = null, a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        if (Gc(a, f), a === N && (X = N = null, Z = 0), (c.subtreeFlags & 2064) === 0 && (c.flags & 2064) === 0 || Ch || (Ch = !0, Mh(Pc, function() {
          return Oh(), null;
        })), f = (c.flags & 15990) !== 0, (c.subtreeFlags & 15990) !== 0 || f) {
          f = W.transition, W.transition = null;
          var g = C;
          C = 1;
          var h = H;
          H |= 4, uh.current = null, Lg(a, c), $g(c, a), Ia(a.containerInfo), a.current = c, dh(c, a, e), Mc(), H = h, C = g, W.transition = f;
        } else a.current = c;
        if (Ch && (Ch = !1, Dh = a, Eh = e), f = a.pendingLanes, f === 0 && (Mf = null), Tc(c.stateNode, d), Kh(a, D()), b !== null) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Jf) throw Jf = !1, a = Kf, Kf = null, a;
        return (Eh & 1) !== 0 && a.tag !== 0 && Oh(), f = a.pendingLanes, (f & 1) !== 0 ? a === Gh ? Fh++ : (Fh = 0, Gh = a) : Fh = 0, ad(), null;
      }
      function Oh() {
        if (Dh !== null) {
          var a = Ic(Eh), b = W.transition, c = C;
          try {
            if (W.transition = null, C = 16 > a ? 16 : a, Dh === null) var d = !1;
            else {
              if (a = Dh, Dh = null, Eh = 0, (H & 6) !== 0) throw Error(n(331));
              var e = H;
              for (H |= 4, T = a.current; T !== null; ) {
                var f = T, g = f.child;
                if ((T.flags & 16) !== 0) {
                  var h = f.deletions;
                  if (h !== null) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (T = l; T !== null; ) {
                        var m = T;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Mg(8, m, f);
                        }
                        var r = m.child;
                        if (r !== null) r.return = m, T = r;
                        else for (; T !== null; ) {
                          m = T;
                          var p = m.sibling, B = m.return;
                          if (Pg(m), m === l) {
                            T = null;
                            break;
                          }
                          if (p !== null) {
                            p.return = B, T = p;
                            break;
                          }
                          T = B;
                        }
                      }
                    }
                    var w = f.alternate;
                    if (w !== null) {
                      var Y = w.child;
                      if (Y !== null) {
                        w.child = null;
                        do {
                          var ya = Y.sibling;
                          Y.sibling = null, Y = ya;
                        } while (Y !== null);
                      }
                    }
                    T = f;
                  }
                }
                if ((f.subtreeFlags & 2064) !== 0 && g !== null) g.return = f, T = g;
                else b: for (; T !== null; ) {
                  if (f = T, (f.flags & 2048) !== 0) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Mg(9, f, f.return);
                  }
                  var E2 = f.sibling;
                  if (E2 !== null) {
                    E2.return = f.return, T = E2;
                    break b;
                  }
                  T = f.return;
                }
              }
              var u = a.current;
              for (T = u; T !== null; ) {
                g = T;
                var t = g.child;
                if ((g.subtreeFlags & 2064) !== 0 && t !== null) t.return = g, T = t;
                else b: for (g = u; T !== null; ) {
                  if (h = T, (h.flags & 2048) !== 0) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ng(9, h);
                    }
                  } catch (lc) {
                    U(h, h.return, lc);
                  }
                  if (h === g) {
                    T = null;
                    break b;
                  }
                  var Db = h.sibling;
                  if (Db !== null) {
                    Db.return = h.return, T = Db;
                    break b;
                  }
                  T = h.return;
                }
              }
              if (H = e, ad(), Sc && typeof Sc.onPostCommitFiberRoot == "function") try {
                Sc.onPostCommitFiberRoot(Rc, a);
              } catch {
              }
              d = !0;
            }
            return d;
          } finally {
            C = c, W.transition = b;
          }
        }
        return !1;
      }
      function ci(a, b, c) {
        b = Ef(c, b), b = If(a, b, 1), a = he(a, b, 1), b = O(), a !== null && (Fc(a, 1, b), Kh(a, b));
      }
      function U(a, b, c) {
        if (a.tag === 3) ci(a, a, c);
        else for (; b !== null; ) {
          if (b.tag === 3) {
            ci(b, a, c);
            break;
          } else if (b.tag === 1) {
            var d = b.stateNode;
            if (typeof b.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Mf === null || !Mf.has(d))) {
              a = Ef(c, a), a = Lf(b, a, 1), b = he(b, a, 1), a = O(), b !== null && (Fc(b, 1, a), Kh(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Of(a, b, c) {
        var d = a.pingCache;
        d !== null && d.delete(b), b = O(), a.pingedLanes |= a.suspendedLanes & c, N === a && (Z & c) === c && (R === 4 || R === 3 && (Z & 130023424) === Z && 500 > D() - bh ? Rh(a, 0) : xh |= c), Kh(a, b);
      }
      function di(a, b) {
        b === 0 && ((a.mode & 1) === 0 ? b = 1 : (b = xc, xc <<= 1, (xc & 130023424) === 0 && (xc = 4194304)));
        var c = O();
        a = ce(a, b), a !== null && (Fc(a, b, c), Kh(a, c));
      }
      function og(a) {
        var b = a.memoizedState, c = 0;
        b !== null && (c = b.retryLane), di(a, c);
      }
      function Yg(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode, e = a.memoizedState;
            e !== null && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(n(314));
        }
        d !== null && d.delete(b), di(a, c);
      }
      var ai;
      ai = function(a, b, c) {
        if (a !== null) if (a.memoizedProps !== b.pendingProps || z.current) G = !0;
        else {
          if ((a.lanes & c) === 0 && (b.flags & 128) === 0) return G = !1, sg(a, b, c);
          G = (a.flags & 131072) !== 0;
        }
        else G = !1, F && (b.flags & 1048576) !== 0 && ld(b, ed, b.index);
        switch (b.lanes = 0, b.tag) {
          case 2:
            var d = b.type;
            cg(a, b), a = b.pendingProps;
            var e = mc(b, x.current);
            Yd(b, c), e = He(null, b, d, a, e, c);
            var f = Me();
            return b.flags |= 1, typeof e == "object" && e !== null && typeof e.render == "function" && e.$$typeof === void 0 ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, A(d) ? (f = !0, qc(b)) : f = !1, b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, ee(b), e.updater = zf, b.stateNode = e, e._reactInternals = b, Df(b, d, a, c), b = dg(null, b, d, !0, f, c)) : (b.tag = 0, F && f && md(b), P(null, b, e, c), b = b.child), b;
          case 16:
            d = b.elementType;
            a: {
              switch (cg(a, b), a = b.pendingProps, e = d._init, d = e(d._payload), b.type = d, e = b.tag = ei(d), a = xf(d, a), e) {
                case 0:
                  b = Xf(null, b, d, a, c);
                  break a;
                case 1:
                  b = bg(null, b, d, a, c);
                  break a;
                case 11:
                  b = Sf(null, b, d, a, c);
                  break a;
                case 14:
                  b = Uf(null, b, d, xf(d.type, a), c);
                  break a;
              }
              throw Error(n(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), Xf(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), bg(a, b, d, e, c);
          case 3:
            a: {
              if (eg(b), a === null) throw Error(n(387));
              d = b.pendingProps, f = b.memoizedState, e = f.element, fe(a, b), ke(b, d, null, c);
              var g = b.memoizedState;
              if (d = g.element, Va && f.isDehydrated) if (f = { element: d, isDehydrated: !1, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ef(Error(n(423)), b), b = fg(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ef(Error(n(424)), b), b = fg(a, b, d, c, e);
                break a;
              } else for (Va && (pd = Pb(b.stateNode.containerInfo), od = b, F = !0, rd = null, qd = !1), c = Pd(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                if (Ad(), d === e) {
                  b = Tf(a, b, c);
                  break a;
                }
                P(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return ue(b), a === null && wd(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, Na(d, e) ? g = null : f !== null && Na(d, f) && (b.flags |= 32), ag(a, b), P(a, b, g, c), b.child;
          case 6:
            return a === null && wd(b), null;
          case 13:
            return ig(a, b, c);
          case 4:
            return se(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Od(b, null, d, c) : P(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), Sf(a, b, d, e, c);
          case 7:
            return P(a, b, b.pendingProps, c), b.child;
          case 8:
            return P(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return P(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              if (d = b.type._context, e = b.pendingProps, f = b.memoizedProps, g = e.value, Vd(b, d, g), f !== null) if (Vc(f.value, g)) {
                if (f.children === e.children && !z.current) {
                  b = Tf(a, b, c);
                  break a;
                }
              } else for (f = b.child, f !== null && (f.return = b); f !== null; ) {
                var h = f.dependencies;
                if (h !== null) {
                  g = f.child;
                  for (var k = h.firstContext; k !== null; ) {
                    if (k.context === d) {
                      if (f.tag === 1) {
                        k = ge(-1, c & -c), k.tag = 2;
                        var l = f.updateQueue;
                        if (l !== null) {
                          l = l.shared;
                          var m = l.pending;
                          m === null ? k.next = k : (k.next = m.next, m.next = k), l.pending = k;
                        }
                      }
                      f.lanes |= c, k = f.alternate, k !== null && (k.lanes |= c), Xd(f.return, c, b), h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (f.tag === 10) g = f.type === b.type ? null : f.child;
                else if (f.tag === 18) {
                  if (g = f.return, g === null) throw Error(n(341));
                  g.lanes |= c, h = g.alternate, h !== null && (h.lanes |= c), Xd(g, c, b), g = f.sibling;
                } else g = f.child;
                if (g !== null) g.return = f;
                else for (g = f; g !== null; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  if (f = g.sibling, f !== null) {
                    f.return = g.return, g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              P(a, b, e.children, c), b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, Yd(b, c), e = Zd(e), d = d(e), b.flags |= 1, P(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = xf(d, b.pendingProps), e = xf(d.type, e), Uf(a, b, d, e, c);
          case 15:
            return Wf(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : xf(d, e), cg(a, b), b.tag = 1, A(d) ? (a = !0, qc(b)) : a = !1, Yd(b, c), Bf(b, d, e), Df(b, d, e, c), dg(null, b, d, !0, a, c);
          case 19:
            return rg(a, b, c);
          case 22:
            return Yf(a, b, c);
        }
        throw Error(n(156, b.tag));
      };
      function Mh(a, b) {
        return Jc(a, b);
      }
      function fi(a, b, c, d) {
        this.tag = a, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function td(a, b, c, d) {
        return new fi(a, b, c, d);
      }
      function Vf(a) {
        return a = a.prototype, !(!a || !a.isReactComponent);
      }
      function ei(a) {
        if (typeof a == "function") return Vf(a) ? 1 : 0;
        if (a != null) {
          if (a = a.$$typeof, a === ma) return 11;
          if (a === pa) return 14;
        }
        return 2;
      }
      function Jd(a, b) {
        var c = a.alternate;
        return c === null ? (c = td(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = a.flags & 14680064, c.childLanes = a.childLanes, c.lanes = a.lanes, c.child = a.child, c.memoizedProps = a.memoizedProps, c.memoizedState = a.memoizedState, c.updateQueue = a.updateQueue, b = a.dependencies, c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext }, c.sibling = a.sibling, c.index = a.index, c.ref = a.ref, c;
      }
      function Ld(a, b, c, d, e, f) {
        var g = 2;
        if (d = a, typeof a == "function") Vf(a) && (g = 1);
        else if (typeof a == "string") g = 5;
        else a: switch (a) {
          case ha:
            return Nd(c.children, e, f, b);
          case ia:
            g = 8, e |= 8;
            break;
          case ja:
            return a = td(12, c, b, e | 2), a.elementType = ja, a.lanes = f, a;
          case na:
            return a = td(13, c, b, e), a.elementType = na, a.lanes = f, a;
          case oa:
            return a = td(19, c, b, e), a.elementType = oa, a.lanes = f, a;
          case ra:
            return jg(c, e, f, b);
          default:
            if (typeof a == "object" && a !== null) switch (a.$$typeof) {
              case ka:
                g = 10;
                break a;
              case la:
                g = 9;
                break a;
              case ma:
                g = 11;
                break a;
              case pa:
                g = 14;
                break a;
              case qa:
                g = 16, d = null;
                break a;
            }
            throw Error(n(130, a == null ? a : typeof a, ""));
        }
        return b = td(g, c, b, e), b.elementType = a, b.type = d, b.lanes = f, b;
      }
      function Nd(a, b, c, d) {
        return a = td(7, a, d, b), a.lanes = c, a;
      }
      function jg(a, b, c, d) {
        return a = td(22, a, d, b), a.elementType = ra, a.lanes = c, a.stateNode = { isHidden: !1 }, a;
      }
      function Kd(a, b, c) {
        return a = td(6, a, null, b), a.lanes = c, a;
      }
      function Md(a, b, c) {
        return b = td(4, a.children !== null ? a.children : [], a.key, b), b.lanes = c, b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, b;
      }
      function gi(a, b, c, d, e) {
        this.tag = b, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ra, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ec(0), this.expirationTimes = Ec(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ec(0), this.identifierPrefix = d, this.onRecoverableError = e, Va && (this.mutableSourceEagerHydrationData = null);
      }
      function hi(a, b, c, d, e, f, g, h, k) {
        return a = new gi(a, b, c, h, k), b === 1 ? (b = 1, f === !0 && (b |= 8)) : b = 0, f = td(3, null, null, b), a.current = f, f.stateNode = a, f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ee(f), a;
      }
      function ii(a) {
        if (!a) return jc;
        a = a._reactInternals;
        a: {
          if (wa(a) !== a || a.tag !== 1) throw Error(n(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (A(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (b !== null);
          throw Error(n(171));
        }
        if (a.tag === 1) {
          var c = a.type;
          if (A(c)) return pc(a, c, b);
        }
        return b;
      }
      function ji(a) {
        var b = a._reactInternals;
        if (b === void 0)
          throw typeof a.render == "function" ? Error(n(188)) : (a = Object.keys(a).join(","), Error(n(268, a)));
        return a = Aa(b), a === null ? null : a.stateNode;
      }
      function ki(a, b) {
        if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
          var c = a.retryLane;
          a.retryLane = c !== 0 && c < b ? c : b;
        }
      }
      function li(a, b) {
        ki(a, b), (a = a.alternate) && ki(a, b);
      }
      function mi(a) {
        return a = Aa(a), a === null ? null : a.stateNode;
      }
      function ni() {
        return null;
      }
      return exports2.attemptContinuousHydration = function(a) {
        if (a.tag === 13) {
          var b = ce(a, 134217728);
          if (b !== null) {
            var c = O();
            af(b, a, 134217728, c);
          }
          li(a, 134217728);
        }
      }, exports2.attemptDiscreteHydration = function(a) {
        if (a.tag === 13) {
          var b = ce(a, 1);
          if (b !== null) {
            var c = O();
            af(b, a, 1, c);
          }
          li(a, 1);
        }
      }, exports2.attemptHydrationAtCurrentPriority = function(a) {
        if (a.tag === 13) {
          var b = tf(a), c = ce(a, b);
          if (c !== null) {
            var d = O();
            af(c, a, b, d);
          }
          li(a, b);
        }
      }, exports2.attemptSynchronousHydration = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = yc(b.pendingLanes);
              c !== 0 && (Hc(b, c | 1), Kh(b, D()), (H & 6) === 0 && (Bh(), ad()));
            }
            break;
          case 13:
            Xh(function() {
              var b2 = ce(a, 1);
              if (b2 !== null) {
                var c2 = O();
                af(b2, a, 1, c2);
              }
            }), li(a, 1);
        }
      }, exports2.batchedUpdates = function(a, b) {
        var c = H;
        H |= 1;
        try {
          return a(b);
        } finally {
          H = c, H === 0 && (Bh(), Xc && ad());
        }
      }, exports2.createComponentSelector = function(a) {
        return { $$typeof: hh, value: a };
      }, exports2.createContainer = function(a, b, c, d, e, f, g) {
        return hi(a, b, !1, null, c, d, e, f, g);
      }, exports2.createHasPseudoClassSelector = function(a) {
        return { $$typeof: ih, value: a };
      }, exports2.createHydrationContainer = function(a, b, c, d, e, f, g, h, k) {
        return a = hi(c, d, !0, a, e, f, g, h, k), a.context = ii(null), c = a.current, d = O(), e = tf(c), f = ge(d, e), f.callback = b ?? null, he(c, f, e), a.current.lanes = e, Fc(a, e, d), Kh(a, d), a;
      }, exports2.createPortal = function(a, b, c) {
        var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return { $$typeof: fa, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }, exports2.createRoleSelector = function(a) {
        return { $$typeof: jh, value: a };
      }, exports2.createTestNameSelector = function(a) {
        return { $$typeof: kh, value: a };
      }, exports2.createTextSelector = function(a) {
        return { $$typeof: lh, value: a };
      }, exports2.deferredUpdates = function(a) {
        var b = C, c = W.transition;
        try {
          return W.transition = null, C = 16, a();
        } finally {
          C = b, W.transition = c;
        }
      }, exports2.discreteUpdates = function(a, b, c, d, e) {
        var f = C, g = W.transition;
        try {
          return W.transition = null, C = 1, a(b, c, d, e);
        } finally {
          C = f, W.transition = g, H === 0 && Bh();
        }
      }, exports2.findAllNodes = rh, exports2.findBoundingRects = function(a, b) {
        if (!bb) throw Error(n(363));
        b = rh(a, b), a = [];
        for (var c = 0; c < b.length; c++) a.push(db(b[c]));
        for (b = a.length - 1; 0 < b; b--) {
          c = a[b];
          for (var d = c.x, e = d + c.width, f = c.y, g = f + c.height, h = b - 1; 0 <= h; h--) if (b !== h) {
            var k = a[h], l = k.x, m = l + k.width, r = k.y, p = r + k.height;
            if (d >= l && f >= r && e <= m && g <= p) {
              a.splice(b, 1);
              break;
            } else if (d !== l || c.width !== k.width || p < f || r > g) {
              if (!(f !== r || c.height !== k.height || m < d || l > e)) {
                l > d && (k.width += l - d, k.x = d), m < e && (k.width = e - l), a.splice(b, 1);
                break;
              }
            } else {
              r > f && (k.height += r - f, k.y = f), p < g && (k.height = g - r), a.splice(b, 1);
              break;
            }
          }
        }
        return a;
      }, exports2.findHostInstance = ji, exports2.findHostInstanceWithNoPortals = function(a) {
        return a = za(a), a = a !== null ? Ca(a) : null, a === null ? null : a.stateNode;
      }, exports2.findHostInstanceWithWarning = function(a) {
        return ji(a);
      }, exports2.flushControlled = function(a) {
        var b = H;
        H |= 1;
        var c = W.transition, d = C;
        try {
          W.transition = null, C = 1, a();
        } finally {
          C = d, W.transition = c, H = b, H === 0 && (Bh(), ad());
        }
      }, exports2.flushPassiveEffects = Oh, exports2.flushSync = Xh, exports2.focusWithin = function(a, b) {
        if (!bb) throw Error(n(363));
        for (a = nh(a), b = qh(a, b), b = Array.from(b), a = 0; a < b.length; ) {
          var c = b[a++];
          if (!fb(c)) {
            if (c.tag === 5 && hb(c.stateNode)) return !0;
            for (c = c.child; c !== null; ) b.push(c), c = c.sibling;
          }
        }
        return !1;
      }, exports2.getCurrentUpdatePriority = function() {
        return C;
      }, exports2.getFindAllNodesFailureDescription = function(a, b) {
        if (!bb) throw Error(n(363));
        var c = 0, d = [];
        a = [nh(a), 0];
        for (var e = 0; e < a.length; ) {
          var f = a[e++], g = a[e++], h = b[g];
          if ((f.tag !== 5 || !fb(f)) && (oh(f, h) && (d.push(ph(h)), g++, g > c && (c = g)), g < b.length)) for (f = f.child; f !== null; ) a.push(f, g), f = f.sibling;
        }
        if (c < b.length) {
          for (a = []; c < b.length; c++) a.push(ph(b[c]));
          return `findAllNodes was able to match part of the selector:
  ` + (d.join(" > ") + `

No matching component was found for:
  `) + a.join(" > ");
        }
        return null;
      }, exports2.getPublicRootInstance = function(a) {
        if (a = a.current, !a.child) return null;
        switch (a.child.tag) {
          case 5:
            return Ea(a.child.stateNode);
          default:
            return a.child.stateNode;
        }
      }, exports2.injectIntoDevTools = function(a) {
        if (a = { bundleType: a.bundleType, version: a.version, rendererPackageName: a.rendererPackageName, rendererConfig: a.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: da.ReactCurrentDispatcher, findHostInstanceByFiber: mi, findFiberByHostInstance: a.findFiberByHostInstance || ni, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") a = !1;
        else {
          var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (b.isDisabled || !b.supportsFiber) a = !0;
          else {
            try {
              Rc = b.inject(a), Sc = b;
            } catch {
            }
            a = !!b.checkDCE;
          }
        }
        return a;
      }, exports2.isAlreadyRendering = function() {
        return !1;
      }, exports2.observeVisibleRects = function(a, b, c, d) {
        if (!bb) throw Error(n(363));
        a = rh(a, b);
        var e = ib(a, c, d).disconnect;
        return { disconnect: function() {
          e();
        } };
      }, exports2.registerMutableSourceForHydration = function(a, b) {
        var c = b._getVersion;
        c = c(b._source), a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [b, c] : a.mutableSourceEagerHydrationData.push(b, c);
      }, exports2.runWithPriority = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      }, exports2.shouldError = function() {
        return null;
      }, exports2.shouldSuspend = function() {
        return !1;
      }, exports2.updateContainer = function(a, b, c, d) {
        var e = b.current, f = O(), g = tf(e);
        return c = ii(c), b.context === null ? b.context = c : b.pendingContext = c, b = ge(f, g), b.payload = { element: a }, d = d === void 0 ? null : d, d !== null && (b.callback = d), a = he(e, b, g), a !== null && (af(a, e, g, f), ie(a, e, g)), g;
      }, exports2;
    };
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler.development.js
var require_react_reconciler_development = __commonJS({
  "../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler.development.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV !== "production" && (module.exports = function($$$hostConfig) {
      var exports2 = {}, React41 = require_react(), Scheduler = require_scheduler(), ReactSharedInternals = React41.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, suppressWarning = !1;
      function setSuppressWarning(newSuppressWarning) {
        suppressWarning = newSuppressWarning;
      }
      function warn(format) {
        if (!suppressWarning) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          printWarning("warn", format, args);
        }
      }
      function error(format) {
        if (!suppressWarning) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          printWarning("error", format, args);
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
          stack !== "" && (format += "%s", args = args.concat([stack]));
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var assign = Object.assign;
      function get(key) {
        return key._reactInternals;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var enableNewReconciler = !1, enableLazyContextPropagation = !1, enableLegacyHidden = !1, enableSuspenseAvoidThisFallback = !1, warnAboutStringRefs = !0, enableSchedulingProfiler = !0, enableProfilerTimer = !0, enableProfilerCommitHooks = !0, FunctionComponent = 0, ClassComponent = 1, IndeterminateComponent = 2, HostRoot = 3, HostPortal = 4, HostComponent = 5, HostText = 6, Fragment = 7, Mode = 8, ContextConsumer = 9, ContextProvider = 10, ForwardRef = 11, Profiler = 12, SuspenseComponent = 13, MemoComponent = 14, SimpleMemoComponent = 15, LazyComponent = 16, IncompleteClassComponent = 17, DehydratedFragment = 18, SuspenseListComponent = 19, ScopeComponent = 21, OffscreenComponent = 22, LegacyHiddenComponent = 23, CacheComponent = 24, TracingMarkerComponent = 25, REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_CACHE_TYPE = Symbol.for("react.cache"), REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable != "object")
          return null;
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        return typeof maybeIterator == "function" ? maybeIterator : null;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName)
          return displayName;
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null)
          return null;
        if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
          return type.displayName || type.name || null;
        if (typeof type == "string")
          return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      function getWrappedName$1(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName$1(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromFiber(fiber) {
        var tag = fiber.tag, type = fiber.type;
        switch (tag) {
          case CacheComponent:
            return "Cache";
          case ContextConsumer:
            var context = type;
            return getContextName$1(context) + ".Consumer";
          case ContextProvider:
            var provider = type;
            return getContextName$1(provider._context) + ".Provider";
          case DehydratedFragment:
            return "DehydratedFragment";
          case ForwardRef:
            return getWrappedName$1(type, type.render, "ForwardRef");
          case Fragment:
            return "Fragment";
          case HostComponent:
            return type;
          case HostPortal:
            return "Portal";
          case HostRoot:
            return "Root";
          case HostText:
            return "Text";
          case LazyComponent:
            return getComponentNameFromType(type);
          case Mode:
            return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
          case OffscreenComponent:
            return "Offscreen";
          case Profiler:
            return "Profiler";
          case ScopeComponent:
            return "Scope";
          case SuspenseComponent:
            return "Suspense";
          case SuspenseListComponent:
            return "SuspenseList";
          case TracingMarkerComponent:
            return "TracingMarker";
          // The display name for this tags come from the user-provided type:
          case ClassComponent:
          case FunctionComponent:
          case IncompleteClassComponent:
          case IndeterminateComponent:
          case MemoComponent:
          case SimpleMemoComponent:
            if (typeof type == "function")
              return type.displayName || type.name || null;
            if (typeof type == "string")
              return type;
            break;
        }
        return null;
      }
      var NoFlags = (
        /*                      */
        0
      ), PerformedWork = (
        /*                */
        1
      ), Placement = (
        /*                    */
        2
      ), Update = (
        /*                       */
        4
      ), ChildDeletion = (
        /*                */
        16
      ), ContentReset = (
        /*                 */
        32
      ), Callback = (
        /*                     */
        64
      ), DidCapture = (
        /*                   */
        128
      ), ForceClientRender = (
        /*            */
        256
      ), Ref = (
        /*                          */
        512
      ), Snapshot = (
        /*                     */
        1024
      ), Passive = (
        /*                      */
        2048
      ), Hydrating = (
        /*                    */
        4096
      ), Visibility = (
        /*                   */
        8192
      ), StoreConsistency = (
        /*             */
        16384
      ), LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency, HostEffectMask = (
        /*               */
        32767
      ), Incomplete = (
        /*                   */
        32768
      ), ShouldCapture = (
        /*                */
        65536
      ), ForceUpdateForLegacySuspense = (
        /* */
        131072
      ), Forked = (
        /*                       */
        1048576
      ), RefStatic = (
        /*                    */
        2097152
      ), LayoutStatic = (
        /*                 */
        4194304
      ), PassiveStatic = (
        /*                */
        8388608
      ), MountLayoutDev = (
        /*               */
        16777216
      ), MountPassiveDev = (
        /*              */
        33554432
      ), BeforeMutationMask = (
        // TODO: Remove Update flag from before mutation phase by re-landing Visibility
        // flag logic (see #20043)
        Update | Snapshot | 0
      ), MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility, LayoutMask = Update | Callback | Ref | Visibility, PassiveMask = Passive | ChildDeletion, StaticMask = LayoutStatic | PassiveStatic | RefStatic, ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      function getNearestMountedFiber(fiber) {
        var node = fiber, nearestMounted = fiber;
        if (fiber.alternate)
          for (; node.return; )
            node = node.return;
        else {
          var nextNode = node;
          do
            node = nextNode, (node.flags & (Placement | Hydrating)) !== NoFlags && (nearestMounted = node.return), nextNode = node.return;
          while (nextNode);
        }
        return node.tag === HostRoot ? nearestMounted : null;
      }
      function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
      }
      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;
          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner, instance = ownerFiber.stateNode;
            instance._warnedAboutRefsInRender || error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component"), instance._warnedAboutRefsInRender = !0;
          }
        }
        var fiber = get(component);
        return fiber ? getNearestMountedFiber(fiber) === fiber : !1;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw new Error("Unable to find node on an unmounted component.");
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          var nearestMounted = getNearestMountedFiber(fiber);
          if (nearestMounted === null)
            throw new Error("Unable to find node on an unmounted component.");
          return nearestMounted !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (parentA === null)
            break;
          var parentB = parentA.alternate;
          if (parentB === null) {
            var nextParent = parentA.return;
            if (nextParent !== null) {
              a = b = nextParent;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (var child = parentA.child; child; ) {
              if (child === a)
                return assertIsMounted(parentA), fiber;
              if (child === b)
                return assertIsMounted(parentA), alternate;
              child = child.sibling;
            }
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return)
            a = parentA, b = parentB;
          else {
            for (var didFindChild = !1, _child = parentA.child; _child; ) {
              if (_child === a) {
                didFindChild = !0, a = parentA, b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = !0, b = parentA, a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              for (_child = parentB.child; _child; ) {
                if (_child === a) {
                  didFindChild = !0, a = parentB, b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = !0, b = parentB, a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild)
                throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
            }
          }
          if (a.alternate !== b)
            throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
        }
        if (a.tag !== HostRoot)
          throw new Error("Unable to find node on an unmounted component.");
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
      }
      function findCurrentHostFiberImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText)
          return node;
        for (var child = node.child; child !== null; ) {
          var match2 = findCurrentHostFiberImpl(child);
          if (match2 !== null)
            return match2;
          child = child.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText)
          return node;
        for (var child = node.child; child !== null; ) {
          if (child.tag !== HostPortal) {
            var match2 = findCurrentHostFiberWithNoPortalsImpl(child);
            if (match2 !== null)
              return match2;
          }
          child = child.sibling;
        }
        return null;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var getPublicInstance = $$$hostConfig.getPublicInstance, getRootHostContext = $$$hostConfig.getRootHostContext, getChildHostContext = $$$hostConfig.getChildHostContext, prepareForCommit = $$$hostConfig.prepareForCommit, resetAfterCommit = $$$hostConfig.resetAfterCommit, createInstance = $$$hostConfig.createInstance, appendInitialChild = $$$hostConfig.appendInitialChild, finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren, prepareUpdate = $$$hostConfig.prepareUpdate, shouldSetTextContent = $$$hostConfig.shouldSetTextContent, createTextInstance = $$$hostConfig.createTextInstance, scheduleTimeout = $$$hostConfig.scheduleTimeout, cancelTimeout = $$$hostConfig.cancelTimeout, noTimeout = $$$hostConfig.noTimeout, isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer, warnsIfNotActing = $$$hostConfig.warnsIfNotActing, supportsMutation = $$$hostConfig.supportsMutation, supportsPersistence = $$$hostConfig.supportsPersistence, supportsHydration = $$$hostConfig.supportsHydration, getInstanceFromNode = $$$hostConfig.getInstanceFromNode, beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur, afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur, preparePortalMount = $$$hostConfig.preparePortalMount, prepareScopeUpdate = $$$hostConfig.prepareScopeUpdate, getInstanceFromScope = $$$hostConfig.getInstanceFromScope, getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority, detachDeletedInstance = $$$hostConfig.detachDeletedInstance, supportsMicrotasks = $$$hostConfig.supportsMicrotasks, scheduleMicrotask = $$$hostConfig.scheduleMicrotask, supportsTestSelectors = $$$hostConfig.supportsTestSelectors, findFiberRoot = $$$hostConfig.findFiberRoot, getBoundingRect = $$$hostConfig.getBoundingRect, getTextContent = $$$hostConfig.getTextContent, isHiddenSubtree = $$$hostConfig.isHiddenSubtree, matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole, setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable, setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver, appendChild = $$$hostConfig.appendChild, appendChildToContainer = $$$hostConfig.appendChildToContainer, commitTextUpdate = $$$hostConfig.commitTextUpdate, commitMount = $$$hostConfig.commitMount, commitUpdate = $$$hostConfig.commitUpdate, insertBefore = $$$hostConfig.insertBefore, insertInContainerBefore = $$$hostConfig.insertInContainerBefore, removeChild = $$$hostConfig.removeChild, removeChildFromContainer = $$$hostConfig.removeChildFromContainer, resetTextContent = $$$hostConfig.resetTextContent, hideInstance = $$$hostConfig.hideInstance, hideTextInstance = $$$hostConfig.hideTextInstance, unhideInstance = $$$hostConfig.unhideInstance, unhideTextInstance = $$$hostConfig.unhideTextInstance, clearContainer = $$$hostConfig.clearContainer, cloneInstance = $$$hostConfig.cloneInstance, createContainerChildSet = $$$hostConfig.createContainerChildSet, appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet, finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren, replaceContainerChildren = $$$hostConfig.replaceContainerChildren, cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance, cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance, canHydrateInstance = $$$hostConfig.canHydrateInstance, canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance, canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance, isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$hostConfig.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry, getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling, getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance, hydrateInstance = $$$hostConfig.hydrateInstance, hydrateTextInstance = $$$hostConfig.hydrateTextInstance, hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$hostConfig.commitHydratedContainer, commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances, didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance, didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance, didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer, didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance, didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance, didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer, didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer, didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer, didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance, didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance, didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance, didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance, didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance, errorHydratingContainer = $$$hostConfig.errorHydratingContainer, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
      function disabledLog() {
      }
      disabledLog.__reactDisabledLog = !0;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
            var props = {
              configurable: !0,
              enumerable: !0,
              value: disabledLog,
              writable: !0
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          if (disabledDepth--, disabledDepth === 0) {
            var props = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === void 0)
            try {
              throw Error();
            } catch (x) {
              var match2 = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match2 && match2[1] || "";
            }
          return `
` + prefix + name;
        }
      }
      var reentry = !1, componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap();
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry)
          return "";
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== void 0)
            return frame;
        }
        var control;
        reentry = !0;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var previousDispatcher;
        previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            if (Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack == "string") {
            for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
              c--;
            for (; s >= 1 && c >= 0; s--, c--)
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1)
                  do
                    if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                    }
                  while (s >= 1 && c >= 0);
                break;
              }
          }
        } finally {
          reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "", syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        return describeNativeComponentFrame(ctor, !0);
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        return describeNativeComponentFrame(fn, !1);
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null)
          return "";
        if (typeof type == "function")
          return describeNativeComponentFrame(type, shouldConstruct(type));
        if (typeof type == "string")
          return describeBuiltInComponentFrame(type);
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type == "object")
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch {
              }
            }
          }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty, loggedTypeFailures = {}, ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        if (element) {
          var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame.setExtraStackFrame(stack);
        } else
          ReactDebugCurrentFrame.setExtraStackFrame(null);
      }
      function checkPropTypes(typeSpecs, values, location, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs)
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = void 0;
              try {
                if (typeof typeSpecs[typeSpecName] != "function") {
                  var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw err.name = "Invariant Violation", err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
            }
        }
      }
      var valueStack = [], fiberStack;
      fiberStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }
      function pop(cursor, fiber) {
        if (index < 0) {
          error("Unexpected pop.");
          return;
        }
        fiber !== fiberStack[index] && error("Unexpected Fiber popped."), cursor.current = valueStack[index], valueStack[index] = null, fiberStack[index] = null, index--;
      }
      function push(cursor, value, fiber) {
        index++, valueStack[index] = cursor.current, fiberStack[index] = fiber, cursor.current = value;
      }
      var warnedAboutMissingGetChildContext;
      warnedAboutMissingGetChildContext = {};
      var emptyContextObject = {};
      Object.freeze(emptyContextObject);
      var contextStackCursor = createCursor(emptyContextObject), didPerformWorkStackCursor = createCursor(!1), previousContext = emptyContextObject;
      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
        return didPushOwnContextIfProvider && isContextProvider(Component) ? previousContext : contextStackCursor.current;
      }
      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
        {
          var instance = workInProgress2.stateNode;
          instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
        }
      }
      function getMaskedContext(workInProgress2, unmaskedContext) {
        {
          var type = workInProgress2.type, contextTypes = type.contextTypes;
          if (!contextTypes)
            return emptyContextObject;
          var instance = workInProgress2.stateNode;
          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext)
            return instance.__reactInternalMemoizedMaskedChildContext;
          var context = {};
          for (var key in contextTypes)
            context[key] = unmaskedContext[key];
          {
            var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          return instance && cacheContext(workInProgress2, unmaskedContext, context), context;
        }
      }
      function hasContextChanged() {
        return didPerformWorkStackCursor.current;
      }
      function isContextProvider(type) {
        {
          var childContextTypes = type.childContextTypes;
          return childContextTypes != null;
        }
      }
      function popContext(fiber) {
        pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
      }
      function popTopLevelContextObject(fiber) {
        pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
      }
      function pushTopLevelContextObject(fiber, context, didChange) {
        {
          if (contextStackCursor.current !== emptyContextObject)
            throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
          push(contextStackCursor, context, fiber), push(didPerformWorkStackCursor, didChange, fiber);
        }
      }
      function processChildContext(fiber, type, parentContext) {
        {
          var instance = fiber.stateNode, childContextTypes = type.childContextTypes;
          if (typeof instance.getChildContext != "function") {
            {
              var componentName = getComponentNameFromFiber(fiber) || "Unknown";
              warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext)
            if (!(contextKey in childContextTypes))
              throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
          {
            var name = getComponentNameFromFiber(fiber) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      function pushContextProvider(workInProgress2) {
        {
          var instance = workInProgress2.stateNode, memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
          return previousContext = contextStackCursor.current, push(contextStackCursor, memoizedMergedChildContext, workInProgress2), push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2), !0;
        }
      }
      function invalidateContextProvider(workInProgress2, type, didChange) {
        {
          var instance = workInProgress2.stateNode;
          if (!instance)
            throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
          if (didChange) {
            var mergedContext = processChildContext(workInProgress2, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext, pop(didPerformWorkStackCursor, workInProgress2), pop(contextStackCursor, workInProgress2), push(contextStackCursor, mergedContext, workInProgress2), push(didPerformWorkStackCursor, didChange, workInProgress2);
          } else
            pop(didPerformWorkStackCursor, workInProgress2), push(didPerformWorkStackCursor, didChange, workInProgress2);
        }
      }
      function findCurrentUnmaskedContext(fiber) {
        {
          if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent)
            throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
          var node = fiber;
          do {
            switch (node.tag) {
              case HostRoot:
                return node.stateNode.context;
              case ClassComponent: {
                var Component = node.type;
                if (isContextProvider(Component))
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                break;
              }
            }
            node = node.return;
          } while (node !== null);
          throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      var LegacyRoot = 0, ConcurrentRoot = 1, NoMode = (
        /*                         */
        0
      ), ConcurrentMode = (
        /*                 */
        1
      ), ProfileMode = (
        /*                    */
        2
      ), StrictLegacyMode = (
        /*               */
        8
      ), StrictEffectsMode = (
        /*              */
        16
      ), clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        return asUint === 0 ? 32 : 31 - (log(asUint) / LN2 | 0) | 0;
      }
      var TotalLanes = 31, NoLanes = (
        /*                        */
        0
      ), NoLane = (
        /*                          */
        0
      ), SyncLane = (
        /*                        */
        1
      ), InputContinuousHydrationLane = (
        /*    */
        2
      ), InputContinuousLane = (
        /*             */
        4
      ), DefaultHydrationLane = (
        /*            */
        8
      ), DefaultLane = (
        /*                     */
        16
      ), TransitionHydrationLane = (
        /*                */
        32
      ), TransitionLanes = (
        /*                       */
        4194240
      ), TransitionLane1 = (
        /*                        */
        64
      ), TransitionLane2 = (
        /*                        */
        128
      ), TransitionLane3 = (
        /*                        */
        256
      ), TransitionLane4 = (
        /*                        */
        512
      ), TransitionLane5 = (
        /*                        */
        1024
      ), TransitionLane6 = (
        /*                        */
        2048
      ), TransitionLane7 = (
        /*                        */
        4096
      ), TransitionLane8 = (
        /*                        */
        8192
      ), TransitionLane9 = (
        /*                        */
        16384
      ), TransitionLane10 = (
        /*                       */
        32768
      ), TransitionLane11 = (
        /*                       */
        65536
      ), TransitionLane12 = (
        /*                       */
        131072
      ), TransitionLane13 = (
        /*                       */
        262144
      ), TransitionLane14 = (
        /*                       */
        524288
      ), TransitionLane15 = (
        /*                       */
        1048576
      ), TransitionLane16 = (
        /*                       */
        2097152
      ), RetryLanes = (
        /*                            */
        130023424
      ), RetryLane1 = (
        /*                             */
        4194304
      ), RetryLane2 = (
        /*                             */
        8388608
      ), RetryLane3 = (
        /*                             */
        16777216
      ), RetryLane4 = (
        /*                             */
        33554432
      ), RetryLane5 = (
        /*                             */
        67108864
      ), SomeRetryLane = RetryLane1, SelectiveHydrationLane = (
        /*          */
        134217728
      ), NonIdleLanes = (
        /*                          */
        268435455
      ), IdleHydrationLane = (
        /*               */
        268435456
      ), IdleLane = (
        /*                        */
        536870912
      ), OffscreenLane = (
        /*                   */
        1073741824
      );
      function getLabelForLane(lane) {
        {
          if (lane & SyncLane)
            return "Sync";
          if (lane & InputContinuousHydrationLane)
            return "InputContinuousHydration";
          if (lane & InputContinuousLane)
            return "InputContinuous";
          if (lane & DefaultHydrationLane)
            return "DefaultHydration";
          if (lane & DefaultLane)
            return "Default";
          if (lane & TransitionHydrationLane)
            return "TransitionHydration";
          if (lane & TransitionLanes)
            return "Transition";
          if (lane & RetryLanes)
            return "Retry";
          if (lane & SelectiveHydrationLane)
            return "SelectiveHydration";
          if (lane & IdleHydrationLane)
            return "IdleHydration";
          if (lane & IdleLane)
            return "Idle";
          if (lane & OffscreenLane)
            return "Offscreen";
        }
      }
      var NoTimestamp = -1, nextTransitionLane = TransitionLane1, nextRetryLane = RetryLane1;
      function getHighestPriorityLanes(lanes) {
        switch (getHighestPriorityLane(lanes)) {
          case SyncLane:
            return SyncLane;
          case InputContinuousHydrationLane:
            return InputContinuousHydrationLane;
          case InputContinuousLane:
            return InputContinuousLane;
          case DefaultHydrationLane:
            return DefaultHydrationLane;
          case DefaultLane:
            return DefaultLane;
          case TransitionHydrationLane:
            return TransitionHydrationLane;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return lanes & TransitionLanes;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return lanes & RetryLanes;
          case SelectiveHydrationLane:
            return SelectiveHydrationLane;
          case IdleHydrationLane:
            return IdleHydrationLane;
          case IdleLane:
            return IdleLane;
          case OffscreenLane:
            return OffscreenLane;
          default:
            return error("Should have found matching lanes. This is a bug in React."), lanes;
        }
      }
      function getNextLanes(root, wipLanes) {
        var pendingLanes = root.pendingLanes;
        if (pendingLanes === NoLanes)
          return NoLanes;
        var nextLanes = NoLanes, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, nonIdlePendingLanes = pendingLanes & NonIdleLanes;
        if (nonIdlePendingLanes !== NoLanes) {
          var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
          if (nonIdleUnblockedLanes !== NoLanes)
            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
          else {
            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
            nonIdlePingedLanes !== NoLanes && (nextLanes = getHighestPriorityLanes(nonIdlePingedLanes));
          }
        } else {
          var unblockedLanes = pendingLanes & ~suspendedLanes;
          unblockedLanes !== NoLanes ? nextLanes = getHighestPriorityLanes(unblockedLanes) : pingedLanes !== NoLanes && (nextLanes = getHighestPriorityLanes(pingedLanes));
        }
        if (nextLanes === NoLanes)
          return NoLanes;
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
        // bother waiting until the root is complete.
        (wipLanes & suspendedLanes) === NoLanes) {
          var nextLane = getHighestPriorityLane(nextLanes), wipLane = getHighestPriorityLane(wipLanes);
          if (
            // Tests whether the next lane is equal or lower priority than the wip
            // one. This works because the bits decrease in priority as you go left.
            nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
            // only difference between default updates and transition updates is that
            // default updates do not support refresh transitions.
            nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
          )
            return wipLanes;
        }
        (nextLanes & InputContinuousLane) !== NoLanes && (nextLanes |= pendingLanes & DefaultLane);
        var entangledLanes = root.entangledLanes;
        if (entangledLanes !== NoLanes)
          for (var entanglements = root.entanglements, lanes = nextLanes & entangledLanes; lanes > 0; ) {
            var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
            nextLanes |= entanglements[index2], lanes &= ~lane;
          }
        return nextLanes;
      }
      function getMostRecentEventTime(root, lanes) {
        for (var eventTimes = root.eventTimes, mostRecentEventTime = NoTimestamp; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2, eventTime = eventTimes[index2];
          eventTime > mostRecentEventTime && (mostRecentEventTime = eventTime), lanes &= ~lane;
        }
        return mostRecentEventTime;
      }
      function computeExpirationTime(lane, currentTime2) {
        switch (lane) {
          case SyncLane:
          case InputContinuousHydrationLane:
          case InputContinuousLane:
            return currentTime2 + 250;
          case DefaultHydrationLane:
          case DefaultLane:
          case TransitionHydrationLane:
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return currentTime2 + 5e3;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return NoTimestamp;
          case SelectiveHydrationLane:
          case IdleHydrationLane:
          case IdleLane:
          case OffscreenLane:
            return NoTimestamp;
          default:
            return error("Should have found matching lanes. This is a bug in React."), NoTimestamp;
        }
      }
      function markStarvedLanesAsExpired(root, currentTime2) {
        for (var pendingLanes = root.pendingLanes, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = pendingLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2, expirationTime = expirationTimes[index2];
          expirationTime === NoTimestamp ? ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) && (expirationTimes[index2] = computeExpirationTime(lane, currentTime2)) : expirationTime <= currentTime2 && (root.expiredLanes |= lane), lanes &= ~lane;
        }
      }
      function getHighestPriorityPendingLanes(root) {
        return getHighestPriorityLanes(root.pendingLanes);
      }
      function getLanesToRetrySynchronouslyOnError(root) {
        var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;
        return everythingButOffscreen !== NoLanes ? everythingButOffscreen : everythingButOffscreen & OffscreenLane ? OffscreenLane : NoLanes;
      }
      function includesSyncLane(lanes) {
        return (lanes & SyncLane) !== NoLanes;
      }
      function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
      }
      function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
      }
      function includesOnlyNonUrgentLanes(lanes) {
        var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
        return (lanes & UrgentLanes) === NoLanes;
      }
      function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
      }
      function includesBlockingLane(root, lanes) {
        var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
        return (lanes & SyncDefaultLanes) !== NoLanes;
      }
      function includesExpiredLane(root, lanes) {
        return (lanes & root.expiredLanes) !== NoLanes;
      }
      function isTransitionLane(lane) {
        return (lane & TransitionLanes) !== NoLanes;
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        return nextTransitionLane <<= 1, (nextTransitionLane & TransitionLanes) === NoLanes && (nextTransitionLane = TransitionLane1), lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        return nextRetryLane <<= 1, (nextRetryLane & RetryLanes) === NoLanes && (nextRetryLane = RetryLane1), lane;
      }
      function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
      }
      function pickArbitraryLane(lanes) {
        return getHighestPriorityLane(lanes);
      }
      function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
      }
      function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
      }
      function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
      }
      function isSubsetOfLanes(set2, subset) {
        return (set2 & subset) === subset;
      }
      function mergeLanes(a, b) {
        return a | b;
      }
      function removeLanes(set2, subset) {
        return set2 & ~subset;
      }
      function intersectLanes(a, b) {
        return a & b;
      }
      function laneToLanes(lane) {
        return lane;
      }
      function higherPriorityLane(a, b) {
        return a !== NoLane && a < b ? a : b;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; i < TotalLanes; i++)
          laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated(root, updateLane, eventTime) {
        root.pendingLanes |= updateLane, updateLane !== IdleLane && (root.suspendedLanes = NoLanes, root.pingedLanes = NoLanes);
        var eventTimes = root.eventTimes, index2 = laneToIndex(updateLane);
        eventTimes[index2] = eventTime;
      }
      function markRootSuspended(root, suspendedLanes) {
        root.suspendedLanes |= suspendedLanes, root.pingedLanes &= ~suspendedLanes;
        for (var expirationTimes = root.expirationTimes, lanes = suspendedLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
          expirationTimes[index2] = NoTimestamp, lanes &= ~lane;
        }
      }
      function markRootPinged(root, pingedLanes, eventTime) {
        root.pingedLanes |= root.suspendedLanes & pingedLanes;
      }
      function markRootFinished(root, remainingLanes) {
        var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
        root.pendingLanes = remainingLanes, root.suspendedLanes = NoLanes, root.pingedLanes = NoLanes, root.expiredLanes &= remainingLanes, root.mutableReadLanes &= remainingLanes, root.entangledLanes &= remainingLanes;
        for (var entanglements = root.entanglements, eventTimes = root.eventTimes, expirationTimes = root.expirationTimes, lanes = noLongerPendingLanes; lanes > 0; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
          entanglements[index2] = NoLanes, eventTimes[index2] = NoTimestamp, expirationTimes[index2] = NoTimestamp, lanes &= ~lane;
        }
      }
      function markRootEntangled(root, entangledLanes) {
        for (var rootEntangledLanes = root.entangledLanes |= entangledLanes, entanglements = root.entanglements, lanes = rootEntangledLanes; lanes; ) {
          var index2 = pickArbitraryLaneIndex(lanes), lane = 1 << index2;
          // Is this one of the newly entangled lanes?
          lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
          entanglements[index2] & entangledLanes && (entanglements[index2] |= entangledLanes), lanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root, renderLanes2) {
        var renderLane = getHighestPriorityLane(renderLanes2), lane;
        switch (renderLane) {
          case InputContinuousLane:
            lane = InputContinuousHydrationLane;
            break;
          case DefaultLane:
            lane = DefaultHydrationLane;
            break;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            lane = TransitionHydrationLane;
            break;
          case IdleLane:
            lane = IdleHydrationLane;
            break;
          default:
            lane = NoLane;
            break;
        }
        return (lane & (root.suspendedLanes | renderLanes2)) !== NoLane ? NoLane : lane;
      }
      function addFiberToLanesMap(root, fiber, lanes) {
        if (isDevToolsPresent)
          for (var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap; lanes > 0; ) {
            var index2 = laneToIndex(lanes), lane = 1 << index2, updaters = pendingUpdatersLaneMap[index2];
            updaters.add(fiber), lanes &= ~lane;
          }
      }
      function movePendingFibersToMemoized(root, lanes) {
        if (isDevToolsPresent)
          for (var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; lanes > 0; ) {
            var index2 = laneToIndex(lanes), lane = 1 << index2, updaters = pendingUpdatersLaneMap[index2];
            updaters.size > 0 && (updaters.forEach(function(fiber) {
              var alternate = fiber.alternate;
              (alternate === null || !memoizedUpdaters.has(alternate)) && memoizedUpdaters.add(fiber);
            }), updaters.clear()), lanes &= ~lane;
          }
      }
      function getTransitionsForLanes(root, lanes) {
        return null;
      }
      var DiscreteEventPriority = SyncLane, ContinuousEventPriority = InputContinuousLane, DefaultEventPriority2 = DefaultLane, IdleEventPriority = IdleLane, currentUpdatePriority = NoLane;
      function getCurrentUpdatePriority() {
        return currentUpdatePriority;
      }
      function setCurrentUpdatePriority(newPriority) {
        currentUpdatePriority = newPriority;
      }
      function runWithPriority(priority, fn) {
        var previousPriority = currentUpdatePriority;
        try {
          return currentUpdatePriority = priority, fn();
        } finally {
          currentUpdatePriority = previousPriority;
        }
      }
      function higherEventPriority(a, b) {
        return a !== 0 && a < b ? a : b;
      }
      function lowerEventPriority(a, b) {
        return a === 0 || a > b ? a : b;
      }
      function isHigherEventPriority(a, b) {
        return a !== 0 && a < b;
      }
      function lanesToEventPriority(lanes) {
        var lane = getHighestPriorityLane(lanes);
        return isHigherEventPriority(DiscreteEventPriority, lane) ? isHigherEventPriority(ContinuousEventPriority, lane) ? includesNonIdleWork(lane) ? DefaultEventPriority2 : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
      }
      var scheduleCallback = Scheduler.unstable_scheduleCallback, cancelCallback = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, unstable_yieldValue = Scheduler.unstable_yieldValue, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
          return !1;
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled)
          return !0;
        if (!hook.supportsFiber)
          return error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
        try {
          enableSchedulingProfiler && (internals = assign({}, internals, {
            getLaneLabelMap,
            injectProfilingHooks
          })), rendererID = hook.inject(internals), injectedHook = hook;
        } catch (err) {
          error("React instrumentation encountered an error: %s.", err);
        }
        return !!hook.checkDCE;
      }
      function onScheduleRoot(root, children) {
        if (injectedHook && typeof injectedHook.onScheduleFiberRoot == "function")
          try {
            injectedHook.onScheduleFiberRoot(rendererID, root, children);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function onCommitRoot(root, eventPriority) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot == "function")
          try {
            var didError = (root.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) {
              var schedulerPriority;
              switch (eventPriority) {
                case DiscreteEventPriority:
                  schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority2:
                  schedulerPriority = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority;
                  break;
              }
              injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
            } else
              injectedHook.onCommitFiberRoot(rendererID, root, void 0, didError);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function onPostCommitRoot(root) {
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot == "function")
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount == "function")
          try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        if (typeof unstable_yieldValue == "function" && (unstable_setDisableYieldValue(newIsStrictMode), setSuppressWarning(newIsStrictMode)), injectedHook && typeof injectedHook.setStrictMode == "function")
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
          }
      }
      function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
      }
      function getLaneLabelMap() {
        {
          for (var map = /* @__PURE__ */ new Map(), lane = 1, index2 = 0; index2 < TotalLanes; index2++) {
            var label = getLabelForLane(lane);
            map.set(lane, label), lane *= 2;
          }
          return map;
        }
      }
      function markCommitStarted(lanes) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted == "function" && injectedProfilingHooks.markCommitStarted(lanes);
      }
      function markCommitStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped == "function" && injectedProfilingHooks.markCommitStopped();
      }
      function markComponentRenderStarted(fiber) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted == "function" && injectedProfilingHooks.markComponentRenderStarted(fiber);
      }
      function markComponentRenderStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped == "function" && injectedProfilingHooks.markComponentRenderStopped();
      }
      function markComponentPassiveEffectMountStarted(fiber) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted == "function" && injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
      }
      function markComponentPassiveEffectMountStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped == "function" && injectedProfilingHooks.markComponentPassiveEffectMountStopped();
      }
      function markComponentPassiveEffectUnmountStarted(fiber) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted == "function" && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
      }
      function markComponentPassiveEffectUnmountStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped == "function" && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
      }
      function markComponentLayoutEffectMountStarted(fiber) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted == "function" && injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
      }
      function markComponentLayoutEffectMountStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped == "function" && injectedProfilingHooks.markComponentLayoutEffectMountStopped();
      }
      function markComponentLayoutEffectUnmountStarted(fiber) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted == "function" && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
      }
      function markComponentLayoutEffectUnmountStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped == "function" && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
      }
      function markComponentErrored(fiber, thrownValue, lanes) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored == "function" && injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
      }
      function markComponentSuspended(fiber, wakeable, lanes) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended == "function" && injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
      }
      function markLayoutEffectsStarted(lanes) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted == "function" && injectedProfilingHooks.markLayoutEffectsStarted(lanes);
      }
      function markLayoutEffectsStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped == "function" && injectedProfilingHooks.markLayoutEffectsStopped();
      }
      function markPassiveEffectsStarted(lanes) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted == "function" && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
      }
      function markPassiveEffectsStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped == "function" && injectedProfilingHooks.markPassiveEffectsStopped();
      }
      function markRenderStarted(lanes) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted == "function" && injectedProfilingHooks.markRenderStarted(lanes);
      }
      function markRenderYielded() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded == "function" && injectedProfilingHooks.markRenderYielded();
      }
      function markRenderStopped() {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped == "function" && injectedProfilingHooks.markRenderStopped();
      }
      function markRenderScheduled(lane) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled == "function" && injectedProfilingHooks.markRenderScheduled(lane);
      }
      function markForceUpdateScheduled(fiber, lane) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled == "function" && injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
      }
      function markStateUpdateScheduled(fiber, lane) {
        injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled == "function" && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is == "function" ? Object.is : is, syncQueue = null, includesLegacySyncCallbacks = !1, isFlushingSyncQueue = !1;
      function scheduleSyncCallback(callback) {
        syncQueue === null ? syncQueue = [callback] : syncQueue.push(callback);
      }
      function scheduleLegacySyncCallback(callback) {
        includesLegacySyncCallbacks = !0, scheduleSyncCallback(callback);
      }
      function flushSyncCallbacksOnlyInLegacyMode() {
        includesLegacySyncCallbacks && flushSyncCallbacks();
      }
      function flushSyncCallbacks() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = !0;
          var i = 0, previousUpdatePriority = getCurrentUpdatePriority();
          try {
            var isSync = !0, queue = syncQueue;
            for (setCurrentUpdatePriority(DiscreteEventPriority); i < queue.length; i++) {
              var callback = queue[i];
              do
                callback = callback(isSync);
              while (callback !== null);
            }
            syncQueue = null, includesLegacySyncCallbacks = !1;
          } catch (error2) {
            throw syncQueue !== null && (syncQueue = syncQueue.slice(i + 1)), scheduleCallback(ImmediatePriority, flushSyncCallbacks), error2;
          } finally {
            setCurrentUpdatePriority(previousUpdatePriority), isFlushingSyncQueue = !1;
          }
        }
        return null;
      }
      function isRootDehydrated(root) {
        var currentState = root.current.memoizedState;
        return currentState.isDehydrated;
      }
      var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
      function isForkedChild(workInProgress2) {
        return warnIfNotHydrating(), (workInProgress2.flags & Forked) !== NoFlags;
      }
      function getForksAtLevel(workInProgress2) {
        return warnIfNotHydrating(), treeForkCount;
      }
      function getTreeId() {
        var overflow = treeContextOverflow, idWithLeadingBit = treeContextId, id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating(), forkStack[forkStackIndex++] = treeForkCount, forkStack[forkStackIndex++] = treeForkProvider, treeForkProvider = workInProgress2, treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId, baseOverflow = treeContextOverflow, baseLength = getBitLength(baseIdWithLeadingBit) - 1, baseId = baseIdWithLeadingBit & ~(1 << baseLength), slot = index2 + 1, length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5, newOverflowBits = (1 << numberOfOverflowBits) - 1, newOverflow = (baseId & newOverflowBits).toString(32), restOfBaseId = baseId >> numberOfOverflowBits, restOfBaseLength = baseLength - numberOfOverflowBits, restOfLength = getBitLength(totalChildren) + restOfBaseLength, restOfNewBits = slot << restOfBaseLength, id = restOfNewBits | restOfBaseId, overflow = newOverflow + baseOverflow;
          treeContextId = 1 << restOfLength | id, treeContextOverflow = overflow;
        } else {
          var newBits = slot << baseLength, _id = newBits | baseId, _overflow = baseOverflow;
          treeContextId = 1 << length | _id, treeContextOverflow = _overflow;
        }
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        var returnFiber = workInProgress2.return;
        if (returnFiber !== null) {
          var numberOfForks = 1, slotIndex = 0;
          pushTreeFork(workInProgress2, numberOfForks), pushTreeId(workInProgress2, numberOfForks, slotIndex);
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      function getSuspendedTreeContext() {
        return warnIfNotHydrating(), treeContextProvider !== null ? {
          id: treeContextId,
          overflow: treeContextOverflow
        } : null;
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = suspendedContext.id, treeContextOverflow = suspendedContext.overflow, treeContextProvider = workInProgress2;
      }
      function warnIfNotHydrating() {
        getIsHydrating() || error("Expected to be hydrating. This is a bug in React. Please file an issue.");
      }
      var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationErrors = null;
      function warnIfHydrating() {
        isHydrating && error("We should not be hydrating here. This is a bug in React. Please file a bug.");
      }
      function markDidThrowWhileHydratingDEV() {
        didSuspendOrErrorDEV = !0;
      }
      function didSuspendOrErrorWhileHydratingDEV() {
        return didSuspendOrErrorDEV;
      }
      function enterHydrationState(fiber) {
        if (!supportsHydration)
          return !1;
        var parentInstance = fiber.stateNode.containerInfo;
        return nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance), hydrationParentFiber = fiber, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, !0;
      }
      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
        return supportsHydration ? (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance), hydrationParentFiber = fiber, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, treeContext !== null && restoreSuspendedTreeContext(fiber, treeContext), !0) : !1;
      }
      function warnUnhydratedInstance(returnFiber, instance) {
        switch (returnFiber.tag) {
          case HostRoot: {
            didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
            break;
          }
          case HostComponent: {
            var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
            didNotHydrateInstance(
              returnFiber.type,
              returnFiber.memoizedProps,
              returnFiber.stateNode,
              instance,
              // TODO: Delete this argument when we remove the legacy root API.
              isConcurrentMode
            );
            break;
          }
          case SuspenseComponent: {
            var suspenseState = returnFiber.memoizedState;
            suspenseState.dehydrated !== null && didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
            break;
          }
        }
      }
      function deleteHydratableInstance(returnFiber, instance) {
        warnUnhydratedInstance(returnFiber, instance);
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance, childToDelete.return = returnFiber;
        var deletions = returnFiber.deletions;
        deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= ChildDeletion) : deletions.push(childToDelete);
      }
      function warnNonhydratedInstance(returnFiber, fiber) {
        {
          if (didSuspendOrErrorDEV)
            return;
          switch (returnFiber.tag) {
            case HostRoot: {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type, props = fiber.pendingProps;
                  didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                  break;
                case SuspenseComponent:
                  didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);
                  break;
              }
              break;
            }
            case HostComponent: {
              var parentType = returnFiber.type, parentProps = returnFiber.memoizedProps, parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent: {
                  var _type = fiber.type, _props = fiber.pendingProps, isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _type,
                    _props,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostText: {
                  var _text = fiber.pendingProps, _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    _text,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);
                  break;
                }
              }
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState, _parentInstance = suspenseState.dehydrated;
              if (_parentInstance !== null) switch (fiber.tag) {
                case HostComponent:
                  var _type2 = fiber.type, _props2 = fiber.pendingProps;
                  didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);
                  break;
                case HostText:
                  var _text2 = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                  break;
                case SuspenseComponent:
                  didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);
                  break;
              }
              break;
            }
            default:
              return;
          }
        }
      }
      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & ~Hydrating | Placement, warnNonhydratedInstance(returnFiber, fiber);
      }
      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent: {
            var type = fiber.type, props = fiber.pendingProps, instance = canHydrateInstance(nextInstance, type, props);
            return instance !== null ? (fiber.stateNode = instance, hydrationParentFiber = fiber, nextHydratableInstance = getFirstHydratableChild(instance), !0) : !1;
          }
          case HostText: {
            var text = fiber.pendingProps, textInstance = canHydrateTextInstance(nextInstance, text);
            return textInstance !== null ? (fiber.stateNode = textInstance, hydrationParentFiber = fiber, nextHydratableInstance = null, !0) : !1;
          }
          case SuspenseComponent: {
            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
            if (suspenseInstance !== null) {
              var suspenseState = {
                dehydrated: suspenseInstance,
                treeContext: getSuspendedTreeContext(),
                retryLane: OffscreenLane
              };
              fiber.memoizedState = suspenseState;
              var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
              return dehydratedFragment.return = fiber, fiber.child = dehydratedFragment, hydrationParentFiber = fiber, nextHydratableInstance = null, !0;
            }
            return !1;
          }
          default:
            return !1;
        }
      }
      function shouldClientRenderOnMismatch(fiber) {
        return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
      }
      function throwOnHydrationMismatch(fiber) {
        throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
      }
      function tryToClaimNextHydratableInstance(fiber) {
        if (isHydrating) {
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            shouldClientRenderOnMismatch(fiber) && (warnNonhydratedInstance(hydrationParentFiber, fiber), throwOnHydrationMismatch()), insertNonHydratedInstance(hydrationParentFiber, fiber), isHydrating = !1, hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            shouldClientRenderOnMismatch(fiber) && (warnNonhydratedInstance(hydrationParentFiber, fiber), throwOnHydrationMismatch()), nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber), isHydrating = !1, hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
      }
      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        if (!supportsHydration)
          throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
        var instance = fiber.stateNode, shouldWarnIfMismatchDev = !didSuspendOrErrorDEV, updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
        return fiber.updateQueue = updatePayload, updatePayload !== null;
      }
      function prepareToHydrateHostTextInstance(fiber) {
        if (!supportsHydration)
          throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
        var textInstance = fiber.stateNode, textContent = fiber.memoizedProps, shouldWarnIfMismatchDev = !didSuspendOrErrorDEV, shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null)
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo, isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedContainerTextInstance(
                  parentContainer,
                  textInstance,
                  textContent,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type, parentProps = returnFiber.memoizedProps, parentInstance = returnFiber.stateNode, _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  textInstance,
                  textContent,
                  // TODO: Delete this argument when we remove the legacy root API.
                  _isConcurrentMode2
                );
                break;
              }
            }
        }
        return shouldUpdate;
      }
      function prepareToHydrateHostSuspenseInstance(fiber) {
        if (!supportsHydration)
          throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
        var suspenseState = fiber.memoizedState, suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance)
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        hydrateSuspenseInstance(suspenseInstance, fiber);
      }
      function skipPastDehydratedSuspenseInstance(fiber) {
        if (!supportsHydration)
          throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
        var suspenseState = fiber.memoizedState, suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance)
          throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }
      function popToNextHostParent(fiber) {
        for (var parent = fiber.return; parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent; )
          parent = parent.return;
        hydrationParentFiber = parent;
      }
      function popHydrationState(fiber) {
        if (!supportsHydration || fiber !== hydrationParentFiber)
          return !1;
        if (!isHydrating)
          return popToNextHostParent(fiber), isHydrating = !0, !1;
        if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
          var nextInstance = nextHydratableInstance;
          if (nextInstance)
            if (shouldClientRenderOnMismatch(fiber))
              warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch();
            else
              for (; nextInstance; )
                deleteHydratableInstance(fiber, nextInstance), nextInstance = getNextHydratableSibling(nextInstance);
        }
        return popToNextHostParent(fiber), fiber.tag === SuspenseComponent ? nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber) : nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null, !0;
      }
      function hasUnhydratedTailNodes() {
        return isHydrating && nextHydratableInstance !== null;
      }
      function warnIfUnhydratedTailNodes(fiber) {
        for (var nextInstance = nextHydratableInstance; nextInstance; )
          warnUnhydratedInstance(fiber, nextInstance), nextInstance = getNextHydratableSibling(nextInstance);
      }
      function resetHydrationState() {
        supportsHydration && (hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1);
      }
      function upgradeHydrationErrorsToRecoverable() {
        hydrationErrors !== null && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null);
      }
      function getIsHydrating() {
        return isHydrating;
      }
      function queueHydrationError(error2) {
        hydrationErrors === null ? hydrationErrors = [error2] : hydrationErrors.push(error2);
      }
      var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig, NoTransition = null;
      function requestCurrentTransition() {
        return ReactCurrentBatchConfig.transition;
      }
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB))
          return !0;
        if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
          return !1;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length)
          return !1;
        for (var i = 0; i < keysA.length; i++) {
          var currentKey = keysA[i];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return !1;
        }
        return !0;
      }
      function describeFiber(fiber) {
        var owner = fiber._debugOwner ? fiber._debugOwner.type : null, source = fiber._debugSource;
        switch (fiber.tag) {
          case HostComponent:
            return describeBuiltInComponentFrame(fiber.type);
          case LazyComponent:
            return describeBuiltInComponentFrame("Lazy");
          case SuspenseComponent:
            return describeBuiltInComponentFrame("Suspense");
          case SuspenseListComponent:
            return describeBuiltInComponentFrame("SuspenseList");
          case FunctionComponent:
          case IndeterminateComponent:
          case SimpleMemoComponent:
            return describeFunctionComponentFrame(fiber.type);
          case ForwardRef:
            return describeFunctionComponentFrame(fiber.type.render);
          case ClassComponent:
            return describeClassComponentFrame(fiber.type);
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "", node = workInProgress2;
          do
            info += describeFiber(node), node = node.return;
          while (node);
          return info;
        } catch (x) {
          return `
Error generating stack: ` + x.message + `
` + x.stack;
        }
      }
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame, current = null, isRendering = !1;
      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null)
            return null;
          var owner = current._debugOwner;
          if (owner !== null && typeof owner < "u")
            return getComponentNameFromFiber(owner);
        }
        return null;
      }
      function getCurrentFiberStackInDev() {
        return current === null ? "" : getStackByFiberInDevAndProd(current);
      }
      function resetCurrentFiber() {
        ReactDebugCurrentFrame$1.getCurrentStack = null, current = null, isRendering = !1;
      }
      function setCurrentFiber(fiber) {
        ReactDebugCurrentFrame$1.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev, current = fiber, isRendering = !1;
      }
      function getCurrentFiber() {
        return current;
      }
      function setIsRendering(rendering) {
        isRendering = rendering;
      }
      var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {
        },
        flushPendingUnsafeLifecycleWarnings: function() {
        },
        recordLegacyContextWarning: function(fiber, instance) {
        },
        flushLegacyContextWarning: function() {
        },
        discardPendingWarnings: function() {
        }
      };
      {
        var findStrictRoot = function(fiber) {
          for (var maybeStrictRoot = null, node = fiber; node !== null; )
            node.mode & StrictLegacyMode && (maybeStrictRoot = node), node = node.return;
          return maybeStrictRoot;
        }, setToSortedString = function(set2) {
          var array = [];
          return set2.forEach(function(value) {
            array.push(value);
          }), array.sort().join(", ");
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
          instance.componentWillMount.__suppressDeprecationWarning !== !0 && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount == "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps == "function" && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate == "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        }, ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          pendingComponentWillMountWarnings.length > 0 && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          pendingUNSAFE_ComponentWillMountWarnings.length > 0 && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          pendingComponentWillReceivePropsWarnings.length > 0 && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0 && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          pendingComponentWillUpdateWarnings.length > 0 && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0 && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []), UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
          }
          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, _sortedNames);
          }
          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, _sortedNames2);
          }
          if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames3);
          }
          if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames4);
          }
          if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames5);
          }
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = findStrictRoot(fiber);
          if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
            return;
          }
          if (!didWarnAboutLegacyContext.has(fiber.type)) {
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext == "function") && (warningsForRoot === void 0 && (warningsForRoot = [], pendingLegacyContextWarning.set(strictRoot, warningsForRoot)), warningsForRoot.push(fiber));
          }
        }, ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length !== 0) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber), error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, sortedNames);
              } finally {
                resetCurrentFiber();
              }
            }
          });
        }, ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        try {
          return testStringCoercion(value), !1;
        } catch {
          return !0;
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        if (willCoercionThrow(value))
          return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
      }
      function checkPropStringCoercion(value, propName) {
        if (willCoercionThrow(value))
          return error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value)), testStringCoercion(value);
      }
      var didWarnAboutMaps, didWarnAboutGenerators, didWarnAboutStringRefs, ownerHasKeyUseWarning, ownerHasFunctionTypeWarning, warnForMissingKey = function(child, returnFiber) {
      };
      didWarnAboutMaps = !1, didWarnAboutGenerators = !1, didWarnAboutStringRefs = {}, ownerHasKeyUseWarning = {}, ownerHasFunctionTypeWarning = {}, warnForMissingKey = function(child, returnFiber) {
        if (!(child === null || typeof child != "object") && !(!child._store || child._store.validated || child.key != null)) {
          if (typeof child._store != "object")
            throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
          child._store.validated = !0;
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasKeyUseWarning[componentName] || (ownerHasKeyUseWarning[componentName] = !0, error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
        }
      };
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function coerceRef(returnFiber, current2, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef != "function" && typeof mixedRef != "object") {
          if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
          // because these cannot be automatically converted to an arrow function
          // using a codemod. Therefore, we don't have to warn about string refs again.
          !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
          !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
          !(typeof element.type == "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
          element._owner) {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef), didWarnAboutStringRefs[componentName] = !0);
          }
          if (element._owner) {
            var owner = element._owner, inst;
            if (owner) {
              var ownerFiber = owner;
              if (ownerFiber.tag !== ClassComponent)
                throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
              inst = ownerFiber.stateNode;
            }
            if (!inst)
              throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
            var resolvedInst = inst;
            checkPropStringCoercion(mixedRef, "ref");
            var stringRef = "" + mixedRef;
            if (current2 !== null && current2.ref !== null && typeof current2.ref == "function" && current2.ref._stringRef === stringRef)
              return current2.ref;
            var ref = function(value) {
              var refs = resolvedInst.refs;
              value === null ? delete refs[stringRef] : refs[stringRef] = value;
            };
            return ref._stringRef = stringRef, ref;
          } else {
            if (typeof mixedRef != "string")
              throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            if (!element._owner)
              throw new Error("Element ref was specified as a string (" + mixedRef + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
          }
        }
        return mixedRef;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        var childString = Object.prototype.toString.call(newChild);
        throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
      }
      function warnOnFunctionType(returnFiber) {
        {
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasFunctionTypeWarning[componentName])
            return;
          ownerHasFunctionTypeWarning[componentName] = !0, error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
        }
      }
      function resolveLazy(lazyType) {
        var payload = lazyType._payload, init = lazyType._init;
        return init(payload);
      }
      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= ChildDeletion) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects)
            return null;
          for (var childToDelete = currentFirstChild; childToDelete !== null; )
            deleteChild(returnFiber, childToDelete), childToDelete = childToDelete.sibling;
          return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(), existingChild = currentFirstChild; existingChild !== null; )
            existingChild.key !== null ? existingChildren.set(existingChild.key, existingChild) : existingChildren.set(existingChild.index, existingChild), existingChild = existingChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          var clone = createWorkInProgress(fiber, pendingProps);
          return clone.index = 0, clone.sibling = null, clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          if (newFiber.index = newIndex, !shouldTrackSideEffects)
            return newFiber.flags |= Forked, lastPlacedIndex;
          var current2 = newFiber.alternate;
          if (current2 !== null) {
            var oldIndex = current2.index;
            return oldIndex < lastPlacedIndex ? (newFiber.flags |= Placement, lastPlacedIndex) : oldIndex;
          } else
            return newFiber.flags |= Placement, lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          return shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= Placement), newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent, lanes) {
          if (current2 === null || current2.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            return created.return = returnFiber, created;
          } else {
            var existing = useFiber(current2, textContent);
            return existing.return = returnFiber, existing;
          }
        }
        function updateElement(returnFiber, current2, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
          if (current2 !== null && (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
          isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
          // We need to do this after the Hot Reloading check above,
          // because hot reloading has different semantics than prod because
          // it doesn't resuspend. So we can't let the call below suspend.
          typeof elementType == "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type)) {
            var existing = useFiber(current2, element.props);
            return existing.ref = coerceRef(returnFiber, current2, element), existing.return = returnFiber, existing._debugSource = element._source, existing._debugOwner = element._owner, existing;
          }
          var created = createFiberFromElement(element, returnFiber.mode, lanes);
          return created.ref = coerceRef(returnFiber, current2, element), created.return = returnFiber, created;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            return created.return = returnFiber, created;
          } else {
            var existing = useFiber(current2, portal.children || []);
            return existing.return = returnFiber, existing;
          }
        }
        function updateFragment2(returnFiber, current2, fragment, lanes, key) {
          if (current2 === null || current2.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
            return created.return = returnFiber, created;
          } else {
            var existing = useFiber(current2, fragment);
            return existing.return = returnFiber, existing;
          }
        }
        function createChild(returnFiber, newChild, lanes) {
          if (typeof newChild == "string" && newChild !== "" || typeof newChild == "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
            return created.return = returnFiber, created;
          }
          if (typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                return _created.ref = coerceRef(returnFiber, null, newChild), _created.return = returnFiber, _created;
              }
              case REACT_PORTAL_TYPE: {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                return _created2.return = returnFiber, _created2;
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload, init = newChild._init;
                return createChild(returnFiber, init(payload), lanes);
              }
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
              return _created3.return = returnFiber, _created3;
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = oldFiber !== null ? oldFiber.key : null;
          if (typeof newChild == "string" && newChild !== "" || typeof newChild == "number")
            return key !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if (typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload, init = newChild._init;
                return updateSlot(returnFiber, oldFiber, init(payload), lanes);
              }
            }
            if (isArray(newChild) || getIteratorFn(newChild))
              return key !== null ? null : updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (typeof newChild == "string" && newChild !== "" || typeof newChild == "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
          }
          if (typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updateElement(returnFiber, _matchedFiber, newChild, lanes);
              }
              case REACT_PORTAL_TYPE: {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
              }
              case REACT_LAZY_TYPE:
                var payload = newChild._payload, init = newChild._init;
                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
        }
        function warnOnInvalidKey(child, knownKeys, returnFiber) {
          {
            if (typeof child != "object" || child === null)
              return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child, returnFiber);
                var key = child.key;
                if (typeof key != "string")
                  break;
                if (knownKeys === null) {
                  knownKeys = /* @__PURE__ */ new Set(), knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                break;
              case REACT_LAZY_TYPE:
                var payload = child._payload, init = child._init;
                warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                break;
            }
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var knownKeys = null, i = 0; i < newChildren.length; i++) {
            var child = newChildren[i];
            knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
          }
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, lastPlacedIndex = 0, newIdx = 0, nextOldFiber = null; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (newFiber === null) {
              oldFiber === null && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber), lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber, previousNewFiber = newFiber, oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length) {
            if (deleteRemainingChildren(returnFiber, oldFiber), getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
              _newFiber !== null && (lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber : previousNewFiber.sibling = _newFiber, previousNewFiber = _newFiber);
            }
            if (getIsHydrating()) {
              var _numberOfForks = newIdx;
              pushTreeFork(returnFiber, _numberOfForks);
            }
            return resultingFirstChild;
          }
          for (var existingChildren = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
            _newFiber2 !== null && (shouldTrackSideEffects && _newFiber2.alternate !== null && existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key), lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber2 : previousNewFiber.sibling = _newFiber2, previousNewFiber = _newFiber2);
          }
          if (shouldTrackSideEffects && existingChildren.forEach(function(child2) {
            return deleteChild(returnFiber, child2);
          }), getIsHydrating()) {
            var _numberOfForks2 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks2);
          }
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          if (typeof iteratorFn != "function")
            throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
          {
            typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
            newChildrenIterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), newChildrenIterable.entries === iteratorFn && (didWarnAboutMaps || error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren)
              for (var knownKeys = null, _step = _newChildren.next(); !_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          if (newChildren == null)
            throw new Error("An iterable object provided no iterator.");
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, lastPlacedIndex = 0, newIdx = 0, nextOldFiber = null, step = newChildren.next(); oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (newFiber === null) {
              oldFiber === null && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber), lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber, previousNewFiber = newFiber, oldFiber = nextOldFiber;
          }
          if (step.done) {
            if (deleteRemainingChildren(returnFiber, oldFiber), getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, lanes);
              _newFiber3 !== null && (lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber3 : previousNewFiber.sibling = _newFiber3, previousNewFiber = _newFiber3);
            }
            if (getIsHydrating()) {
              var _numberOfForks3 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks3);
            }
            return resultingFirstChild;
          }
          for (var existingChildren = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
            _newFiber4 !== null && (shouldTrackSideEffects && _newFiber4.alternate !== null && existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key), lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber4 : previousNewFiber.sibling = _newFiber4, previousNewFiber = _newFiber4);
          }
          if (shouldTrackSideEffects && existingChildren.forEach(function(child2) {
            return deleteChild(returnFiber, child2);
          }), getIsHydrating()) {
            var _numberOfForks4 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks4);
          }
          return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent);
            return existing.return = returnFiber, existing;
          }
          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
          for (var key = element.key, child = currentFirstChild; child !== null; ) {
            if (child.key === key) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                if (child.tag === Fragment) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, element.props.children);
                  return existing.return = returnFiber, existing._debugSource = element._source, existing._debugOwner = element._owner, existing;
                }
              } else if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
              isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof elementType == "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var _existing = useFiber(child, element.props);
                return _existing.ref = coerceRef(returnFiber, child, element), _existing.return = returnFiber, _existing._debugSource = element._source, _existing._debugOwner = element._owner, _existing;
              }
              deleteRemainingChildren(returnFiber, child);
              break;
            } else
              deleteChild(returnFiber, child);
            child = child.sibling;
          }
          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
            return created.return = returnFiber, created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
            return _created4.ref = coerceRef(returnFiber, currentFirstChild, element), _created4.return = returnFiber, _created4;
          }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
          for (var key = portal.key, child = currentFirstChild; child !== null; ) {
            if (child.key === key)
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || []);
                return existing.return = returnFiber, existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            else
              deleteChild(returnFiber, child);
            child = child.sibling;
          }
          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        }
        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
          var isUnkeyedTopLevelFragment = typeof newChild == "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
          if (isUnkeyedTopLevelFragment && (newChild = newChild.props.children), typeof newChild == "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_LAZY_TYPE:
                var payload = newChild._payload, init = newChild._init;
                return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
            }
            if (isArray(newChild))
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            if (getIteratorFn(newChild))
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return typeof newChild == "string" && newChild !== "" || typeof newChild == "number" ? placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes)) : (typeof newChild == "function" && warnOnFunctionType(returnFiber), deleteRemainingChildren(returnFiber, currentFirstChild));
        }
        return reconcileChildFibers2;
      }
      var reconcileChildFibers = ChildReconciler(!0), mountChildFibers = ChildReconciler(!1);
      function cloneChildFibers(current2, workInProgress2) {
        if (current2 !== null && workInProgress2.child !== current2.child)
          throw new Error("Resuming work not yet implemented.");
        if (workInProgress2.child !== null) {
          var currentChild = workInProgress2.child, newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          for (workInProgress2.child = newChild, newChild.return = workInProgress2; currentChild.sibling !== null; )
            currentChild = currentChild.sibling, newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps), newChild.return = workInProgress2;
          newChild.sibling = null;
        }
      }
      function resetChildFibers(workInProgress2, lanes) {
        for (var child = workInProgress2.child; child !== null; )
          resetWorkInProgress(child, lanes), child = child.sibling;
      }
      var valueCursor = createCursor(null), rendererSigil;
      rendererSigil = {};
      var currentlyRenderingFiber = null, lastContextDependency = null, lastFullyObservedContext = null, isDisallowedContextReadInDEV = !1;
      function resetContextDependencies() {
        currentlyRenderingFiber = null, lastContextDependency = null, lastFullyObservedContext = null, isDisallowedContextReadInDEV = !1;
      }
      function enterDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = !0;
      }
      function exitDisallowedContextReadInDEV() {
        isDisallowedContextReadInDEV = !1;
      }
      function pushProvider(providerFiber, context, nextValue) {
        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer2 = rendererSigil);
      }
      function popProvider(context, providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber), isPrimaryRenderer ? context._currentValue = currentValue : context._currentValue2 = currentValue;
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (var node = parent; node !== null; ) {
          var alternate = node.alternate;
          if (isSubsetOfLanes(node.childLanes, renderLanes2) ? alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2) && (alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2)) : (node.childLanes = mergeLanes(node.childLanes, renderLanes2), alternate !== null && (alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2))), node === propagationRoot)
            break;
          node = node.return;
        }
        node !== propagationRoot && error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
      }
      function propagateContextChange(workInProgress2, context, renderLanes2) {
        propagateContextChange_eager(workInProgress2, context, renderLanes2);
      }
      function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
        var fiber = workInProgress2.child;
        for (fiber !== null && (fiber.return = workInProgress2); fiber !== null; ) {
          var nextFiber = void 0, list = fiber.dependencies;
          if (list !== null) {
            nextFiber = fiber.child;
            for (var dependency = list.firstContext; dependency !== null; ) {
              if (dependency.context === context) {
                if (fiber.tag === ClassComponent) {
                  var lane = pickArbitraryLane(renderLanes2), update = createUpdate(NoTimestamp, lane);
                  update.tag = ForceUpdate;
                  var updateQueue = fiber.updateQueue;
                  if (updateQueue !== null) {
                    var sharedQueue = updateQueue.shared, pending = sharedQueue.pending;
                    pending === null ? update.next = update : (update.next = pending.next, pending.next = update), sharedQueue.pending = update;
                  }
                }
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                var alternate = fiber.alternate;
                alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)), scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2), list.lanes = mergeLanes(list.lanes, renderLanes2);
                break;
              }
              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider)
            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
          else if (fiber.tag === DehydratedFragment) {
            var parentSuspense = fiber.return;
            if (parentSuspense === null)
              throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
            var _alternate = parentSuspense.alternate;
            _alternate !== null && (_alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2)), scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2), nextFiber = fiber.sibling;
          } else
            nextFiber = fiber.child;
          if (nextFiber !== null)
            nextFiber.return = fiber;
          else
            for (nextFiber = fiber; nextFiber !== null; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              var sibling = nextFiber.sibling;
              if (sibling !== null) {
                sibling.return = nextFiber.return, nextFiber = sibling;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function prepareToReadContext(workInProgress2, renderLanes2) {
        currentlyRenderingFiber = workInProgress2, lastContextDependency = null, lastFullyObservedContext = null;
        var dependencies = workInProgress2.dependencies;
        if (dependencies !== null) {
          var firstContext = dependencies.firstContext;
          firstContext !== null && (includesSomeLane(dependencies.lanes, renderLanes2) && markWorkInProgressReceivedUpdate(), dependencies.firstContext = null);
        }
      }
      function readContext(context) {
        isDisallowedContextReadInDEV && error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;
        if (lastFullyObservedContext !== context) {
          var contextItem = {
            context,
            memoizedValue: value,
            next: null
          };
          if (lastContextDependency === null) {
            if (currentlyRenderingFiber === null)
              throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            lastContextDependency = contextItem, currentlyRenderingFiber.dependencies = {
              lanes: NoLanes,
              firstContext: contextItem
            };
          } else
            lastContextDependency = lastContextDependency.next = contextItem;
        }
        return value;
      }
      var concurrentQueues = null;
      function pushConcurrentUpdateQueue(queue) {
        concurrentQueues === null ? concurrentQueues = [queue] : concurrentQueues.push(queue);
      }
      function finishQueueingConcurrentUpdates() {
        if (concurrentQueues !== null) {
          for (var i = 0; i < concurrentQueues.length; i++) {
            var queue = concurrentQueues[i], lastInterleavedUpdate = queue.interleaved;
            if (lastInterleavedUpdate !== null) {
              queue.interleaved = null;
              var firstInterleavedUpdate = lastInterleavedUpdate.next, lastPendingUpdate = queue.pending;
              if (lastPendingUpdate !== null) {
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = firstInterleavedUpdate, lastInterleavedUpdate.next = firstPendingUpdate;
              }
              queue.pending = lastInterleavedUpdate;
            }
          }
          concurrentQueues = null;
        }
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        return interleaved === null ? (update.next = update, pushConcurrentUpdateQueue(queue)) : (update.next = interleaved.next, interleaved.next = update), queue.interleaved = update, markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        interleaved === null ? (update.next = update, pushConcurrentUpdateQueue(queue)) : (update.next = interleaved.next, interleaved.next = update), queue.interleaved = update;
      }
      function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        return interleaved === null ? (update.next = update, pushConcurrentUpdateQueue(queue)) : (update.next = interleaved.next, interleaved.next = update), queue.interleaved = update, markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, lane)), alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        for (var node = sourceFiber, parent = sourceFiber.return; parent !== null; )
          parent.childLanes = mergeLanes(parent.childLanes, lane), alternate = parent.alternate, alternate !== null ? alternate.childLanes = mergeLanes(alternate.childLanes, lane) : (parent.flags & (Placement | Hydrating)) !== NoFlags && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = parent.return;
        if (node.tag === HostRoot) {
          var root = node.stateNode;
          return root;
        } else
          return null;
      }
      var UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1, didWarnUpdateInsideUpdate, currentlyProcessingQueue;
      didWarnUpdateInsideUpdate = !1, currentlyProcessingQueue = null;
      function initializeUpdateQueue(fiber) {
        var queue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            interleaved: null,
            lanes: NoLanes
          },
          effects: null
        };
        fiber.updateQueue = queue;
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        var queue = workInProgress2.updateQueue, currentQueue = current2.updateQueue;
        if (queue === currentQueue) {
          var clone = {
            baseState: currentQueue.baseState,
            firstBaseUpdate: currentQueue.firstBaseUpdate,
            lastBaseUpdate: currentQueue.lastBaseUpdate,
            shared: currentQueue.shared,
            effects: currentQueue.effects
          };
          workInProgress2.updateQueue = clone;
        }
      }
      function createUpdate(eventTime, lane) {
        var update = {
          eventTime,
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
        return update;
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null)
          return null;
        var sharedQueue = updateQueue.shared;
        if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate && (error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), didWarnUpdateInsideUpdate = !0), isUnsafeClassRenderPhaseUpdate()) {
          var pending = sharedQueue.pending;
          return pending === null ? update.next = update : (update.next = pending.next, pending.next = update), sharedQueue.pending = update, unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
        } else
          return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
      }
      function entangleTransitions(root, fiber, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue !== null) {
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes, markRootEntangled(root, newQueueLanes);
          }
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
        if (current2 !== null) {
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var newFirst = null, newLast = null, firstBaseUpdate = queue.firstBaseUpdate;
            if (firstBaseUpdate !== null) {
              var update = firstBaseUpdate;
              do {
                var clone = {
                  eventTime: update.eventTime,
                  lane: update.lane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLast === null ? newFirst = newLast = clone : (newLast.next = clone, newLast = clone), update = update.next;
              } while (update !== null);
              newLast === null ? newFirst = newLast = capturedUpdate : (newLast.next = capturedUpdate, newLast = capturedUpdate);
            } else
              newFirst = newLast = capturedUpdate;
            queue = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            }, workInProgress2.updateQueue = queue;
            return;
          }
        }
        var lastBaseUpdate = queue.lastBaseUpdate;
        lastBaseUpdate === null ? queue.firstBaseUpdate = capturedUpdate : lastBaseUpdate.next = capturedUpdate, queue.lastBaseUpdate = capturedUpdate;
      }
      function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState: {
            var payload = update.payload;
            if (typeof payload == "function") {
              enterDisallowedContextReadInDEV();
              var nextState = payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(!0);
                  try {
                    payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(!1);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
              return nextState;
            }
            return payload;
          }
          case CaptureUpdate:
            workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
          // Intentional fallthrough
          case UpdateState: {
            var _payload = update.payload, partialState;
            if (typeof _payload == "function") {
              enterDisallowedContextReadInDEV(), partialState = _payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(!0);
                  try {
                    _payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(!1);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
            } else
              partialState = _payload;
            return partialState == null ? prevState : assign({}, prevState, partialState);
          }
          case ForceUpdate:
            return hasForceUpdate = !0, prevState;
        }
        return prevState;
      }
      function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
        var queue = workInProgress2.updateQueue;
        hasForceUpdate = !1, currentlyProcessingQueue = queue.shared;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (pendingQueue !== null) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null, lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate, lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue, currentLastBaseUpdate = currentQueue.lastBaseUpdate;
            currentLastBaseUpdate !== lastBaseUpdate && (currentLastBaseUpdate === null ? currentQueue.firstBaseUpdate = firstPendingUpdate : currentLastBaseUpdate.next = firstPendingUpdate, currentQueue.lastBaseUpdate = lastPendingUpdate);
          }
        }
        if (firstBaseUpdate !== null) {
          var newState = queue.baseState, newLanes = NoLanes, newBaseState = null, newFirstBaseUpdate = null, newLastBaseUpdate = null, update = firstBaseUpdate;
          do {
            var updateLane = update.lane, updateEventTime = update.eventTime;
            if (isSubsetOfLanes(renderLanes2, updateLane)) {
              if (newLastBaseUpdate !== null) {
                var _clone = {
                  eventTime: updateEventTime,
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
              }
              newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
              var callback = update.callback;
              if (callback !== null && // If the update was already committed, we should not queue its
              // callback again.
              update.lane !== NoLane) {
                workInProgress2.flags |= Callback;
                var effects = queue.effects;
                effects === null ? queue.effects = [update] : effects.push(update);
              }
            } else {
              var clone = {
                eventTime: updateEventTime,
                lane: updateLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              newLastBaseUpdate === null ? (newFirstBaseUpdate = newLastBaseUpdate = clone, newBaseState = newState) : newLastBaseUpdate = newLastBaseUpdate.next = clone, newLanes = mergeLanes(newLanes, updateLane);
            }
            if (update = update.next, update === null) {
              if (pendingQueue = queue.shared.pending, pendingQueue === null)
                break;
              var _lastPendingUpdate = pendingQueue, _firstPendingUpdate = _lastPendingUpdate.next;
              _lastPendingUpdate.next = null, update = _firstPendingUpdate, queue.lastBaseUpdate = _lastPendingUpdate, queue.shared.pending = null;
            }
          } while (!0);
          newLastBaseUpdate === null && (newBaseState = newState), queue.baseState = newBaseState, queue.firstBaseUpdate = newFirstBaseUpdate, queue.lastBaseUpdate = newLastBaseUpdate;
          var lastInterleaved = queue.shared.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do
              newLanes = mergeLanes(newLanes, interleaved.lane), interleaved = interleaved.next;
            while (interleaved !== lastInterleaved);
          } else firstBaseUpdate === null && (queue.shared.lanes = NoLanes);
          markSkippedUpdateLanes(newLanes), workInProgress2.lanes = newLanes, workInProgress2.memoizedState = newState;
        }
        currentlyProcessingQueue = null;
      }
      function callCallback(callback, context) {
        if (typeof callback != "function")
          throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
        callback.call(context);
      }
      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = !1;
      }
      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }
      function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        var effects = finishedQueue.effects;
        if (finishedQueue.effects = null, effects !== null)
          for (var i = 0; i < effects.length; i++) {
            var effect = effects[i], callback = effect.callback;
            callback !== null && (effect.callback = null, callCallback(callback, instance));
          }
      }
      var NO_CONTEXT = {}, contextStackCursor$1 = createCursor(NO_CONTEXT), contextFiberStackCursor = createCursor(NO_CONTEXT), rootInstanceStackCursor = createCursor(NO_CONTEXT);
      function requiredContext(c) {
        if (c === NO_CONTEXT)
          throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
        return c;
      }
      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber), push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber), push(contextStackCursor$1, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber), pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }
      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current), context = requiredContext(contextStackCursor$1.current), nextContext = getChildHostContext(context, fiber.type, rootInstance);
        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, nextContext, fiber));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
      }
      var DefaultSuspenseContext = 0, SubtreeSuspenseContextMask = 1, InvisibleParentSuspenseContext = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(DefaultSuspenseContext);
      function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
      }
      function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
      }
      function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
      }
      function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
      }
      function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
      }
      function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
      }
      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
        var nextState = workInProgress2.memoizedState;
        if (nextState !== null)
          return nextState.dehydrated !== null;
        var props = workInProgress2.memoizedProps;
        return !0;
      }
      function findFirstSuspended(row) {
        for (var node = row; node !== null; ) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              var dehydrated = state.dehydrated;
              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated))
                return node;
            }
          } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
          // keep track of whether it suspended or not.
          node.memoizedProps.revealOrder !== void 0) {
            var didSuspend = (node.flags & DidCapture) !== NoFlags;
            if (didSuspend)
              return node;
          } else if (node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === row)
            return null;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === row)
              return null;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return null;
      }
      var NoFlags$1 = (
        /*   */
        0
      ), HasEffect = (
        /* */
        1
      ), Insertion = (
        /*  */
        2
      ), Layout = (
        /*    */
        4
      ), Passive$1 = (
        /*   */
        8
      ), workInProgressSources = [];
      function resetWorkInProgressVersions() {
        for (var i = 0; i < workInProgressSources.length; i++) {
          var mutableSource = workInProgressSources[i];
          isPrimaryRenderer ? mutableSource._workInProgressVersionPrimary = null : mutableSource._workInProgressVersionSecondary = null;
        }
        workInProgressSources.length = 0;
      }
      function registerMutableSourceForHydration(root, mutableSource) {
        var getVersion = mutableSource._getVersion, version = getVersion(mutableSource._source);
        root.mutableSourceEagerHydrationData == null ? root.mutableSourceEagerHydrationData = [mutableSource, version] : root.mutableSourceEagerHydrationData.push(mutableSource, version);
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig, didWarnAboutMismatchedHooksForComponent, didWarnUncachedGetSnapshot;
      didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
      var renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, localIdCounter = 0, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;
      function mountHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
      }
      function updateHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName && warnOnHookMismatchInDev(hookName));
        }
      }
      function checkDepsAreArrayDev(deps) {
        deps != null && !isArray(deps) && error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
      }
      function warnOnHookMismatchInDev(currentHookName) {
        {
          var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), hookTypesDev !== null)) {
            for (var table = "", secondColumnStart = 30, i = 0; i <= hookTypesUpdateIndexDev; i++) {
              for (var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName, row = i + 1 + ". " + oldHookName; row.length < secondColumnStart; )
                row += " ";
              row += newHookName + `
`, table += row;
            }
            error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName, table);
          }
        }
      }
      function throwInvalidHookError() {
        throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (ignorePreviousDependencies)
          return !1;
        if (prevDeps === null)
          return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
        nextDeps.length !== prevDeps.length && error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i]))
            return !1;
        return !0;
      }
      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes, currentlyRenderingFiber$1 = workInProgress2, hookTypesDev = current2 !== null ? current2._debugHookTypes : null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.lanes = NoLanes, current2 !== null && current2.memoizedState !== null ? ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV : hookTypesDev !== null ? ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV : ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
        var children = Component(props, secondArg);
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
          var numberOfReRenders = 0;
          do {
            if (didScheduleRenderPhaseUpdateDuringThisPass = !1, localIdCounter = 0, numberOfReRenders >= RE_RENDER_LIMIT)
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            numberOfReRenders += 1, ignorePreviousDependencies = !1, currentHook = null, workInProgressHook = null, workInProgress2.updateQueue = null, hookTypesUpdateIndexDev = -1, ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV, children = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher, workInProgress2._debugHookTypes = hookTypesDev;
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        if (renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
        // and creates false positives. To make this work in legacy mode, we'd
        // need to mark fibers that commit in an incomplete state, somehow. For
        // now I'll disable the warning that most of the bugs that would trigger
        // it are either exclusive to concurrent mode or exist in both.
        (current2.mode & ConcurrentMode) !== NoMode && error("Internal React error: Expected static flag was missing. Please notify the React team."), didScheduleRenderPhaseUpdate = !1, didRenderTooFewHooks)
          throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        return localIdCounter = 0, didRenderIdHook;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue, (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update) : workInProgress2.flags &= ~(Passive | Update), current2.lanes = removeLanes(current2.lanes, lanes);
      }
      function resetHooksAfterThrow() {
        if (ReactCurrentDispatcher$1.current = ContextOnlyDispatcher, didScheduleRenderPhaseUpdate) {
          for (var hook = currentlyRenderingFiber$1.memoizedState; hook !== null; ) {
            var queue = hook.queue;
            queue !== null && (queue.pending = null), hook = hook.next;
          }
          didScheduleRenderPhaseUpdate = !1;
        }
        renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, currentHookNameInDev = null, isUpdatingOpaqueValueInRenderPhase = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, localIdCounter = 0;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        return workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook, workInProgressHook;
      }
      function updateWorkInProgressHook() {
        var nextCurrentHook;
        if (currentHook === null) {
          var current2 = currentlyRenderingFiber$1.alternate;
          current2 !== null ? nextCurrentHook = current2.memoizedState : nextCurrentHook = null;
        } else
          nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook;
        if (workInProgressHook === null ? nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState : nextWorkInProgressHook = workInProgressHook.next, nextWorkInProgressHook !== null)
          workInProgressHook = nextWorkInProgressHook, nextWorkInProgressHook = workInProgressHook.next, currentHook = nextCurrentHook;
        else {
          if (nextCurrentHook === null)
            throw new Error("Rendered more hooks than during the previous render.");
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook : workInProgressHook = workInProgressHook.next = newHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null,
          stores: null
        };
      }
      function basicStateReducer(state, action) {
        return typeof action == "function" ? action(state) : action;
      }
      function mountReducer(reducer2, initialArg, init) {
        var hook = mountWorkInProgressHook(), initialState;
        init !== void 0 ? initialState = init(initialArg) : initialState = initialArg, hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: reducer2,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateReducer(reducer2, initialArg, init) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (queue === null)
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer = reducer2;
        var current2 = currentHook, baseQueue = current2.baseQueue, pendingQueue = queue.pending;
        if (pendingQueue !== null) {
          if (baseQueue !== null) {
            var baseFirst = baseQueue.next, pendingFirst = pendingQueue.next;
            baseQueue.next = pendingFirst, pendingQueue.next = baseFirst;
          }
          current2.baseQueue !== baseQueue && error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), current2.baseQueue = baseQueue = pendingQueue, queue.pending = null;
        }
        if (baseQueue !== null) {
          var first = baseQueue.next, newState = current2.baseState, newBaseState = null, newBaseQueueFirst = null, newBaseQueueLast = null, update = first;
          do {
            var updateLane = update.lane;
            if (isSubsetOfLanes(renderLanes, updateLane)) {
              if (newBaseQueueLast !== null) {
                var _clone = {
                  // This update is going to be committed so we never want uncommit
                  // it. Using NoLane works because 0 is a subset of all bitmasks, so
                  // this will never be skipped by the check above.
                  lane: NoLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              }
              if (update.hasEagerState)
                newState = update.eagerState;
              else {
                var action = update.action;
                newState = reducer2(newState, action);
              }
            } else {
              var clone = {
                lane: updateLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              };
              newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = clone, newBaseState = newState) : newBaseQueueLast = newBaseQueueLast.next = clone, currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane), markSkippedUpdateLanes(updateLane);
            }
            update = update.next;
          } while (update !== null && update !== first);
          newBaseQueueLast === null ? newBaseState = newState : newBaseQueueLast.next = newBaseQueueFirst, objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(), hook.memoizedState = newState, hook.baseState = newBaseState, hook.baseQueue = newBaseQueueLast, queue.lastRenderedState = newState;
        }
        var lastInterleaved = queue.interleaved;
        if (lastInterleaved !== null) {
          var interleaved = lastInterleaved;
          do {
            var interleavedLane = interleaved.lane;
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane), markSkippedUpdateLanes(interleavedLane), interleaved = interleaved.next;
          } while (interleaved !== lastInterleaved);
        } else baseQueue === null && (queue.lanes = NoLanes);
        var dispatch = queue.dispatch;
        return [hook.memoizedState, dispatch];
      }
      function rerenderReducer(reducer2, initialArg, init) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (queue === null)
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        queue.lastRenderedReducer = reducer2;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
          queue.pending = null;
          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next, update = firstRenderPhaseUpdate;
          do {
            var action = update.action;
            newState = reducer2(newState, action), update = update.next;
          } while (update !== firstRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(), hook.memoizedState = newState, hook.baseQueue === null && (hook.baseState = newState), queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountMutableSource(source, getSnapshot, subscribe) {
      }
      function updateMutableSource(source, getSnapshot, subscribe) {
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook(), nextSnapshot, isHydrating2 = getIsHydrating();
        if (isHydrating2) {
          if (getServerSnapshot === void 0)
            throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
          nextSnapshot = getServerSnapshot(), didWarnUncachedGetSnapshot || nextSnapshot !== getServerSnapshot() && (error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        } else {
          if (nextSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(nextSnapshot, cachedSnapshot) || (error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
          }
          var root = getWorkInProgressRoot();
          if (root === null)
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          includesBlockingLane(root, renderLanes) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
        }
        hook.memoizedState = nextSnapshot;
        var inst = {
          value: nextSnapshot,
          getSnapshot
        };
        return hook.queue = inst, mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]), fiber.flags |= Passive, pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null), nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), nextSnapshot = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedSnapshot = getSnapshot();
          objectIs(nextSnapshot, cachedSnapshot) || (error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        var prevSnapshot = hook.memoizedState, snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
        snapshotChanged && (hook.memoizedState = nextSnapshot, markWorkInProgressReceivedUpdate());
        var inst = hook.queue;
        if (updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]), inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
        // checking whether we scheduled a subscription effect above.
        workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= Passive, pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          var root = getWorkInProgressRoot();
          if (root === null)
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          includesBlockingLane(root, renderLanes) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
        }
        return nextSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= StoreConsistency;
        var check = {
          getSnapshot,
          value: renderedSnapshot
        }, componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = componentUpdateQueue, componentUpdateQueue.stores = [check];
        else {
          var stores = componentUpdateQueue.stores;
          stores === null ? componentUpdateQueue.stores = [check] : stores.push(check);
        }
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        var handleStoreChange = function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        };
        return subscribe(handleStoreChange);
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch {
          return !0;
        }
      }
      function forceStoreRerender(fiber) {
        var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
        root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
      }
      function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        typeof initialState == "function" && (initialState = initialState()), hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateState(initialState) {
        return updateReducer(basicStateReducer);
      }
      function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
      }
      function pushEffect(tag, create2, destroy, deps) {
        var effect = {
          tag,
          create: create2,
          destroy,
          deps,
          // Circular
          next: null
        }, componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null)
          componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = componentUpdateQueue, componentUpdateQueue.lastEffect = effect.next = effect;
        else {
          var lastEffect = componentUpdateQueue.lastEffect;
          if (lastEffect === null)
            componentUpdateQueue.lastEffect = effect.next = effect;
          else {
            var firstEffect = lastEffect.next;
            lastEffect.next = effect, effect.next = firstEffect, componentUpdateQueue.lastEffect = effect;
          }
        }
        return effect;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        {
          var _ref2 = {
            current: initialValue
          };
          return hook.memoizedState = _ref2, _ref2;
        }
      }
      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, void 0, nextDeps);
      }
      function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
        var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, destroy = void 0;
        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          if (destroy = prevEffect.destroy, nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              hook.memoizedState = pushEffect(hookFlags, create2, destroy, nextDeps);
              return;
            }
          }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, destroy, nextDeps);
      }
      function mountEffect(create2, deps) {
        return (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create2, deps) : mountEffectImpl(Passive | PassiveStatic, Passive$1, create2, deps);
      }
      function updateEffect(create2, deps) {
        return updateEffectImpl(Passive, Passive$1, create2, deps);
      }
      function mountInsertionEffect(create2, deps) {
        return mountEffectImpl(Update, Insertion, create2, deps);
      }
      function updateInsertionEffect(create2, deps) {
        return updateEffectImpl(Update, Insertion, create2, deps);
      }
      function mountLayoutEffect(create2, deps) {
        var fiberFlags = Update;
        return fiberFlags |= LayoutStatic, (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), mountEffectImpl(fiberFlags, Layout, create2, deps);
      }
      function updateLayoutEffect(create2, deps) {
        return updateEffectImpl(Update, Layout, create2, deps);
      }
      function imperativeHandleEffect(create2, ref) {
        if (typeof ref == "function") {
          var refCallback = ref, _inst = create2();
          return refCallback(_inst), function() {
            refCallback(null);
          };
        } else if (ref != null) {
          var refObject = ref;
          refObject.hasOwnProperty("current") || error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
          var _inst2 = create2();
          return refObject.current = _inst2, function() {
            refObject.current = null;
          };
        }
      }
      function mountImperativeHandle(ref, create2, deps) {
        typeof create2 != "function" && error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
        var effectDeps = deps != null ? deps.concat([ref]) : null, fiberFlags = Update;
        return fiberFlags |= LayoutStatic, (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
      }
      function updateImperativeHandle(ref, create2, deps) {
        typeof create2 != "function" && error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
        var effectDeps = deps != null ? deps.concat([ref]) : null;
        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
      }
      function mountDebugValue(value, formatterFn) {
      }
      var updateDebugValue = mountDebugValue;
      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps;
        return hook.memoizedState = [callback, nextDeps], callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, prevState = hook.memoizedState;
        if (prevState !== null && nextDeps !== null) {
          var prevDeps = prevState[1];
          if (areHookInputsEqual(nextDeps, prevDeps))
            return prevState[0];
        }
        return hook.memoizedState = [callback, nextDeps], callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, nextValue = nextCreate();
        return hook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, prevState = hook.memoizedState;
        if (prevState !== null && nextDeps !== null) {
          var prevDeps = prevState[1];
          if (areHookInputsEqual(nextDeps, prevDeps))
            return prevState[0];
        }
        var nextValue = nextCreate();
        return hook.memoizedState = [nextValue, nextDeps], nextValue;
      }
      function mountDeferredValue(value) {
        var hook = mountWorkInProgressHook();
        return hook.memoizedState = value, value;
      }
      function updateDeferredValue(value) {
        var hook = updateWorkInProgressHook(), resolvedCurrentHook = currentHook, prevValue = resolvedCurrentHook.memoizedState;
        return updateDeferredValueImpl(hook, prevValue, value);
      }
      function rerenderDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        if (currentHook === null)
          return hook.memoizedState = value, value;
        var prevValue = currentHook.memoizedState;
        return updateDeferredValueImpl(hook, prevValue, value);
      }
      function updateDeferredValueImpl(hook, prevValue, value) {
        var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
        if (shouldDeferValue) {
          if (!objectIs(value, prevValue)) {
            var deferredLane = claimNextTransitionLane();
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane), markSkippedUpdateLanes(deferredLane), hook.baseState = !0;
          }
          return prevValue;
        } else
          return hook.baseState && (hook.baseState = !1, markWorkInProgressReceivedUpdate()), hook.memoizedState = value, value;
      }
      function startTransition(setPending, callback, options) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority)), setPending(!0);
        var prevTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition = {};
        var currentTransition = ReactCurrentBatchConfig$1.transition;
        ReactCurrentBatchConfig$1.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          setPending(!1), callback();
        } finally {
          if (setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$1.transition = prevTransition, prevTransition === null && currentTransition._updatedFibers) {
            var updatedFibersCount = currentTransition._updatedFibers.size;
            updatedFibersCount > 10 && warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), currentTransition._updatedFibers.clear();
          }
        }
      }
      function mountTransition() {
        var _mountState = mountState(!1), isPending = _mountState[0], setPending = _mountState[1], start = startTransition.bind(null, setPending), hook = mountWorkInProgressHook();
        return hook.memoizedState = start, [isPending, start];
      }
      function updateTransition() {
        var _updateState = updateState(), isPending = _updateState[0], hook = updateWorkInProgressHook(), start = hook.memoizedState;
        return [isPending, start];
      }
      function rerenderTransition() {
        var _rerenderState = rerenderState(), isPending = _rerenderState[0], hook = updateWorkInProgressHook(), start = hook.memoizedState;
        return [isPending, start];
      }
      var isUpdatingOpaqueValueInRenderPhase = !1;
      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        return isUpdatingOpaqueValueInRenderPhase;
      }
      function mountId() {
        var hook = mountWorkInProgressHook(), root = getWorkInProgressRoot(), identifierPrefix = root.identifierPrefix, id;
        if (getIsHydrating()) {
          var treeId = getTreeId();
          id = ":" + identifierPrefix + "R" + treeId;
          var localId = localIdCounter++;
          localId > 0 && (id += "H" + localId.toString(32)), id += ":";
        } else {
          var globalClientId = globalClientIdCounter++;
          id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
        }
        return hook.memoizedState = id, id;
      }
      function updateId() {
        var hook = updateWorkInProgressHook(), id = hook.memoizedState;
        return id;
      }
      function dispatchReducerAction(fiber, queue, action) {
        typeof arguments[3] == "function" && error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        var lane = requestUpdateLane(fiber), update = {
          lane,
          action,
          hasEagerState: !1,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber))
          enqueueRenderPhaseUpdate(queue, update);
        else {
          var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root, fiber, lane, eventTime), entangleTransitionUpdate(root, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function dispatchSetState(fiber, queue, action) {
        typeof arguments[3] == "function" && error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
        var lane = requestUpdateLane(fiber), update = {
          lane,
          action,
          hasEagerState: !1,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber))
          enqueueRenderPhaseUpdate(queue, update);
        else {
          var alternate = fiber.alternate;
          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
            var lastRenderedReducer = queue.lastRenderedReducer;
            if (lastRenderedReducer !== null) {
              var prevDispatcher;
              prevDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = lastRenderedReducer(currentState, action);
                if (update.hasEagerState = !0, update.eagerState = eagerState, objectIs(eagerState, currentState)) {
                  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                  return;
                }
              } catch {
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            }
          }
          var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root, fiber, lane, eventTime), entangleTransitionUpdate(root, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
        var pending = queue.pending;
        pending === null ? update.next = update : (update.next = pending.next, pending.next = update), queue.pending = update;
      }
      function entangleTransitionUpdate(root, queue, lane) {
        if (isTransitionLane(lane)) {
          var queueLanes = queue.lanes;
          queueLanes = intersectLanes(queueLanes, root.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          queue.lanes = newQueueLanes, markRootEntangled(root, newQueueLanes);
        }
      }
      function markUpdateInDevTools(fiber, lane, action) {
        markStateUpdateScheduled(fiber, lane);
      }
      var ContextOnlyDispatcher = {
        readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
      }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      {
        var warnInvalidContextAccess = function() {
          error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
        }, warnInvalidHookAccess = function() {
          error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
        };
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", mountHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", mountHookTypesDev(), checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", mountHookTypesDev(), mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", mountHookTypesDev(), void 0;
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", mountHookTypesDev(), mountDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", mountHookTypesDev(), mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", mountHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", mountHookTypesDev(), mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", mountHookTypesDev(), mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", updateHookTypesDev(), mountCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", updateHookTypesDev(), mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", updateHookTypesDev(), mountInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", updateHookTypesDev(), mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), void 0;
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), mountDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", updateHookTypesDev(), mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", updateHookTypesDev(), mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", updateHookTypesDev(), mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", updateHookTypesDev(), updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", updateHookTypesDev(), updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), updateDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", updateHookTypesDev(), updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", updateHookTypesDev(), updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", updateHookTypesDev(), updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", updateHookTypesDev(), updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), rerenderDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", updateHookTypesDev(), rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", updateHookTypesDev(), updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return warnInvalidContextAccess(), readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), mountHookTypesDev(), mountCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", warnInvalidHookAccess(), mountHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), mountHookTypesDev(), mountImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", warnInvalidHookAccess(), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", warnInvalidHookAccess(), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", warnInvalidHookAccess(), mountHookTypesDev(), mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", warnInvalidHookAccess(), mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), mountHookTypesDev(), void 0;
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), mountHookTypesDev(), mountDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), mountHookTypesDev(), mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), mountHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", warnInvalidHookAccess(), mountHookTypesDev(), mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", warnInvalidHookAccess(), mountHookTypesDev(), mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return warnInvalidContextAccess(), readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", warnInvalidHookAccess(), updateHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), updateHookTypesDev(), updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), updateHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", warnInvalidHookAccess(), updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", warnInvalidHookAccess(), updateHookTypesDev(), updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        }, InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return warnInvalidContextAccess(), readContext(context);
          },
          useCallback: function(callback, deps) {
            return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), updateHookTypesDev(), updateCallback(callback, deps);
          },
          useContext: function(context) {
            return currentHookNameInDev = "useContext", warnInvalidHookAccess(), updateHookTypesDev(), readContext(context);
          },
          useEffect: function(create2, deps) {
            return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateEffect(create2, deps);
          },
          useImperativeHandle: function(ref, create2, deps) {
            return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
          },
          useInsertionEffect: function(create2, deps) {
            return currentHookNameInDev = "useInsertionEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateInsertionEffect(create2, deps);
          },
          useLayoutEffect: function(create2, deps) {
            return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateLayoutEffect(create2, deps);
          },
          useMemo: function(create2, deps) {
            currentHookNameInDev = "useMemo", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create2, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer2, initialArg, init) {
            currentHookNameInDev = "useReducer", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer2, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            return currentHookNameInDev = "useRef", warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState", warnInvalidHookAccess(), updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDebugValue();
          },
          useDeferredValue: function(value) {
            return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), updateHookTypesDev(), rerenderDeferredValue(value);
          },
          useTransition: function() {
            return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), updateHookTypesDev(), rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), updateHookTypesDev(), void 0;
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            return currentHookNameInDev = "useSyncExternalStore", warnInvalidHookAccess(), updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            return currentHookNameInDev = "useId", warnInvalidHookAccess(), updateHookTypesDev(), updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
      }
      var now$1 = Scheduler.unstable_now, commitTime = 0, layoutEffectStartTime = -1, profilerStartTime = -1, passiveEffectStartTime = -1, currentUpdateIsNested = !1, nestedUpdateScheduled = !1;
      function isCurrentUpdateNested() {
        return currentUpdateIsNested;
      }
      function markNestedUpdateScheduled() {
        nestedUpdateScheduled = !0;
      }
      function resetNestedUpdateFlag() {
        currentUpdateIsNested = !1, nestedUpdateScheduled = !1;
      }
      function syncNestedUpdateFlag() {
        currentUpdateIsNested = nestedUpdateScheduled, nestedUpdateScheduled = !1;
      }
      function getCommitTime() {
        return commitTime;
      }
      function recordCommitTime() {
        commitTime = now$1();
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now$1(), fiber.actualStartTime < 0 && (fiber.actualStartTime = now$1());
      }
      function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
      }
      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
          var elapsedTime = now$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime, overrideBaseTime && (fiber.selfBaseDuration = elapsedTime), profilerStartTime = -1;
        }
      }
      function recordLayoutEffectDuration(fiber) {
        if (layoutEffectStartTime >= 0) {
          var elapsedTime = now$1() - layoutEffectStartTime;
          layoutEffectStartTime = -1;
          for (var parentFiber = fiber.return; parentFiber !== null; ) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root = parentFiber.stateNode;
                root.effectDuration += elapsedTime;
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                parentStateNode.effectDuration += elapsedTime;
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function recordPassiveEffectDuration(fiber) {
        if (passiveEffectStartTime >= 0) {
          var elapsedTime = now$1() - passiveEffectStartTime;
          passiveEffectStartTime = -1;
          for (var parentFiber = fiber.return; parentFiber !== null; ) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root = parentFiber.stateNode;
                root !== null && (root.passiveEffectDuration += elapsedTime);
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                parentStateNode !== null && (parentStateNode.passiveEffectDuration += elapsedTime);
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function startLayoutEffectTimer() {
        layoutEffectStartTime = now$1();
      }
      function startPassiveEffectTimer() {
        passiveEffectStartTime = now$1();
      }
      function transferActualDuration(fiber) {
        for (var child = fiber.child; child; )
          fiber.actualDuration += child.actualDuration, child = child.sibling;
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps), defaultProps = Component.defaultProps;
          for (var propName in defaultProps)
            props[propName] === void 0 && (props[propName] = defaultProps[propName]);
          return props;
        }
        return baseProps;
      }
      var fakeInternalInstance = {}, didWarnAboutStateAssignmentForComponent, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType, didWarnAboutLegacyContext$1;
      {
        didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set(), didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set(), didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        warnOnInvalidCallback = function(callback, callerName) {
          if (!(callback === null || typeof callback == "function")) {
            var key = callerName + "_" + callback;
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
          }
        }, warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === void 0) {
            var componentName = getComponentNameFromType(type) || "Component";
            didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
          }
        }, Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: !1,
          value: function() {
            throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
          }
        }), Object.freeze(fakeInternalInstance);
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState == null ? prevState : assign({}, prevState, partialState);
        if (workInProgress2.memoizedState = memoizedState, workInProgress2.lanes === NoLanes) {
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = memoizedState;
        }
      }
      var classComponentUpdater = {
        isMounted,
        enqueueSetState: function(inst, payload, callback) {
          var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
          update.payload = payload, callback != null && (warnOnInvalidCallback(callback, "setState"), update.callback = callback);
          var root = enqueueUpdate(fiber, update, lane);
          root !== null && (scheduleUpdateOnFiber(root, fiber, lane, eventTime), entangleTransitions(root, fiber, lane)), markStateUpdateScheduled(fiber, lane);
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
          update.tag = ReplaceState, update.payload = payload, callback != null && (warnOnInvalidCallback(callback, "replaceState"), update.callback = callback);
          var root = enqueueUpdate(fiber, update, lane);
          root !== null && (scheduleUpdateOnFiber(root, fiber, lane, eventTime), entangleTransitions(root, fiber, lane)), markStateUpdateScheduled(fiber, lane);
        },
        enqueueForceUpdate: function(inst, callback) {
          var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
          update.tag = ForceUpdate, callback != null && (warnOnInvalidCallback(callback, "forceUpdate"), update.callback = callback);
          var root = enqueueUpdate(fiber, update, lane);
          root !== null && (scheduleUpdateOnFiber(root, fiber, lane, eventTime), entangleTransitions(root, fiber, lane)), markForceUpdateScheduled(fiber, lane);
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if (typeof instance.shouldComponentUpdate == "function") {
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(!0);
              try {
                shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              } finally {
                setIsStrictModeForDevtools(!1);
              }
            }
            shouldUpdate === void 0 && error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
          }
          return shouldUpdate;
        }
        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
      }
      function checkClassInstance(workInProgress2, ctor, newProps) {
        var instance = workInProgress2.stateNode;
        {
          var name = getComponentNameFromType(ctor) || "Component", renderPresent = instance.render;
          renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name) : error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name)), instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state && error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name), instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name), instance.propTypes && error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name), instance.contextType && error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name), ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
          // this one.
          (workInProgress2.mode & StrictLegacyMode) === NoMode && (didWarnAboutLegacyContext$1.add(ctor), error(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, name)), ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
          // this one.
          (workInProgress2.mode & StrictLegacyMode) === NoMode && (didWarnAboutLegacyContext$1.add(ctor), error(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, name)), instance.contextTypes && error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name)), typeof instance.componentShouldUpdate == "function" && error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate < "u" && error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component"), typeof instance.componentDidUnmount == "function" && error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name), typeof instance.componentDidReceiveProps == "function" && error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name), typeof instance.componentWillRecieveProps == "function" && error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name), typeof instance.UNSAFE_componentWillRecieveProps == "function" && error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance.props !== newProps;
          instance.props !== void 0 && hasMutatedProps && error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name), instance.defaultProps && error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name), typeof instance.getSnapshotBeforeUpdate == "function" && typeof instance.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor))), typeof instance.getDerivedStateFromProps == "function" && error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof instance.getDerivedStateFromError == "function" && error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name), typeof ctor.getSnapshotBeforeUpdate == "function" && error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var _state = instance.state;
          _state && (typeof _state != "object" || isArray(_state)) && error("%s.state: must be set to an object or null", name), typeof instance.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
        }
      }
      function adoptClassInstance(workInProgress2, instance) {
        instance.updater = classComponentUpdater, workInProgress2.stateNode = instance, set(instance, workInProgress2), instance._reactInternalInstance = fakeInternalInstance;
      }
      function constructClassInstance(workInProgress2, ctor, props) {
        var isLegacyContextConsumer = !1, unmaskedContext = emptyContextObject, context = emptyContextObject, contextType = ctor.contextType;
        if ("contextType" in ctor) {
          var isValid = (
            // Allow null for conditional declaration
            contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
          );
          if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            var addendum = "";
            contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
          }
        }
        if (typeof contextType == "object" && contextType !== null)
          context = readContext(contextType);
        else {
          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes != null, context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
        }
        var instance = new ctor(props, context);
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            instance = new ctor(props, context);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
        adoptClassInstance(workInProgress2, instance);
        {
          if (typeof ctor.getDerivedStateFromProps == "function" && state === null) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
          }
          if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            if (typeof instance.componentWillMount == "function" && instance.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
        }
        return isLegacyContextConsumer && cacheContext(workInProgress2, unmaskedContext, context), instance;
      }
      function callComponentWillMount(workInProgress2, instance) {
        var oldState = instance.state;
        typeof instance.componentWillMount == "function" && instance.componentWillMount(), typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount(), oldState !== instance.state && (error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps(newProps, nextContext), typeof instance.UNSAFE_componentWillReceiveProps == "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext), instance.state !== oldState) {
          {
            var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
            didWarnAboutStateAssignmentForComponent.has(componentName) || (didWarnAboutStateAssignmentForComponent.add(componentName), error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName));
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        checkClassInstance(workInProgress2, ctor, newProps);
        var instance = workInProgress2.stateNode;
        instance.props = newProps, instance.state = workInProgress2.memoizedState, instance.refs = {}, initializeUpdateQueue(workInProgress2);
        var contextType = ctor.contextType;
        if (typeof contextType == "object" && contextType !== null)
          instance.context = readContext(contextType);
        else {
          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          instance.context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance), ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
        }
        instance.state = workInProgress2.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), instance.state = workInProgress2.memoizedState), typeof ctor.getDerivedStateFromProps != "function" && typeof instance.getSnapshotBeforeUpdate != "function" && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (callComponentWillMount(workInProgress2, instance), processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), instance.state = workInProgress2.memoizedState), typeof instance.componentDidMount == "function") {
          var fiberFlags = Update;
          fiberFlags |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), workInProgress2.flags |= fiberFlags;
        }
      }
      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode, oldProps = workInProgress2.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context, contextType = ctor.contextType, nextContext = emptyContextObject;
        if (typeof contextType == "object" && contextType !== null)
          nextContext = readContext(contextType);
        else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps, hasNewLifecycles = typeof getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function";
        !hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps == "function" || typeof instance.componentWillReceiveProps == "function") && (oldProps !== newProps || oldContext !== nextContext) && callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext), resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState, newState = instance.state = oldState;
        if (processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), newState = workInProgress2.memoizedState, oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount == "function") {
            var fiberFlags = Update;
            fiberFlags |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), workInProgress2.flags |= fiberFlags;
          }
          return !1;
        }
        typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), newState = workInProgress2.memoizedState);
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (typeof instance.componentWillMount == "function" && instance.componentWillMount(), typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount()), typeof instance.componentDidMount == "function") {
            var _fiberFlags = Update;
            _fiberFlags |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (_fiberFlags |= MountLayoutDev), workInProgress2.flags |= _fiberFlags;
          }
        } else {
          if (typeof instance.componentDidMount == "function") {
            var _fiberFlags2 = Update;
            _fiberFlags2 |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (_fiberFlags2 |= MountLayoutDev), workInProgress2.flags |= _fiberFlags2;
          }
          workInProgress2.memoizedProps = newProps, workInProgress2.memoizedState = newState;
        }
        return instance.props = newProps, instance.state = newState, instance.context = nextContext, shouldUpdate;
      }
      function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress2.pendingProps, oldContext = instance.context, contextType = ctor.contextType, nextContext = emptyContextObject;
        if (typeof contextType == "object" && contextType !== null)
          nextContext = readContext(contextType);
        else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps, hasNewLifecycles = typeof getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function";
        !hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps == "function" || typeof instance.componentWillReceiveProps == "function") && (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) && callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext), resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState, newState = instance.state = oldState;
        if (processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), newState = workInProgress2.memoizedState, unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation)
          return typeof instance.componentDidUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Snapshot), !1;
        typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), newState = workInProgress2.memoizedState);
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
        // both before and after `shouldComponentUpdate` has been called. Not ideal,
        // but I'm loath to refactor this function. This only happens for memoized
        // components so it's not that common.
        enableLazyContextPropagation;
        return shouldUpdate ? (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate == "function" || typeof instance.componentWillUpdate == "function") && (typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate(newProps, newState, nextContext), typeof instance.UNSAFE_componentWillUpdate == "function" && instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext)), typeof instance.componentDidUpdate == "function" && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (workInProgress2.flags |= Snapshot)) : (typeof instance.componentDidUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Snapshot), workInProgress2.memoizedProps = newProps, workInProgress2.memoizedState = newState), instance.props = newProps, instance.state = newState, instance.context = nextContext, shouldUpdate;
      }
      function createCapturedValueAtFiber(value, source) {
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source),
          digest: null
        };
      }
      function createCapturedValue(value, digest, stack) {
        return {
          value,
          source: null,
          stack: stack ?? null,
          digest: digest ?? null
        };
      }
      function showErrorDialog(boundary, errorInfo) {
        return !0;
      }
      function logCapturedError(boundary, errorInfo) {
        try {
          var logError = showErrorDialog(boundary, errorInfo);
          if (logError === !1)
            return;
          var error2 = errorInfo.value, source = errorInfo.source, stack = errorInfo.stack, componentStack = stack !== null ? stack : "";
          if (error2 != null && error2._suppressLogging) {
            if (boundary.tag === ClassComponent)
              return;
            console.error(error2);
          }
          var componentName = source ? getComponentNameFromFiber(source) : null, componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:", errorBoundaryMessage;
          if (boundary.tag === HostRoot)
            errorBoundaryMessage = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
          else {
            var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
            errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
          }
          var combinedMessage = componentNameMessage + `
` + componentStack + `

` + ("" + errorBoundaryMessage);
          console.error(combinedMessage);
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      var PossiblyWeakMap$1 = typeof WeakMap == "function" ? WeakMap : Map;
      function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate, update.payload = {
          element: null
        };
        var error2 = errorInfo.value;
        return update.callback = function() {
          onUncaughtError(error2), logCapturedError(fiber, errorInfo);
        }, update;
      }
      function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError == "function") {
          var error$1 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error$1);
          }, update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber), logCapturedError(fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        return inst !== null && typeof inst.componentDidCatch == "function" && (update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber), logCapturedError(fiber, errorInfo), typeof getDerivedStateFromError != "function" && markLegacyErrorBoundaryAsFailed(this);
          var error$12 = errorInfo.value, stack = errorInfo.stack;
          this.componentDidCatch(error$12, {
            componentStack: stack !== null ? stack : ""
          }), typeof getDerivedStateFromError != "function" && (includesSomeLane(fiber.lanes, SyncLane) || error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown"));
        }), update;
      }
      function attachPingListener(root, wakeable, lanes) {
        var pingCache = root.pingCache, threadIDs;
        if (pingCache === null ? (pingCache = root.pingCache = new PossiblyWeakMap$1(), threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs)) : (threadIDs = pingCache.get(wakeable), threadIDs === void 0 && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs))), !threadIDs.has(lanes)) {
          threadIDs.add(lanes);
          var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
          isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(ping, ping);
        }
      }
      function attachRetryListener(suspenseBoundary, root, wakeable, lanes) {
        var wakeables = suspenseBoundary.updateQueue;
        if (wakeables === null) {
          var updateQueue = /* @__PURE__ */ new Set();
          updateQueue.add(wakeable), suspenseBoundary.updateQueue = updateQueue;
        } else
          wakeables.add(wakeable);
      }
      function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
        var tag = sourceFiber.tag;
        if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
          var currentSource = sourceFiber.alternate;
          currentSource ? (sourceFiber.updateQueue = currentSource.updateQueue, sourceFiber.memoizedState = currentSource.memoizedState, sourceFiber.lanes = currentSource.lanes) : (sourceFiber.updateQueue = null, sourceFiber.memoizedState = null);
        }
      }
      function getNearestSuspenseBoundaryToCapture(returnFiber) {
        var node = returnFiber;
        do {
          if (node.tag === SuspenseComponent && shouldCaptureSuspense(node))
            return node;
          node = node.return;
        } while (node !== null);
        return null;
      }
      function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {
        if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
          if (suspenseBoundary === returnFiber)
            suspenseBoundary.flags |= ShouldCapture;
          else {
            if (suspenseBoundary.flags |= DidCapture, sourceFiber.flags |= ForceUpdateForLegacySuspense, sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete), sourceFiber.tag === ClassComponent) {
              var currentSourceFiber = sourceFiber.alternate;
              if (currentSourceFiber === null)
                sourceFiber.tag = IncompleteClassComponent;
              else {
                var update = createUpdate(NoTimestamp, SyncLane);
                update.tag = ForceUpdate, enqueueUpdate(sourceFiber, update, SyncLane);
              }
            }
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
          }
          return suspenseBoundary;
        }
        return suspenseBoundary.flags |= ShouldCapture, suspenseBoundary.lanes = rootRenderLanes, suspenseBoundary;
      }
      function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
        if (sourceFiber.flags |= Incomplete, isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes), value !== null && typeof value == "object" && typeof value.then == "function") {
          var wakeable = value;
          resetSuspendedComponent(sourceFiber), getIsHydrating() && sourceFiber.mode & ConcurrentMode && markDidThrowWhileHydratingDEV();
          var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
          if (suspenseBoundary !== null) {
            suspenseBoundary.flags &= ~ForceClientRender, markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes), suspenseBoundary.mode & ConcurrentMode && attachPingListener(root, wakeable, rootRenderLanes), attachRetryListener(suspenseBoundary, root, wakeable);
            return;
          } else {
            if (!includesSyncLane(rootRenderLanes)) {
              attachPingListener(root, wakeable, rootRenderLanes), renderDidSuspendDelayIfPossible();
              return;
            }
            var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
            value = uncaughtSuspenseError;
          }
        } else if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
          markDidThrowWhileHydratingDEV();
          var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
          if (_suspenseBoundary !== null) {
            (_suspenseBoundary.flags & ShouldCapture) === NoFlags && (_suspenseBoundary.flags |= ForceClientRender), markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes), queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
            return;
          }
        }
        value = createCapturedValueAtFiber(value, sourceFiber), renderDidError(value);
        var workInProgress2 = returnFiber;
        do {
          switch (workInProgress2.tag) {
            case HostRoot: {
              var _errorInfo = value;
              workInProgress2.flags |= ShouldCapture;
              var lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
              enqueueCapturedUpdate(workInProgress2, update);
              return;
            }
            case ClassComponent:
              var errorInfo = value, ctor = workInProgress2.type, instance = workInProgress2.stateNode;
              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError == "function" || instance !== null && typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress2.flags |= ShouldCapture;
                var _lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                enqueueCapturedUpdate(workInProgress2, _update);
                return;
              }
              break;
          }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2 !== null);
      }
      function getSuspendedCache() {
        return null;
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, didReceiveUpdate = !1, didWarnAboutBadClass, didWarnAboutModulePatternComponent, didWarnAboutContextTypeOnFunctionComponent, didWarnAboutGetDerivedStateOnFunctionComponent, didWarnAboutFunctionRefs, didWarnAboutReassigningProps, didWarnAboutRevealOrder, didWarnAboutTailOptions, didWarnAboutDefaultPropsOnFunctionComponent;
      didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutFunctionRefs = {}, didWarnAboutReassigningProps = !1, didWarnAboutRevealOrder = {}, didWarnAboutTailOptions = {}, didWarnAboutDefaultPropsOnFunctionComponent = {};
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        current2 === null ? workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
      }
      function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
      }
      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var innerPropTypes = Component.propTypes;
          innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            // Resolved props
            "prop",
            getComponentNameFromType(Component)
          );
        }
        var render3 = Component.render, ref = workInProgress2.ref, nextChildren, hasId;
        prepareToReadContext(workInProgress2, renderLanes2), markComponentRenderStarted(workInProgress2);
        {
          if (ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref, renderLanes2), hasId = checkDidRenderIdHook(), workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref, renderLanes2), hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          setIsRendering(!1);
        }
        return markComponentRenderStopped(), current2 !== null && !didReceiveUpdate ? (bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)) : (getIsHydrating() && hasId && pushMaterializedTreeId(workInProgress2), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child);
      }
      function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (current2 === null) {
          var type = Component.type;
          if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
          Component.defaultProps === void 0) {
            var resolvedType = type;
            return resolvedType = resolveFunctionForHotReloading(type), workInProgress2.tag = SimpleMemoComponent, workInProgress2.type = resolvedType, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
          }
          {
            var innerPropTypes = type.propTypes;
            if (innerPropTypes && checkPropTypes(
              innerPropTypes,
              nextProps,
              // Resolved props
              "prop",
              getComponentNameFromType(type)
            ), Component.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] || (error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName), didWarnAboutDefaultPropsOnFunctionComponent[componentName] = !0);
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
          return child.ref = workInProgress2.ref, child.return = workInProgress2, workInProgress2.child = child, child;
        }
        {
          var _type = Component.type, _innerPropTypes = _type.propTypes;
          _innerPropTypes && checkPropTypes(
            _innerPropTypes,
            nextProps,
            // Resolved props
            "prop",
            getComponentNameFromType(_type)
          );
        }
        var currentChild = current2.child, hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
        if (!hasScheduledUpdateOrContext) {
          var prevProps = currentChild.memoizedProps, compare = Component.compare;
          if (compare = compare !== null ? compare : shallowEqual, compare(prevProps, nextProps) && current2.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        return newChild.ref = workInProgress2.ref, newChild.return = workInProgress2, workInProgress2.child = newChild, newChild;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var outerMemoType = workInProgress2.elementType;
          if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
            var lazyComponent = outerMemoType, payload = lazyComponent._payload, init = lazyComponent._init;
            try {
              outerMemoType = init(payload);
            } catch {
              outerMemoType = null;
            }
            var outerPropTypes = outerMemoType && outerMemoType.propTypes;
            outerPropTypes && checkPropTypes(
              outerPropTypes,
              nextProps,
              // Resolved (SimpleMemoComponent has no defaultProps)
              "prop",
              getComponentNameFromType(outerMemoType)
            );
          }
        }
        if (current2 !== null) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
          workInProgress2.type === current2.type)
            if (didReceiveUpdate = !1, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
              (current2.flags & ForceUpdateForLegacySuspense) !== NoFlags && (didReceiveUpdate = !0);
            else return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = current2 !== null ? current2.memoizedState : null;
        if (nextProps.mode === "hidden" || enableLegacyHidden)
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            var nextState = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = nextState, pushRenderLanes(workInProgress2, renderLanes2);
          } else if (includesSomeLane(renderLanes2, OffscreenLane)) {
            var _nextState2 = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState2;
            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
          } else {
            var spawnedCachePool = null, nextBaseLanes;
            if (prevState !== null) {
              var prevBaseLanes = prevState.baseLanes;
              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
            } else
              nextBaseLanes = renderLanes2;
            workInProgress2.lanes = workInProgress2.childLanes = OffscreenLane;
            var _nextState = {
              baseLanes: nextBaseLanes,
              cachePool: spawnedCachePool,
              transitions: null
            };
            return workInProgress2.memoizedState = _nextState, workInProgress2.updateQueue = null, pushRenderLanes(workInProgress2, nextBaseLanes), null;
          }
        else {
          var _subtreeRenderLanes;
          prevState !== null ? (_subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2), workInProgress2.memoizedState = null) : _subtreeRenderLanes = renderLanes2, pushRenderLanes(workInProgress2, _subtreeRenderLanes);
        }
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateFragment(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps;
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateMode(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps.children;
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateProfiler(current2, workInProgress2, renderLanes2) {
        {
          workInProgress2.flags |= Update;
          {
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
          }
        }
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children;
        return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function markRef(current2, workInProgress2) {
        var ref = workInProgress2.ref;
        (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) && (workInProgress2.flags |= Ref, workInProgress2.flags |= RefStatic);
      }
      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (workInProgress2.type !== workInProgress2.elementType) {
          var innerPropTypes = Component.propTypes;
          innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            // Resolved props
            "prop",
            getComponentNameFromType(Component)
          );
        }
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, !0);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        var nextChildren, hasId;
        prepareToReadContext(workInProgress2, renderLanes2), markComponentRenderStarted(workInProgress2);
        {
          if (ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2), hasId = checkDidRenderIdHook(), workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2), hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          setIsRendering(!1);
        }
        return markComponentRenderStopped(), current2 !== null && !didReceiveUpdate ? (bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)) : (getIsHydrating() && hasId && pushMaterializedTreeId(workInProgress2), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child);
      }
      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          switch (shouldError(workInProgress2)) {
            case !1: {
              var _instance = workInProgress2.stateNode, ctor = workInProgress2.type, tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context), state = tempInstance.state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            }
            case !0: {
              workInProgress2.flags |= DidCapture, workInProgress2.flags |= ShouldCapture;
              var error$1 = new Error("Simulated error coming from DevTools"), lane = pickArbitraryLane(renderLanes2);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
              enqueueCapturedUpdate(workInProgress2, update);
              break;
            }
          }
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            innerPropTypes && checkPropTypes(
              innerPropTypes,
              nextProps,
              // Resolved props
              "prop",
              getComponentNameFromType(Component)
            );
          }
        }
        var hasContext;
        isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, prepareToReadContext(workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode, shouldUpdate;
        instance === null ? (resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2), constructClassInstance(workInProgress2, Component, nextProps), mountClassInstance(workInProgress2, Component, nextProps, renderLanes2), shouldUpdate = !0) : current2 === null ? shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2) : shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
        var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
        {
          var inst = workInProgress2.stateNode;
          shouldUpdate && inst.props !== nextProps && (didWarnAboutReassigningProps || error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component"), didWarnAboutReassigningProps = !0);
        }
        return nextUnitOfWork;
      }
      function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
        markRef(current2, workInProgress2);
        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError)
          return hasContext && invalidateContextProvider(workInProgress2, Component, !1), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode;
        ReactCurrentOwner$1.current = workInProgress2;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError != "function")
          nextChildren = null, stopProfilerTimerIfRunning();
        else {
          markComponentRenderStarted(workInProgress2);
          {
            if (setIsRendering(!0), nextChildren = instance.render(), workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(!0);
              try {
                instance.render();
              } finally {
                setIsStrictModeForDevtools(!1);
              }
            }
            setIsRendering(!1);
          }
          markComponentRenderStopped();
        }
        return workInProgress2.flags |= PerformedWork, current2 !== null && didCaptureError ? forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) : reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.memoizedState = instance.state, hasContext && invalidateContextProvider(workInProgress2, Component, !0), workInProgress2.child;
      }
      function pushHostRootContext(workInProgress2) {
        var root = workInProgress2.stateNode;
        root.pendingContext ? pushTopLevelContextObject(workInProgress2, root.pendingContext, root.pendingContext !== root.context) : root.context && pushTopLevelContextObject(workInProgress2, root.context, !1), pushHostContainer(workInProgress2, root.containerInfo);
      }
      function updateHostRoot(current2, workInProgress2, renderLanes2) {
        if (pushHostRootContext(workInProgress2), current2 === null)
          throw new Error("Should have a current fiber. This is a bug in React.");
        var nextProps = workInProgress2.pendingProps, prevState = workInProgress2.memoizedState, prevChildren = prevState.element;
        cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
        var nextState = workInProgress2.memoizedState, root = workInProgress2.stateNode, nextChildren = nextState.element;
        if (supportsHydration && prevState.isDehydrated) {
          var overrideState = {
            element: nextChildren,
            isDehydrated: !1,
            cache: nextState.cache,
            pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
            transitions: nextState.transitions
          }, updateQueue = workInProgress2.updateQueue;
          if (updateQueue.baseState = overrideState, workInProgress2.memoizedState = overrideState, workInProgress2.flags & ForceClientRender) {
            var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
          } else if (nextChildren !== prevChildren) {
            var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
          } else {
            enterHydrationState(workInProgress2);
            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            workInProgress2.child = child;
            for (var node = child; node; )
              node.flags = node.flags & ~Placement | Hydrating, node = node.sibling;
          }
        } else {
          if (resetHydrationState(), nextChildren === prevChildren)
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
        return resetHydrationState(), queueHydrationError(recoverableError), workInProgress2.flags |= ForceClientRender, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateHostComponent(current2, workInProgress2, renderLanes2) {
        pushHostContext(workInProgress2), current2 === null && tryToClaimNextHydratableInstance(workInProgress2);
        var type = workInProgress2.type, nextProps = workInProgress2.pendingProps, prevProps = current2 !== null ? current2.memoizedProps : null, nextChildren = nextProps.children, isDirectTextChild = shouldSetTextContent(type, nextProps);
        return isDirectTextChild ? nextChildren = null : prevProps !== null && shouldSetTextContent(type, prevProps) && (workInProgress2.flags |= ContentReset), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      function updateHostText(current2, workInProgress2) {
        return current2 === null && tryToClaimNextHydratableInstance(workInProgress2), null;
      }
      function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps, lazyComponent = elementType, payload = lazyComponent._payload, init = lazyComponent._init, Component = init(payload);
        workInProgress2.type = Component;
        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component), resolvedProps = resolveDefaultProps(Component, props), child;
        switch (resolvedTag) {
          case FunctionComponent:
            return validateFunctionComponentInDev(workInProgress2, Component), workInProgress2.type = Component = resolveFunctionForHotReloading(Component), child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
          case ClassComponent:
            return workInProgress2.type = Component = resolveClassForHotReloading(Component), child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
          case ForwardRef:
            return workInProgress2.type = Component = resolveForwardRefForHotReloading(Component), child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
          case MemoComponent: {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerPropTypes = Component.propTypes;
              outerPropTypes && checkPropTypes(
                outerPropTypes,
                resolvedProps,
                // Resolved for outer only
                "prop",
                getComponentNameFromType(Component)
              );
            }
            return child = updateMemoComponent(
              null,
              workInProgress2,
              Component,
              resolveDefaultProps(Component.type, resolvedProps),
              // The inner type can have defaults too
              renderLanes2
            ), child;
          }
        }
        var hint = "";
        throw Component !== null && typeof Component == "object" && Component.$$typeof === REACT_LAZY_TYPE && (hint = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
      }
      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2), workInProgress2.tag = ClassComponent;
        var hasContext;
        return isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, prepareToReadContext(workInProgress2, renderLanes2), constructClassInstance(workInProgress2, Component, nextProps), mountClassInstance(workInProgress2, Component, nextProps, renderLanes2), finishClassComponent(null, workInProgress2, Component, !0, hasContext, renderLanes2);
      }
      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps, context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, !1);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var value, hasId;
        markComponentRenderStarted(workInProgress2);
        {
          if (Component.prototype && typeof Component.prototype.render == "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutBadClass[componentName] || (error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null), setIsRendering(!0), ReactCurrentOwner$1.current = workInProgress2, value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2), hasId = checkDidRenderIdHook(), setIsRendering(!1);
        }
        if (markComponentRenderStopped(), workInProgress2.flags |= PerformedWork, typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0) {
          var _componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
        }
        if (
          // Run these checks in production only if the flag is off.
          // Eventually we'll delete this branch altogether.
          typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0
        ) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutModulePatternComponent[_componentName2] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
          }
          workInProgress2.tag = ClassComponent, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null;
          var hasContext = !1;
          return isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null, initializeUpdateQueue(workInProgress2), adoptClassInstance(workInProgress2, value), mountClassInstance(workInProgress2, Component, props, renderLanes2), finishClassComponent(null, workInProgress2, Component, !0, hasContext, renderLanes2);
        } else {
          if (workInProgress2.tag = FunctionComponent, workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2), hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          return getIsHydrating() && hasId && pushMaterializedTreeId(workInProgress2), reconcileChildren(null, workInProgress2, value, renderLanes2), validateFunctionComponentInDev(workInProgress2, Component), workInProgress2.child;
        }
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        {
          if (Component && Component.childContextTypes && error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component"), workInProgress2.ref !== null) {
            var info = "", ownerName = getCurrentFiberOwnerNameInDevOrNull();
            ownerName && (info += `

Check the render method of \`` + ownerName + "`.");
            var warningKey = ownerName || "", debugSource = workInProgress2._debugSource;
            debugSource && (warningKey = debugSource.fileName + ":" + debugSource.lineNumber), didWarnAboutFunctionRefs[warningKey] || (didWarnAboutFunctionRefs[warningKey] = !0, error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info));
          }
          if (Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutDefaultPropsOnFunctionComponent[componentName] || (error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName), didWarnAboutDefaultPropsOnFunctionComponent[componentName] = !0);
          }
          if (typeof Component.getDerivedStateFromProps == "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
          }
          if (typeof Component.contextType == "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
          }
        }
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: NoLane
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return {
          baseLanes: renderLanes2,
          cachePool: getSuspendedCache(),
          transitions: null
        };
      }
      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
        var cachePool = null;
        return {
          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
          cachePool,
          transitions: prevOffscreenState.transitions
        };
      }
      function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          var suspenseState = current2.memoizedState;
          if (suspenseState === null)
            return !1;
        }
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      }
      function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
        return removeLanes(current2.childLanes, renderLanes2);
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        shouldSuspend(workInProgress2) && (workInProgress2.flags |= DidCapture);
        var suspenseContext = suspenseStackCursor.current, showFallback = !1, didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current2) ? (showFallback = !0, workInProgress2.flags &= ~DidCapture) : (current2 === null || current2.memoizedState !== null) && (suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext)), suspenseContext = setDefaultShallowSuspenseContext(suspenseContext), pushSuspenseContext(workInProgress2, suspenseContext), current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
          var suspenseState = workInProgress2.memoizedState;
          if (suspenseState !== null) {
            var dehydrated = suspenseState.dehydrated;
            if (dehydrated !== null)
              return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
          }
          var nextPrimaryChildren = nextProps.children, nextFallbackChildren = nextProps.fallback;
          if (showFallback) {
            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2), primaryChildFragment = workInProgress2.child;
            return primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackFragment;
          } else
            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
        } else {
          var prevState = current2.memoizedState;
          if (prevState !== null) {
            var _dehydrated = prevState.dehydrated;
            if (_dehydrated !== null)
              return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
          }
          if (showFallback) {
            var _nextFallbackChildren = nextProps.fallback, _nextPrimaryChildren = nextProps.children, fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2), _primaryChildFragment2 = workInProgress2.child, prevOffscreenState = current2.child.memoizedState;
            return _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2), _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackChildFragment;
          } else {
            var _nextPrimaryChildren2 = nextProps.children, _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
            return workInProgress2.memoizedState = null, _primaryChildFragment3;
          }
        }
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
        var mode = workInProgress2.mode, primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        }, primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
        return primaryChildFragment.return = workInProgress2, workInProgress2.child = primaryChildFragment, primaryChildFragment;
      }
      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode, progressedPrimaryFragment = workInProgress2.child, primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        }, primaryChildFragment, fallbackChildFragment;
        return (mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null ? (primaryChildFragment = progressedPrimaryFragment, primaryChildFragment.childLanes = NoLanes, primaryChildFragment.pendingProps = primaryChildProps, workInProgress2.mode & ProfileMode && (primaryChildFragment.actualDuration = 0, primaryChildFragment.actualStartTime = -1, primaryChildFragment.selfBaseDuration = 0, primaryChildFragment.treeBaseDuration = 0), fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null)) : (primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode), fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null)), primaryChildFragment.return = workInProgress2, fallbackChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, fallbackChildFragment;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
        return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
      }
      function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
        return createWorkInProgress(current2, offscreenProps);
      }
      function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
        var currentPrimaryChildFragment = current2.child, currentFallbackChildFragment = currentPrimaryChildFragment.sibling, primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
          mode: "visible",
          children: primaryChildren
        });
        if ((workInProgress2.mode & ConcurrentMode) === NoMode && (primaryChildFragment.lanes = renderLanes2), primaryChildFragment.return = workInProgress2, primaryChildFragment.sibling = null, currentFallbackChildFragment !== null) {
          var deletions = workInProgress2.deletions;
          deletions === null ? (workInProgress2.deletions = [currentFallbackChildFragment], workInProgress2.flags |= ChildDeletion) : deletions.push(currentFallbackChildFragment);
        }
        return workInProgress2.child = primaryChildFragment, primaryChildFragment;
      }
      function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode, currentPrimaryChildFragment = current2.child, currentFallbackChildFragment = currentPrimaryChildFragment.sibling, primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        }, primaryChildFragment;
        if (
          // In legacy mode, we commit the primary tree as if it successfully
          // completed, even though it's in an inconsistent state.
          (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
          // already cloned. In legacy mode, the only case where this isn't true is
          // when DevTools forces us to display a fallback; we skip the first render
          // pass entirely and go straight to rendering the fallback. (In Concurrent
          // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
          // only codepath.)
          workInProgress2.child !== currentPrimaryChildFragment
        ) {
          var progressedPrimaryFragment = workInProgress2.child;
          primaryChildFragment = progressedPrimaryFragment, primaryChildFragment.childLanes = NoLanes, primaryChildFragment.pendingProps = primaryChildProps, workInProgress2.mode & ProfileMode && (primaryChildFragment.actualDuration = 0, primaryChildFragment.actualStartTime = -1, primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration, primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration), workInProgress2.deletions = null;
        } else
          primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps), primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
        var fallbackChildFragment;
        return currentFallbackChildFragment !== null ? fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren) : (fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null), fallbackChildFragment.flags |= Placement), fallbackChildFragment.return = workInProgress2, primaryChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, fallbackChildFragment;
      }
      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
        recoverableError !== null && queueHydrationError(recoverableError), reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        var nextProps = workInProgress2.pendingProps, primaryChildren = nextProps.children, primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
        return primaryChildFragment.flags |= Placement, workInProgress2.memoizedState = null, primaryChildFragment;
      }
      function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var fiberMode = workInProgress2.mode, primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        }, primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode), fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
        return fallbackChildFragment.flags |= Placement, primaryChildFragment.return = workInProgress2, fallbackChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, (workInProgress2.mode & ConcurrentMode) !== NoMode && reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), fallbackChildFragment;
      }
      function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
        return (workInProgress2.mode & ConcurrentMode) === NoMode ? (error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), workInProgress2.lanes = SyncLane) : isSuspenseInstanceFallback(suspenseInstance) ? workInProgress2.lanes = DefaultHydrationLane : workInProgress2.lanes = OffscreenLane, null;
      }
      function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
        if (didSuspend)
          if (workInProgress2.flags & ForceClientRender) {
            workInProgress2.flags &= ~ForceClientRender;
            var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
          } else {
            if (workInProgress2.memoizedState !== null)
              return workInProgress2.child = current2.child, workInProgress2.flags |= DidCapture, null;
            var nextPrimaryChildren = nextProps.children, nextFallbackChildren = nextProps.fallback, fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2), _primaryChildFragment4 = workInProgress2.child;
            return _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackChildFragment;
          }
        else {
          if (warnIfHydrating(), (workInProgress2.mode & ConcurrentMode) === NoMode)
            return retrySuspenseComponentWithoutHydrating(
              current2,
              workInProgress2,
              renderLanes2,
              // TODO: When we delete legacy mode, we should make this error argument
              // required — every concurrent mode path that causes hydration to
              // de-opt to client rendering should have an error message.
              null
            );
          if (isSuspenseInstanceFallback(suspenseInstance)) {
            var digest, message, stack;
            {
              var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
              digest = _getSuspenseInstanceF.digest, message = _getSuspenseInstanceF.message, stack = _getSuspenseInstanceF.stack;
            }
            var error2;
            message ? error2 = new Error(message) : error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
            var capturedValue = createCapturedValue(error2, digest, stack);
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
          }
          var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
          if (didReceiveUpdate || hasContextChanged2) {
            var root = getWorkInProgressRoot();
            if (root !== null) {
              var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes2);
              if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                suspenseState.retryLane = attemptHydrationAtLane;
                var eventTime = NoTimestamp;
                enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane), scheduleUpdateOnFiber(root, current2, attemptHydrationAtLane, eventTime);
              }
            }
            renderDidSuspendDelayIfPossible();
            var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
          } else if (isSuspenseInstancePending(suspenseInstance)) {
            workInProgress2.flags |= DidCapture, workInProgress2.child = current2.child;
            var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
            return registerSuspenseInstanceRetry(suspenseInstance, retry), null;
          } else {
            reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
            var primaryChildren = nextProps.children, primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            return primaryChildFragment.flags |= Hydrating, primaryChildFragment;
          }
        }
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
        var alternate = fiber.alternate;
        alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)), scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
        for (var node = firstChild; node !== null; ) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            state !== null && scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
          } else if (node.tag === SuspenseListComponent)
            scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
          else if (node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === workInProgress2)
            return;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === workInProgress2)
              return;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
      }
      function findLastContentRow(firstChild) {
        for (var row = firstChild, lastContentRow = null; row !== null; ) {
          var currentRow = row.alternate;
          currentRow !== null && findFirstSuspended(currentRow) === null && (lastContentRow = row), row = row.sibling;
        }
        return lastContentRow;
      }
      function validateRevealOrder(revealOrder) {
        if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder])
          if (didWarnAboutRevealOrder[revealOrder] = !0, typeof revealOrder == "string")
            switch (revealOrder.toLowerCase()) {
              case "together":
              case "forwards":
              case "backwards": {
                error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                break;
              }
              case "forward":
              case "backward": {
                error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                break;
              }
              default:
                error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                break;
            }
          else
            error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
      }
      function validateTailOptions(tailMode, revealOrder) {
        tailMode !== void 0 && !didWarnAboutTailOptions[tailMode] && (tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[tailMode] = !0, error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && (didWarnAboutTailOptions[tailMode] = !0, error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
      }
      function validateSuspenseListNestedChild(childSlot, index2) {
        {
          var isAnArray = isArray(childSlot), isIterable = !isAnArray && typeof getIteratorFn(childSlot) == "function";
          if (isAnArray || isIterable) {
            var type = isAnArray ? "array" : "iterable";
            return error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index2, type), !1;
          }
        }
        return !0;
      }
      function validateSuspenseListChildren(children, revealOrder) {
        if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== !1)
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++)
              if (!validateSuspenseListNestedChild(children[i], i))
                return;
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn == "function") {
              var childrenIterator = iteratorFn.call(children);
              if (childrenIterator)
                for (var step = childrenIterator.next(), _i = 0; !step.done; step = childrenIterator.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i))
                    return;
                  _i++;
                }
            } else
              error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
          }
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        renderState === null ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children;
        validateRevealOrder(revealOrder), validateTailOptions(tailMode, revealOrder), validateSuspenseListChildren(newChildren, revealOrder), reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        var suspenseContext = suspenseStackCursor.current, shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback)
          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback), workInProgress2.flags |= DidCapture;
        else {
          var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
          didSuspendBefore && propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2), suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        if (pushSuspenseContext(workInProgress2, suspenseContext), (workInProgress2.mode & ConcurrentMode) === NoMode)
          workInProgress2.memoizedState = null;
        else
          switch (revealOrder) {
            case "forwards": {
              var lastContentRow = findLastContentRow(workInProgress2.child), tail;
              lastContentRow === null ? (tail = workInProgress2.child, workInProgress2.child = null) : (tail = lastContentRow.sibling, lastContentRow.sibling = null), initSuspenseListRenderState(
                workInProgress2,
                !1,
                // isBackwards
                tail,
                lastContentRow,
                tailMode
              );
              break;
            }
            case "backwards": {
              var _tail = null, row = workInProgress2.child;
              for (workInProgress2.child = null; row !== null; ) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                  workInProgress2.child = row;
                  break;
                }
                var nextRow = row.sibling;
                row.sibling = _tail, _tail = row, row = nextRow;
              }
              initSuspenseListRenderState(
                workInProgress2,
                !0,
                // isBackwards
                _tail,
                null,
                // last
                tailMode
              );
              break;
            }
            case "together": {
              initSuspenseListRenderState(
                workInProgress2,
                !1,
                // isBackwards
                null,
                // tail
                null,
                // last
                void 0
              );
              break;
            }
            default:
              workInProgress2.memoizedState = null;
          }
        return workInProgress2.child;
      }
      function updatePortalComponent(current2, workInProgress2, renderLanes2) {
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        var nextChildren = workInProgress2.pendingProps;
        return current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
      }
      var hasWarnedAboutUsingNoValuePropOnContextProvider = !1;
      function updateContextProvider(current2, workInProgress2, renderLanes2) {
        var providerType = workInProgress2.type, context = providerType._context, newProps = workInProgress2.pendingProps, oldProps = workInProgress2.memoizedProps, newValue = newProps.value;
        {
          "value" in newProps || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
          var providerPropTypes = workInProgress2.type.propTypes;
          providerPropTypes && checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
        }
        if (pushProvider(workInProgress2, context, newValue), oldProps !== null) {
          var oldValue = oldProps.value;
          if (objectIs(oldValue, newValue)) {
            if (oldProps.children === newProps.children && !hasContextChanged())
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          } else
            propagateContextChange(workInProgress2, context, renderLanes2);
        }
        var newChildren = newProps.children;
        return reconcileChildren(current2, workInProgress2, newChildren, renderLanes2), workInProgress2.child;
      }
      var hasWarnedAboutUsingContextAsConsumer = !1;
      function updateContextConsumer(current2, workInProgress2, renderLanes2) {
        var context = workInProgress2.type;
        context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
        var newProps = workInProgress2.pendingProps, render3 = newProps.children;
        typeof render3 != "function" && error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2, renderLanes2);
        var newValue = readContext(context);
        markComponentRenderStarted(workInProgress2);
        var newChildren;
        return ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), newChildren = render3(newValue), setIsRendering(!1), markComponentRenderStopped(), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, newChildren, renderLanes2), workInProgress2.child;
      }
      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = !0;
      }
      function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
        (workInProgress2.mode & ConcurrentMode) === NoMode && current2 !== null && (current2.alternate = null, workInProgress2.alternate = null, workInProgress2.flags |= Placement);
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        return current2 !== null && (workInProgress2.dependencies = current2.dependencies), stopProfilerTimerIfRunning(), markSkippedUpdateLanes(workInProgress2.lanes), includesSomeLane(renderLanes2, workInProgress2.childLanes) ? (cloneChildFibers(current2, workInProgress2), workInProgress2.child) : null;
      }
      function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
        {
          var returnFiber = oldWorkInProgress.return;
          if (returnFiber === null)
            throw new Error("Cannot swap the root fiber.");
          if (current2.alternate = null, oldWorkInProgress.alternate = null, newWorkInProgress.index = oldWorkInProgress.index, newWorkInProgress.sibling = oldWorkInProgress.sibling, newWorkInProgress.return = oldWorkInProgress.return, newWorkInProgress.ref = oldWorkInProgress.ref, oldWorkInProgress === returnFiber.child)
            returnFiber.child = newWorkInProgress;
          else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null)
              throw new Error("Expected parent to have a child.");
            for (; prevSibling.sibling !== oldWorkInProgress; )
              if (prevSibling = prevSibling.sibling, prevSibling === null)
                throw new Error("Expected to find the previous sibling.");
            prevSibling.sibling = newWorkInProgress;
          }
          var deletions = returnFiber.deletions;
          return deletions === null ? (returnFiber.deletions = [current2], returnFiber.flags |= ChildDeletion) : deletions.push(current2), newWorkInProgress.flags |= Placement, newWorkInProgress;
        }
      }
      function checkScheduledUpdateOrContext(current2, renderLanes2) {
        var updateLanes = current2.lanes;
        return !!includesSomeLane(updateLanes, renderLanes2);
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress2);
            var root = workInProgress2.stateNode;
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress2);
            break;
          case ClassComponent: {
            var Component = workInProgress2.type;
            isContextProvider(Component) && pushContextProvider(workInProgress2);
            break;
          }
          case HostPortal:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case ContextProvider: {
            var newValue = workInProgress2.memoizedProps.value, context = workInProgress2.type._context;
            pushProvider(workInProgress2, context, newValue);
            break;
          }
          case Profiler:
            {
              var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              hasChildWork && (workInProgress2.flags |= Update);
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
              }
            }
            break;
          case SuspenseComponent: {
            var state = workInProgress2.memoizedState;
            if (state !== null) {
              if (state.dehydrated !== null)
                return pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current)), workInProgress2.flags |= DidCapture, null;
              var primaryChildFragment = workInProgress2.child, primaryChildLanes = primaryChildFragment.childLanes;
              if (includesSomeLane(renderLanes2, primaryChildLanes))
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              return child !== null ? child.sibling : null;
            } else
              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            break;
          }
          case SuspenseListComponent: {
            var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags, _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
            if (didSuspendBefore) {
              if (_hasChildWork)
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              workInProgress2.flags |= DidCapture;
            }
            var renderState = workInProgress2.memoizedState;
            if (renderState !== null && (renderState.rendering = null, renderState.tail = null, renderState.lastEffect = null), pushSuspenseContext(workInProgress2, suspenseStackCursor.current), _hasChildWork)
              break;
            return null;
          }
          case OffscreenComponent:
          case LegacyHiddenComponent:
            return workInProgress2.lanes = NoLanes, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
        }
        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        if (workInProgress2._debugNeedsRemount && current2 !== null)
          return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
        if (current2 !== null) {
          var oldProps = current2.memoizedProps, newProps = workInProgress2.pendingProps;
          if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
          workInProgress2.type !== current2.type)
            didReceiveUpdate = !0;
          else {
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
            // may not be work scheduled on `current`, so we check for this flag.
            (workInProgress2.flags & DidCapture) === NoFlags)
              return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
            (current2.flags & ForceUpdateForLegacySuspense) !== NoFlags ? didReceiveUpdate = !0 : didReceiveUpdate = !1;
          }
        } else if (didReceiveUpdate = !1, getIsHydrating() && isForkedChild(workInProgress2)) {
          var slotIndex = workInProgress2.index, numberOfForks = getForksAtLevel();
          pushTreeId(workInProgress2, numberOfForks, slotIndex);
        }
        switch (workInProgress2.lanes = NoLanes, workInProgress2.tag) {
          case IndeterminateComponent:
            return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
          case LazyComponent: {
            var elementType = workInProgress2.elementType;
            return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
          }
          case FunctionComponent: {
            var Component = workInProgress2.type, unresolvedProps = workInProgress2.pendingProps, resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
            return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
          }
          case ClassComponent: {
            var _Component = workInProgress2.type, _unresolvedProps = workInProgress2.pendingProps, _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
            return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
          }
          case HostRoot:
            return updateHostRoot(current2, workInProgress2, renderLanes2);
          case HostComponent:
            return updateHostComponent(current2, workInProgress2, renderLanes2);
          case HostText:
            return updateHostText(current2, workInProgress2);
          case SuspenseComponent:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case HostPortal:
            return updatePortalComponent(current2, workInProgress2, renderLanes2);
          case ForwardRef: {
            var type = workInProgress2.type, _unresolvedProps2 = workInProgress2.pendingProps, _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
            return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
          }
          case Fragment:
            return updateFragment(current2, workInProgress2, renderLanes2);
          case Mode:
            return updateMode(current2, workInProgress2, renderLanes2);
          case Profiler:
            return updateProfiler(current2, workInProgress2, renderLanes2);
          case ContextProvider:
            return updateContextProvider(current2, workInProgress2, renderLanes2);
          case ContextConsumer:
            return updateContextConsumer(current2, workInProgress2, renderLanes2);
          case MemoComponent: {
            var _type2 = workInProgress2.type, _unresolvedProps3 = workInProgress2.pendingProps, _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerPropTypes = _type2.propTypes;
              outerPropTypes && checkPropTypes(
                outerPropTypes,
                _resolvedProps3,
                // Resolved for outer only
                "prop",
                getComponentNameFromType(_type2)
              );
            }
            return _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3), updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
          }
          case SimpleMemoComponent:
            return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
          case IncompleteClassComponent: {
            var _Component2 = workInProgress2.type, _unresolvedProps4 = workInProgress2.pendingProps, _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
            return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
          }
          case SuspenseListComponent:
            return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
          case ScopeComponent:
            break;
          case OffscreenComponent:
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= Update;
      }
      function markRef$1(workInProgress2) {
        workInProgress2.flags |= Ref, workInProgress2.flags |= RefStatic;
      }
      function hadNoMutationsEffects(current2, completedWork) {
        var didBailout = current2 !== null && current2.child === completedWork.child;
        if (didBailout)
          return !0;
        if ((completedWork.flags & ChildDeletion) !== NoFlags)
          return !1;
        for (var child = completedWork.child; child !== null; ) {
          if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags)
            return !1;
          child = child.sibling;
        }
        return !0;
      }
      var appendAllChildren, updateHostContainer, updateHostComponent$1, updateHostText$1;
      if (supportsMutation)
        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden2) {
          for (var node = workInProgress2.child; node !== null; ) {
            if (node.tag === HostComponent || node.tag === HostText)
              appendInitialChild(parent, node.stateNode);
            else if (node.tag !== HostPortal) {
              if (node.child !== null) {
                node.child.return = node, node = node.child;
                continue;
              }
            }
            if (node === workInProgress2)
              return;
            for (; node.sibling === null; ) {
              if (node.return === null || node.return === workInProgress2)
                return;
              node = node.return;
            }
            node.sibling.return = node.return, node = node.sibling;
          }
        }, updateHostContainer = function(current2, workInProgress2) {
        }, updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
          var oldProps = current2.memoizedProps;
          if (oldProps !== newProps) {
            var instance = workInProgress2.stateNode, currentHostContext = getHostContext(), updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload, updatePayload && markUpdate(workInProgress2);
          }
        }, updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
          oldText !== newText && markUpdate(workInProgress2);
        };
      else if (supportsPersistence) {
        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden2) {
          for (var node = workInProgress2.child; node !== null; ) {
            if (node.tag === HostComponent) {
              var instance = node.stateNode;
              if (needsVisibilityToggle && isHidden2) {
                var props = node.memoizedProps, type = node.type;
                instance = cloneHiddenInstance(instance, type, props, node);
              }
              appendInitialChild(parent, instance);
            } else if (node.tag === HostText) {
              var _instance = node.stateNode;
              if (needsVisibilityToggle && isHidden2) {
                var text = node.memoizedProps;
                _instance = cloneHiddenTextInstance(_instance, text, node);
              }
              appendInitialChild(parent, _instance);
            } else if (node.tag !== HostPortal) {
              if (node.tag === OffscreenComponent && node.memoizedState !== null) {
                var child = node.child;
                child !== null && (child.return = node), appendAllChildren(parent, node, !0, !0);
              } else if (node.child !== null) {
                node.child.return = node, node = node.child;
                continue;
              }
            }
            if (node = node, node === workInProgress2)
              return;
            for (; node.sibling === null; ) {
              if (node.return === null || node.return === workInProgress2)
                return;
              node = node.return;
            }
            node.sibling.return = node.return, node = node.sibling;
          }
        };
        var appendAllChildrenToContainer = function(containerChildSet, workInProgress2, needsVisibilityToggle, isHidden2) {
          for (var node = workInProgress2.child; node !== null; ) {
            if (node.tag === HostComponent) {
              var instance = node.stateNode;
              if (needsVisibilityToggle && isHidden2) {
                var props = node.memoizedProps, type = node.type;
                instance = cloneHiddenInstance(instance, type, props, node);
              }
              appendChildToContainerChildSet(containerChildSet, instance);
            } else if (node.tag === HostText) {
              var _instance2 = node.stateNode;
              if (needsVisibilityToggle && isHidden2) {
                var text = node.memoizedProps;
                _instance2 = cloneHiddenTextInstance(_instance2, text, node);
              }
              appendChildToContainerChildSet(containerChildSet, _instance2);
            } else if (node.tag !== HostPortal) {
              if (node.tag === OffscreenComponent && node.memoizedState !== null) {
                var child = node.child;
                child !== null && (child.return = node), appendAllChildrenToContainer(containerChildSet, node, !0, !0);
              } else if (node.child !== null) {
                node.child.return = node, node = node.child;
                continue;
              }
            }
            if (node = node, node === workInProgress2)
              return;
            for (; node.sibling === null; ) {
              if (node.return === null || node.return === workInProgress2)
                return;
              node = node.return;
            }
            node.sibling.return = node.return, node = node.sibling;
          }
        };
        updateHostContainer = function(current2, workInProgress2) {
          var portalOrRoot = workInProgress2.stateNode, childrenUnchanged = hadNoMutationsEffects(current2, workInProgress2);
          if (!childrenUnchanged) {
            var container = portalOrRoot.containerInfo, newChildSet = createContainerChildSet(container);
            appendAllChildrenToContainer(newChildSet, workInProgress2, !1, !1), portalOrRoot.pendingChildren = newChildSet, markUpdate(workInProgress2), finalizeContainerChildren(container, newChildSet);
          }
        }, updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
          var currentInstance = current2.stateNode, oldProps = current2.memoizedProps, childrenUnchanged = hadNoMutationsEffects(current2, workInProgress2);
          if (childrenUnchanged && oldProps === newProps) {
            workInProgress2.stateNode = currentInstance;
            return;
          }
          var recyclableInstance = workInProgress2.stateNode, currentHostContext = getHostContext(), updatePayload = null;
          if (oldProps !== newProps && (updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext)), childrenUnchanged && updatePayload === null) {
            workInProgress2.stateNode = currentInstance;
            return;
          }
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress2, childrenUnchanged, recyclableInstance);
          finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext) && markUpdate(workInProgress2), workInProgress2.stateNode = newInstance, childrenUnchanged ? markUpdate(workInProgress2) : appendAllChildren(newInstance, workInProgress2, !1, !1);
        }, updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
          if (oldText !== newText) {
            var rootContainerInstance = getRootHostContainer(), currentHostContext = getHostContext();
            workInProgress2.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress2), markUpdate(workInProgress2);
          } else
            workInProgress2.stateNode = current2.stateNode;
        };
      } else
        updateHostContainer = function(current2, workInProgress2) {
        }, updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
        }, updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
        };
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!getIsHydrating())
          switch (renderState.tailMode) {
            case "hidden": {
              for (var tailNode = renderState.tail, lastTailNode = null; tailNode !== null; )
                tailNode.alternate !== null && (lastTailNode = tailNode), tailNode = tailNode.sibling;
              lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            }
            case "collapsed": {
              for (var _tailNode = renderState.tail, _lastTailNode = null; _tailNode !== null; )
                _tailNode.alternate !== null && (_lastTailNode = _tailNode), _tailNode = _tailNode.sibling;
              _lastTailNode === null ? !hasRenderedATailFallback && renderState.tail !== null ? renderState.tail.sibling = null : renderState.tail = null : _lastTailNode.sibling = null;
              break;
            }
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = NoLanes, subtreeFlags = NoFlags;
        if (didBailout) {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; _child2 !== null; )
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)), subtreeFlags |= _child2.subtreeFlags & StaticMask, subtreeFlags |= _child2.flags & StaticMask, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else
            for (var _child3 = completedWork.child; _child3 !== null; )
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)), subtreeFlags |= _child3.subtreeFlags & StaticMask, subtreeFlags |= _child3.flags & StaticMask, _child3.return = completedWork, _child3 = _child3.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
        } else {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            for (var actualDuration = completedWork.actualDuration, treeBaseDuration = completedWork.selfBaseDuration, child = completedWork.child; child !== null; )
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)), subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, actualDuration += child.actualDuration, treeBaseDuration += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = actualDuration, completedWork.treeBaseDuration = treeBaseDuration;
          } else
            for (var _child = completedWork.child; _child !== null; )
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes)), subtreeFlags |= _child.subtreeFlags, subtreeFlags |= _child.flags, _child.return = completedWork, _child = _child.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
        }
        return completedWork.childLanes = newChildLanes, didBailout;
      }
      function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
        if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags)
          return warnIfUnhydratedTailNodes(workInProgress2), resetHydrationState(), workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture, !1;
        var wasHydrated = popHydrationState(workInProgress2);
        if (nextState !== null && nextState.dehydrated !== null)
          if (current2 === null) {
            if (!wasHydrated)
              throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
            if (prepareToHydrateHostSuspenseInstance(workInProgress2), bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode) {
              var isTimedOutSuspense = nextState !== null;
              if (isTimedOutSuspense) {
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment !== null && (workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration);
              }
            }
            return !1;
          } else {
            if (resetHydrationState(), (workInProgress2.flags & DidCapture) === NoFlags && (workInProgress2.memoizedState = null), workInProgress2.flags |= Update, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode) {
              var _isTimedOutSuspense = nextState !== null;
              if (_isTimedOutSuspense) {
                var _primaryChildFragment = workInProgress2.child;
                _primaryChildFragment !== null && (workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration);
              }
            }
            return !1;
          }
        else
          return upgradeHydrationErrorsToRecoverable(), !0;
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        switch (popTreeContext(workInProgress2), workInProgress2.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case SimpleMemoComponent:
          case FunctionComponent:
          case ForwardRef:
          case Fragment:
          case Mode:
          case Profiler:
          case ContextConsumer:
          case MemoComponent:
            return bubbleProperties(workInProgress2), null;
          case ClassComponent: {
            var Component = workInProgress2.type;
            return isContextProvider(Component) && popContext(workInProgress2), bubbleProperties(workInProgress2), null;
          }
          case HostRoot: {
            var fiberRoot = workInProgress2.stateNode;
            if (popHostContainer(workInProgress2), popTopLevelContextObject(workInProgress2), resetWorkInProgressVersions(), fiberRoot.pendingContext && (fiberRoot.context = fiberRoot.pendingContext, fiberRoot.pendingContext = null), current2 === null || current2.child === null) {
              var wasHydrated = popHydrationState(workInProgress2);
              if (wasHydrated)
                markUpdate(workInProgress2);
              else if (current2 !== null) {
                var prevState = current2.memoizedState;
                // Check if this is a client root
                (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                (workInProgress2.flags & ForceClientRender) !== NoFlags) && (workInProgress2.flags |= Snapshot, upgradeHydrationErrorsToRecoverable());
              }
            }
            return updateHostContainer(current2, workInProgress2), bubbleProperties(workInProgress2), null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            var rootContainerInstance = getRootHostContainer(), type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null)
              updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance), current2.ref !== workInProgress2.ref && markRef$1(workInProgress2);
            else {
              if (!newProps) {
                if (workInProgress2.stateNode === null)
                  throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                return bubbleProperties(workInProgress2), null;
              }
              var currentHostContext = getHostContext(), _wasHydrated = popHydrationState(workInProgress2);
              if (_wasHydrated)
                prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext) && markUpdate(workInProgress2);
              else {
                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                appendAllChildren(instance, workInProgress2, !1, !1), workInProgress2.stateNode = instance, finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext) && markUpdate(workInProgress2);
              }
              workInProgress2.ref !== null && markRef$1(workInProgress2);
            }
            return bubbleProperties(workInProgress2), null;
          }
          case HostText: {
            var newText = newProps;
            if (current2 && workInProgress2.stateNode != null) {
              var oldText = current2.memoizedProps;
              updateHostText$1(current2, workInProgress2, oldText, newText);
            } else {
              if (typeof newText != "string" && workInProgress2.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              var _rootContainerInstance = getRootHostContainer(), _currentHostContext = getHostContext(), _wasHydrated2 = popHydrationState(workInProgress2);
              _wasHydrated2 ? prepareToHydrateHostTextInstance(workInProgress2) && markUpdate(workInProgress2) : workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
            }
            return bubbleProperties(workInProgress2), null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var nextState = workInProgress2.memoizedState;
            if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
              var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
              if (!fallthroughToNormalSuspensePath)
                return workInProgress2.flags & ShouldCapture ? workInProgress2 : null;
            }
            if ((workInProgress2.flags & DidCapture) !== NoFlags)
              return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
            var nextDidTimeout = nextState !== null, prevDidTimeout = current2 !== null && current2.memoizedState !== null;
            if (nextDidTimeout !== prevDidTimeout && nextDidTimeout) {
              var _offscreenFiber2 = workInProgress2.child;
              if (_offscreenFiber2.flags |= Visibility, (workInProgress2.mode & ConcurrentMode) !== NoMode) {
                var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== !0 || !enableSuspenseAvoidThisFallback);
                hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext) ? renderDidSuspend() : renderDidSuspendDelayIfPossible();
              }
            }
            var wakeables = workInProgress2.updateQueue;
            if (wakeables !== null && (workInProgress2.flags |= Update), bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && nextDidTimeout) {
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment !== null && (workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration);
            }
            return null;
          }
          case HostPortal:
            return popHostContainer(workInProgress2), updateHostContainer(current2, workInProgress2), current2 === null && preparePortalMount(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            return popProvider(context, workInProgress2), bubbleProperties(workInProgress2), null;
          case IncompleteClassComponent: {
            var _Component = workInProgress2.type;
            return isContextProvider(_Component) && popContext(workInProgress2), bubbleProperties(workInProgress2), null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            var renderState = workInProgress2.memoizedState;
            if (renderState === null)
              return bubbleProperties(workInProgress2), null;
            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags, renderedTail = renderState.rendering;
            if (renderedTail === null)
              if (didSuspendAlready)
                cutOffTailIfNeeded(renderState, !1);
              else {
                var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                if (!cannotBeSuspended)
                  for (var row = workInProgress2.child; row !== null; ) {
                    var suspended = findFirstSuspended(row);
                    if (suspended !== null) {
                      didSuspendAlready = !0, workInProgress2.flags |= DidCapture, cutOffTailIfNeeded(renderState, !1);
                      var newThenables = suspended.updateQueue;
                      return newThenables !== null && (workInProgress2.updateQueue = newThenables, workInProgress2.flags |= Update), workInProgress2.subtreeFlags = NoFlags, resetChildFibers(workInProgress2, renderLanes2), pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)), workInProgress2.child;
                    }
                    row = row.sibling;
                  }
                renderState.tail !== null && now() > getRenderTargetTime() && (workInProgress2.flags |= DidCapture, didSuspendAlready = !0, cutOffTailIfNeeded(renderState, !1), workInProgress2.lanes = SomeRetryLane);
              }
            else {
              if (!didSuspendAlready) {
                var _suspended = findFirstSuspended(renderedTail);
                if (_suspended !== null) {
                  workInProgress2.flags |= DidCapture, didSuspendAlready = !0;
                  var _newThenables = _suspended.updateQueue;
                  if (_newThenables !== null && (workInProgress2.updateQueue = _newThenables, workInProgress2.flags |= Update), cutOffTailIfNeeded(renderState, !0), renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating())
                    return bubbleProperties(workInProgress2), null;
                } else // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane && (workInProgress2.flags |= DidCapture, didSuspendAlready = !0, cutOffTailIfNeeded(renderState, !1), workInProgress2.lanes = SomeRetryLane);
              }
              if (renderState.isBackwards)
                renderedTail.sibling = workInProgress2.child, workInProgress2.child = renderedTail;
              else {
                var previousSibling = renderState.last;
                previousSibling !== null ? previousSibling.sibling = renderedTail : workInProgress2.child = renderedTail, renderState.last = renderedTail;
              }
            }
            if (renderState.tail !== null) {
              var next = renderState.tail;
              renderState.rendering = next, renderState.tail = next.sibling, renderState.renderingStartTime = now(), next.sibling = null;
              var suspenseContext = suspenseStackCursor.current;
              return didSuspendAlready ? suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback) : suspenseContext = setDefaultShallowSuspenseContext(suspenseContext), pushSuspenseContext(workInProgress2, suspenseContext), next;
            }
            return bubbleProperties(workInProgress2), null;
          }
          case ScopeComponent:
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            popRenderLanes(workInProgress2);
            var _nextState = workInProgress2.memoizedState, nextIsHidden = _nextState !== null;
            if (current2 !== null) {
              var _prevState = current2.memoizedState, prevIsHidden = _prevState !== null;
              prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
              !enableLegacyHidden && (workInProgress2.flags |= Visibility);
            }
            return !nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode ? bubbleProperties(workInProgress2) : includesSomeLane(subtreeRenderLanes, OffscreenLane) && (bubbleProperties(workInProgress2), supportsMutation && workInProgress2.subtreeFlags & (Placement | Update) && (workInProgress2.flags |= Visibility)), null;
          }
          case CacheComponent:
            return null;
          case TracingMarkerComponent:
            return null;
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
      }
      function unwindWork(current2, workInProgress2, renderLanes2) {
        switch (popTreeContext(workInProgress2), workInProgress2.tag) {
          case ClassComponent: {
            var Component = workInProgress2.type;
            isContextProvider(Component) && popContext(workInProgress2);
            var flags = workInProgress2.flags;
            return flags & ShouldCapture ? (workInProgress2.flags = flags & ~ShouldCapture | DidCapture, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          }
          case HostRoot: {
            var root = workInProgress2.stateNode;
            popHostContainer(workInProgress2), popTopLevelContextObject(workInProgress2), resetWorkInProgressVersions();
            var _flags = workInProgress2.flags;
            return (_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags ? (workInProgress2.flags = _flags & ~ShouldCapture | DidCapture, workInProgress2) : null;
          }
          case HostComponent:
            return popHostContext(workInProgress2), null;
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              if (workInProgress2.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              resetHydrationState();
            }
            var _flags2 = workInProgress2.flags;
            return _flags2 & ShouldCapture ? (workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
          }
          case SuspenseListComponent:
            return popSuspenseContext(workInProgress2), null;
          case HostPortal:
            return popHostContainer(workInProgress2), null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            return popProvider(context, workInProgress2), null;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            return popRenderLanes(workInProgress2), null;
          case CacheComponent:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
        switch (popTreeContext(interruptedWork), interruptedWork.tag) {
          case ClassComponent: {
            var childContextTypes = interruptedWork.type.childContextTypes;
            childContextTypes != null && popContext(interruptedWork);
            break;
          }
          case HostRoot: {
            var root = interruptedWork.stateNode;
            popHostContainer(interruptedWork), popTopLevelContextObject(interruptedWork), resetWorkInProgressVersions();
            break;
          }
          case HostComponent: {
            popHostContext(interruptedWork);
            break;
          }
          case HostPortal:
            popHostContainer(interruptedWork);
            break;
          case SuspenseComponent:
            popSuspenseContext(interruptedWork);
            break;
          case SuspenseListComponent:
            popSuspenseContext(interruptedWork);
            break;
          case ContextProvider:
            var context = interruptedWork.type._context;
            popProvider(context, interruptedWork);
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(interruptedWork);
            break;
        }
      }
      function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
          func.apply(context, funcArgs);
        } catch (error2) {
          this.onError(error2);
        }
      }
      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
      if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
        var fakeNode = document.createElement("react");
        invokeGuardedCallbackImpl = function(name, func, context, a, b, c, d, e, f) {
          if (typeof document > "u" || document === null)
            throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
          var evt = document.createEvent("Event"), didCall = !1, didError = !0, windowEvent = window.event, windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
          function restoreAfterDispatch() {
            fakeNode.removeEventListener(evtType, callCallback2, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = windowEvent);
          }
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          function callCallback2() {
            didCall = !0, restoreAfterDispatch(), func.apply(context, funcArgs), didError = !1;
          }
          var error2, didSetError = !1, isCrossOriginError = !1;
          function handleWindowError(event) {
            if (error2 = event.error, didSetError = !0, error2 === null && event.colno === 0 && event.lineno === 0 && (isCrossOriginError = !0), event.defaultPrevented && error2 != null && typeof error2 == "object")
              try {
                error2._suppressLogging = !0;
              } catch {
              }
          }
          var evtType = "react-" + (name || "invokeguardedcallback");
          if (window.addEventListener("error", handleWindowError), fakeNode.addEventListener(evtType, callCallback2, !1), evt.initEvent(evtType, !1, !1), fakeNode.dispatchEvent(evt), windowEventDescriptor && Object.defineProperty(window, "event", windowEventDescriptor), didCall && didError && (didSetError ? isCrossOriginError && (error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(error2)), window.removeEventListener("error", handleWindowError), !didCall)
            return restoreAfterDispatch(), invokeGuardedCallbackProd.apply(this, arguments);
        };
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl, hasError = !1, caughtError = null, reporter = {
        onError: function(error2) {
          hasError = !0, caughtError = error2;
        }
      };
      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = !1, caughtError = null, invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }
      function hasCaughtError() {
        return hasError;
      }
      function clearCaughtError() {
        if (hasError) {
          var error2 = caughtError;
          return hasError = !1, caughtError = null, error2;
        } else
          throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
      }
      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
      var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, PossiblyWeakSet = typeof WeakSet == "function" ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null;
      function reportUncaughtErrorInDEV(error2) {
        invokeGuardedCallback(null, function() {
          throw error2;
        }), clearCaughtError();
      }
      var callComponentWillUnmountWithTimer = function(current2, instance) {
        if (instance.props = current2.memoizedProps, instance.state = current2.memoizedState, current2.mode & ProfileMode)
          try {
            startLayoutEffectTimer(), instance.componentWillUnmount();
          } finally {
            recordLayoutEffectDuration(current2);
          }
        else
          instance.componentWillUnmount();
      };
      function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
        try {
          commitHookEffectListMount(Layout, current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
        try {
          callComponentWillUnmountWithTimer(current2, instance);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentDidMount();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current2, nearestMountedAncestor) {
        try {
          commitAttachRef(current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current2, nearestMountedAncestor) {
        var ref = current2.ref;
        if (ref !== null)
          if (typeof ref == "function") {
            var retVal;
            try {
              if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode)
                try {
                  startLayoutEffectTimer(), retVal = ref(null);
                } finally {
                  recordLayoutEffectDuration(current2);
                }
              else
                retVal = ref(null);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
            typeof retVal == "function" && error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
          } else
            ref.current = null;
      }
      function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      var focusedInstanceHandle = null, shouldFireAfterActiveInstanceBlur = !1;
      function commitBeforeMutationEffects(root, firstChild) {
        focusedInstanceHandle = prepareForCommit(root.containerInfo), nextEffect = firstChild, commitBeforeMutationEffects_begin();
        var shouldFire = shouldFireAfterActiveInstanceBlur;
        return shouldFireAfterActiveInstanceBlur = !1, focusedInstanceHandle = null, shouldFire;
      }
      function commitBeforeMutationEffects_begin() {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect, child = fiber.child;
          (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null ? (child.return = fiber, nextEffect = child) : commitBeforeMutationEffects_complete();
        }
      }
      function commitBeforeMutationEffects_complete() {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            commitBeforeMutationEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return, nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitBeforeMutationEffectsOnFiber(finishedWork) {
        var current2 = finishedWork.alternate, flags = finishedWork.flags;
        if ((flags & Snapshot) !== NoFlags) {
          switch (setCurrentFiber(finishedWork), finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent:
              break;
            case ClassComponent: {
              if (current2 !== null) {
                var prevProps = current2.memoizedProps, prevState = current2.memoizedState, instance = finishedWork.stateNode;
                finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  snapshot === void 0 && !didWarnSet.has(finishedWork.type) && (didWarnSet.add(finishedWork.type), error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork)));
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
              }
              break;
            }
            case HostRoot: {
              if (supportsMutation) {
                var root = finishedWork.stateNode;
                clearContainer(root.containerInfo);
              }
              break;
            }
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
              break;
            default:
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
          resetCurrentFiber();
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next, effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              var destroy = effect.destroy;
              effect.destroy = void 0, destroy !== void 0 && ((flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!0), safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!1), (flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectUnmountStopped());
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next, effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              (flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectMountStarted(finishedWork);
              var create2 = effect.create;
              (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!0), effect.destroy = create2(), (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!1), (flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectMountStopped();
              {
                var destroy = effect.destroy;
                if (destroy !== void 0 && typeof destroy != "function") {
                  var hookName = void 0;
                  (effect.tag & Layout) !== NoFlags ? hookName = "useLayoutEffect" : (effect.tag & Insertion) !== NoFlags ? hookName = "useInsertionEffect" : hookName = "useEffect";
                  var addendum = void 0;
                  destroy === null ? addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof destroy.then == "function" ? addendum = `

It looks like you wrote ` + hookName + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : addendum = " You returned: " + destroy, error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitPassiveEffectDurations(finishedRoot, finishedWork) {
        if ((finishedWork.flags & Update) !== NoFlags)
          switch (finishedWork.tag) {
            case Profiler: {
              var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration, _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit, commitTime2 = getCommitTime(), phase = finishedWork.alternate === null ? "mount" : "update";
              isCurrentUpdateNested() && (phase = "nested-update"), typeof onPostCommit == "function" && onPostCommit(id, phase, passiveEffectDuration, commitTime2);
              var parentFiber = finishedWork.return;
              outer: for (; parentFiber !== null; ) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root = parentFiber.stateNode;
                    root.passiveEffectDuration += passiveEffectDuration;
                    break outer;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.passiveEffectDuration += passiveEffectDuration;
                    break outer;
                }
                parentFiber = parentFiber.return;
              }
              break;
            }
          }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
        if ((finishedWork.flags & LayoutMask) !== NoFlags)
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden)
                if (finishedWork.mode & ProfileMode)
                  try {
                    startLayoutEffectTimer(), commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                else
                  commitHookEffectListMount(Layout | HasEffect, finishedWork);
              break;
            }
            case ClassComponent: {
              var instance = finishedWork.stateNode;
              if (finishedWork.flags & Update && !offscreenSubtreeWasHidden)
                if (current2 === null)
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), finishedWork.mode & ProfileMode)
                    try {
                      startLayoutEffectTimer(), instance.componentDidMount();
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  else
                    instance.componentDidMount();
                else {
                  var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps), prevState = current2.memoizedState;
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), finishedWork.mode & ProfileMode)
                    try {
                      startLayoutEffectTimer(), instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  else
                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                }
              var updateQueue = finishedWork.updateQueue;
              updateQueue !== null && (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), commitUpdateQueue(finishedWork, updateQueue, instance));
              break;
            }
            case HostRoot: {
              var _updateQueue = finishedWork.updateQueue;
              if (_updateQueue !== null) {
                var _instance = null;
                if (finishedWork.child !== null)
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;
                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                commitUpdateQueue(finishedWork, _updateQueue, _instance);
              }
              break;
            }
            case HostComponent: {
              var _instance2 = finishedWork.stateNode;
              if (current2 === null && finishedWork.flags & Update) {
                var type = finishedWork.type, props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props, finishedWork);
              }
              break;
            }
            case HostText:
              break;
            case HostPortal:
              break;
            case Profiler: {
              {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender, effectDuration = finishedWork.stateNode.effectDuration, commitTime2 = getCommitTime(), phase = current2 === null ? "mount" : "update";
                isCurrentUpdateNested() && (phase = "nested-update"), typeof onRender == "function" && onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                {
                  typeof onCommit == "function" && onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2), enqueuePendingPassiveProfilerEffect(finishedWork);
                  var parentFiber = finishedWork.return;
                  outer: for (; parentFiber !== null; ) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root = parentFiber.stateNode;
                        root.effectDuration += effectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.effectDuration += effectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                }
              }
              break;
            }
            case SuspenseComponent: {
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            }
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
            case TracingMarkerComponent:
              break;
            default:
              throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
          }
        offscreenSubtreeWasHidden || finishedWork.flags & Ref && commitAttachRef(finishedWork);
      }
      function reappearLayoutEffectsOnFiber(node) {
        switch (node.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (node.mode & ProfileMode)
              try {
                startLayoutEffectTimer(), safelyCallCommitHookLayoutEffectListMount(node, node.return);
              } finally {
                recordLayoutEffectDuration(node);
              }
            else
              safelyCallCommitHookLayoutEffectListMount(node, node.return);
            break;
          }
          case ClassComponent: {
            var instance = node.stateNode;
            typeof instance.componentDidMount == "function" && safelyCallComponentDidMount(node, node.return, instance), safelyAttachRef(node, node.return);
            break;
          }
          case HostComponent: {
            safelyAttachRef(node, node.return);
            break;
          }
        }
      }
      function hideOrUnhideAllChildren(finishedWork, isHidden2) {
        var hostSubtreeRoot = null;
        if (supportsMutation)
          for (var node = finishedWork; ; ) {
            if (node.tag === HostComponent) {
              if (hostSubtreeRoot === null) {
                hostSubtreeRoot = node;
                try {
                  var instance = node.stateNode;
                  isHidden2 ? hideInstance(instance) : unhideInstance(node.stateNode, node.memoizedProps);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if (node.tag === HostText) {
              if (hostSubtreeRoot === null)
                try {
                  var _instance3 = node.stateNode;
                  isHidden2 ? hideTextInstance(_instance3) : unhideTextInstance(_instance3, node.memoizedProps);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
            } else if (!((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)) {
              if (node.child !== null) {
                node.child.return = node, node = node.child;
                continue;
              }
            }
            if (node === finishedWork)
              return;
            for (; node.sibling === null; ) {
              if (node.return === null || node.return === finishedWork)
                return;
              hostSubtreeRoot === node && (hostSubtreeRoot = null), node = node.return;
            }
            hostSubtreeRoot === node && (hostSubtreeRoot = null), node.sibling.return = node.return, node = node.sibling;
          }
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
          var instance = finishedWork.stateNode, instanceToUse;
          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;
            default:
              instanceToUse = instance;
          }
          if (typeof ref == "function") {
            var retVal;
            if (finishedWork.mode & ProfileMode)
              try {
                startLayoutEffectTimer(), retVal = ref(instanceToUse);
              } finally {
                recordLayoutEffectDuration(finishedWork);
              }
            else
              retVal = ref(instanceToUse);
            typeof retVal == "function" && error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
          } else
            ref.hasOwnProperty("current") || error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
        }
      }
      function detachFiberMutation(fiber) {
        var alternate = fiber.alternate;
        alternate !== null && (alternate.return = null), fiber.return = null;
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        {
          if (fiber.child = null, fiber.deletions = null, fiber.sibling = null, fiber.tag === HostComponent) {
            var hostInstance = fiber.stateNode;
            hostInstance !== null && detachDeletedInstance(hostInstance);
          }
          fiber.stateNode = null, fiber._debugOwner = null, fiber.return = null, fiber.dependencies = null, fiber.memoizedProps = null, fiber.memoizedState = null, fiber.pendingProps = null, fiber.stateNode = null, fiber.updateQueue = null;
        }
      }
      function emptyPortalContainer(current2) {
        if (supportsPersistence) {
          var portal = current2.stateNode, containerInfo = portal.containerInfo, emptyChildSet = createContainerChildSet(containerInfo);
          replaceContainerChildren(containerInfo, emptyChildSet);
        }
      }
      function getHostParentFiber(fiber) {
        for (var parent = fiber.return; parent !== null; ) {
          if (isHostParent(parent))
            return parent;
          parent = parent.return;
        }
        throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }
      function getHostSibling(fiber) {
        var node = fiber;
        siblings: for (; ; ) {
          for (; node.sibling === null; ) {
            if (node.return === null || isHostParent(node.return))
              return null;
            node = node.return;
          }
          for (node.sibling.return = node.return, node = node.sibling; node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment; ) {
            if (node.flags & Placement || node.child === null || node.tag === HostPortal)
              continue siblings;
            node.child.return = node, node = node.child;
          }
          if (!(node.flags & Placement))
            return node.stateNode;
        }
      }
      function commitPlacement(finishedWork) {
        if (supportsMutation) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              parentFiber.flags & ContentReset && (resetTextContent(parent), parentFiber.flags &= ~ContentReset);
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo, _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            // eslint-disable-next-line-no-fallthrough
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag, isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          before ? insertInContainerBefore(parent, stateNode, before) : appendChildToContainer(parent, stateNode);
        } else if (tag !== HostPortal) {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
            for (var sibling = child.sibling; sibling !== null; )
              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent), sibling = sibling.sibling;
          }
        }
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag, isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          before ? insertBefore(parent, stateNode, before) : appendChild(parent, stateNode);
        } else if (tag !== HostPortal) {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNode(child, before, parent);
            for (var sibling = child.sibling; sibling !== null; )
              insertOrAppendPlacementNode(sibling, before, parent), sibling = sibling.sibling;
          }
        }
      }
      var hostParent = null, hostParentIsContainer = !1;
      function commitDeletionEffects(root, returnFiber, deletedFiber) {
        if (supportsMutation) {
          var parent = returnFiber;
          findParent: for (; parent !== null; ) {
            switch (parent.tag) {
              case HostComponent: {
                hostParent = parent.stateNode, hostParentIsContainer = !1;
                break findParent;
              }
              case HostRoot: {
                hostParent = parent.stateNode.containerInfo, hostParentIsContainer = !0;
                break findParent;
              }
              case HostPortal: {
                hostParent = parent.stateNode.containerInfo, hostParentIsContainer = !0;
                break findParent;
              }
            }
            parent = parent.return;
          }
          if (hostParent === null)
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber), hostParent = null, hostParentIsContainer = !1;
        } else
          commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
        detachFiberMutation(deletedFiber);
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (var child = parent.child; child !== null; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child), child = child.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        switch (onCommitUnmount(deletedFiber), deletedFiber.tag) {
          case HostComponent:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          // eslint-disable-next-line-no-fallthrough
          case HostText: {
            if (supportsMutation) {
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, hostParent !== null && (hostParentIsContainer ? removeChildFromContainer(hostParent, deletedFiber.stateNode) : removeChild(hostParent, deletedFiber.stateNode));
            } else
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case DehydratedFragment: {
            supportsMutation && hostParent !== null && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            return;
          }
          case HostPortal: {
            if (supportsMutation) {
              var _prevHostParent = hostParent, _prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = _prevHostParent, hostParentIsContainer = _prevHostParentIsContainer;
            } else
              emptyPortalContainer(deletedFiber), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (!offscreenSubtreeWasHidden) {
              var updateQueue = deletedFiber.updateQueue;
              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;
                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next, effect = firstEffect;
                  do {
                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                    destroy !== void 0 && ((tag & Insertion) !== NoFlags$1 ? safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy) : (tag & Layout) !== NoFlags$1 && (markComponentLayoutEffectUnmountStarted(deletedFiber), deletedFiber.mode & ProfileMode ? (startLayoutEffectTimer(), safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy), recordLayoutEffectDuration(deletedFiber)) : safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy), markComponentLayoutEffectUnmountStopped())), effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ClassComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var instance = deletedFiber.stateNode;
              typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ScopeComponent: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case OffscreenComponent: {
            if (
              // TODO: Remove this dead flag
              deletedFiber.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            break;
          }
          default: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
        }
      }
      function commitSuspenseCallback(finishedWork) {
        var newState = finishedWork.memoizedState;
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (supportsHydration) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current2 = finishedWork.alternate;
            if (current2 !== null) {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                suspenseInstance !== null && commitHydratedSuspenseInstance(suspenseInstance);
              }
            }
          }
        }
      }
      function attachSuspenseRetryListeners(finishedWork) {
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet()), wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              if (retryCache.add(wakeable), isDevToolsPresent)
                if (inProgressLanes !== null && inProgressRoot !== null)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error("Expected finished root and lanes to be set. This is a bug in React.");
              wakeable.then(retry, retry);
            }
          });
        }
      }
      function commitMutationEffects(root, finishedWork, committedLanes) {
        inProgressLanes = committedLanes, inProgressRoot = root, setCurrentFiber(finishedWork), commitMutationEffectsOnFiber(finishedWork, root), setCurrentFiber(finishedWork), inProgressLanes = null, inProgressRoot = null;
      }
      function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {
        var deletions = parentFiber.deletions;
        if (deletions !== null)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            try {
              commitDeletionEffects(root, parentFiber, childToDelete);
            } catch (error2) {
              captureCommitPhaseError(childToDelete, parentFiber, error2);
            }
          }
        var prevDebugFiber = getCurrentFiber();
        if (parentFiber.subtreeFlags & MutationMask)
          for (var child = parentFiber.child; child !== null; )
            setCurrentFiber(child), commitMutationEffectsOnFiber(child, root), child = child.sibling;
        setCurrentFiber(prevDebugFiber);
      }
      function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
        var current2 = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Update) {
              try {
                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer(), commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                recordLayoutEffectDuration(finishedWork);
              } else
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
            }
            return;
          }
          case ClassComponent: {
            recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Ref && current2 !== null && safelyDetachRef(current2, current2.return);
            return;
          }
          case HostComponent: {
            if (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Ref && current2 !== null && safelyDetachRef(current2, current2.return), supportsMutation) {
              if (finishedWork.flags & ContentReset) {
                var instance = finishedWork.stateNode;
                try {
                  resetTextContent(instance);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              if (flags & Update) {
                var _instance4 = finishedWork.stateNode;
                if (_instance4 != null) {
                  var newProps = finishedWork.memoizedProps, oldProps = current2 !== null ? current2.memoizedProps : newProps, type = finishedWork.type, updatePayload = finishedWork.updateQueue;
                  if (finishedWork.updateQueue = null, updatePayload !== null)
                    try {
                      commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                }
              }
            }
            return;
          }
          case HostText: {
            if (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Update && supportsMutation) {
              if (finishedWork.stateNode === null)
                throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
              var textInstance = finishedWork.stateNode, newText = finishedWork.memoizedProps, oldText = current2 !== null ? current2.memoizedProps : newText;
              try {
                commitTextUpdate(textInstance, oldText, newText);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            return;
          }
          case HostRoot: {
            if (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Update) {
              if (supportsMutation && supportsHydration && current2 !== null) {
                var prevRootState = current2.memoizedState;
                if (prevRootState.isDehydrated)
                  try {
                    commitHydratedContainer(root.containerInfo);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
              }
              if (supportsPersistence) {
                var containerInfo = root.containerInfo, pendingChildren = root.pendingChildren;
                try {
                  replaceContainerChildren(containerInfo, pendingChildren);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case HostPortal: {
            if (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Update && supportsPersistence) {
              var portal = finishedWork.stateNode, _containerInfo = portal.containerInfo, _pendingChildren = portal.pendingChildren;
              try {
                replaceContainerChildren(_containerInfo, _pendingChildren);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            return;
          }
          case SuspenseComponent: {
            recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
            var offscreenFiber = finishedWork.child;
            if (offscreenFiber.flags & Visibility) {
              var offscreenInstance = offscreenFiber.stateNode, newState = offscreenFiber.memoizedState, isHidden2 = newState !== null;
              if (offscreenInstance.isHidden = isHidden2, isHidden2) {
                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                wasHidden || markCommitTimeOfFallback();
              }
            }
            if (flags & Update) {
              try {
                commitSuspenseCallback(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case OffscreenComponent: {
            var _wasHidden = current2 !== null && current2.memoizedState !== null;
            if (
              // TODO: Remove this dead flag
              finishedWork.mode & ConcurrentMode
            ) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden, recursivelyTraverseMutationEffects(root, finishedWork), offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else
              recursivelyTraverseMutationEffects(root, finishedWork);
            if (commitReconciliationEffects(finishedWork), flags & Visibility) {
              var _offscreenInstance = finishedWork.stateNode, _newState = finishedWork.memoizedState, _isHidden = _newState !== null, offscreenBoundary = finishedWork;
              if (_offscreenInstance.isHidden = _isHidden, _isHidden && !_wasHidden && (offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                nextEffect = offscreenBoundary;
                for (var offscreenChild = offscreenBoundary.child; offscreenChild !== null; )
                  nextEffect = offscreenChild, disappearLayoutEffects_begin(offscreenChild), offscreenChild = offscreenChild.sibling;
              }
              supportsMutation && hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
            }
            return;
          }
          case SuspenseListComponent: {
            recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), flags & Update && attachSuspenseRetryListeners(finishedWork);
            return;
          }
          case ScopeComponent:
            return;
          default: {
            recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
            return;
          }
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & Placement) {
          try {
            commitPlacement(finishedWork);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= ~Placement;
        }
        flags & Hydrating && (finishedWork.flags &= ~Hydrating);
      }
      function commitLayoutEffects(finishedWork, root, committedLanes) {
        inProgressLanes = committedLanes, inProgressRoot = root, nextEffect = finishedWork, commitLayoutEffects_begin(finishedWork, root, committedLanes), inProgressLanes = null, inProgressRoot = null;
      }
      function commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {
        for (var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode; nextEffect !== null; ) {
          var fiber = nextEffect, firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent && isModernRoot) {
            var isHidden2 = fiber.memoizedState !== null, newOffscreenSubtreeIsHidden = isHidden2 || offscreenSubtreeIsHidden;
            if (newOffscreenSubtreeIsHidden) {
              commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
              continue;
            } else {
              var current2 = fiber.alternate, wasHidden = current2 !== null && current2.memoizedState !== null, newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden, offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden, offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden && (nextEffect = fiber, reappearLayoutEffects_begin(fiber));
              for (var child = firstChild; child !== null; )
                nextEffect = child, commitLayoutEffects_begin(
                  child,
                  // New root; bubble back up to here and stop.
                  root,
                  committedLanes
                ), child = child.sibling;
              nextEffect = fiber, offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden, offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden, commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
              continue;
            }
          }
          (fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);
        }
      }
      function commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          if ((fiber.flags & LayoutMask) !== NoFlags) {
            var current2 = fiber.alternate;
            setCurrentFiber(fiber);
            try {
              commitLayoutEffectOnFiber(root, current2, fiber, committedLanes);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return, nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function disappearLayoutEffects_begin(subtreeRoot) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect, firstChild = fiber.child;
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (fiber.mode & ProfileMode)
                try {
                  startLayoutEffectTimer(), commitHookEffectListUnmount(Layout, fiber, fiber.return);
                } finally {
                  recordLayoutEffectDuration(fiber);
                }
              else
                commitHookEffectListUnmount(Layout, fiber, fiber.return);
              break;
            }
            case ClassComponent: {
              safelyDetachRef(fiber, fiber.return);
              var instance = fiber.stateNode;
              typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              break;
            }
            case HostComponent: {
              safelyDetachRef(fiber, fiber.return);
              break;
            }
            case OffscreenComponent: {
              var isHidden2 = fiber.memoizedState !== null;
              if (isHidden2) {
                disappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
              break;
            }
          }
          firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : disappearLayoutEffects_complete(subtreeRoot);
        }
      }
      function disappearLayoutEffects_complete(subtreeRoot) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return, nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function reappearLayoutEffects_begin(subtreeRoot) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect, firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent) {
            var isHidden2 = fiber.memoizedState !== null;
            if (isHidden2) {
              reappearLayoutEffects_complete(subtreeRoot);
              continue;
            }
          }
          firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : reappearLayoutEffects_complete(subtreeRoot);
        }
      }
      function reappearLayoutEffects_complete(subtreeRoot) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            reappearLayoutEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          if (resetCurrentFiber(), fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return, nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {
        nextEffect = finishedWork, commitPassiveMountEffects_begin(finishedWork, root, committedLanes, committedTransitions);
      }
      function commitPassiveMountEffects_begin(subtreeRoot, root, committedLanes, committedTransitions) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect, firstChild = fiber.child;
          (fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions);
        }
      }
      function commitPassiveMountEffects_complete(subtreeRoot, root, committedLanes, committedTransitions) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            try {
              commitPassiveMountOnFiber(root, fiber, committedLanes, committedTransitions);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return, nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              } finally {
                recordPassiveEffectDuration(finishedWork);
              }
            } else
              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
            break;
          }
        }
      }
      function commitPassiveUnmountEffects(firstChild) {
        nextEffect = firstChild, commitPassiveUnmountEffects_begin();
      }
      function commitPassiveUnmountEffects_begin() {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect, child = fiber.child;
          if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
            var deletions = fiber.deletions;
            if (deletions !== null) {
              for (var i = 0; i < deletions.length; i++) {
                var fiberToDelete = deletions[i];
                nextEffect = fiberToDelete, commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
              }
              {
                var previousFiber = fiber.alternate;
                if (previousFiber !== null) {
                  var detachedChild = previousFiber.child;
                  if (detachedChild !== null) {
                    previousFiber.child = null;
                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null, detachedChild = detachedSibling;
                    } while (detachedChild !== null);
                  }
                }
              }
              nextEffect = fiber;
            }
          }
          (fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null ? (child.return = fiber, nextEffect = child) : commitPassiveUnmountEffects_complete();
        }
      }
      function commitPassiveUnmountEffects_complete() {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          (fiber.flags & Passive) !== NoFlags && (setCurrentFiber(fiber), commitPassiveUnmountOnFiber(fiber), resetCurrentFiber());
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return, nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            finishedWork.mode & ProfileMode ? (startPassiveEffectTimer(), commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return), recordPassiveEffectDuration(finishedWork)) : commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
            break;
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect;
          setCurrentFiber(fiber), commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor), resetCurrentFiber();
          var child = fiber.child;
          child !== null ? (child.return = fiber, nextEffect = child) : commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
        for (; nextEffect !== null; ) {
          var fiber = nextEffect, sibling = fiber.sibling, returnFiber = fiber.return;
          if (detachFiberAfterEffects(fiber), fiber === deletedSubtreeRoot) {
            nextEffect = null;
            return;
          }
          if (sibling !== null) {
            sibling.return = returnFiber, nextEffect = sibling;
            return;
          }
          nextEffect = returnFiber;
        }
      }
      function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
        switch (current2.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            current2.mode & ProfileMode ? (startPassiveEffectTimer(), commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor), recordPassiveEffectDuration(current2)) : commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
            break;
          }
        }
      }
      function invokeLayoutEffectMountInDEV(fiber) {
        switch (fiber.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            try {
              commitHookEffectListMount(Layout | HasEffect, fiber);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            break;
          }
          case ClassComponent: {
            var instance = fiber.stateNode;
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            break;
          }
        }
      }
      function invokePassiveEffectMountInDEV(fiber) {
        switch (fiber.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            try {
              commitHookEffectListMount(Passive$1 | HasEffect, fiber);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            break;
          }
        }
      }
      function invokeLayoutEffectUnmountInDEV(fiber) {
        switch (fiber.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            try {
              commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            break;
          }
          case ClassComponent: {
            var instance = fiber.stateNode;
            typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(fiber, fiber.return, instance);
            break;
          }
        }
      }
      function invokePassiveEffectUnmountInDEV(fiber) {
        switch (fiber.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            try {
              commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
        }
      }
      var COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;
      if (typeof Symbol == "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        COMPONENT_TYPE = symbolFor("selector.component"), HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class"), ROLE_TYPE = symbolFor("selector.role"), TEST_NAME_TYPE = symbolFor("selector.test_id"), TEXT_TYPE = symbolFor("selector.text");
      }
      function createComponentSelector(component) {
        return {
          $$typeof: COMPONENT_TYPE,
          value: component
        };
      }
      function createHasPseudoClassSelector(selectors) {
        return {
          $$typeof: HAS_PSEUDO_CLASS_TYPE,
          value: selectors
        };
      }
      function createRoleSelector(role) {
        return {
          $$typeof: ROLE_TYPE,
          value: role
        };
      }
      function createTextSelector(text) {
        return {
          $$typeof: TEXT_TYPE,
          value: text
        };
      }
      function createTestNameSelector(id) {
        return {
          $$typeof: TEST_NAME_TYPE,
          value: id
        };
      }
      function findFiberRootForHostRoot(hostRoot) {
        var maybeFiber = getInstanceFromNode(hostRoot);
        if (maybeFiber != null) {
          if (typeof maybeFiber.memoizedProps["data-testname"] != "string")
            throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
          return maybeFiber;
        } else {
          var fiberRoot = findFiberRoot(hostRoot);
          if (fiberRoot === null)
            throw new Error("Could not find React container within specified host subtree.");
          return fiberRoot.stateNode.current;
        }
      }
      function matchSelector(fiber, selector) {
        switch (selector.$$typeof) {
          case COMPONENT_TYPE:
            if (fiber.type === selector.value)
              return !0;
            break;
          case HAS_PSEUDO_CLASS_TYPE:
            return hasMatchingPaths(fiber, selector.value);
          case ROLE_TYPE:
            if (fiber.tag === HostComponent) {
              var node = fiber.stateNode;
              if (matchAccessibilityRole(node, selector.value))
                return !0;
            }
            break;
          case TEXT_TYPE:
            if (fiber.tag === HostComponent || fiber.tag === HostText) {
              var textContent = getTextContent(fiber);
              if (textContent !== null && textContent.indexOf(selector.value) >= 0)
                return !0;
            }
            break;
          case TEST_NAME_TYPE:
            if (fiber.tag === HostComponent) {
              var dataTestID = fiber.memoizedProps["data-testname"];
              if (typeof dataTestID == "string" && dataTestID.toLowerCase() === selector.value.toLowerCase())
                return !0;
            }
            break;
          default:
            throw new Error("Invalid selector type specified.");
        }
        return !1;
      }
      function selectorToString(selector) {
        switch (selector.$$typeof) {
          case COMPONENT_TYPE:
            var displayName = getComponentNameFromType(selector.value) || "Unknown";
            return "<" + displayName + ">";
          case HAS_PSEUDO_CLASS_TYPE:
            return ":has(" + (selectorToString(selector) || "") + ")";
          case ROLE_TYPE:
            return '[role="' + selector.value + '"]';
          case TEXT_TYPE:
            return '"' + selector.value + '"';
          case TEST_NAME_TYPE:
            return '[data-testname="' + selector.value + '"]';
          default:
            throw new Error("Invalid selector type specified.");
        }
      }
      function findPaths(root, selectors) {
        for (var matchingFibers = [], stack = [root, 0], index2 = 0; index2 < stack.length; ) {
          var fiber = stack[index2++], selectorIndex = stack[index2++], selector = selectors[selectorIndex];
          if (!(fiber.tag === HostComponent && isHiddenSubtree(fiber))) {
            for (; selector != null && matchSelector(fiber, selector); )
              selectorIndex++, selector = selectors[selectorIndex];
            if (selectorIndex === selectors.length)
              matchingFibers.push(fiber);
            else
              for (var child = fiber.child; child !== null; )
                stack.push(child, selectorIndex), child = child.sibling;
          }
        }
        return matchingFibers;
      }
      function hasMatchingPaths(root, selectors) {
        for (var stack = [root, 0], index2 = 0; index2 < stack.length; ) {
          var fiber = stack[index2++], selectorIndex = stack[index2++], selector = selectors[selectorIndex];
          if (!(fiber.tag === HostComponent && isHiddenSubtree(fiber))) {
            for (; selector != null && matchSelector(fiber, selector); )
              selectorIndex++, selector = selectors[selectorIndex];
            if (selectorIndex === selectors.length)
              return !0;
            for (var child = fiber.child; child !== null; )
              stack.push(child, selectorIndex), child = child.sibling;
          }
        }
        return !1;
      }
      function findAllNodes(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw new Error("Test selector API is not supported by this renderer.");
        for (var root = findFiberRootForHostRoot(hostRoot), matchingFibers = findPaths(root, selectors), instanceRoots = [], stack = Array.from(matchingFibers), index2 = 0; index2 < stack.length; ) {
          var node = stack[index2++];
          if (node.tag === HostComponent) {
            if (isHiddenSubtree(node))
              continue;
            instanceRoots.push(node.stateNode);
          } else
            for (var child = node.child; child !== null; )
              stack.push(child), child = child.sibling;
        }
        return instanceRoots;
      }
      function getFindAllNodesFailureDescription(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw new Error("Test selector API is not supported by this renderer.");
        for (var root = findFiberRootForHostRoot(hostRoot), maxSelectorIndex = 0, matchedNames = [], stack = [root, 0], index2 = 0; index2 < stack.length; ) {
          var fiber = stack[index2++], selectorIndex = stack[index2++], selector = selectors[selectorIndex];
          if (!(fiber.tag === HostComponent && isHiddenSubtree(fiber)) && (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length))
            for (var child = fiber.child; child !== null; )
              stack.push(child, selectorIndex), child = child.sibling;
        }
        if (maxSelectorIndex < selectors.length) {
          for (var unmatchedNames = [], i = maxSelectorIndex; i < selectors.length; i++)
            unmatchedNames.push(selectorToString(selectors[i]));
          return `findAllNodes was able to match part of the selector:
` + ("  " + matchedNames.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + unmatchedNames.join(" > "));
        }
        return null;
      }
      function findBoundingRects(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw new Error("Test selector API is not supported by this renderer.");
        for (var instanceRoots = findAllNodes(hostRoot, selectors), boundingRects = [], i = 0; i < instanceRoots.length; i++)
          boundingRects.push(getBoundingRect(instanceRoots[i]));
        for (var _i = boundingRects.length - 1; _i > 0; _i--)
          for (var targetRect = boundingRects[_i], targetLeft = targetRect.x, targetRight = targetLeft + targetRect.width, targetTop = targetRect.y, targetBottom = targetTop + targetRect.height, j = _i - 1; j >= 0; j--)
            if (_i !== j) {
              var otherRect = boundingRects[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;
              if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {
                boundingRects.splice(_i, 1);
                break;
              } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {
                otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop), otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop), boundingRects.splice(_i, 1);
                break;
              } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {
                otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft), otherRight < targetRight && (otherRect.width = targetRight - otherLeft), boundingRects.splice(_i, 1);
                break;
              }
            }
        return boundingRects;
      }
      function focusWithin(hostRoot, selectors) {
        if (!supportsTestSelectors)
          throw new Error("Test selector API is not supported by this renderer.");
        for (var root = findFiberRootForHostRoot(hostRoot), matchingFibers = findPaths(root, selectors), stack = Array.from(matchingFibers), index2 = 0; index2 < stack.length; ) {
          var fiber = stack[index2++];
          if (!isHiddenSubtree(fiber)) {
            if (fiber.tag === HostComponent) {
              var node = fiber.stateNode;
              if (setFocusIfFocusable(node))
                return !0;
            }
            for (var child = fiber.child; child !== null; )
              stack.push(child), child = child.sibling;
          }
        }
        return !1;
      }
      var commitHooks = [];
      function onCommitRoot$1() {
        supportsTestSelectors && commitHooks.forEach(function(commitHook) {
          return commitHook();
        });
      }
      function observeVisibleRects(hostRoot, selectors, callback, options) {
        if (!supportsTestSelectors)
          throw new Error("Test selector API is not supported by this renderer.");
        var instanceRoots = findAllNodes(hostRoot, selectors), _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve, commitHook = function() {
          var nextInstanceRoots = findAllNodes(hostRoot, selectors);
          instanceRoots.forEach(function(target) {
            nextInstanceRoots.indexOf(target) < 0 && unobserve(target);
          }), nextInstanceRoots.forEach(function(target) {
            instanceRoots.indexOf(target) < 0 && observe(target);
          });
        };
        return commitHooks.push(commitHook), {
          disconnect: function() {
            var index2 = commitHooks.indexOf(commitHook);
            index2 >= 0 && commitHooks.splice(index2, 1), disconnect();
          }
        };
      }
      var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
      function isLegacyActEnvironment(fiber) {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
          ), jestIsDefined = typeof jest < "u";
          return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== !1;
        }
      }
      function isConcurrentActEnvironment() {
        {
          var isReactActEnvironmentGlobal = (
            // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
            typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
          );
          return !isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null && error("The current testing environment is not configured to support act(...)"), isReactActEnvironmentGlobal;
        }
      }
      var ceil = Math.ceil, ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue, NoContext = (
        /*             */
        0
      ), BatchedContext = (
        /*               */
        1
      ), RenderContext = (
        /*                */
        2
      ), CommitContext = (
        /*                */
        4
      ), RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = NoLanes, subtreeRenderLanes = NoLanes, subtreeRenderLanesCursor = createCursor(NoLanes), workInProgressRootExitStatus = RootInProgress, workInProgressRootFatalError = null, workInProgressRootIncludedLanes = NoLanes, workInProgressRootSkippedLanes = NoLanes, workInProgressRootInterleavedUpdatedLanes = NoLanes, workInProgressRootPingedLanes = NoLanes, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 500, workInProgressRootRenderTargetTime = 1 / 0, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null;
      function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
      }
      function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
      }
      var hasUncaughtError = !1, firstUncaughtError = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = NoLanes, pendingPassiveProfilerEffects = [], pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, currentEventTime = NoTimestamp, currentEventTransitionLane = NoLanes, isRunningInsertionEffect = !1;
      function getWorkInProgressRoot() {
        return workInProgressRoot;
      }
      function requestEventTime() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext ? now() : (currentEventTime !== NoTimestamp || (currentEventTime = now()), currentEventTime);
      }
      function requestUpdateLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode)
          return SyncLane;
        if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes)
          return pickArbitraryLane(workInProgressRootRenderLanes);
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
          if (ReactCurrentBatchConfig$2.transition !== null) {
            var transition = ReactCurrentBatchConfig$2.transition;
            transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber);
          }
          return currentEventTransitionLane === NoLane && (currentEventTransitionLane = claimNextTransitionLane()), currentEventTransitionLane;
        }
        var updateLane = getCurrentUpdatePriority();
        if (updateLane !== NoLane)
          return updateLane;
        var eventLane = getCurrentEventPriority();
        return eventLane;
      }
      function requestRetryLane(fiber) {
        var mode = fiber.mode;
        return (mode & ConcurrentMode) === NoMode ? SyncLane : claimNextRetryLane();
      }
      function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
        checkForNestedUpdates(), isRunningInsertionEffect && error("useInsertionEffect must not schedule updates."), isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0), markRootUpdated(root, lane, eventTime), (executionContext & RenderContext) !== NoLanes && root === workInProgressRoot ? warnAboutRenderPhaseUpdatesInDEV(fiber) : (isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane)), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended$1(root, workInProgressRootRenderLanes)), ensureRootIsScheduled(root, eventTime), lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ReactCurrentActQueue$1.isBatchingLegacy && (resetRenderTimer(), flushSyncCallbacksOnlyInLegacyMode()));
      }
      function scheduleInitialHydrationOnRoot(root, lane, eventTime) {
        var current2 = root.current;
        current2.lanes = lane, markRootUpdated(root, lane, eventTime), ensureRootIsScheduled(root, eventTime);
      }
      function isUnsafeClassRenderPhaseUpdate(fiber) {
        return (
          // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
          // decided not to enable it.
          (executionContext & RenderContext) !== NoContext
        );
      }
      function ensureRootIsScheduled(root, currentTime2) {
        var existingCallbackNode = root.callbackNode;
        markStarvedLanesAsExpired(root, currentTime2);
        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (nextLanes === NoLanes) {
          existingCallbackNode !== null && cancelCallback$1(existingCallbackNode), root.callbackNode = null, root.callbackPriority = NoLane;
          return;
        }
        var newCallbackPriority = getHighestPriorityLane(nextLanes), existingCallbackPriority = root.callbackPriority;
        if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
        // Scheduler task, rather than an `act` task, cancel it and re-scheduled
        // on the `act` queue.
        !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
          existingCallbackNode == null && existingCallbackPriority !== SyncLane && error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        existingCallbackNode != null && cancelCallback$1(existingCallbackNode);
        var newCallbackNode;
        if (newCallbackPriority === SyncLane)
          root.tag === LegacyRoot ? (ReactCurrentActQueue$1.isBatchingLegacy !== null && (ReactCurrentActQueue$1.didScheduleLegacyUpdate = !0), scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root))) : scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root)), supportsMicrotasks ? ReactCurrentActQueue$1.current !== null ? ReactCurrentActQueue$1.current.push(flushSyncCallbacks) : scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncCallbacks();
          }) : scheduleCallback$1(ImmediatePriority, flushSyncCallbacks), newCallbackNode = null;
        else {
          var schedulerPriorityLevel;
          switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
              schedulerPriorityLevel = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriorityLevel = UserBlockingPriority;
              break;
            case DefaultEventPriority2:
              schedulerPriorityLevel = NormalPriority;
              break;
            case IdleEventPriority:
              schedulerPriorityLevel = IdlePriority;
              break;
            default:
              schedulerPriorityLevel = NormalPriority;
              break;
          }
          newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
        }
        root.callbackPriority = newCallbackPriority, root.callbackNode = newCallbackNode;
      }
      function performConcurrentWorkOnRoot(root, didTimeout) {
        if (resetNestedUpdateFlag(), currentEventTime = NoTimestamp, currentEventTransitionLane = NoLanes, (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw new Error("Should not already be working.");
        var originalCallbackNode = root.callbackNode, didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects && root.callbackNode !== originalCallbackNode)
          return null;
        var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes)
          return null;
        var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout, exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);
        if (exitStatus !== RootInProgress) {
          if (exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
            errorRetryLanes !== NoLanes && (lanes = errorRetryLanes, exitStatus = recoverFromConcurrentError(root, errorRetryLanes));
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            throw prepareFreshStack(root, NoLanes), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, now()), fatalError;
          }
          if (exitStatus === RootDidNotComplete)
            markRootSuspended$1(root, lanes);
          else {
            var renderWasConcurrent = !includesBlockingLane(root, lanes), finishedWork = root.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
              if (exitStatus = renderRootSync(root, lanes), exitStatus === RootErrored) {
                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
                _errorRetryLanes !== NoLanes && (lanes = _errorRetryLanes, exitStatus = recoverFromConcurrentError(root, _errorRetryLanes));
              }
              if (exitStatus === RootFatalErrored) {
                var _fatalError = workInProgressRootFatalError;
                throw prepareFreshStack(root, NoLanes), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, now()), _fatalError;
              }
            }
            root.finishedWork = finishedWork, root.finishedLanes = lanes, finishConcurrentRender(root, exitStatus, lanes);
          }
        }
        return ensureRootIsScheduled(root, now()), root.callbackNode === originalCallbackNode ? performConcurrentWorkOnRoot.bind(null, root) : null;
      }
      function recoverFromConcurrentError(root, errorRetryLanes) {
        var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
        if (isRootDehydrated(root)) {
          var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);
          rootWorkInProgress.flags |= ForceClientRender, errorHydratingContainer(root.containerInfo);
        }
        var exitStatus = renderRootSync(root, errorRetryLanes);
        if (exitStatus !== RootErrored) {
          var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
          workInProgressRootRecoverableErrors = errorsFromFirstAttempt, errorsFromSecondAttempt !== null && queueRecoverableErrors(errorsFromSecondAttempt);
        }
        return exitStatus;
      }
      function queueRecoverableErrors(errors) {
        workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
      }
      function finishConcurrentRender(root, exitStatus, lanes) {
        switch (exitStatus) {
          case RootInProgress:
          case RootFatalErrored:
            throw new Error("Root did not complete. This is a bug in React.");
          // Flow knows about invariant, so it complains if I add a break
          // statement, but eslint doesn't know about invariant, so it complains
          // if I do. eslint-disable-next-line no-fallthrough
          case RootErrored: {
            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspended: {
            if (markRootSuspended$1(root, lanes), includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
            !shouldForceFlushFallbacksInDEV()) {
              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
              if (msUntilTimeout > 10) {
                var nextLanes = getNextLanes(root, NoLanes);
                if (nextLanes !== NoLanes)
                  break;
                var suspendedLanes = root.suspendedLanes;
                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                  var eventTime = requestEventTime();
                  markRootPinged(root, suspendedLanes);
                  break;
                }
                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                break;
              }
            }
            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspendedWithDelay: {
            if (markRootSuspended$1(root, lanes), includesOnlyTransitions(lanes))
              break;
            if (!shouldForceFlushFallbacksInDEV()) {
              var mostRecentEventTime = getMostRecentEventTime(root, lanes), eventTimeMs = mostRecentEventTime, timeElapsedMs = now() - eventTimeMs, _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
              if (_msUntilTimeout > 10) {
                root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                break;
              }
            }
            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootCompleted: {
            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          default:
            throw new Error("Unknown root exit status.");
        }
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node = finishedWork; ; ) {
          if (node.flags & StoreConsistency) {
            var updateQueue = node.updateQueue;
            if (updateQueue !== null) {
              var checks = updateQueue.stores;
              if (checks !== null)
                for (var i = 0; i < checks.length; i++) {
                  var check = checks[i], getSnapshot = check.getSnapshot, renderedValue = check.value;
                  try {
                    if (!objectIs(getSnapshot(), renderedValue))
                      return !1;
                  } catch {
                    return !1;
                  }
                }
            }
          }
          var child = node.child;
          if (node.subtreeFlags & StoreConsistency && child !== null) {
            child.return = node, node = child;
            continue;
          }
          if (node === finishedWork)
            return !0;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === finishedWork)
              return !0;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return !0;
      }
      function markRootSuspended$1(root, suspendedLanes) {
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes), suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes), markRootSuspended(root, suspendedLanes);
      }
      function performSyncWorkOnRoot(root) {
        if (syncNestedUpdateFlag(), (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw new Error("Should not already be working.");
        flushPassiveEffects();
        var lanes = getNextLanes(root, NoLanes);
        if (!includesSomeLane(lanes, SyncLane))
          return ensureRootIsScheduled(root, now()), null;
        var exitStatus = renderRootSync(root, lanes);
        if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);
          errorRetryLanes !== NoLanes && (lanes = errorRetryLanes, exitStatus = recoverFromConcurrentError(root, errorRetryLanes));
        }
        if (exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          throw prepareFreshStack(root, NoLanes), markRootSuspended$1(root, lanes), ensureRootIsScheduled(root, now()), fatalError;
        }
        if (exitStatus === RootDidNotComplete)
          throw new Error("Root did not complete. This is a bug in React.");
        var finishedWork = root.current.alternate;
        return root.finishedWork = finishedWork, root.finishedLanes = lanes, commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions), ensureRootIsScheduled(root, now()), null;
      }
      function flushRoot(root, lanes) {
        lanes !== NoLanes && (markRootEntangled(root, mergeLanes(lanes, SyncLane)), ensureRootIsScheduled(root, now()), (executionContext & (RenderContext | CommitContext)) === NoContext && (resetRenderTimer(), flushSyncCallbacks()));
      }
      function deferredUpdates(fn) {
        var previousPriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig$2.transition;
        try {
          return ReactCurrentBatchConfig$2.transition = null, setCurrentUpdatePriority(DefaultEventPriority2), fn();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition;
        }
      }
      function batchedUpdates(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext, executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
          !ReactCurrentActQueue$1.isBatchingLegacy && (resetRenderTimer(), flushSyncCallbacksOnlyInLegacyMode());
        }
      }
      function discreteUpdates(fn, a, b, c, d) {
        var previousPriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig$2.transition;
        try {
          return ReactCurrentBatchConfig$2.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), fn(a, b, c, d);
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition, executionContext === NoContext && resetRenderTimer();
        }
      }
      function flushSync(fn) {
        rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext && flushPassiveEffects();
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        var prevTransition = ReactCurrentBatchConfig$2.transition, previousPriority = getCurrentUpdatePriority();
        try {
          return ReactCurrentBatchConfig$2.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), fn ? fn() : void 0;
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncCallbacks();
        }
      }
      function isAlreadyRendering() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext;
      }
      function flushControlled(fn) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        var prevTransition = ReactCurrentBatchConfig$2.transition, previousPriority = getCurrentUpdatePriority();
        try {
          ReactCurrentBatchConfig$2.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), fn();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition, executionContext = prevExecutionContext, executionContext === NoContext && (resetRenderTimer(), flushSyncCallbacks());
        }
      }
      function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber), subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes), workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
      }
      function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current, pop(subtreeRenderLanesCursor, fiber);
      }
      function prepareFreshStack(root, lanes) {
        root.finishedWork = null, root.finishedLanes = NoLanes;
        var timeoutHandle = root.timeoutHandle;
        if (timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle)), workInProgress !== null)
          for (var interruptedWork = workInProgress.return; interruptedWork !== null; ) {
            var current2 = interruptedWork.alternate;
            unwindInterruptedWork(current2, interruptedWork), interruptedWork = interruptedWork.return;
          }
        workInProgressRoot = root;
        var rootWorkInProgress = createWorkInProgress(root.current, null);
        return workInProgress = rootWorkInProgress, workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes, workInProgressRootExitStatus = RootInProgress, workInProgressRootFatalError = null, workInProgressRootSkippedLanes = NoLanes, workInProgressRootInterleavedUpdatedLanes = NoLanes, workInProgressRootPingedLanes = NoLanes, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, finishQueueingConcurrentUpdates(), ReactStrictModeWarnings.discardPendingWarnings(), rootWorkInProgress;
      }
      function handleError(root, thrownValue) {
        do {
          var erroredWork = workInProgress;
          try {
            if (resetContextDependencies(), resetHooksAfterThrow(), resetCurrentFiber(), ReactCurrentOwner$2.current = null, erroredWork === null || erroredWork.return === null) {
              workInProgressRootExitStatus = RootFatalErrored, workInProgressRootFatalError = thrownValue, workInProgress = null;
              return;
            }
            if (enableProfilerTimer && erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDelta(erroredWork, !0), enableSchedulingProfiler)
              if (markComponentRenderStopped(), thrownValue !== null && typeof thrownValue == "object" && typeof thrownValue.then == "function") {
                var wakeable = thrownValue;
                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
              } else
                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
            throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes), completeUnitOfWork(erroredWork);
          } catch (yetAnotherThrownValue) {
            thrownValue = yetAnotherThrownValue, workInProgress === erroredWork && erroredWork !== null ? (erroredWork = erroredWork.return, workInProgress = erroredWork) : erroredWork = workInProgress;
            continue;
          }
          return;
        } while (!0);
      }
      function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        return ReactCurrentDispatcher$2.current = ContextOnlyDispatcher, prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
      }
      function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
      }
      function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
      }
      function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
      }
      function renderDidSuspend() {
        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended);
      }
      function renderDidSuspendDelayIfPossible() {
        (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) && (workInProgressRootExitStatus = RootSuspendedWithDelay), workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
      }
      function renderDidError(error2) {
        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored), workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [error2] : workInProgressRootConcurrentErrors.push(error2);
      }
      function renderHasNotSuspendedYet() {
        return workInProgressRootExitStatus === RootInProgress;
      }
      function renderRootSync(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root.memoizedUpdaters;
            memoizedUpdaters.size > 0 && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear()), movePendingFibersToMemoized(root, lanes);
          }
          workInProgressTransitions = getTransitionsForLanes(), prepareFreshStack(root, lanes);
        }
        markRenderStarted(lanes);
        do
          try {
            workLoopSync();
            break;
          } catch (thrownValue) {
            handleError(root, thrownValue);
          }
        while (!0);
        if (resetContextDependencies(), executionContext = prevExecutionContext, popDispatcher(prevDispatcher), workInProgress !== null)
          throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
        return markRenderStopped(), workInProgressRoot = null, workInProgressRootRenderLanes = NoLanes, workInProgressRootExitStatus;
      }
      function workLoopSync() {
        for (; workInProgress !== null; )
          performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root.memoizedUpdaters;
            memoizedUpdaters.size > 0 && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear()), movePendingFibersToMemoized(root, lanes);
          }
          workInProgressTransitions = getTransitionsForLanes(), resetRenderTimer(), prepareFreshStack(root, lanes);
        }
        markRenderStarted(lanes);
        do
          try {
            workLoopConcurrent();
            break;
          } catch (thrownValue) {
            handleError(root, thrownValue);
          }
        while (!0);
        return resetContextDependencies(), popDispatcher(prevDispatcher), executionContext = prevExecutionContext, workInProgress !== null ? (markRenderYielded(), RootInProgress) : (markRenderStopped(), workInProgressRoot = null, workInProgressRootRenderLanes = NoLanes, workInProgressRootExitStatus);
      }
      function workLoopConcurrent() {
        for (; workInProgress !== null && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), next = beginWork$1(current2, unitOfWork, subtreeRenderLanes), stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0)) : next = beginWork$1(current2, unitOfWork, subtreeRenderLanes), resetCurrentFiber(), unitOfWork.memoizedProps = unitOfWork.pendingProps, next === null ? completeUnitOfWork(unitOfWork) : workInProgress = next, ReactCurrentOwner$2.current = null;
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          var current2 = completedWork.alternate, returnFiber = completedWork.return;
          if ((completedWork.flags & Incomplete) === NoFlags) {
            setCurrentFiber(completedWork);
            var next = void 0;
            if ((completedWork.mode & ProfileMode) === NoMode ? next = completeWork(current2, completedWork, subtreeRenderLanes) : (startProfilerTimer(completedWork), next = completeWork(current2, completedWork, subtreeRenderLanes), stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1)), resetCurrentFiber(), next !== null) {
              workInProgress = next;
              return;
            }
          } else {
            var _next = unwindWork(current2, completedWork);
            if (_next !== null) {
              _next.flags &= HostEffectMask, workInProgress = _next;
              return;
            }
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1);
              for (var actualDuration = completedWork.actualDuration, child = completedWork.child; child !== null; )
                actualDuration += child.actualDuration, child = child.sibling;
              completedWork.actualDuration = actualDuration;
            }
            if (returnFiber !== null)
              returnFiber.flags |= Incomplete, returnFiber.subtreeFlags = NoFlags, returnFiber.deletions = null;
            else {
              workInProgressRootExitStatus = RootDidNotComplete, workInProgress = null;
              return;
            }
          }
          var siblingFiber = completedWork.sibling;
          if (siblingFiber !== null) {
            workInProgress = siblingFiber;
            return;
          }
          completedWork = returnFiber, workInProgress = completedWork;
        } while (completedWork !== null);
        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
      }
      function commitRoot(root, recoverableErrors, transitions) {
        var previousUpdateLanePriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig$2.transition;
        try {
          ReactCurrentBatchConfig$2.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);
        } finally {
          ReactCurrentBatchConfig$2.transition = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);
        }
        return null;
      }
      function commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {
        do
          flushPassiveEffects();
        while (rootWithPendingPassiveEffects !== null);
        if (flushRenderPhaseStrictModeWarningsInDEV(), (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw new Error("Should not already be working.");
        var finishedWork = root.finishedWork, lanes = root.finishedLanes;
        if (markCommitStarted(lanes), finishedWork === null)
          return markCommitStopped(), null;
        if (lanes === NoLanes && error("root.finishedLanes should not be empty during a commit. This is a bug in React."), root.finishedWork = null, root.finishedLanes = NoLanes, finishedWork === root.current)
          throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
        root.callbackNode = null, root.callbackPriority = NoLane;
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root, remainingLanes), root === workInProgressRoot && (workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = NoLanes), ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) && (rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority, function() {
          return flushPassiveEffects(), null;
        })));
        var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags, rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        if (subtreeHasEffects || rootHasEffect) {
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(DiscreteEventPriority);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext, ReactCurrentOwner$2.current = null;
          var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root, finishedWork);
          recordCommitTime(), commitMutationEffects(root, finishedWork, lanes), resetAfterCommit(root.containerInfo), root.current = finishedWork, markLayoutEffectsStarted(lanes), commitLayoutEffects(finishedWork, root, lanes), markLayoutEffectsStopped(), requestPaint(), executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition;
        } else
          root.current = finishedWork, recordCommitTime();
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = lanes) : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null), remainingLanes = root.pendingLanes, remainingLanes === NoLanes && (legacyErrorBoundariesThatAlreadyFailed = null), rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root.current, !1), onCommitRoot(finishedWork.stateNode, renderPriorityLevel), isDevToolsPresent && root.memoizedUpdaters.clear(), onCommitRoot$1(), ensureRootIsScheduled(root, now()), recoverableErrors !== null)
          for (var onRecoverableError = root.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
            var recoverableError = recoverableErrors[i], componentStack = recoverableError.stack, digest = recoverableError.digest;
            onRecoverableError(recoverableError.value, {
              componentStack,
              digest
            });
          }
        if (hasUncaughtError) {
          hasUncaughtError = !1;
          var error$1 = firstUncaughtError;
          throw firstUncaughtError = null, error$1;
        }
        return includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot && flushPassiveEffects(), remainingLanes = root.pendingLanes, includesSomeLane(remainingLanes, SyncLane) ? (markNestedUpdateScheduled(), root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0, flushSyncCallbacks(), markCommitStopped(), null;
      }
      function flushPassiveEffects() {
        if (rootWithPendingPassiveEffects !== null) {
          var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = lowerEventPriority(DefaultEventPriority2, renderPriority), prevTransition = ReactCurrentBatchConfig$2.transition, previousPriority = getCurrentUpdatePriority();
          try {
            return ReactCurrentBatchConfig$2.transition = null, setCurrentUpdatePriority(priority), flushPassiveEffectsImpl();
          } finally {
            setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition;
          }
        }
        return !1;
      }
      function enqueuePendingPassiveProfilerEffect(fiber) {
        pendingPassiveProfilerEffects.push(fiber), rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, scheduleCallback$1(NormalPriority, function() {
          return flushPassiveEffects(), null;
        }));
      }
      function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null)
          return !1;
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
        if (rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = NoLanes, (executionContext & (RenderContext | CommitContext)) !== NoContext)
          throw new Error("Cannot flush passive effects while already rendering.");
        isFlushingPassiveEffects = !0, didScheduleUpdateDuringPassiveEffects = !1, markPassiveEffectsStarted(lanes);
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext, commitPassiveUnmountEffects(root.current), commitPassiveMountEffects(root, root.current, lanes, transitions);
        {
          var profilerEffects = pendingPassiveProfilerEffects;
          pendingPassiveProfilerEffects = [];
          for (var i = 0; i < profilerEffects.length; i++) {
            var _fiber = profilerEffects[i];
            commitPassiveEffectDurations(root, _fiber);
          }
        }
        markPassiveEffectsStopped(), commitDoubleInvokeEffectsInDEV(root.current, !0), executionContext = prevExecutionContext, flushSyncCallbacks(), didScheduleUpdateDuringPassiveEffects ? root === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root) : nestedPassiveUpdateCount = 0, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, onPostCommitRoot(root);
        {
          var stateNode = root.current.stateNode;
          stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
        }
        return !0;
      }
      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }
      function markLegacyErrorBoundaryAsFailed(instance) {
        legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]) : legacyErrorBoundariesThatAlreadyFailed.add(instance);
      }
      function prepareToThrowUncaughtError(error2) {
        hasUncaughtError || (hasUncaughtError = !0, firstUncaughtError = error2);
      }
      var onUncaughtError = prepareToThrowUncaughtError;
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        var errorInfo = createCapturedValueAtFiber(error2, sourceFiber), update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane), root = enqueueUpdate(rootFiber, update, SyncLane), eventTime = requestEventTime();
        root !== null && (markRootUpdated(root, SyncLane, eventTime), ensureRootIsScheduled(root, eventTime));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
        if (reportUncaughtErrorInDEV(error$1), setIsRunningInsertionEffect(!1), sourceFiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
          return;
        }
        var fiber = null;
        for (fiber = nearestMountedAncestor; fiber !== null; ) {
          if (fiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
            return;
          } else if (fiber.tag === ClassComponent) {
            var ctor = fiber.type, instance = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError == "function" || typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
              var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber), update = createClassErrorUpdate(fiber, errorInfo, SyncLane), root = enqueueUpdate(fiber, update, SyncLane), eventTime = requestEventTime();
              root !== null && (markRootUpdated(root, SyncLane, eventTime), ensureRootIsScheduled(root, eventTime));
              return;
            }
          }
          fiber = fiber.return;
        }
        error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, error$1);
      }
      function pingSuspendedRoot(root, wakeable, pingedLanes) {
        var pingCache = root.pingCache;
        pingCache !== null && pingCache.delete(wakeable);
        var eventTime = requestEventTime();
        markRootPinged(root, pingedLanes), warnIfSuspenseResolutionNotWrappedWithActDEV(root), workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes) && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? prepareFreshStack(root, NoLanes) : workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes)), ensureRootIsScheduled(root, eventTime);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        retryLane === NoLane && (retryLane = requestRetryLane(boundaryFiber));
        var eventTime = requestEventTime(), root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        root !== null && (markRootUpdated(root, retryLane, eventTime), ensureRootIsScheduled(root, eventTime));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = NoLane;
        suspenseState !== null && (retryLane = suspenseState.retryLane), retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane, retryCache;
        switch (boundaryFiber.tag) {
          case SuspenseComponent:
            retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            suspenseState !== null && (retryLane = suspenseState.retryLane);
            break;
          case SuspenseListComponent:
            retryCache = boundaryFiber.stateNode;
            break;
          default:
            throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
        }
        retryCache !== null && retryCache.delete(wakeable), retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
      }
      function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
      }
      function flushRenderPhaseStrictModeWarningsInDEV() {
        ReactStrictModeWarnings.flushLegacyContextWarning(), ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
      }
      function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
        setCurrentFiber(fiber), invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV), hasPassiveEffects && invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV), invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV), hasPassiveEffects && invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV), resetCurrentFiber();
      }
      function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
        for (var current2 = firstChild, subtreeRoot = null; current2 !== null; ) {
          var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
          current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags ? current2 = current2.child : ((current2.flags & fiberFlags) !== NoFlags && invokeEffectFn(current2), current2.sibling !== null ? current2 = current2.sibling : current2 = subtreeRoot = current2.return);
        }
      }
      var didWarnStateUpdateForNotYetMountedComponent = null;
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        {
          if ((executionContext & RenderContext) !== NoContext || !(fiber.mode & ConcurrentMode))
            return;
          var tag = fiber.tag;
          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent)
            return;
          var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName))
              return;
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
          } else
            didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
          var previousFiber = current;
          try {
            setCurrentFiber(fiber), error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
          } finally {
            previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
          }
        }
      }
      var beginWork$1;
      {
        var dummyFiber = null;
        beginWork$1 = function(current2, unitOfWork, lanes) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
          try {
            return beginWork(current2, unitOfWork, lanes);
          } catch (originalError) {
            if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError == "object" && typeof originalError.then == "function")
              throw originalError;
            if (resetContextDependencies(), resetHooksAfterThrow(), unwindInterruptedWork(current2, unitOfWork), assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy), unitOfWork.mode & ProfileMode && startProfilerTimer(unitOfWork), invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes), hasCaughtError()) {
              var replayError = clearCaughtError();
              typeof replayError == "object" && replayError !== null && replayError._suppressLogging && typeof originalError == "object" && originalError !== null && !originalError._suppressLogging && (originalError._suppressLogging = !0);
            }
            throw originalError;
          }
        };
      }
      var didWarnAboutUpdateInRender = !1, didWarnAboutUpdateInRenderForAnotherComponent;
      didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
      function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV())
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown", dedupeKey = renderingComponentName;
              if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
              }
              break;
            }
            case ClassComponent: {
              didWarnAboutUpdateInRender || (error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
              break;
            }
          }
      }
      function restorePendingUpdaters(root, lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root.memoizedUpdaters;
          memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root, schedulingFiber, lanes);
          });
        }
      }
      var fakeActCallbackNode = {};
      function scheduleCallback$1(priorityLevel, callback) {
        {
          var actQueue = ReactCurrentActQueue$1.current;
          return actQueue !== null ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback(priorityLevel, callback);
        }
      }
      function cancelCallback$1(callbackNode) {
        if (callbackNode !== fakeActCallbackNode)
          return cancelCallback(callbackNode);
      }
      function shouldForceFlushFallbacksInDEV() {
        return ReactCurrentActQueue$1.current !== null;
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        {
          if (fiber.mode & ConcurrentMode) {
            if (!isConcurrentActEnvironment())
              return;
          } else if (!isLegacyActEnvironment() || executionContext !== NoContext || fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent)
            return;
          if (ReactCurrentActQueue$1.current === null) {
            var previousFiber = current;
            try {
              setCurrentFiber(fiber), error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, getComponentNameFromFiber(fiber));
            } finally {
              previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
            }
          }
        }
      }
      function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {
        root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null && error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
      }
      function setIsRunningInsertionEffect(isRunning) {
        isRunningInsertionEffect = isRunning;
      }
      var resolveFamily = null, failedBoundaries = null, setRefreshHandler = function(handler2) {
        resolveFamily = handler2;
      };
      function resolveFunctionForHotReloading(type) {
        {
          if (resolveFamily === null)
            return type;
          var family = resolveFamily(type);
          return family === void 0 ? type : family.current;
        }
      }
      function resolveClassForHotReloading(type) {
        return resolveFunctionForHotReloading(type);
      }
      function resolveForwardRefForHotReloading(type) {
        {
          if (resolveFamily === null)
            return type;
          var family = resolveFamily(type);
          if (family === void 0) {
            if (type != null && typeof type.render == "function") {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = {
                  $$typeof: REACT_FORWARD_REF_TYPE,
                  render: currentRender
                };
                return type.displayName !== void 0 && (syntheticType.displayName = type.displayName), syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        {
          if (resolveFamily === null)
            return !1;
          var prevType = fiber.elementType, nextType = element.type, needsCompareFamilies = !1, $$typeofNextType = typeof nextType == "object" && nextType !== null ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case ClassComponent: {
              typeof nextType == "function" && (needsCompareFamilies = !0);
              break;
            }
            case FunctionComponent: {
              (typeof nextType == "function" || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            }
            case ForwardRef: {
              ($$typeofNextType === REACT_FORWARD_REF_TYPE || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            }
            case MemoComponent:
            case SimpleMemoComponent: {
              ($$typeofNextType === REACT_MEMO_TYPE || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
              break;
            }
            default:
              return !1;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType))
              return !0;
          }
          return !1;
        }
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        {
          if (resolveFamily === null || typeof WeakSet != "function")
            return;
          failedBoundaries === null && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber);
        }
      }
      var scheduleRefresh = function(root, update) {
        {
          if (resolveFamily === null)
            return;
          var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
          flushPassiveEffects(), flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
          });
        }
      }, scheduleRoot = function(root, element) {
        {
          if (root.context !== emptyContextObject)
            return;
          flushPassiveEffects(), flushSync(function() {
            updateContainer(element, root, null, null);
          });
        }
      };
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          if (resolveFamily === null)
            throw new Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = !1, needsRemount = !1;
          if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            family !== void 0 && (staleFamilies.has(family) ? needsRemount = !0 : updatedFamilies.has(family) && (tag === ClassComponent ? needsRemount = !0 : needsRender = !0));
          }
          if (failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (needsRemount = !0), needsRemount && (fiber._debugNeedsRemount = !0), needsRemount || needsRender) {
            var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            _root !== null && scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
          }
          child !== null && !needsRemount && scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies), sibling !== null && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
        }
      }
      var findHostInstancesForRefresh = function(root, families) {
        {
          var hostInstances = /* @__PURE__ */ new Set(), types2 = new Set(families.map(function(family) {
            return family.current;
          }));
          return findHostInstancesForMatchingFibersRecursively(root.current, types2, hostInstances), hostInstances;
        }
      };
      function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
        {
          var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          var didMatch = !1;
          candidateType !== null && types2.has(candidateType) && (didMatch = !0), didMatch ? findHostInstancesForFiberShallowly(fiber, hostInstances) : child !== null && findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances), sibling !== null && findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
        }
      }
      function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
          if (foundHostInstances)
            return;
          for (var node = fiber; ; ) {
            switch (node.tag) {
              case HostComponent:
                hostInstances.add(node.stateNode);
                return;
              case HostPortal:
                hostInstances.add(node.stateNode.containerInfo);
                return;
              case HostRoot:
                hostInstances.add(node.stateNode.containerInfo);
                return;
            }
            if (node.return === null)
              throw new Error("Expected to reach root first.");
            node = node.return;
          }
        }
      }
      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        for (var node = fiber, foundHostInstances = !1; ; ) {
          if (node.tag === HostComponent)
            foundHostInstances = !0, hostInstances.add(node.stateNode);
          else if (node.child !== null) {
            node.child.return = node, node = node.child;
            continue;
          }
          if (node === fiber)
            return foundHostInstances;
          for (; node.sibling === null; ) {
            if (node.return === null || node.return === fiber)
              return foundHostInstances;
            node = node.return;
          }
          node.sibling.return = node.return, node = node.sibling;
        }
        return !1;
      }
      var hasBadMapPolyfill;
      {
        hasBadMapPolyfill = !1;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
        } catch {
          hasBadMapPolyfill = !0;
        }
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag, this.key = key, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = pendingProps, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = mode, this.flags = NoFlags, this.subtreeFlags = NoFlags, this.deletions = null, this.lanes = NoLanes, this.childLanes = NoLanes, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !hasBadMapPolyfill && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
      }
      var createFiber = function(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };
      function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function isSimpleFunctionComponent(type) {
        return typeof type == "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
      }
      function resolveLazyComponentTag(Component) {
        if (typeof Component == "function")
          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        if (Component != null) {
          var $$typeof = Component.$$typeof;
          if ($$typeof === REACT_FORWARD_REF_TYPE)
            return ForwardRef;
          if ($$typeof === REACT_MEMO_TYPE)
            return MemoComponent;
        }
        return IndeterminateComponent;
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugSource = current2._debugSource, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = NoFlags, workInProgress2.subtreeFlags = NoFlags, workInProgress2.deletions = null, workInProgress2.actualDuration = 0, workInProgress2.actualStartTime = -1), workInProgress2.flags = current2.flags & StaticMask, workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue;
        var currentDependencies = current2.dependencies;
        switch (workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        }, workInProgress2.sibling = current2.sibling, workInProgress2.index = current2.index, workInProgress2.ref = current2.ref, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration, workInProgress2._debugNeedsRemount = current2._debugNeedsRemount, workInProgress2.tag) {
          case IndeterminateComponent:
          case FunctionComponent:
          case SimpleMemoComponent:
            workInProgress2.type = resolveFunctionForHotReloading(current2.type);
            break;
          case ClassComponent:
            workInProgress2.type = resolveClassForHotReloading(current2.type);
            break;
          case ForwardRef:
            workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
            break;
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= StaticMask | Placement;
        var current2 = workInProgress2.alternate;
        if (current2 === null)
          workInProgress2.childLanes = NoLanes, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = NoFlags, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0;
        else {
          workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = NoFlags, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        }
        return workInProgress2;
      }
      function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
        var mode;
        return tag === ConcurrentRoot ? (mode = ConcurrentMode, isStrictMode === !0 && (mode |= StrictLegacyMode, mode |= StrictEffectsMode)) : mode = NoMode, isDevToolsPresent && (mode |= ProfileMode), createFiber(HostRoot, null, null, mode);
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent, resolvedType = type;
        if (typeof type == "function")
          shouldConstruct$1(type) ? (fiberTag = ClassComponent, resolvedType = resolveClassForHotReloading(resolvedType)) : resolvedType = resolveFunctionForHotReloading(resolvedType);
        else if (typeof type == "string")
          fiberTag = HostComponent;
        else
          getTag: switch (type) {
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = Mode, mode |= StrictLegacyMode, (mode & ConcurrentMode) !== NoMode && (mode |= StrictEffectsMode);
              break;
            case REACT_PROFILER_TYPE:
              return createFiberFromProfiler(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_TYPE:
              return createFiberFromSuspense(pendingProps, mode, lanes, key);
            case REACT_SUSPENSE_LIST_TYPE:
              return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
            case REACT_OFFSCREEN_TYPE:
              return createFiberFromOffscreen(pendingProps, mode, lanes, key);
            case REACT_LEGACY_HIDDEN_TYPE:
            // eslint-disable-next-line no-fallthrough
            case REACT_SCOPE_TYPE:
            // eslint-disable-next-line no-fallthrough
            case REACT_CACHE_TYPE:
            // eslint-disable-next-line no-fallthrough
            case REACT_TRACING_MARKER_TYPE:
            // eslint-disable-next-line no-fallthrough
            case REACT_DEBUG_TRACING_MODE_TYPE:
            // eslint-disable-next-line no-fallthrough
            default: {
              if (typeof type == "object" && type !== null)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    break getTag;
                  case REACT_CONTEXT_TYPE:
                    fiberTag = ContextConsumer;
                    break getTag;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef, resolvedType = resolveForwardRefForHotReloading(resolvedType);
                    break getTag;
                  case REACT_MEMO_TYPE:
                    fiberTag = MemoComponent;
                    break getTag;
                  case REACT_LAZY_TYPE:
                    fiberTag = LazyComponent, resolvedType = null;
                    break getTag;
                }
              var info = "";
              {
                (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                ownerName && (info += `

Check the render method of \`` + ownerName + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
            }
          }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        return fiber.elementType = type, fiber.type = resolvedType, fiber.lanes = lanes, fiber._debugOwner = owner, fiber;
      }
      function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        owner = element._owner;
        var type = element.type, key = element.key, pendingProps = element.props, fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        return fiber._debugSource = element._source, fiber._debugOwner = element._owner, fiber;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        return fiber.lanes = lanes, fiber;
      }
      function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        typeof pendingProps.id != "string" && error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        return fiber.elementType = REACT_PROFILER_TYPE, fiber.lanes = lanes, fiber.stateNode = {
          effectDuration: 0,
          passiveEffectDuration: 0
        }, fiber;
      }
      function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        return fiber.elementType = REACT_SUSPENSE_TYPE, fiber.lanes = lanes, fiber;
      }
      function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        return fiber.elementType = REACT_SUSPENSE_LIST_TYPE, fiber.lanes = lanes, fiber;
      }
      function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
        fiber.elementType = REACT_OFFSCREEN_TYPE, fiber.lanes = lanes;
        var primaryChildInstance = {
          isHidden: !1
        };
        return fiber.stateNode = primaryChildInstance, fiber;
      }
      function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        return fiber.lanes = lanes, fiber;
      }
      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode);
        return fiber.elementType = "DELETED", fiber;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiber(DehydratedFragment, null, null, NoMode);
        return fiber.stateNode = dehydratedNode, fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [], fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        return fiber.lanes = lanes, fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          // Used by persistent updates
          implementation: portal.implementation
        }, fiber;
      }
      function assignFiberPropertiesInDEV(target, source) {
        return target === null && (target = createFiber(IndeterminateComponent, null, null, NoMode)), target.tag = source.tag, target.key = source.key, target.elementType = source.elementType, target.type = source.type, target.stateNode = source.stateNode, target.return = source.return, target.child = source.child, target.sibling = source.sibling, target.index = source.index, target.ref = source.ref, target.pendingProps = source.pendingProps, target.memoizedProps = source.memoizedProps, target.updateQueue = source.updateQueue, target.memoizedState = source.memoizedState, target.dependencies = source.dependencies, target.mode = source.mode, target.flags = source.flags, target.subtreeFlags = source.subtreeFlags, target.deletions = source.deletions, target.lanes = source.lanes, target.childLanes = source.childLanes, target.alternate = source.alternate, target.actualDuration = source.actualDuration, target.actualStartTime = source.actualStartTime, target.selfBaseDuration = source.selfBaseDuration, target.treeBaseDuration = source.treeBaseDuration, target._debugSource = source._debugSource, target._debugOwner = source._debugOwner, target._debugNeedsRemount = source._debugNeedsRemount, target._debugHookTypes = source._debugHookTypes, target;
      }
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {
        this.tag = tag, this.containerInfo = containerInfo, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = noTimeout, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = NoLane, this.eventTimes = createLaneMap(NoLanes), this.expirationTimes = createLaneMap(NoTimestamp), this.pendingLanes = NoLanes, this.suspendedLanes = NoLanes, this.pingedLanes = NoLanes, this.expiredLanes = NoLanes, this.mutableReadLanes = NoLanes, this.finishedLanes = NoLanes, this.entangledLanes = NoLanes, this.entanglements = createLaneMap(NoLanes), this.identifierPrefix = identifierPrefix, this.onRecoverableError = onRecoverableError, supportsHydration && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
        {
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          for (var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [], _i = 0; _i < TotalLanes; _i++)
            pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
        }
        switch (tag) {
          case ConcurrentRoot:
            this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
            break;
          case LegacyRoot:
            this._debugRootType = hydrate ? "hydrate()" : "render()";
            break;
        }
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError), uninitializedFiber = createHostRootFiber(tag, isStrictMode);
        root.current = uninitializedFiber, uninitializedFiber.stateNode = root;
        {
          var _initialState = {
            element: initialChildren,
            isDehydrated: hydrate,
            cache: null,
            // not enabled yet
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          uninitializedFiber.memoizedState = _initialState;
        }
        return initializeUpdateQueue(uninitializedFiber), root;
      }
      var ReactVersion = "18.3.1";
      function createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        return checkKeyStringCoercion(key), {
          // This tag allow us to uniquely identify this as a React Portal
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var didWarnAboutNestedUpdates, didWarnAboutFindNodeInStrictMode;
      didWarnAboutNestedUpdates = !1, didWarnAboutFindNodeInStrictMode = {};
      function getContextForSubtree(parentComponent) {
        if (!parentComponent)
          return emptyContextObject;
        var fiber = get(parentComponent), parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;
          if (isContextProvider(Component))
            return processChildContext(fiber, Component, parentContext);
        }
        return parentContext;
      }
      function findHostInstance(component) {
        var fiber = get(component);
        if (fiber === void 0) {
          if (typeof component.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var keys = Object.keys(component).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
        }
        var hostFiber = findCurrentHostFiber(fiber);
        return hostFiber === null ? null : hostFiber.stateNode;
      }
      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get(component);
          if (fiber === void 0) {
            if (typeof component.render == "function")
              throw new Error("Unable to find node on an unmounted component.");
            var keys = Object.keys(component).join(",");
            throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
          }
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null)
            return null;
          if (hostFiber.mode & StrictLegacyMode) {
            var componentName = getComponentNameFromFiber(fiber) || "Component";
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = !0;
              var previousFiber = current;
              try {
                setCurrentFiber(hostFiber), fiber.mode & StrictLegacyMode ? error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName) : error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
              } finally {
                previousFiber ? setCurrentFiber(previousFiber) : resetCurrentFiber();
              }
            }
          }
          return hostFiber.stateNode;
        }
      }
      function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate = !1, initialChildren = null;
        return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      }
      function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate = !0, root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        root.context = getContextForSubtree(null);
        var current2 = root.current, eventTime = requestEventTime(), lane = requestUpdateLane(current2), update = createUpdate(eventTime, lane);
        return update.callback = callback ?? null, enqueueUpdate(current2, update, lane), scheduleInitialHydrationOnRoot(root, lane, eventTime), root;
      }
      function updateContainer(element, container, parentComponent, callback) {
        onScheduleRoot(container, element);
        var current$1 = container.current, eventTime = requestEventTime(), lane = requestUpdateLane(current$1);
        markRenderScheduled(lane);
        var context = getContextForSubtree(parentComponent);
        container.context === null ? container.context = context : container.pendingContext = context, isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentNameFromFiber(current) || "Unknown"));
        var update = createUpdate(eventTime, lane);
        update.payload = {
          element
        }, callback = callback === void 0 ? null : callback, callback !== null && (typeof callback != "function" && error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), update.callback = callback);
        var root = enqueueUpdate(current$1, update, lane);
        return root !== null && (scheduleUpdateOnFiber(root, current$1, lane, eventTime), entangleTransitions(root, current$1, lane)), lane;
      }
      function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child)
          return null;
        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);
          default:
            return containerFiber.child.stateNode;
        }
      }
      function attemptSynchronousHydration(fiber) {
        switch (fiber.tag) {
          case HostRoot: {
            var root = fiber.stateNode;
            if (isRootDehydrated(root)) {
              var lanes = getHighestPriorityPendingLanes(root);
              flushRoot(root, lanes);
            }
            break;
          }
          case SuspenseComponent: {
            flushSync(function() {
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, SyncLane, eventTime);
              }
            });
            var retryLane = SyncLane;
            markRetryLaneIfNotHydrated(fiber, retryLane);
            break;
          }
        }
      }
      function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        suspenseState !== null && suspenseState.dehydrated !== null && (suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane));
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        alternate && markRetryLaneImpl(alternate, retryLane);
      }
      function attemptDiscreteHydration(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var lane = SyncLane, root = enqueueConcurrentRenderForLane(fiber, lane);
          if (root !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function attemptContinuousHydration(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var lane = SelectiveHydrationLane, root = enqueueConcurrentRenderForLane(fiber, lane);
          if (root !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function attemptHydrationAtCurrentPriority(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);
          if (root !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
      }
      function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        return hostFiber === null ? null : hostFiber.stateNode;
      }
      var shouldErrorImpl = function(fiber) {
        return null;
      };
      function shouldError(fiber) {
        return shouldErrorImpl(fiber);
      }
      var shouldSuspendImpl = function(fiber) {
        return !1;
      };
      function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
      }
      var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
      {
        var copyWithDeleteImpl = function(obj, path8, index2) {
          var key = path8[index2], updated = isArray(obj) ? obj.slice() : assign({}, obj);
          return index2 + 1 === path8.length ? (isArray(updated) ? updated.splice(key, 1) : delete updated[key], updated) : (updated[key] = copyWithDeleteImpl(obj[key], path8, index2 + 1), updated);
        }, copyWithDelete = function(obj, path8) {
          return copyWithDeleteImpl(obj, path8, 0);
        }, copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
          var oldKey = oldPath[index2], updated = isArray(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === oldPath.length) {
            var newKey = newPath[index2];
            updated[newKey] = updated[oldKey], isArray(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey];
          } else
            updated[oldKey] = copyWithRenameImpl(
              // $FlowFixMe number or string is fine here
              obj[oldKey],
              oldPath,
              newPath,
              index2 + 1
            );
          return updated;
        }, copyWithRename = function(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length) {
            warn("copyWithRename() expects paths of the same length");
            return;
          } else
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                warn("copyWithRename() expects paths to be the same except for the deepest key");
                return;
              }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        }, copyWithSetImpl = function(obj, path8, index2, value) {
          if (index2 >= path8.length)
            return value;
          var key = path8[index2], updated = isArray(obj) ? obj.slice() : assign({}, obj);
          return updated[key] = copyWithSetImpl(obj[key], path8, index2 + 1, value), updated;
        }, copyWithSet = function(obj, path8, value) {
          return copyWithSetImpl(obj, path8, 0, value);
        }, findHook = function(fiber, id) {
          for (var currentHook2 = fiber.memoizedState; currentHook2 !== null && id > 0; )
            currentHook2 = currentHook2.next, id--;
          return currentHook2;
        };
        overrideHookState = function(fiber, id, path8, value) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path8, value);
            hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
          }
        }, overrideHookStateDeletePath = function(fiber, id, path8) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path8);
            hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
          }
        }, overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
          }
        }, overrideProps = function(fiber, path8, value) {
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path8, value), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
        }, overridePropsDeletePath = function(fiber, path8) {
          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path8), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
        }, overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
        }, scheduleUpdate = function(fiber) {
          var root = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root !== null && scheduleUpdateOnFiber(root, fiber, SyncLane, NoTimestamp);
        }, setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        }, setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
      }
      function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        return hostFiber === null ? null : hostFiber.stateNode;
      }
      function emptyFindFiberByHostInstance(instance) {
        return null;
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance, ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
          bundleType: devToolsConfig.bundleType,
          version: devToolsConfig.version,
          rendererPackageName: devToolsConfig.rendererPackageName,
          rendererConfig: devToolsConfig.rendererConfig,
          overrideHookState,
          overrideHookStateDeletePath,
          overrideHookStateRenamePath,
          overrideProps,
          overridePropsDeletePath,
          overridePropsRenamePath,
          setErrorHandler,
          setSuspenseHandler,
          scheduleUpdate,
          currentDispatcherRef: ReactCurrentDispatcher2,
          findHostInstanceByFiber,
          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
          // React Refresh
          findHostInstancesForRefresh,
          scheduleRefresh,
          scheduleRoot,
          setRefreshHandler,
          // Enables DevTools to append owner stacks to error messages in DEV mode.
          getCurrentFiber: getCurrentFiberForDevTools,
          // Enables DevTools to detect reconciler version rather than renderer version
          // which may not match for third party renderers.
          reconcilerVersion: ReactVersion
        });
      }
      return exports2.attemptContinuousHydration = attemptContinuousHydration, exports2.attemptDiscreteHydration = attemptDiscreteHydration, exports2.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority, exports2.attemptSynchronousHydration = attemptSynchronousHydration, exports2.batchedUpdates = batchedUpdates, exports2.createComponentSelector = createComponentSelector, exports2.createContainer = createContainer, exports2.createHasPseudoClassSelector = createHasPseudoClassSelector, exports2.createHydrationContainer = createHydrationContainer, exports2.createPortal = createPortal, exports2.createRoleSelector = createRoleSelector, exports2.createTestNameSelector = createTestNameSelector, exports2.createTextSelector = createTextSelector, exports2.deferredUpdates = deferredUpdates, exports2.discreteUpdates = discreteUpdates, exports2.findAllNodes = findAllNodes, exports2.findBoundingRects = findBoundingRects, exports2.findHostInstance = findHostInstance, exports2.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals, exports2.findHostInstanceWithWarning = findHostInstanceWithWarning, exports2.flushControlled = flushControlled, exports2.flushPassiveEffects = flushPassiveEffects, exports2.flushSync = flushSync, exports2.focusWithin = focusWithin, exports2.getCurrentUpdatePriority = getCurrentUpdatePriority, exports2.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription, exports2.getPublicRootInstance = getPublicRootInstance, exports2.injectIntoDevTools = injectIntoDevTools, exports2.isAlreadyRendering = isAlreadyRendering, exports2.observeVisibleRects = observeVisibleRects, exports2.registerMutableSourceForHydration = registerMutableSourceForHydration, exports2.runWithPriority = runWithPriority, exports2.shouldError = shouldError, exports2.shouldSuspend = shouldSuspend, exports2.updateContainer = updateContainer, exports2;
    });
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/index.js
var require_react_reconciler = __commonJS({
  "../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV === "production" ? module.exports = require_react_reconciler_production_min() : module.exports = require_react_reconciler_development();
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler-constants.production.min.js
var require_react_reconciler_constants_production_min = __commonJS({
  "../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler-constants.production.min.js"(exports) {
    "use strict";
    init_cjs_shims();
    exports.ConcurrentRoot = 1;
    exports.ContinuousEventPriority = 4;
    exports.DefaultEventPriority = 16;
    exports.DiscreteEventPriority = 1;
    exports.IdleEventPriority = 536870912;
    exports.LegacyRoot = 0;
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js
var require_react_reconciler_constants_development = __commonJS({
  "../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js"(exports) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV !== "production" && function() {
      "use strict";
      var SyncLane = (
        /*                        */
        1
      ), InputContinuousLane = (
        /*             */
        4
      ), DefaultLane = (
        /*                     */
        16
      ), IdleLane = (
        /*                        */
        536870912
      ), DiscreteEventPriority = SyncLane, ContinuousEventPriority = InputContinuousLane, DefaultEventPriority2 = DefaultLane, IdleEventPriority = IdleLane, LegacyRoot = 0, ConcurrentRoot = 1;
      exports.ConcurrentRoot = ConcurrentRoot, exports.ContinuousEventPriority = ContinuousEventPriority, exports.DefaultEventPriority = DefaultEventPriority2, exports.DiscreteEventPriority = DiscreteEventPriority, exports.IdleEventPriority = IdleEventPriority, exports.LegacyRoot = LegacyRoot;
    }();
  }
});

// ../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/react-reconciler@0.29.2_react@18.3.1/node_modules/react-reconciler/constants.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    process.env.NODE_ENV === "production" ? module.exports = require_react_reconciler_constants_production_min() : module.exports = require_react_reconciler_constants_development();
  }
});

// ../../node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js
var require_eastasianwidth = __commonJS({
  "../../node_modules/.pnpm/eastasianwidth@0.2.0/node_modules/eastasianwidth/eastasianwidth.js"(exports, module) {
    init_cjs_shims();
    var eaw = {};
    typeof module > "u" ? window.eastasianwidth = eaw : module.exports = eaw;
    eaw.eastAsianWidth = function(character) {
      var x = character.charCodeAt(0), y = character.length == 2 ? character.charCodeAt(1) : 0, codePoint = x;
      return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), codePoint == 12288 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : codePoint == 8361 || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || codePoint == 172 || codePoint == 175 || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : codePoint == 161 || codePoint == 164 || 167 <= codePoint && codePoint <= 168 || codePoint == 170 || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || codePoint == 198 || codePoint == 208 || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || codePoint == 230 || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || codePoint == 240 || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || codePoint == 252 || codePoint == 254 || codePoint == 257 || codePoint == 273 || codePoint == 275 || codePoint == 283 || 294 <= codePoint && codePoint <= 295 || codePoint == 299 || 305 <= codePoint && codePoint <= 307 || codePoint == 312 || 319 <= codePoint && codePoint <= 322 || codePoint == 324 || 328 <= codePoint && codePoint <= 331 || codePoint == 333 || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || codePoint == 363 || codePoint == 462 || codePoint == 464 || codePoint == 466 || codePoint == 468 || codePoint == 470 || codePoint == 472 || codePoint == 474 || codePoint == 476 || codePoint == 593 || codePoint == 609 || codePoint == 708 || codePoint == 711 || 713 <= codePoint && codePoint <= 715 || codePoint == 717 || codePoint == 720 || 728 <= codePoint && codePoint <= 731 || codePoint == 733 || codePoint == 735 || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || codePoint == 1025 || 1040 <= codePoint && codePoint <= 1103 || codePoint == 1105 || codePoint == 8208 || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || codePoint == 8240 || 8242 <= codePoint && codePoint <= 8243 || codePoint == 8245 || codePoint == 8251 || codePoint == 8254 || codePoint == 8308 || codePoint == 8319 || 8321 <= codePoint && codePoint <= 8324 || codePoint == 8364 || codePoint == 8451 || codePoint == 8453 || codePoint == 8457 || codePoint == 8467 || codePoint == 8470 || 8481 <= codePoint && codePoint <= 8482 || codePoint == 8486 || codePoint == 8491 || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || codePoint == 8585 || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || codePoint == 8658 || codePoint == 8660 || codePoint == 8679 || codePoint == 8704 || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || codePoint == 8715 || codePoint == 8719 || codePoint == 8721 || codePoint == 8725 || codePoint == 8730 || 8733 <= codePoint && codePoint <= 8736 || codePoint == 8739 || codePoint == 8741 || 8743 <= codePoint && codePoint <= 8748 || codePoint == 8750 || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || codePoint == 8776 || codePoint == 8780 || codePoint == 8786 || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || codePoint == 8853 || codePoint == 8857 || codePoint == 8869 || codePoint == 8895 || codePoint == 8978 || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || codePoint == 9675 || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || codePoint == 9711 || 9733 <= codePoint && codePoint <= 9734 || codePoint == 9737 || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || codePoint == 9756 || codePoint == 9758 || codePoint == 9792 || codePoint == 9794 || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || codePoint == 9839 || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || codePoint == 9955 || 9960 <= codePoint && codePoint <= 9983 || codePoint == 10045 || codePoint == 10071 || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || codePoint == 65533 || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
    };
    eaw.characterLength = function(character) {
      var code = this.eastAsianWidth(character);
      return code == "F" || code == "W" || code == "A" ? 2 : 1;
    };
    function stringToArray(string) {
      return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    eaw.length = function(string) {
      for (var characters = stringToArray(string), len = 0, i = 0; i < characters.length; i++)
        len = len + this.characterLength(characters[i]);
      return len;
    };
    eaw.slice = function(text, start, end) {
      textLen = eaw.length(text), start = start || 0, end = end || 1, start < 0 && (start = textLen + start), end < 0 && (end = textLen + end);
      for (var result = "", eawLen = 0, chars = stringToArray(text), i = 0; i < chars.length; i++) {
        var char = chars[i], charLen = eaw.length(char);
        if (eawLen >= start - (charLen == 2 ? 1 : 0))
          if (eawLen + charLen <= end)
            result += char;
          else
            break;
        eawLen += charLen;
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/emoji-regex@9.2.2/node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "../../node_modules/.pnpm/emoji-regex@9.2.2/node_modules/emoji-regex/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// ../../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/boxes.json
var require_boxes = __commonJS({
  "../../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/boxes.json"(exports, module) {
    module.exports = {
      single: {
        topLeft: "\u250C",
        top: "\u2500",
        topRight: "\u2510",
        right: "\u2502",
        bottomRight: "\u2518",
        bottom: "\u2500",
        bottomLeft: "\u2514",
        left: "\u2502"
      },
      double: {
        topLeft: "\u2554",
        top: "\u2550",
        topRight: "\u2557",
        right: "\u2551",
        bottomRight: "\u255D",
        bottom: "\u2550",
        bottomLeft: "\u255A",
        left: "\u2551"
      },
      round: {
        topLeft: "\u256D",
        top: "\u2500",
        topRight: "\u256E",
        right: "\u2502",
        bottomRight: "\u256F",
        bottom: "\u2500",
        bottomLeft: "\u2570",
        left: "\u2502"
      },
      bold: {
        topLeft: "\u250F",
        top: "\u2501",
        topRight: "\u2513",
        right: "\u2503",
        bottomRight: "\u251B",
        bottom: "\u2501",
        bottomLeft: "\u2517",
        left: "\u2503"
      },
      singleDouble: {
        topLeft: "\u2553",
        top: "\u2500",
        topRight: "\u2556",
        right: "\u2551",
        bottomRight: "\u255C",
        bottom: "\u2500",
        bottomLeft: "\u2559",
        left: "\u2551"
      },
      doubleSingle: {
        topLeft: "\u2552",
        top: "\u2550",
        topRight: "\u2555",
        right: "\u2502",
        bottomRight: "\u255B",
        bottom: "\u2550",
        bottomLeft: "\u2558",
        left: "\u2502"
      },
      classic: {
        topLeft: "+",
        top: "-",
        topRight: "+",
        right: "|",
        bottomRight: "+",
        bottom: "-",
        bottomLeft: "+",
        left: "|"
      },
      arrow: {
        topLeft: "\u2198",
        top: "\u2193",
        topRight: "\u2199",
        right: "\u2190",
        bottomRight: "\u2196",
        bottom: "\u2191",
        bottomLeft: "\u2197",
        left: "\u2192"
      }
    };
  }
});

// ../../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/index.js
var require_cli_boxes = __commonJS({
  "../../node_modules/.pnpm/cli-boxes@3.0.0/node_modules/cli-boxes/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var cliBoxes2 = require_boxes();
    module.exports = cliBoxes2;
    module.exports.default = cliBoxes2;
  }
});

// ../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var mimicFn = (to, from) => {
      for (let prop of Reflect.ownKeys(from))
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      return to;
    };
    module.exports = mimicFn;
    module.exports.default = mimicFn;
  }
});

// ../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime = __commonJS({
  "../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var mimicFn = require_mimic_fn(), calledFunctions2 = /* @__PURE__ */ new WeakMap(), onetime3 = (function_, options = {}) => {
      if (typeof function_ != "function")
        throw new TypeError("Expected a function");
      let returnValue, callCount = 0, functionName = function_.displayName || function_.name || "<anonymous>", onetime4 = function(...arguments_) {
        if (calledFunctions2.set(onetime4, ++callCount), callCount === 1)
          returnValue = function_.apply(this, arguments_), function_ = null;
        else if (options.throw === !0)
          throw new Error(`Function \`${functionName}\` can only be called once`);
        return returnValue;
      };
      return mimicFn(onetime4, function_), calledFunctions2.set(onetime4, callCount), onetime4;
    };
    module.exports = onetime3;
    module.exports.default = onetime3;
    module.exports.callCount = (function_) => {
      if (!calledFunctions2.has(function_))
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      return calledFunctions2.get(function_);
    };
  }
});

// ../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string != "string")
        throw new TypeError("Expected a string");
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// ../../node_modules/.pnpm/stack-utils@2.0.6/node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "../../node_modules/.pnpm/stack-utils@2.0.6/node_modules/stack-utils/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var escapeStringRegexp2 = require_escape_string_regexp(), cwd3 = typeof process == "object" && process && typeof process.cwd == "function" ? process.cwd() : ".", natives = [].concat(
      __require("module").builtinModules,
      "bootstrap_node",
      "node"
    ).map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(
      /\((?:node:)?internal\/[^:]+:\d+:\d+\)$/,
      /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/,
      /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/
    );
    var StackUtils2 = class _StackUtils {
      constructor(opts) {
        opts = {
          ignoredPackages: [],
          ...opts
        }, "internals" in opts || (opts.internals = _StackUtils.nodeInternals()), "cwd" in opts || (opts.cwd = cwd3), this._cwd = opts.cwd.replace(/\\/g, "/"), this._internals = [].concat(
          opts.internals,
          ignoredPackagesRegExp(opts.ignoredPackages)
        ), this._wrapCallSite = opts.wrapCallSite || !1;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent), Array.isArray(stack) || (stack = stack.split(`
`)), !/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1]) && (stack = stack.slice(1));
        let outdent = !1, lastNonAtLine = null, result = [];
        return stack.forEach((st) => {
          if (st = st.replace(/\\/g, "/"), this._internals.some((internal) => internal.test(st)))
            return;
          let isAtLine = /^\s*at /.test(st);
          outdent ? st = st.trimEnd().replace(/^(\s+)at /, "$1") : (st = st.trim(), isAtLine && (st = st.slice(3))), st = st.replace(`${this._cwd}/`, ""), st && (isAtLine ? (lastNonAtLine && (result.push(lastNonAtLine), lastNonAtLine = null), result.push(st)) : (outdent = !0, lastNonAtLine = st));
        }), result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        typeof limit == "function" && (fn = limit, limit = 1 / 0);
        let { stackTraceLimit } = Error;
        limit && (Error.stackTraceLimit = limit);
        let obj = {};
        Error.captureStackTrace(obj, fn);
        let { stack } = obj;
        return Error.stackTraceLimit = stackTraceLimit, this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        typeof limit == "function" && (fn = limit, limit = 1 / 0);
        let { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => this._wrapCallSite ? site.map(this._wrapCallSite) : site, limit && (Error.stackTraceLimit = limit);
        let obj = {};
        Error.captureStackTrace(obj, fn);
        let { stack } = obj;
        return Object.assign(Error, { prepareStackTrace, stackTraceLimit }), stack;
      }
      at(fn = this.at) {
        let [site] = this.capture(1, fn);
        if (!site)
          return {};
        let res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd), site.isConstructor() && Object.defineProperty(res, "constructor", {
          value: !0,
          configurable: !0
        }), site.isEval() && (res.evalOrigin = site.getEvalOrigin()), site.isNative() && (res.native = !0);
        let typename;
        try {
          typename = site.getTypeName();
        } catch {
        }
        typename && typename !== "Object" && typename !== "[object Object]" && (res.type = typename);
        let fname = site.getFunctionName();
        fname && (res.function = fname);
        let meth = site.getMethodName();
        return meth && fname !== meth && (res.method = meth), res;
      }
      parseLine(line) {
        let match2 = line && line.match(re);
        if (!match2)
          return null;
        let ctor = match2[1] === "new", fname = match2[2], evalOrigin = match2[3], evalFile = match2[4], evalLine = Number(match2[5]), evalCol = Number(match2[6]), file = match2[7], lnum = match2[8], col = match2[9], native = match2[10] === "native", closeParen = match2[11] === ")", method, res = {};
        if (lnum && (res.line = Number(lnum)), col && (res.column = Number(col)), closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--)
            if (file.charAt(i) === ")")
              closes++;
            else if (file.charAt(i) === "(" && file.charAt(i - 1) === " " && (closes--, closes === -1 && file.charAt(i - 1) === " ")) {
              let before = file.slice(0, i - 1);
              file = file.slice(i + 1), fname += ` (${before}`;
              break;
            }
        }
        if (fname) {
          let methodMatch = fname.match(methodRe);
          methodMatch && (fname = methodMatch[1], method = methodMatch[2]);
        }
        return setFile(res, file, this._cwd), ctor && Object.defineProperty(res, "constructor", {
          value: !0,
          configurable: !0
        }), evalOrigin && (res.evalOrigin = evalOrigin, res.evalLine = evalLine, res.evalColumn = evalCol, res.evalFile = evalFile && evalFile.replace(/\\/g, "/")), native && (res.native = !0), fname && (res.function = fname), method && fname !== method && (res.method = method), res;
      }
    };
    function setFile(result, filename, cwd4) {
      filename && (filename = filename.replace(/\\/g, "/"), filename.startsWith(`${cwd4}/`) && (filename = filename.slice(cwd4.length + 1)), result.file = filename);
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0)
        return [];
      let packages = ignoredPackages.map((mod) => escapeStringRegexp2(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp(
      "^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"
    ), methodRe = /^(.*?) \[as (.*?)\]$/;
    module.exports = StackUtils2;
  }
});

// ../../node_modules/.pnpm/is-upper-case@2.0.2/node_modules/is-upper-case/dist/index.js
var require_dist16 = __commonJS({
  "../../node_modules/.pnpm/is-upper-case@2.0.2/node_modules/is-upper-case/dist/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isUpperCase = void 0;
    function isUpperCase2(input) {
      return input.toUpperCase() === input && input.toLowerCase() !== input;
    }
    exports.isUpperCase = isUpperCase2;
  }
});

// ../../node_modules/.pnpm/ts-error@1.0.6/node_modules/ts-error/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/ts-error@1.0.6/node_modules/ts-error/lib/helpers.js"(exports) {
    "use strict";
    init_cjs_shims();
    exports.__esModule = void 0;
    exports.__esModule = !0;
    var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function(target, prototype) {
      objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(target, prototype) : target.__proto__ = prototype;
    };
    exports.setPrototypeOf = setPrototypeOf;
    var getPrototypeOf = function(target) {
      return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(target) : target.__proto__ || target.prototype;
    };
    exports.getPrototypeOf = getPrototypeOf;
    var ie8ObjectDefinePropertyBug = !1, defineProperty = function defineProperty2(target, name, propertyDescriptor) {
      if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
        try {
          Object.defineProperty(target, name, propertyDescriptor);
        } catch {
          ie8ObjectDefinePropertyBug = !0, defineProperty2(target, name, propertyDescriptor);
        }
      else
        target[name] = propertyDescriptor.value;
    };
    exports.defineProperty = defineProperty;
    var hasOwnProperty = function(target, name) {
      return objectHasOwnPropertyIsDefined ? target.hasOwnProperty(target, name) : target[name] === void 0;
    };
    exports.hasOwnProperty = hasOwnProperty;
    var objectCreate = function(prototype, propertyDescriptors) {
      if (objectCreateIsDefined)
        return Object.create(prototype, propertyDescriptors);
      var F = function() {
      };
      F.prototype = prototype;
      var result = new F();
      if (typeof propertyDescriptors > "u")
        return result;
      if (typeof propertyDescriptors == "null")
        throw new Error("PropertyDescriptors must not be null.");
      if (typeof propertyDescriptors == "object")
        for (var key in propertyDescriptors)
          hasOwnProperty(propertyDescriptors, key) && (result[key] = propertyDescriptors[key].value);
      return result;
    };
    exports.objectCreate = objectCreate;
  }
});

// ../../node_modules/.pnpm/ts-error@1.0.6/node_modules/ts-error/lib/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/.pnpm/ts-error@1.0.6/node_modules/ts-error/lib/cjs.js"(exports) {
    "use strict";
    init_cjs_shims();
    exports.__esModule = void 0;
    exports.__esModule = !0;
    var helpers = require_helpers(), setPrototypeOf = helpers.setPrototypeOf, getPrototypeOf = helpers.getPrototypeOf, defineProperty = helpers.defineProperty, objectCreate = helpers.objectCreate, uglyErrorPrinting = new Error().toString() === "[object Error]", extendableErrorName = "";
    function ExtendableError2(message) {
      var originalConstructor = this.constructor, constructorName = originalConstructor.name || function() {
        var constructorNameMatch = originalConstructor.toString().match(/^function\s*([^\s(]+)/);
        return constructorNameMatch === null ? extendableErrorName || "Error" : constructorNameMatch[1];
      }(), constructorNameIsError = constructorName === "Error", name = constructorNameIsError ? extendableErrorName : constructorName, instance = Error.apply(this, arguments);
      if (setPrototypeOf(instance, getPrototypeOf(this)), !(instance instanceof originalConstructor) || !(instance instanceof ExtendableError2)) {
        var instance = this;
        Error.apply(this, arguments), defineProperty(instance, "message", {
          configurable: !0,
          enumerable: !1,
          value: message,
          writable: !0
        });
      }
      if (defineProperty(instance, "name", {
        configurable: !0,
        enumerable: !1,
        value: name,
        writable: !0
      }), Error.captureStackTrace && Error.captureStackTrace(
        instance,
        constructorNameIsError ? ExtendableError2 : originalConstructor
      ), instance.stack === void 0) {
        var err = new Error(message);
        err.name = instance.name, instance.stack = err.stack;
      }
      return uglyErrorPrinting && defineProperty(instance, "toString", {
        configurable: !0,
        enumerable: !1,
        value: function() {
          return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
        },
        writable: !0
      }), instance;
    }
    extendableErrorName = ExtendableError2.name || "ExtendableError";
    ExtendableError2.prototype = objectCreate(Error.prototype, {
      constructor: {
        value: Error,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    });
    exports.ExtendableError = ExtendableError2;
    exports.default = exports.ExtendableError;
  }
});

// ../../node_modules/.pnpm/node-abort-controller@3.1.1/node_modules/node-abort-controller/index.js
var require_node_abort_controller = __commonJS({
  "../../node_modules/.pnpm/node-abort-controller@3.1.1/node_modules/node-abort-controller/index.js"(exports, module) {
    init_cjs_shims();
    var { EventEmitter: EventEmitter4 } = __require("events"), AbortSignal2 = class {
      constructor() {
        this.eventEmitter = new EventEmitter4(), this.onabort = null, this.aborted = !1, this.reason = void 0;
      }
      toString() {
        return "[object AbortSignal]";
      }
      get [Symbol.toStringTag]() {
        return "AbortSignal";
      }
      removeEventListener(name, handler2) {
        this.eventEmitter.removeListener(name, handler2);
      }
      addEventListener(name, handler2) {
        this.eventEmitter.on(name, handler2);
      }
      dispatchEvent(type) {
        let event = { type, target: this }, handlerName = `on${type}`;
        typeof this[handlerName] == "function" && this[handlerName](event), this.eventEmitter.emit(type, event);
      }
      throwIfAborted() {
        if (this.aborted)
          throw this.reason;
      }
      static abort(reason) {
        let controller = new AbortController2();
        return controller.abort(), controller.signal;
      }
      static timeout(time) {
        let controller = new AbortController2();
        return setTimeout(() => controller.abort(new Error("TimeoutError")), time), controller.signal;
      }
    }, AbortController2 = class {
      constructor() {
        this.signal = new AbortSignal2();
      }
      abort(reason) {
        this.signal.aborted || (this.signal.aborted = !0, reason ? this.signal.reason = reason : this.signal.reason = new Error("AbortError"), this.signal.dispatchEvent("abort"));
      }
      toString() {
        return "[object AbortController]";
      }
      get [Symbol.toStringTag]() {
        return "AbortController";
      }
    };
    module.exports = { AbortController: AbortController2, AbortSignal: AbortSignal2 };
  }
});

// ../../node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/SyncPromise.js
var require_SyncPromise = __commonJS({
  "../../node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/SyncPromise.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = class SyncPromise {
      constructor(fn) {
        try {
          fn(
            (x) => {
              this.setValue(x, !1);
            },
            // resolve
            (x) => {
              this.setValue(x, !0);
            }
            // reject
          );
        } catch (e) {
          this.setValue(e, !0);
        }
      }
      setValue(x, rejected) {
        this.val = x instanceof SyncPromise ? x.val : x, this.rejected = rejected || (x instanceof SyncPromise ? x.rejected : !1);
      }
      static valueFrom(x) {
        if (x instanceof SyncPromise) {
          if (x.rejected) throw x.val;
          return x.val;
        } else
          return x;
      }
      then(fn) {
        try {
          if (!this.rejected) return SyncPromise.resolve(fn(this.val));
        } catch (e) {
          return SyncPromise.reject(e);
        }
        return this;
      }
      catch(fn) {
        try {
          if (this.rejected) return SyncPromise.resolve(fn(this.val));
        } catch (e) {
          return SyncPromise.reject(e);
        }
        return this;
      }
      static resolve(x) {
        return new SyncPromise((resolve) => {
          resolve(x);
        });
      }
      static reject(x) {
        return new SyncPromise((_2, reject) => {
          reject(x);
        });
      }
    };
  }
});

// ../../node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/path.js
var require_path = __commonJS({
  "../../node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/path.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var isBrowser2 = typeof window < "u" && window.window === window && window.navigator, cwd3 = isBrowser2 ? window.location.href : process.cwd(), urlRegexp = new RegExp("^((https|http)://)?[a-z0-9A-Z]{3}.[a-z0-9A-Z][a-z0-9A-Z]{0,61}?[a-z0-9A-Z].com|net|cn|cc (:s[0-9]{1-4})?/$"), path8 = module.exports = {
      concat(a, b) {
        let a_endsWithSlash = a[a.length - 1] === "/", b_startsWithSlash = b[0] === "/";
        return a + (a_endsWithSlash || b_startsWithSlash ? "" : "/") + (a_endsWithSlash && b_startsWithSlash ? b.substring(1) : b);
      },
      resolve(x) {
        return path8.isAbsolute(x) ? path8.normalize(x) : path8.normalize(path8.concat(cwd3, x));
      },
      normalize(x) {
        let output2 = [], skip = 0;
        x.split("/").reverse().filter((x2) => x2 !== ".").forEach((x2) => {
          x2 === ".." ? skip++ : skip === 0 ? output2.push(x2) : skip--;
        });
        let result = output2.reverse().join("/");
        return (isBrowser2 && result[0] === "/" ? result[1] === "/" ? window.location.protocol : window.location.origin : "") + result;
      },
      isData: (x) => x.indexOf("data:") === 0,
      isURL: (x) => urlRegexp.test(x),
      isAbsolute: (x) => x[0] === "/" || /^[^\/]*:/.test(x),
      relativeToFile(a, b) {
        return path8.isData(a) || path8.isAbsolute(b) ? path8.normalize(b) : path8.normalize(path8.concat(a.split("/").slice(0, -1).join("/"), b));
      }
    };
  }
});

// ../../node_modules/.pnpm/data-uri-to-buffer@2.0.2/node_modules/data-uri-to-buffer/index.js
var require_data_uri_to_buffer = __commonJS({
  "../../node_modules/.pnpm/data-uri-to-buffer@2.0.2/node_modules/data-uri-to-buffer/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = dataUriToBuffer;
    function dataUriToBuffer(uri) {
      if (!/^data\:/i.test(uri))
        throw new TypeError(
          '`uri` does not appear to be a Data URI (must begin with "data:")'
        );
      uri = uri.replace(/\r?\n/g, "");
      var firstComma = uri.indexOf(",");
      if (firstComma === -1 || firstComma <= 4)
        throw new TypeError("malformed data: URI");
      for (var meta = uri.substring(5, firstComma).split(";"), type = meta[0] || "text/plain", typeFull = type, base64 = !1, charset = "", i = 1; i < meta.length; i++)
        meta[i] == "base64" ? base64 = !0 : (typeFull += ";" + meta[i], meta[i].indexOf("charset=") == 0 && (charset = meta[i].substring(8)));
      !meta[0] && !charset.length && (typeFull += ";charset=US-ASCII", charset = "US-ASCII");
      var data = unescape(uri.substring(firstComma + 1)), encoding = base64 ? "base64" : "ascii", buffer = Buffer.from ? Buffer.from(data, encoding) : new Buffer(data, encoding);
      return buffer.type = type, buffer.typeFull = typeFull, buffer.charset = charset, buffer;
    }
  }
});

// ../../node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/get-source.js
var require_get_source = __commonJS({
  "../../node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/get-source.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var { assign } = Object, isBrowser2 = typeof window < "u" && window.window === window && window.navigator, SourceMapConsumer = require_source_map().SourceMapConsumer, SyncPromise = require_SyncPromise(), path8 = require_path(), dataURIToBuffer = require_data_uri_to_buffer(), nodeRequire = isBrowser2 ? null : module.require, memoize = (f) => {
      let m = (x) => x in m.cache ? m.cache[x] : m.cache[x] = f(x);
      return m.forgetEverything = () => {
        m.cache = /* @__PURE__ */ Object.create(null);
      }, m.cache = /* @__PURE__ */ Object.create(null), m;
    };
    function impl(fetchFile, sync) {
      let PromiseImpl = sync ? SyncPromise : Promise, SourceFileMemoized = memoize((path9) => SourceFile(path9, fetchFile(path9)));
      function SourceFile(srcPath, text) {
        return text === void 0 ? SourceFileMemoized(path8.resolve(srcPath)) : PromiseImpl.resolve(text).then((text2) => {
          let file, lines, resolver, _resolve = (loc) => (resolver = resolver || SourceMapResolverFromFetchedFile(file))(loc);
          return file = {
            path: srcPath,
            text: text2,
            get lines() {
              return lines = lines || text2.split(`
`);
            },
            resolve(loc) {
              let result = _resolve(loc);
              if (sync)
                try {
                  return SyncPromise.valueFrom(result);
                } catch (e) {
                  return assign({}, loc, { error: e });
                }
              else
                return Promise.resolve(result);
            },
            _resolve
          };
        });
      }
      function SourceMapResolverFromFetchedFile(file) {
        let re = /\u0023 sourceMappingURL=(.+)\n?/g, lastMatch;
        for (; ; ) {
          let match2 = re.exec(file.text);
          if (match2) lastMatch = match2;
          else break;
        }
        let url = lastMatch && lastMatch[1], defaultResolver = (loc) => assign({}, loc, {
          sourceFile: file,
          sourceLine: file.lines[loc.line - 1] || ""
        });
        return url ? SourceMapResolver(file.path, url, defaultResolver) : defaultResolver;
      }
      function SourceMapResolver(originalFilePath, sourceMapPath, fallbackResolve) {
        let srcFile = sourceMapPath.startsWith("data:") ? SourceFile(originalFilePath, dataURIToBuffer(sourceMapPath).toString()) : SourceFile(path8.relativeToFile(originalFilePath, sourceMapPath)), parsedMap = srcFile.then((f) => SourceMapConsumer(JSON.parse(f.text))), sourceFor = memoize(function(filePath) {
          return srcFile.then((f) => {
            let fullPath = path8.relativeToFile(f.path, filePath);
            return parsedMap.then((x) => SourceFile(
              fullPath,
              x.sourceContentFor(
                filePath,
                !0
                /* return null on missing */
              ) || void 0
            ));
          });
        });
        return (loc) => parsedMap.then((x) => {
          let originalLoc = x.originalPositionFor(loc);
          return originalLoc.source ? sourceFor(originalLoc.source).then(
            (x2) => x2._resolve(assign({}, loc, {
              line: originalLoc.line,
              column: originalLoc.column + 1,
              name: originalLoc.name
            }))
          ) : fallbackResolve(loc);
        }).catch((e) => assign(fallbackResolve(loc), { sourceMapError: e }));
      }
      return assign(function(path9) {
        let file = SourceFile(path9);
        if (sync)
          try {
            return SyncPromise.valueFrom(file);
          } catch (e) {
            let noFile = {
              path: path9,
              text: "",
              lines: [],
              error: e,
              resolve(loc) {
                return assign({}, loc, { error: e, sourceLine: "", sourceFile: noFile });
              }
            };
            return noFile;
          }
        return file;
      }, {
        resetCache: () => SourceFileMemoized.forgetEverything(),
        getCache: () => SourceFileMemoized.cache
      });
    }
    module.exports = impl(function(path9) {
      return new SyncPromise((resolve) => {
        if (isBrowser2) {
          let xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path9,
            !1
            /* SYNCHRONOUS XHR FTW :) */
          ), xhr.send(null), resolve(xhr.responseText);
        } else
          resolve(nodeRequire("fs").readFileSync(path9, { encoding: "utf8" }));
      });
    }, !0);
    module.exports.async = impl(function(path9) {
      return new Promise((resolve, reject) => {
        if (isBrowser2) {
          let xhr = new XMLHttpRequest();
          xhr.open("GET", path9), xhr.onreadystatechange = (event) => {
            xhr.readyState === 4 && (xhr.status === 200 ? resolve(xhr.responseText) : reject(new Error(xhr.statusText)));
          }, xhr.send(null);
        } else
          nodeRequire("fs").readFile(path9, { encoding: "utf8" }, (e, x) => {
            e ? reject(e) : resolve(x);
          });
      });
    });
  }
});

// ../../node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/impl/partition.js
var require_partition = __commonJS({
  "../../node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/impl/partition.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (arr_, pred) => {
      let arr = arr_ || [], spans = [], span = {
        label: void 0,
        items: [arr.first]
      };
      return arr.forEach((x) => {
        let label = pred(x);
        span.label !== label && span.items.length ? spans.push(span = { label, items: [x] }) : span.items.push(x);
      }), spans;
    };
  }
});

// ../../node_modules/.pnpm/printable-characters@1.0.42/node_modules/printable-characters/build/printable-characters.js
var require_printable_characters = __commonJS({
  "../../node_modules/.pnpm/printable-characters@1.0.42/node_modules/printable-characters/build/printable-characters.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var _slicedToArray = /* @__PURE__ */ function() {
      function sliceIterator(arr, i) {
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
            ;
        } catch (err) {
          _d = !0, _e = err;
        } finally {
          try {
            !_n && _i.return && _i.return();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr))
          return arr;
        if (Symbol.iterator in Object(arr))
          return sliceIterator(arr, i);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), ansiEscapeCode = "[\x1B\x9B][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]", zeroWidthCharacterExceptNewline = "\0-\b\v-\x1B\x9B\xAD\u200B\u2028\u2029\uFEFF\uFE00-\uFE0F", zeroWidthCharacter = `
` + zeroWidthCharacterExceptNewline, zeroWidthCharactersExceptNewline = new RegExp("(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacterExceptNewline + "]", "g"), zeroWidthCharacters = new RegExp("(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacter + "]", "g"), partition = new RegExp("((?:" + ansiEscapeCode + ")|[	" + zeroWidthCharacter + "])?([^	" + zeroWidthCharacter + "]*)", "g");
    module.exports = {
      zeroWidthCharacters,
      ansiEscapeCodes: new RegExp(ansiEscapeCode, "g"),
      strlen: (s) => Array.from(s.replace(zeroWidthCharacters, "")).length,
      // Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
      isBlank: (s) => s.replace(zeroWidthCharacters, "").replace(/\s/g, "").length === 0,
      blank: (s) => Array.from(s.replace(zeroWidthCharactersExceptNewline, "")).map((x) => x === "	" || x === `
` ? x : " ").join(""),
      partition(s) {
        for (var m, spans = []; partition.lastIndex !== s.length && (m = partition.exec(s)); )
          spans.push([m[1] || "", m[2]]);
        return partition.lastIndex = 0, spans;
      },
      first(s, n) {
        let result = "", length = 0;
        for (let _ref of module.exports.partition(s)) {
          var _ref2 = _slicedToArray(_ref, 2);
          let nonPrintable = _ref2[0], printable = _ref2[1], text = Array.from(printable).slice(0, n - length);
          result += nonPrintable + text.join(""), length += text.length;
        }
        return result;
      }
    };
  }
});

// ../../node_modules/.pnpm/as-table@1.0.55/node_modules/as-table/build/as-table.js
var require_as_table = __commonJS({
  "../../node_modules/.pnpm/as-table@1.0.55/node_modules/as-table/build/as-table.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
        return arr2;
      } else
        return Array.from(arr);
    }
    var O = Object, _require = require_printable_characters(), first = _require.first, strlen = _require.strlen, limit = (s, n) => first(s, n - 1) + "\u2026", asColumns = (rows, cfg_) => {
      let zip = (arrs, f) => arrs.reduce((a, b) => b.map((b2, i) => [].concat(_toConsumableArray(a[i] || []), [b2])), []).map((args) => f.apply(void 0, _toConsumableArray(args))), cells = rows.map((r) => r.map((c) => c.replace(/\n/g, "\\n"))), cellWidths = cells.map((r) => r.map(strlen)), maxWidths = zip(cellWidths, Math.max), cfg = O.assign({
        delimiter: "  ",
        minColumnWidths: maxWidths.map((x) => 0),
        maxTotalWidth: 0
      }, cfg_), delimiterLength = strlen(cfg.delimiter), totalWidth = maxWidths.reduce((a, b) => a + b, 0), relativeWidths = maxWidths.map((w) => w / totalWidth), maxTotalWidth = cfg.maxTotalWidth - delimiterLength * (maxWidths.length - 1), excessWidth = Math.max(0, totalWidth - maxTotalWidth), computedWidths = zip([cfg.minColumnWidths, maxWidths, relativeWidths], (min, max, relative) => Math.max(min, Math.floor(max - excessWidth * relative))), restCellWidths = cellWidths.map((widths) => zip([computedWidths, widths], (a, b) => a - b));
      return zip([cells, restCellWidths], (a, b) => zip([a, b], (str, w) => w >= 0 ? cfg.right ? " ".repeat(w) + str : str + " ".repeat(w) : limit(str, strlen(str) + w)).join(cfg.delimiter));
    }, asTable = (cfg) => O.assign((arr) => {
      var _ref;
      if (arr[0] && Array.isArray(arr[0]))
        return asColumns(arr.map((r) => r.map((c, i) => c === void 0 ? "" : cfg.print(c, i))), cfg).join(`
`);
      let colNames = [].concat(_toConsumableArray(new Set((_ref = []).concat.apply(_ref, _toConsumableArray(arr.map(O.keys)))))), columns = [colNames.map(cfg.title)].concat(_toConsumableArray(arr.map((o) => colNames.map((key) => o[key] === void 0 ? "" : cfg.print(o[key], key))))), lines = asColumns(columns, cfg);
      return (cfg.dash ? [lines[0], cfg.dash.repeat(strlen(lines[0]))].concat(_toConsumableArray(lines.slice(1))) : lines).join(`
`);
    }, cfg, {
      configure: (newConfig) => asTable(O.assign({}, cfg, newConfig))
    });
    module.exports = asTable({
      maxTotalWidth: Number.MAX_SAFE_INTEGER,
      print: String,
      title: String,
      dash: "-",
      right: !1
    });
  }
});

// ../../node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/stacktracey.js
var require_stacktracey = __commonJS({
  "../../node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/stacktracey.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var O = Object, isBrowser2 = typeof window < "u" && window.window === window && window.navigator, nodeRequire = isBrowser2 ? null : module.require, lastOf = (x) => x[x.length - 1], getSource = require_get_source(), partition = require_partition(), asTable = require_as_table(), nixSlashes = (x) => x.replace(/\\/g, "/"), pathRoot = isBrowser2 ? window.location.href : nixSlashes(process.cwd()) + "/", StackTracey2 = class _StackTracey {
      constructor(input, offset) {
        let originalInput = input, isParseableSyntaxError = input && input instanceof SyntaxError && !isBrowser2;
        if (input || (input = new Error(), offset = offset === void 0 ? 1 : offset), input instanceof Error && (input = input.stack || ""), typeof input == "string" && (input = this.rawParse(input).slice(offset).map((x) => this.extractEntryMetadata(x))), Array.isArray(input)) {
          if (isParseableSyntaxError) {
            let rawLines = __require("util").inspect(originalInput).split(`
`), fileLine = rawLines[0].split(":"), line = fileLine.pop(), file = fileLine.join(":");
            file && input.unshift({
              file: nixSlashes(file),
              line,
              column: (rawLines[2] || "").indexOf("^") + 1,
              sourceLine: rawLines[1],
              callee: "(syntax error)",
              syntaxError: !0
            });
          }
          this.items = input;
        } else
          this.items = [];
      }
      extractEntryMetadata(e) {
        let decomposedPath = this.decomposePath(e.file || ""), fileRelative = decomposedPath[0], externalDomain = decomposedPath[1];
        return O.assign(e, {
          calleeShort: e.calleeShort || lastOf((e.callee || "").split(".")),
          fileRelative,
          fileShort: this.shortenPath(fileRelative),
          fileName: lastOf((e.file || "").split("/")),
          thirdParty: this.isThirdParty(fileRelative, externalDomain) && !e.index,
          externalDomain
        });
      }
      shortenPath(relativePath) {
        return relativePath.replace(/^node_modules\//, "").replace(/^webpack\/bootstrap\//, "").replace(/^__parcel_source_root\//, "");
      }
      decomposePath(fullPath) {
        let result = fullPath;
        isBrowser2 && (result = result.replace(pathRoot, ""));
        let externalDomainMatch = result.match(/^(http|https)\:\/\/?([^\/]+)\/(.*)/), externalDomain = externalDomainMatch ? externalDomainMatch[2] : void 0;
        return result = externalDomainMatch ? externalDomainMatch[3] : result, isBrowser2 || (result = __require("path").relative(pathRoot, result)), [
          nixSlashes(result).replace(/^.*\:\/\/?\/?/, ""),
          // cut webpack:/// and webpack:/ things
          externalDomain
        ];
      }
      isThirdParty(relativePath, externalDomain) {
        return externalDomain || relativePath[0] === "~" || // webpack-specific heuristic
        relativePath[0] === "/" || // external source
        relativePath.indexOf("node_modules") === 0 || relativePath.indexOf("webpack/bootstrap") === 0;
      }
      rawParse(str) {
        return (str || "").split(`
`).map((line) => {
          line = line.trim();
          let callee, fileLineColumn = [], native, planA, planB;
          if ((planA = line.match(/at (.+) \(eval at .+ \((.+)\), .+\)/)) || // eval calls
          (planA = line.match(/at (.+) \((.+)\)/)) || line.slice(0, 3) !== "at " && (planA = line.match(/(.*)@(.*)/)))
            callee = planA[1], native = planA[2] === "native", fileLineColumn = (planA[2].match(/(.*):(\d+):(\d+)/) || planA[2].match(/(.*):(\d+)/) || []).slice(1);
          else if (planB = line.match(/^(at\s+)*(.+):(\d+):(\d+)/))
            fileLineColumn = planB.slice(2);
          else
            return;
          return callee && !fileLineColumn[0] && callee.split(".")[0] === "Array" && (native = !0), {
            beforeParse: line,
            callee: callee || "",
            index: isBrowser2 && fileLineColumn[0] === window.location.href,
            native: native || !1,
            file: nixSlashes(fileLineColumn[0] || ""),
            line: parseInt(fileLineColumn[1] || "", 10) || void 0,
            column: parseInt(fileLineColumn[2] || "", 10) || void 0
          };
        }).filter((x) => x !== void 0);
      }
      withSourceAt(i) {
        return this.items[i] && this.withSource(this.items[i]);
      }
      withSourceAsyncAt(i) {
        return this.items[i] && this.withSourceAsync(this.items[i]);
      }
      withSource(loc) {
        if (this.shouldSkipResolving(loc))
          return loc;
        {
          let resolved = getSource(loc.file || "").resolve(loc);
          return resolved.sourceFile ? this.withSourceResolved(loc, resolved) : loc;
        }
      }
      withSourceAsync(loc) {
        return this.shouldSkipResolving(loc) ? Promise.resolve(loc) : getSource.async(loc.file || "").then((x) => x.resolve(loc)).then((resolved) => this.withSourceResolved(loc, resolved)).catch((e) => this.withSourceResolved(loc, { error: e, sourceLine: "" }));
      }
      shouldSkipResolving(loc) {
        return loc.sourceFile || loc.error || loc.file && loc.file.indexOf("<") >= 0;
      }
      withSourceResolved(loc, resolved) {
        return resolved.sourceFile && !resolved.sourceFile.error && (resolved.file = nixSlashes(resolved.sourceFile.path), resolved = this.extractEntryMetadata(resolved)), resolved.sourceLine.includes("// @hide") && (resolved.sourceLine = resolved.sourceLine.replace("// @hide", ""), resolved.hide = !0), (resolved.sourceLine.includes("__webpack_require__") || // webpack-specific heuristics
        resolved.sourceLine.includes("/******/ ({")) && (resolved.thirdParty = !0), O.assign({ sourceLine: "" }, loc, resolved);
      }
      withSources() {
        return this.map((x) => this.withSource(x));
      }
      withSourcesAsync() {
        return Promise.all(this.items.map((x) => this.withSourceAsync(x))).then((items) => new _StackTracey(items));
      }
      mergeRepeatedLines() {
        return new _StackTracey(
          partition(this.items, (e) => e.file + e.line).map(
            (group) => group.items.slice(1).reduce((memo2, entry) => (memo2.callee = (memo2.callee || "<anonymous>") + " \u2192 " + (entry.callee || "<anonymous>"), memo2.calleeShort = (memo2.calleeShort || "<anonymous>") + " \u2192 " + (entry.calleeShort || "<anonymous>"), memo2), O.assign({}, group.items[0]))
          )
        );
      }
      clean() {
        let s = this.withSources().mergeRepeatedLines();
        return s.filter(s.isClean.bind(s));
      }
      cleanAsync() {
        return this.withSourcesAsync().then((s) => (s = s.mergeRepeatedLines(), s.filter(s.isClean.bind(s))));
      }
      isClean(entry, index) {
        return index === 0 || !(entry.thirdParty || entry.hide || entry.native);
      }
      at(i) {
        return O.assign({
          beforeParse: "",
          callee: "<???>",
          index: !1,
          native: !1,
          file: "<???>",
          line: 0,
          column: 0
        }, this.items[i]);
      }
      asTable(opts) {
        let maxColumnWidths = opts && opts.maxColumnWidths || this.maxColumnWidths(), trimEnd = (s, n) => s && (s.length > n ? s.slice(0, n - 1) + "\u2026" : s), trimStart = (s, n) => s && (s.length > n ? "\u2026" + s.slice(-(n - 1)) : s), trimmed = this.map(
          (e) => [
            "at " + trimEnd(e.calleeShort, maxColumnWidths.callee),
            trimStart(e.fileShort && e.fileShort + ":" + e.line || "", maxColumnWidths.file),
            trimEnd((e.sourceLine || "").trim() || "", maxColumnWidths.sourceLine)
          ]
        );
        return asTable(trimmed.items);
      }
      maxColumnWidths() {
        return {
          callee: 30,
          file: 60,
          sourceLine: 80
        };
      }
      static resetCache() {
        getSource.resetCache(), getSource.async.resetCache();
      }
      static locationsEqual(a, b) {
        return a.file === b.file && a.line === b.line && a.column === b.column;
      }
    };
    ["map", "filter", "slice", "concat"].forEach((method) => {
      StackTracey2.prototype[method] = function() {
        return new StackTracey2(this.items[method].apply(this.items, arguments));
      };
    });
    module.exports = StackTracey2;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports, module) {
    init_cjs_shims();
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === !1)
            break;
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports, module) {
    init_cjs_shims();
    var createBaseFor = require_createBaseFor(), baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports, module) {
    init_cjs_shims();
    var baseFor = require_baseFor(), keys = require_keys();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    module.exports = baseForOwn;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js"(exports, module) {
    init_cjs_shims();
    var isArrayLike = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null)
          return collection;
        if (!isArrayLike(collection))
          return eachFunc(collection, iteratee);
        for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); (fromRight ? index-- : ++index < length) && iteratee(iterable[index], index, iterable) !== !1; )
          ;
        return collection;
      };
    }
    module.exports = createBaseEach;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js"(exports, module) {
    init_cjs_shims();
    var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach(), baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js"(exports, module) {
    init_cjs_shims();
    var baseEach = require_baseEach(), isArrayLike = require_isArrayLike();
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      return baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      }), result;
    }
    module.exports = baseMap;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSortBy.js
var require_baseSortBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSortBy.js"(exports, module) {
    init_cjs_shims();
    function baseSortBy(array, comparer) {
      var length = array.length;
      for (array.sort(comparer); length--; )
        array[length] = array[length].value;
      return array;
    }
    module.exports = baseSortBy;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_compareAscending.js
var require_compareAscending = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_compareAscending.js"(exports, module) {
    init_cjs_shims();
    var isSymbol = require_isSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
          return 1;
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
          return -1;
      }
      return 0;
    }
    module.exports = compareAscending;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_compareMultiple.js
var require_compareMultiple = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_compareMultiple.js"(exports, module) {
    init_cjs_shims();
    var compareAscending = require_compareAscending();
    function compareMultiple(object, other, orders) {
      for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength)
            return result;
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    module.exports = compareMultiple;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseOrderBy.js
var require_baseOrderBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseOrderBy.js"(exports, module) {
    init_cjs_shims();
    var arrayMap = require_arrayMap(), baseGet = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary(), compareMultiple = require_compareMultiple(), identity = require_identity(), isArray = require_isArray();
    function baseOrderBy(collection, iteratees, orders) {
      iteratees.length ? iteratees = arrayMap(iteratees, function(iteratee) {
        return isArray(iteratee) ? function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        } : iteratee;
      }) : iteratees = [identity];
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { criteria, index: ++index, value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    module.exports = baseOrderBy;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js"(exports, module) {
    init_cjs_shims();
    var eq = require_eq(), isArrayLike = require_isArrayLike(), isIndex = require_isIndex(), isObject = require_isObject();
    function isIterateeCall(value, index, object) {
      if (!isObject(object))
        return !1;
      var type = typeof index;
      return (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) ? eq(object[index], value) : !1;
    }
    module.exports = isIterateeCall;
  }
});

// ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/sortBy.js
var require_sortBy = __commonJS({
  "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/sortBy.js"(exports, module) {
    init_cjs_shims();
    var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall(), sortBy2 = baseRest(function(collection, iteratees) {
      if (collection == null)
        return [];
      var length = iteratees.length;
      return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    module.exports = sortBy2;
  }
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/util.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var stringReplaceAll2 = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1)
        return string;
      let substringLength = substring.length, endIndex = 0, returnValue = "";
      do
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
      while (index !== -1);
      return returnValue += string.substr(endIndex), returnValue;
    }, stringEncaseCRLFWithFirstIndex2 = (string, prefix, postfix, index) => {
      let endIndex = 0, returnValue = "";
      do {
        let gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
      } while (index !== -1);
      return returnValue += string.substr(endIndex), returnValue;
    };
    module.exports = {
      stringReplaceAll: stringReplaceAll2,
      stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
    };
  }
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/templates.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, ESCAPES5 = /* @__PURE__ */ new Map([
      ["n", `
`],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape3(c) {
      let u = c[0] === "u", bracket = c[1] === "{";
      return u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3 ? String.fromCharCode(parseInt(c.slice(1), 16)) : u && bracket ? String.fromCodePoint(parseInt(c.slice(2, -1), 16)) : ESCAPES5.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      let results = [], chunks = arguments_.trim().split(/\s*,\s*/g), matches;
      for (let chunk of chunks) {
        let number = Number(chunk);
        if (!Number.isNaN(number))
          results.push(number);
        else if (matches = chunk.match(STRING_REGEX))
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape3, character) => escape3 ? unescape3(escape3) : character));
        else
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      let results = [], matches;
      for (; (matches = STYLE_REGEX.exec(style)) !== null; ) {
        let name = matches[1];
        if (matches[2]) {
          let args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else
          results.push([name]);
      }
      return results;
    }
    function buildStyle(chalk2, styles6) {
      let enabled = {};
      for (let layer of styles6)
        for (let style of layer.styles)
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
      let current = chalk2;
      for (let [styleName, styles7] of Object.entries(enabled))
        if (Array.isArray(styles7)) {
          if (!(styleName in current))
            throw new Error(`Unknown Chalk style: ${styleName}`);
          current = styles7.length > 0 ? current[styleName](...styles7) : current[styleName];
        }
      return current;
    }
    module.exports = (chalk2, temporary) => {
      let styles6 = [], chunks = [], chunk = [];
      if (temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter)
          chunk.push(unescape3(escapeCharacter));
        else if (style) {
          let string = chunk.join("");
          chunk = [], chunks.push(styles6.length === 0 ? string : buildStyle(chalk2, styles6)(string)), styles6.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles6.length === 0)
            throw new Error("Found extraneous } in Chalk template literal");
          chunks.push(buildStyle(chalk2, styles6)(chunk.join(""))), chunk = [], styles6.pop();
        } else
          chunk.push(character);
      }), chunks.push(chunk.join("")), styles6.length > 0) {
        let errMessage = `Chalk template literal is missing ${styles6.length} closing bracket${styles6.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "../../node_modules/.pnpm/chalk@4.1.2/node_modules/chalk/source/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var ansiStyles4 = require_ansi_styles(), { stdout: stdoutColor2, stderr: stderrColor2 } = require_supports_color(), {
      stringReplaceAll: stringReplaceAll2,
      stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex2
    } = require_util2(), { isArray } = Array, levelMapping2 = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ], styles6 = /* @__PURE__ */ Object.create(null), applyOptions2 = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
        throw new Error("The `level` option should be an integer from 0 to 3");
      let colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    }, ChalkClass = class {
      constructor(options) {
        return chalkFactory2(options);
      }
    }, chalkFactory2 = (options) => {
      let chalk3 = {};
      return applyOptions2(chalk3, options), chalk3.template = (...arguments_) => chalkTag(chalk3.template, ...arguments_), Object.setPrototypeOf(chalk3, Chalk.prototype), Object.setPrototypeOf(chalk3.template, chalk3), chalk3.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      }, chalk3.template.Instance = ChalkClass, chalk3.template;
    };
    function Chalk(options) {
      return chalkFactory2(options);
    }
    for (let [styleName, style] of Object.entries(ansiStyles4))
      styles6[styleName] = {
        get() {
          let builder = createBuilder2(this, createStyler2(style.open, style.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, styleName, { value: builder }), builder;
        }
      };
    styles6.visible = {
      get() {
        let builder = createBuilder2(this, this._styler, !0);
        return Object.defineProperty(this, "visible", { value: builder }), builder;
      }
    };
    var usedModels2 = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (let model of usedModels2)
      styles6[model] = {
        get() {
          let { level } = this;
          return function(...arguments_) {
            let styler = createStyler2(ansiStyles4.color[levelMapping2[level]][model](...arguments_), ansiStyles4.color.close, this._styler);
            return createBuilder2(this, styler, this._isEmpty);
          };
        }
      };
    for (let model of usedModels2) {
      let bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles6[bgModel] = {
        get() {
          let { level } = this;
          return function(...arguments_) {
            let styler = createStyler2(ansiStyles4.bgColor[levelMapping2[level]][model](...arguments_), ansiStyles4.bgColor.close, this._styler);
            return createBuilder2(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto2 = Object.defineProperties(() => {
    }, {
      ...styles6,
      level: {
        enumerable: !0,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }), createStyler2 = (open, close, parent) => {
      let openAll, closeAll;
      return parent === void 0 ? (openAll = open, closeAll = close) : (openAll = parent.openAll + open, closeAll = close + parent.closeAll), {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    }, createBuilder2 = (self2, _styler, _isEmpty) => {
      let builder = (...arguments_) => isArray(arguments_[0]) && isArray(arguments_[0].raw) ? applyStyle2(builder, chalkTag(builder, ...arguments_)) : applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      return Object.setPrototypeOf(builder, proto2), builder._generator = self2, builder._styler = _styler, builder._isEmpty = _isEmpty, builder;
    }, applyStyle2 = (self2, string) => {
      if (self2.level <= 0 || !string)
        return self2._isEmpty ? "" : string;
      let styler = self2._styler;
      if (styler === void 0)
        return string;
      let { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1)
        for (; styler !== void 0; )
          string = stringReplaceAll2(string, styler.close, styler.open), styler = styler.parent;
      let lfIndex = string.indexOf(`
`);
      return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex2(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
    }, template, chalkTag = (chalk3, ...strings) => {
      let [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw))
        return strings.join(" ");
      let arguments_ = strings.slice(1), parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++)
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      return template === void 0 && (template = require_templates()), template(chalk3, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles6);
    var chalk2 = Chalk();
    chalk2.supportsColor = stdoutColor2;
    chalk2.stderr = Chalk({ level: stderrColor2 ? stderrColor2.level : 0 });
    chalk2.stderr.supportsColor = stderrColor2;
    module.exports = chalk2;
  }
});

// ../../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/cjs/tinycolor.js
var require_tinycolor = __commonJS({
  "../../node_modules/.pnpm/tinycolor2@1.6.0/node_modules/tinycolor2/cjs/tinycolor.js"(exports, module) {
    init_cjs_shims();
    (function(global2, factory) {
      typeof exports == "object" && typeof module < "u" ? module.exports = factory() : typeof define == "function" && define.amd ? define(factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, global2.tinycolor = factory());
    })(exports, function() {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
          return typeof obj2;
        } : function(obj2) {
          return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, _typeof(obj);
      }
      var trimLeft = /^\s+/, trimRight = /\s+$/;
      function tinycolor(color, opts) {
        if (color = color || "", opts = opts || {}, color instanceof tinycolor)
          return color;
        if (!(this instanceof tinycolor))
          return new tinycolor(color, opts);
        var rgb = inputToRGB(color);
        this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format, this._gradientType = opts.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = rgb.ok;
      }
      tinycolor.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb = this.toRgb(), RsRGB, GsRGB, BsRGB, R, G, B;
          return RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255, RsRGB <= 0.03928 ? R = RsRGB / 12.92 : R = Math.pow((RsRGB + 0.055) / 1.055, 2.4), GsRGB <= 0.03928 ? G = GsRGB / 12.92 : G = Math.pow((GsRGB + 0.055) / 1.055, 2.4), BsRGB <= 0.03928 ? B = BsRGB / 12.92 : B = Math.pow((BsRGB + 0.055) / 1.055, 2.4), 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function(value) {
          return this._a = boundAlpha(value), this._roundA = Math.round(100 * this._a) / 100, this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return {
            h: hsv.h * 360,
            s: hsv.s,
            v: hsv.v,
            a: this._a
          };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b), h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b);
          return {
            h: hsl.h * 360,
            s: hsl.s,
            l: hsl.l,
            a: this._a
          };
        },
        toHslString: function() {
          var hsl = rgbToHsl(this._r, this._g, this._b), h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
          return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return {
            r: Math.round(this._r),
            g: Math.round(this._g),
            b: Math.round(this._b),
            a: this._a
          };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return {
            r: Math.round(bound01(this._r, 255) * 100) + "%",
            g: Math.round(bound01(this._g, 255) * 100) + "%",
            b: Math.round(bound01(this._b, 255) * 100) + "%",
            a: this._a
          };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          return this._a === 0 ? "transparent" : this._a < 1 ? !1 : hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), secondHex8String = hex8String, gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format) {
          var formatSet = !!format;
          format = format || this._format;
          var formattedString = !1, hasAlpha = this._a < 1 && this._a >= 0, needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
          return needsAlphaFormat ? format === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (format === "rgb" && (formattedString = this.toRgbString()), format === "prgb" && (formattedString = this.toPercentageRgbString()), (format === "hex" || format === "hex6") && (formattedString = this.toHexString()), format === "hex3" && (formattedString = this.toHexString(!0)), format === "hex4" && (formattedString = this.toHex8String(!0)), format === "hex8" && (formattedString = this.toHex8String()), format === "name" && (formattedString = this.toName()), format === "hsl" && (formattedString = this.toHslString()), format === "hsv" && (formattedString = this.toHsvString()), formattedString || this.toHexString());
        },
        clone: function() {
          return tinycolor(this.toString());
        },
        _applyModification: function(fn, args) {
          var color = fn.apply(null, [this].concat([].slice.call(args)));
          return this._r = color._r, this._g = color._g, this._b = color._b, this.setAlpha(color._a), this;
        },
        lighten: function() {
          return this._applyModification(_lighten, arguments);
        },
        brighten: function() {
          return this._applyModification(_brighten, arguments);
        },
        darken: function() {
          return this._applyModification(_darken, arguments);
        },
        desaturate: function() {
          return this._applyModification(_desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(_saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(_greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(_spin, arguments);
        },
        _applyCombination: function(fn, args) {
          return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(_analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(_complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(_monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(_splitcomplement, arguments);
        },
        // Disabled until https://github.com/bgrins/TinyColor/issues/254
        // polyad: function (number) {
        //   return this._applyCombination(polyad, [number]);
        // },
        triad: function() {
          return this._applyCombination(polyad, [3]);
        },
        tetrad: function() {
          return this._applyCombination(polyad, [4]);
        }
      }, tinycolor.fromRatio = function(color, opts) {
        if (_typeof(color) == "object") {
          var newColor = {};
          for (var i in color)
            color.hasOwnProperty(i) && (i === "a" ? newColor[i] = color[i] : newColor[i] = convertToPercentage(color[i]));
          color = newColor;
        }
        return tinycolor(color, opts);
      };
      function inputToRGB(color) {
        var rgb = {
          r: 0,
          g: 0,
          b: 0
        }, a = 1, s = null, v = null, l = null, ok = !1, format = !1;
        return typeof color == "string" && (color = stringInputToObject(color)), _typeof(color) == "object" && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = rgbToRgb(color.r, color.g, color.b), ok = !0, format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s = convertToPercentage(color.s), v = convertToPercentage(color.v), rgb = hsvToRgb(color.h, s, v), ok = !0, format = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s = convertToPercentage(color.s), l = convertToPercentage(color.l), rgb = hslToRgb(color.h, s, l), ok = !0, format = "hsl"), color.hasOwnProperty("a") && (a = color.a)), a = boundAlpha(a), {
          ok,
          format: color.format || format,
          r: Math.min(255, Math.max(rgb.r, 0)),
          g: Math.min(255, Math.max(rgb.g, 0)),
          b: Math.min(255, Math.max(rgb.b, 0)),
          a
        };
      }
      function rgbToRgb(r, g, b) {
        return {
          r: bound01(r, 255) * 255,
          g: bound01(g, 255) * 255,
          b: bound01(b, 255) * 255
        };
      }
      function rgbToHsl(r, g, b) {
        r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
        var max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, l = (max + min) / 2;
        if (max == min)
          h = s = 0;
        else {
          var d = max - min;
          switch (s = l > 0.5 ? d / (2 - max - min) : d / (max + min), max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return {
          h,
          s,
          l
        };
      }
      function hslToRgb(h, s, l) {
        var r, g, b;
        h = bound01(h, 360), s = bound01(s, 100), l = bound01(l, 100);
        function hue2rgb(p2, q2, t) {
          return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p2 + (q2 - p2) * 6 * t : t < 1 / 2 ? q2 : t < 2 / 3 ? p2 + (q2 - p2) * (2 / 3 - t) * 6 : p2;
        }
        if (s === 0)
          r = g = b = l;
        else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
          r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3);
        }
        return {
          r: r * 255,
          g: g * 255,
          b: b * 255
        };
      }
      function rgbToHsv(r, g, b) {
        r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
        var max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, v = max, d = max - min;
        if (s = max === 0 ? 0 : d / max, max == min)
          h = 0;
        else {
          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;
            case g:
              h = (b - r) / d + 2;
              break;
            case b:
              h = (r - g) / d + 4;
              break;
          }
          h /= 6;
        }
        return {
          h,
          s,
          v
        };
      }
      function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6, s = bound01(s, 100), v = bound01(v, 100);
        var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
        return {
          r: r * 255,
          g: g * 255,
          b: b * 255
        };
      }
      function rgbToHex(r, g, b, allow3Char) {
        var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
        return allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) : hex.join("");
      }
      function rgbaToHex(r, g, b, a, allow4Char) {
        var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
        return allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0) : hex.join("");
      }
      function rgbaToArgbHex(r, g, b, a) {
        var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
        return hex.join("");
      }
      tinycolor.equals = function(color1, color2) {
        return !color1 || !color2 ? !1 : tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
      }, tinycolor.random = function() {
        return tinycolor.fromRatio({
          r: Math.random(),
          g: Math.random(),
          b: Math.random()
        });
      };
      function _desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl);
      }
      function _saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl);
      }
      function _greyscale(color) {
        return tinycolor(color).desaturate(100);
      }
      function _lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl);
      }
      function _brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor(color).toRgb();
        return rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100)))), rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100)))), rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100)))), tinycolor(rgb);
      }
      function _darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl);
      }
      function _spin(color, amount) {
        var hsl = tinycolor(color).toHsl(), hue = (hsl.h + amount) % 360;
        return hsl.h = hue < 0 ? 360 + hue : hue, tinycolor(hsl);
      }
      function _complement(color) {
        var hsl = tinycolor(color).toHsl();
        return hsl.h = (hsl.h + 180) % 360, tinycolor(hsl);
      }
      function polyad(color, number) {
        if (isNaN(number) || number <= 0)
          throw new Error("Argument to polyad must be a positive number");
        for (var hsl = tinycolor(color).toHsl(), result = [tinycolor(color)], step = 360 / number, i = 1; i < number; i++)
          result.push(tinycolor({
            h: (hsl.h + i * step) % 360,
            s: hsl.s,
            l: hsl.l
          }));
        return result;
      }
      function _splitcomplement(color) {
        var hsl = tinycolor(color).toHsl(), h = hsl.h;
        return [tinycolor(color), tinycolor({
          h: (h + 72) % 360,
          s: hsl.s,
          l: hsl.l
        }), tinycolor({
          h: (h + 216) % 360,
          s: hsl.s,
          l: hsl.l
        })];
      }
      function _analogous(color, results, slices) {
        results = results || 6, slices = slices || 30;
        var hsl = tinycolor(color).toHsl(), part = 360 / slices, ret = [tinycolor(color)];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; )
          hsl.h = (hsl.h + part) % 360, ret.push(tinycolor(hsl));
        return ret;
      }
      function _monochromatic(color, results) {
        results = results || 6;
        for (var hsv = tinycolor(color).toHsv(), h = hsv.h, s = hsv.s, v = hsv.v, ret = [], modification = 1 / results; results--; )
          ret.push(tinycolor({
            h,
            s,
            v
          })), v = (v + modification) % 1;
        return ret;
      }
      tinycolor.mix = function(color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor(color1).toRgb(), rgb2 = tinycolor(color2).toRgb(), p = amount / 100, rgba = {
          r: (rgb2.r - rgb1.r) * p + rgb1.r,
          g: (rgb2.g - rgb1.g) * p + rgb1.g,
          b: (rgb2.b - rgb1.b) * p + rgb1.b,
          a: (rgb2.a - rgb1.a) * p + rgb1.a
        };
        return tinycolor(rgba);
      }, tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1), c2 = tinycolor(color2);
        return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      }, tinycolor.isReadable = function(color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2), wcag2Parms, out;
        switch (out = !1, wcag2Parms = validateWCAG2Parms(wcag2), wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      }, tinycolor.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null, bestScore = 0, readability, includeFallbackColors, level, size;
        args = args || {}, includeFallbackColors = args.includeFallbackColors, level = args.level, size = args.size;
        for (var i = 0; i < colorList.length; i++)
          readability = tinycolor.readability(baseColor, colorList[i]), readability > bestScore && (bestScore = readability, bestColor = tinycolor(colorList[i]));
        return tinycolor.isReadable(baseColor, bestColor, {
          level,
          size
        }) || !includeFallbackColors ? bestColor : (args.includeFallbackColors = !1, tinycolor.mostReadable(baseColor, ["#fff", "#000"], args));
      };
      var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      }, hexNames = tinycolor.hexNames = flip(names);
      function flip(o) {
        var flipped = {};
        for (var i in o)
          o.hasOwnProperty(i) && (flipped[o[i]] = i);
        return flipped;
      }
      function boundAlpha(a) {
        return a = parseFloat(a), (isNaN(a) || a < 0 || a > 1) && (a = 1), a;
      }
      function bound01(n, max) {
        isOnePointZero(n) && (n = "100%");
        var processPercent = isPercentage(n);
        return n = Math.min(max, Math.max(0, parseFloat(n))), processPercent && (n = parseInt(n * max, 10) / 100), Math.abs(n - max) < 1e-6 ? 1 : n % max / parseFloat(max);
      }
      function clamp01(val) {
        return Math.min(1, Math.max(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
      }
      function isPercentage(n) {
        return typeof n == "string" && n.indexOf("%") != -1;
      }
      function pad2(c) {
        return c.length == 1 ? "0" + c : "" + c;
      }
      function convertToPercentage(n) {
        return n <= 1 && (n = n * 100 + "%"), n;
      }
      function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
      }
      function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?", CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?", CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
      }
      function stringInputToObject(color) {
        color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named = !1;
        if (names[color])
          color = names[color], named = !0;
        else if (color == "transparent")
          return {
            r: 0,
            g: 0,
            b: 0,
            a: 0,
            format: "name"
          };
        var match2;
        return (match2 = matchers.rgb.exec(color)) ? {
          r: match2[1],
          g: match2[2],
          b: match2[3]
        } : (match2 = matchers.rgba.exec(color)) ? {
          r: match2[1],
          g: match2[2],
          b: match2[3],
          a: match2[4]
        } : (match2 = matchers.hsl.exec(color)) ? {
          h: match2[1],
          s: match2[2],
          l: match2[3]
        } : (match2 = matchers.hsla.exec(color)) ? {
          h: match2[1],
          s: match2[2],
          l: match2[3],
          a: match2[4]
        } : (match2 = matchers.hsv.exec(color)) ? {
          h: match2[1],
          s: match2[2],
          v: match2[3]
        } : (match2 = matchers.hsva.exec(color)) ? {
          h: match2[1],
          s: match2[2],
          v: match2[3],
          a: match2[4]
        } : (match2 = matchers.hex8.exec(color)) ? {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          a: convertHexToDecimal(match2[4]),
          format: named ? "name" : "hex8"
        } : (match2 = matchers.hex6.exec(color)) ? {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          format: named ? "name" : "hex"
        } : (match2 = matchers.hex4.exec(color)) ? {
          r: parseIntFromHex(match2[1] + "" + match2[1]),
          g: parseIntFromHex(match2[2] + "" + match2[2]),
          b: parseIntFromHex(match2[3] + "" + match2[3]),
          a: convertHexToDecimal(match2[4] + "" + match2[4]),
          format: named ? "name" : "hex8"
        } : (match2 = matchers.hex3.exec(color)) ? {
          r: parseIntFromHex(match2[1] + "" + match2[1]),
          g: parseIntFromHex(match2[2] + "" + match2[2]),
          b: parseIntFromHex(match2[3] + "" + match2[3]),
          format: named ? "name" : "hex"
        } : !1;
      }
      function validateWCAG2Parms(parms) {
        var level, size;
        return parms = parms || {
          level: "AA",
          size: "small"
        }, level = (parms.level || "AA").toUpperCase(), size = (parms.size || "small").toLowerCase(), level !== "AA" && level !== "AAA" && (level = "AA"), size !== "small" && size !== "large" && (size = "small"), {
          level,
          size
        };
      }
      return tinycolor;
    });
  }
});

// ../../node_modules/.pnpm/tinygradient@1.1.5/node_modules/tinygradient/index.js
var require_tinygradient = __commonJS({
  "../../node_modules/.pnpm/tinygradient@1.1.5/node_modules/tinygradient/index.js"(exports, module) {
    init_cjs_shims();
    var tinycolor = require_tinycolor(), RGBA_MAX = { r: 256, g: 256, b: 256, a: 1 }, HSVA_MAX = { h: 360, s: 1, v: 1, a: 1 };
    function stepize(start, end, steps) {
      let step = {};
      for (let k in start)
        start.hasOwnProperty(k) && (step[k] = steps === 0 ? 0 : (end[k] - start[k]) / steps);
      return step;
    }
    function interpolate(step, start, i, max) {
      let color = {};
      for (let k in start)
        start.hasOwnProperty(k) && (color[k] = step[k] * i + start[k], color[k] = color[k] < 0 ? color[k] + max[k] : max[k] !== 1 ? color[k] % max[k] : color[k]);
      return color;
    }
    function interpolateRgb(stop1, stop2, steps) {
      let start = stop1.color.toRgb(), end = stop2.color.toRgb(), step = stepize(start, end, steps), gradient2 = [stop1.color];
      for (let i = 1; i < steps; i++) {
        let color = interpolate(step, start, i, RGBA_MAX);
        gradient2.push(tinycolor(color));
      }
      return gradient2;
    }
    function interpolateHsv(stop1, stop2, steps, mode) {
      let start = stop1.color.toHsv(), end = stop2.color.toHsv();
      if (start.s === 0 || end.s === 0)
        return interpolateRgb(stop1, stop2, steps);
      let trigonometric;
      if (typeof mode == "boolean")
        trigonometric = mode;
      else {
        let trigShortest = start.h < end.h && end.h - start.h < 180 || start.h > end.h && start.h - end.h > 180;
        trigonometric = mode === "long" && trigShortest || mode === "short" && !trigShortest;
      }
      let step = stepize(start, end, steps), gradient2 = [stop1.color], diff2;
      start.h <= end.h && !trigonometric || start.h >= end.h && trigonometric ? diff2 = end.h - start.h : trigonometric ? diff2 = 360 - end.h + start.h : diff2 = 360 - start.h + end.h, step.h = Math.pow(-1, trigonometric ? 1 : 0) * Math.abs(diff2) / steps;
      for (let i = 1; i < steps; i++) {
        let color = interpolate(step, start, i, HSVA_MAX);
        gradient2.push(tinycolor(color));
      }
      return gradient2;
    }
    function computeSubsteps(stops, steps) {
      let l = stops.length;
      if (steps = parseInt(steps, 10), isNaN(steps) || steps < 2)
        throw new Error("Invalid number of steps (< 2)");
      if (steps < l)
        throw new Error("Number of steps cannot be inferior to number of stops");
      let substeps = [];
      for (let i = 1; i < l; i++) {
        let step = (steps - 1) * (stops[i].pos - stops[i - 1].pos);
        substeps.push(Math.max(1, Math.round(step)));
      }
      let totalSubsteps = 1;
      for (let n = l - 1; n--; ) totalSubsteps += substeps[n];
      for (; totalSubsteps !== steps; )
        if (totalSubsteps < steps) {
          let min = Math.min.apply(null, substeps);
          substeps[substeps.indexOf(min)]++, totalSubsteps++;
        } else {
          let max = Math.max.apply(null, substeps);
          substeps[substeps.indexOf(max)]--, totalSubsteps--;
        }
      return substeps;
    }
    function computeAt(stops, pos, method, max) {
      if (pos < 0 || pos > 1)
        throw new Error("Position must be between 0 and 1");
      let start, end;
      for (let i = 0, l = stops.length; i < l - 1; i++)
        if (pos >= stops[i].pos && pos < stops[i + 1].pos) {
          start = stops[i], end = stops[i + 1];
          break;
        }
      start || (start = end = stops[stops.length - 1]);
      let step = stepize(start.color[method](), end.color[method](), (end.pos - start.pos) * 100), color = interpolate(step, start.color[method](), (pos - start.pos) * 100, max);
      return tinycolor(color);
    }
    var TinyGradient = class _TinyGradient {
      /**
       * @param {StopInput[]|ColorInput[]} stops
       * @returns {TinyGradient}
       */
      constructor(stops) {
        if (stops.length < 2)
          throw new Error("Invalid number of stops (< 2)");
        let havingPositions = stops[0].pos !== void 0, l = stops.length, p = -1, lastColorLess = !1;
        this.stops = stops.map((stop, i) => {
          let hasPosition = stop.pos !== void 0;
          if (havingPositions ^ hasPosition)
            throw new Error("Cannot mix positionned and not posionned color stops");
          if (hasPosition) {
            let hasColor = stop.color !== void 0;
            if (!hasColor && (lastColorLess || i === 0 || i === l - 1))
              throw new Error("Cannot define two consecutive position-only stops");
            if (lastColorLess = !hasColor, stop = {
              color: hasColor ? tinycolor(stop.color) : null,
              colorLess: !hasColor,
              pos: stop.pos
            }, stop.pos < 0 || stop.pos > 1)
              throw new Error("Color stops positions must be between 0 and 1");
            if (stop.pos < p)
              throw new Error("Color stops positions are not ordered");
            p = stop.pos;
          } else
            stop = {
              color: tinycolor(stop.color !== void 0 ? stop.color : stop),
              pos: i / (l - 1)
            };
          return stop;
        }), this.stops[0].pos !== 0 && (this.stops.unshift({
          color: this.stops[0].color,
          pos: 0
        }), l++), this.stops[l - 1].pos !== 1 && this.stops.push({
          color: this.stops[l - 1].color,
          pos: 1
        });
      }
      /**
       * Return new instance with reversed stops
       * @return {TinyGradient}
       */
      reverse() {
        let stops = [];
        return this.stops.forEach(function(stop) {
          stops.push({
            color: stop.color,
            pos: 1 - stop.pos
          });
        }), new _TinyGradient(stops.reverse());
      }
      /**
       * Return new instance with looped stops
       * @return {TinyGradient}
       */
      loop() {
        let stops1 = [], stops2 = [];
        return this.stops.forEach((stop) => {
          stops1.push({
            color: stop.color,
            pos: stop.pos / 2
          });
        }), this.stops.slice(0, -1).forEach((stop) => {
          stops2.push({
            color: stop.color,
            pos: 1 - stop.pos / 2
          });
        }), new _TinyGradient(stops1.concat(stops2.reverse()));
      }
      /**
       * Generate gradient with RGBa interpolation
       * @param {number} steps
       * @return {tinycolor[]}
       */
      rgb(steps) {
        let substeps = computeSubsteps(this.stops, steps), gradient2 = [];
        this.stops.forEach((stop, i) => {
          stop.colorLess && (stop.color = interpolateRgb(this.stops[i - 1], this.stops[i + 1], 2)[1]);
        });
        for (let i = 0, l = this.stops.length; i < l - 1; i++) {
          let rgb = interpolateRgb(this.stops[i], this.stops[i + 1], substeps[i]);
          gradient2.splice(gradient2.length, 0, ...rgb);
        }
        return gradient2.push(this.stops[this.stops.length - 1].color), gradient2;
      }
      /**
       * Generate gradient with HSVa interpolation
       * @param {number} steps
       * @param {boolean|'long'|'short'} [mode=false]
       *    - false to step in clockwise
       *    - true to step in trigonometric order
       *    - 'short' to use the shortest way
       *    - 'long' to use the longest way
       * @return {tinycolor[]}
       */
      hsv(steps, mode) {
        let substeps = computeSubsteps(this.stops, steps), gradient2 = [];
        this.stops.forEach((stop, i) => {
          stop.colorLess && (stop.color = interpolateHsv(this.stops[i - 1], this.stops[i + 1], 2, mode)[1]);
        });
        for (let i = 0, l = this.stops.length; i < l - 1; i++) {
          let hsv = interpolateHsv(this.stops[i], this.stops[i + 1], substeps[i], mode);
          gradient2.splice(gradient2.length, 0, ...hsv);
        }
        return gradient2.push(this.stops[this.stops.length - 1].color), gradient2;
      }
      /**
       * Generate CSS3 command (no prefix) for this gradient
       * @param {String} [mode=linear] - 'linear' or 'radial'
       * @param {String} [direction] - default is 'to right' or 'ellipse at center'
       * @return {String}
       */
      css(mode, direction) {
        mode = mode || "linear", direction = direction || (mode === "linear" ? "to right" : "ellipse at center");
        let css = mode + "-gradient(" + direction;
        return this.stops.forEach(function(stop) {
          css += ", " + (stop.colorLess ? "" : stop.color.toRgbString() + " ") + stop.pos * 100 + "%";
        }), css += ")", css;
      }
      /**
       * Returns the color at specific position with RGBa interpolation
       * @param {number} pos, between 0 and 1
       * @return {tinycolor}
       */
      rgbAt(pos) {
        return computeAt(this.stops, pos, "toRgb", RGBA_MAX);
      }
      /**
       * Returns the color at specific position with HSVa interpolation
       * @param {number} pos, between 0 and 1
       * @return {tinycolor}
       */
      hsvAt(pos) {
        return computeAt(this.stops, pos, "toHsv", HSVA_MAX);
      }
    };
    module.exports = function(stops) {
      if (arguments.length === 1) {
        if (!Array.isArray(arguments[0]))
          throw new Error('"stops" is not an array');
        stops = arguments[0];
      } else
        stops = Array.prototype.slice.call(arguments);
      return new TinyGradient(stops);
    };
  }
});

// ../../node_modules/.pnpm/gradient-string@2.0.2/node_modules/gradient-string/index.js
var require_gradient_string = __commonJS({
  "../../node_modules/.pnpm/gradient-string@2.0.2/node_modules/gradient-string/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var chalk2 = require_source(), tinygradient = require_tinygradient(), forbiddenChars = /\s/g;
    function InitGradient(...args) {
      let grad = tinygradient.apply(this, args), ret = (str, opts) => applyGradient(str ? str.toString() : "", grad, opts);
      return ret.multiline = (str, opts) => multilineGradient(str ? str.toString() : "", grad, opts), ret;
    }
    var getColors = (gradient2, options, count) => options.interpolation.toLowerCase() === "hsv" ? gradient2.hsv(count, options.hsvSpin.toLowerCase()) : gradient2.rgb(count);
    function applyGradient(str, gradient2, opts) {
      let options = validateOptions(opts), colorsCount = Math.max(str.replace(forbiddenChars, "").length, gradient2.stops.length), colors = getColors(gradient2, options, colorsCount), result = "";
      for (let s of str)
        result += s.match(forbiddenChars) ? s : chalk2.hex(colors.shift().toHex())(s);
      return result;
    }
    function multilineGradient(str, gradient2, opts) {
      let options = validateOptions(opts), lines = str.split(`
`), maxLength = Math.max.apply(null, lines.map((l) => l.length).concat([gradient2.stops.length])), colors = getColors(gradient2, options, maxLength), results = [];
      for (let line of lines) {
        let lineColors = colors.slice(0), lineResult = "";
        for (let l of line)
          lineResult += chalk2.hex(lineColors.shift().toHex())(l);
        results.push(lineResult);
      }
      return results.join(`
`);
    }
    function validateOptions(opts) {
      let options = { interpolation: "rgb", hsvSpin: "short", ...opts };
      if (opts !== void 0 && typeof opts != "object")
        throw new TypeError(`Expected \`options\` to be an \`object\`, got \`${typeof opts}\``);
      if (typeof options.interpolation != "string")
        throw new TypeError(`Expected \`options.interpolation\` to be a \`string\`, got \`${typeof options.interpolation}\``);
      if (options.interpolation.toLowerCase() === "hsv" && typeof options.hsvSpin != "string")
        throw new TypeError(`Expected \`options.hsvSpin\` to be a \`string\`, got \`${typeof options.hsvSpin}\``);
      return options;
    }
    var aliases2 = {
      atlas: { colors: ["#feac5e", "#c779d0", "#4bc0c8"], options: {} },
      cristal: { colors: ["#bdfff3", "#4ac29a"], options: {} },
      teen: { colors: ["#77a1d3", "#79cbca", "#e684ae"], options: {} },
      mind: { colors: ["#473b7b", "#3584a7", "#30d2be"], options: {} },
      morning: { colors: ["#ff5f6d", "#ffc371"], options: { interpolation: "hsv" } },
      vice: { colors: ["#5ee7df", "#b490ca"], options: { interpolation: "hsv" } },
      passion: { colors: ["#f43b47", "#453a94"], options: {} },
      fruit: { colors: ["#ff4e50", "#f9d423"], options: {} },
      instagram: { colors: ["#833ab4", "#fd1d1d", "#fcb045"], options: {} },
      retro: { colors: ["#3f51b1", "#5a55ae", "#7b5fac", "#8f6aae", "#a86aa4", "#cc6b8e", "#f18271", "#f3a469", "#f7c978"], options: {} },
      summer: { colors: ["#fdbb2d", "#22c1c3"], options: {} },
      rainbow: { colors: ["#ff0000", "#ff0100"], options: { interpolation: "hsv", hsvSpin: "long" } },
      pastel: { colors: ["#74ebd5", "#74ecd5"], options: { interpolation: "hsv", hsvSpin: "long" } }
    };
    module.exports = InitGradient;
    for (let a in aliases2)
      module.exports[a] = (str) => new InitGradient(aliases2[a].colors)(str, aliases2[a].options), module.exports[a].multiline = (str) => new InitGradient(aliases2[a].colors).multiline(str, aliases2[a].options);
  }
});

// ../cli-kit/dist/public/node/ui.js
init_cjs_shims();

// ../cli-kit/dist/public/node/error.js
init_cjs_shims();

// ../cli-kit/dist/public/node/output.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/local.js
init_cjs_shims();

// ../cli-kit/dist/public/node/context/utilities.js
init_cjs_shims();
function isTruthy(variable) {
  return variable ? ["1", "true", "TRUE", "yes", "YES"].includes(variable) : !1;
}

// ../cli-kit/dist/private/node/context/utilities.js
init_cjs_shims();
function isSet(variable) {
  return !(variable === void 0 || variable.trim() === "");
}
function getCIMetadata(envName, envs) {
  switch (envName) {
    case "bitbucket":
      return {
        branch: envs.BITBUCKET_BRANCH,
        build: envs.BITBUCKET_BUILD_NUMBER,
        commitSha: envs.BITBUCKET_COMMIT,
        run: envs.BITBUCKET_BUILD_NUMBER,
        url: `https://bitbucket.org/${envs.BITBUCKET_WORKSPACE}/${envs.BITBUCKET_REPO_SLUG}/pipelines/results/${envs.BITBUCKET_BUILD_NUMBER}`
      };
    case "circleci":
      return {
        actor: envs.CIRCLE_USERNAME,
        branch: envs.CIRCLE_BRANCH,
        build: envs.CIRCLE_BUILD_NUM,
        commitSha: envs.CIRCLE_SHA1,
        run: envs.CIRCLE_WORKFLOW_ID,
        url: envs.CIRCLE_BUILD_URL
      };
    case "github":
      return {
        actor: envs.GITHUB_ACTOR,
        attempt: envs.GITHUB_RUN_ATTEMPT,
        branch: envs.GITHUB_REF_NAME,
        build: envs.GITHUB_RUN_ID,
        commitSha: envs.GITHUB_SHA,
        run: envs.GITHUB_RUN_ID,
        runNumber: envs.GITHUB_RUN_NUMBER,
        url: `${envs.GITHUB_SERVER_URL}/${envs.GITHUB_REPOSITORY}/actions/runs/${envs.GITHUB_RUN_ID}`
      };
    case "gitlab":
      return {
        actor: envs.GITLAB_USER_LOGIN,
        branch: envs.CI_COMMIT_REF_NAME,
        build: envs.CI_PIPELINE_ID,
        commitSha: envs.CI_COMMIT_SHA,
        commitMessage: envs.CI_COMMIT_MESSAGE,
        run: envs.CI_RUNNER_ID,
        url: envs.CI_PIPELINE_URL
      };
    case "buildkite":
      return {
        branch: envs.BUILDKITE_BRANCH,
        build: envs.BUILDKITE_BUILD_NUMBER,
        commitSha: envs.BUILDKITE_COMMIT,
        commitMessage: envs.BUILDKITE_MESSAGE,
        run: envs.BUILDKITE_BUILD_NUMBER,
        url: envs.BUILDKITE_BUILD_URL
      };
    default:
      return {};
  }
}

// ../cli-kit/dist/private/node/constants.js
init_cjs_shims();

// ../../node_modules/.pnpm/env-paths@3.0.0/node_modules/env-paths/index.js
init_cjs_shims();
import path from "node:path";
import os from "node:os";
import process2 from "node:process";
var homedir = os.homedir(), tmpdir = os.tmpdir(), { env } = process2, macos = (name) => {
  let library = path.join(homedir, "Library");
  return {
    data: path.join(library, "Application Support", name),
    config: path.join(library, "Preferences", name),
    cache: path.join(library, "Caches", name),
    log: path.join(library, "Logs", name),
    temp: path.join(tmpdir, name)
  };
}, windows = (name) => {
  let appData = env.APPDATA || path.join(homedir, "AppData", "Roaming"), localAppData = env.LOCALAPPDATA || path.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path.join(localAppData, name, "Data"),
    config: path.join(appData, name, "Config"),
    cache: path.join(localAppData, name, "Cache"),
    log: path.join(localAppData, name, "Log"),
    temp: path.join(tmpdir, name)
  };
}, linux = (name) => {
  let username2 = path.basename(homedir);
  return {
    data: path.join(env.XDG_DATA_HOME || path.join(homedir, ".local", "share"), name),
    config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, ".config"), name),
    cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, ".cache"), name),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path.join(env.XDG_STATE_HOME || path.join(homedir, ".local", "state"), name),
    temp: path.join(tmpdir, username2, name)
  };
};
function envPaths(name, { suffix = "nodejs" } = {}) {
  if (typeof name != "string")
    throw new TypeError(`Expected a string, got ${typeof name}`);
  return suffix && (name += `-${suffix}`), process2.platform === "darwin" ? macos(name) : process2.platform === "win32" ? windows(name) : linux(name);
}

// ../cli-kit/dist/private/node/constants.js
var identifier = "shopify-cli", cacheFolder = () => process.env.XDG_CACHE_HOME ? process.env.XDG_CACHE_HOME : envPaths(identifier).cache;
var environmentVariables = {
  alwaysLogAnalytics: "SHOPIFY_CLI_ALWAYS_LOG_ANALYTICS",
  alwaysLogMetrics: "SHOPIFY_CLI_ALWAYS_LOG_METRICS",
  deviceAuth: "SHOPIFY_CLI_DEVICE_AUTH",
  enableCliRedirect: "SHOPIFY_CLI_ENABLE_CLI_REDIRECT",
  env: "SHOPIFY_CLI_ENV",
  firstPartyDev: "SHOPIFY_CLI_1P_DEV",
  noAnalytics: "SHOPIFY_CLI_NO_ANALYTICS",
  partnersToken: "SHOPIFY_CLI_PARTNERS_TOKEN",
  runAsUser: "SHOPIFY_RUN_AS_USER",
  serviceEnv: "SHOPIFY_SERVICE_ENV",
  skipCliRedirect: "SHOPIFY_CLI_SKIP_CLI_REDIRECT",
  spinInstance: "SPIN_INSTANCE",
  themeToken: "SHOPIFY_CLI_THEME_TOKEN",
  unitTest: "SHOPIFY_UNIT_TEST",
  verbose: "SHOPIFY_FLAG_VERBOSE",
  // Variables to detect if the CLI is running in a cloud environment
  codespaces: "CODESPACES",
  codespaceName: "CODESPACE_NAME",
  codespacePortForwardingDomain: "GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN",
  gitpod: "GITPOD_WORKSPACE_URL",
  cloudShell: "CLOUD_SHELL",
  spinAppPort: "SERVER_PORT",
  spinAppHost: "SPIN_APP_HOST",
  organization: "SHOPIFY_CLI_ORGANIZATION",
  identityToken: "SHOPIFY_CLI_IDENTITY_TOKEN",
  refreshToken: "SHOPIFY_CLI_REFRESH_TOKEN",
  otelURL: "SHOPIFY_CLI_OTEL_EXPORTER_OTLP_ENDPOINT",
  themeKitAccessDomain: "SHOPIFY_CLI_THEME_KIT_ACCESS_DOMAIN",
  json: "SHOPIFY_FLAG_JSON",
  neverUsePartnersApi: "SHOPIFY_CLI_NEVER_USE_PARTNERS_API",
  skipNetworkLevelRetry: "SHOPIFY_CLI_SKIP_NETWORK_LEVEL_RETRY",
  maxRequestTimeForNetworkCalls: "SHOPIFY_CLI_MAX_REQUEST_TIME_FOR_NETWORK_CALLS"
}, defaultThemeKitAccessDomain = "theme-kit-access.shopifyapps.com", systemEnvironmentVariables = {
  backendPort: "BACKEND_PORT"
}, pathConstants = {
  executables: {
    dev: "/opt/dev/bin/dev"
  },
  directories: {
    cache: {
      path: () => cacheFolder(),
      vendor: {
        path: () => joinPath(cacheFolder(), "vendor"),
        binaries: () => joinPath(cacheFolder(), "vendor", "binaries")
      }
    }
  }
}, sessionConstants = {
  expirationTimeMarginInMinutes: 4
}, bugsnagApiKey = "9e1e6889176fd0c795d5c659225e0fae", reportingRateLimit = { limit: 300, timeout: { days: 1 } }, themeKitAccessDomain = process.env[environmentVariables.themeKitAccessDomain] ?? defaultThemeKitAccessDomain;

// ../cli-kit/dist/public/node/fs.js
init_cjs_shims();

// ../cli-kit/dist/public/common/string.js
init_cjs_shims();

// ../cli-kit/dist/public/common/array.js
init_cjs_shims();
var import_uniqBy = __toESM(require_uniqBy(), 1), import_difference = __toESM(require_difference(), 1);
function takeRandomFromArray(array) {
  return array[Math.floor(Math.random() * array.length)];
}
function getArrayRejectingUndefined(array) {
  return array.filter((item) => item !== void 0);
}
function getArrayContainsDuplicates(array) {
  return array.length !== new Set(array).size;
}
function uniq(array) {
  return Array.from(new Set(array));
}
function uniqBy(array, iteratee) {
  return (0, import_uniqBy.default)(array, iteratee);
}
function difference(array, ...values) {
  return (0, import_difference.default)(array, ...values);
}
function asHumanFriendlyArray(items) {
  return items.length < 2 ? items : items.reduce((acc, item, index) => (index === items.length - 1 ? acc.push("and") : index !== 0 && acc.push(", "), acc.push(item), acc), []);
}

// ../cli-kit/dist/public/common/string.js
var import_change_case = __toESM(require_dist15(), 1), SAFE_RANDOM_BUSINESS_ADJECTIVES = [
  "commercial",
  "profitable",
  "amortizable",
  "branded",
  "integrated",
  "synergistic",
  "consolidated",
  "diversified",
  "lean",
  "niche",
  "premium",
  "luxury",
  "scalable",
  "optimized",
  "empowered",
  "international",
  "beneficial",
  "fruitful",
  "extensive",
  "lucrative",
  "modern",
  "stable",
  "strategic",
  "adaptive",
  "efficient",
  "growing",
  "sustainable",
  "innovative",
  "regional",
  "specialized",
  "focused",
  "pragmatic",
  "ethical",
  "flexible",
  "competitive"
], SAFE_RANDOM_CREATIVE_ADJECTIVES = [
  "bright",
  "impactful",
  "stylish",
  "colorful",
  "modern",
  "minimal",
  "trendy",
  "creative",
  "artistic",
  "spectacular",
  "glamorous",
  "luxury",
  "retro",
  "nostalgic",
  "comfy",
  "polished",
  "fabulous",
  "balanced",
  "monochrome",
  "glitched",
  "contrasted",
  "elegant",
  "textured",
  "vibrant",
  "harmonious",
  "versatile",
  "eclectic",
  "futuristic",
  "idealistic",
  "intricate",
  "bohemian",
  "abstract",
  "meticulous",
  "refined",
  "flamboyant"
], SAFE_RANDOM_BUSINESS_NOUNS = [
  "account",
  "consumer",
  "customer",
  "enterprise",
  "business",
  "venture",
  "marketplace",
  "revenue",
  "vertical",
  "portfolio",
  "negotiation",
  "shipping",
  "demand",
  "supply",
  "growth",
  "merchant",
  "investment",
  "shareholder",
  "conversion",
  "capital",
  "projection",
  "upside",
  "trade",
  "deal",
  "merchandise",
  "transaction",
  "sale",
  "franchise",
  "subsidiary",
  "logistics",
  "sponsorship",
  "partnership",
  "tax",
  "policy",
  "outsource",
  "equity",
  "strategy",
  "valuation",
  "benchmark",
  "metrics",
  "duplication"
], SAFE_RANDOM_CREATIVE_NOUNS = [
  "vibe",
  "style",
  "moment",
  "mood",
  "flavor",
  "look",
  "appearance",
  "perspective",
  "aspect",
  "ambience",
  "quality",
  "backdrop",
  "focus",
  "tone",
  "inspiration",
  "imagery",
  "aesthetics",
  "palette",
  "ornamentation",
  "contrast",
  "colorway",
  "visuals",
  "typography",
  "composition",
  "scale",
  "symmetry",
  "gradients",
  "proportions",
  "textures",
  "harmony",
  "shapes",
  "patterns"
];
function getRandomName(family = "business") {
  let mapping = {
    business: {
      adjectives: SAFE_RANDOM_BUSINESS_ADJECTIVES,
      nouns: SAFE_RANDOM_BUSINESS_NOUNS
    },
    creative: {
      adjectives: SAFE_RANDOM_CREATIVE_ADJECTIVES,
      nouns: SAFE_RANDOM_CREATIVE_NOUNS
    }
  };
  return `${takeRandomFromArray(mapping[family].adjectives)}-${takeRandomFromArray(mapping[family].nouns)}`;
}
function capitalize(str) {
  return str.substring(0, 1).toUpperCase() + str.substring(1);
}
function pluralize(items, plural, singular, none) {
  return items.length === 1 ? singular(items[0]) : items.length > 1 ? plural(items) : none ? none() : "";
}
function tryParseInt(maybeInt) {
  let asInt;
  return maybeInt !== void 0 && (asInt = parseInt(maybeInt, 10), isNaN(asInt) && (asInt = void 0)), asInt;
}
function linesToColumns(lines) {
  let widths = [];
  for (let i = 0; lines[0] && i < lines[0].length; i++) {
    let columnRows = lines.map((line) => line[i]);
    widths.push(Math.max(...columnRows.map((row) => unstyled(row).length)));
  }
  return lines.map((line) => line.map((col, index) => `${col}${" ".repeat(widths[index] - unstyled(col).length)}`).join("   ").trimEnd()).join(`
`);
}
function slugify(str) {
  return str.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function camelize(input) {
  return (0, import_change_case.camelCase)(input);
}
function hyphenate(input) {
  return (0, import_change_case.paramCase)(input);
}
function underscore(input) {
  return (0, import_change_case.snakeCase)(input);
}
function constantize(input) {
  return (0, import_change_case.constantCase)(input);
}
function formatDate(date) {
  let components = date.toISOString().split("T"), dateString = components[0] ?? date.toDateString(), timeString = components[1]?.split(".")[0] ?? date.toTimeString();
  return `${dateString} ${timeString}`;
}
function formatLocalDate(dateString) {
  let dateObj = new Date(dateString), localDate = new Date(Date.UTC(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), dateObj.getHours(), dateObj.getMinutes(), dateObj.getSeconds()));
  return formatDate(localDate);
}
function joinWithAnd(items) {
  return items.length === 0 ? "" : items.length === 1 ? `"${items[0]}"` : `${items.slice(0, -1).map((item) => `"${item}"`).join(", ")} and "${items[items.length - 1]}"`;
}
function pascalize(str) {
  return (0, import_change_case.pascalCase)(str);
}
function normalizeDelimitedString(delimitedString, delimiter2 = ",") {
  if (!delimitedString)
    return;
  let sortedItems = delimitedString.split(delimiter2).map((value) => value.trim()).filter((value) => value !== "").sort();
  return [...new Set(sortedItems)].join(delimiter2);
}

// ../../node_modules/.pnpm/fs-extra@11.1.0/node_modules/fs-extra/lib/esm.mjs
init_cjs_shims();
var import_copy = __toESM(require_copy2(), 1), import_empty = __toESM(require_empty(), 1), import_ensure = __toESM(require_ensure(), 1), import_json = __toESM(require_json(), 1), import_mkdirs = __toESM(require_mkdirs(), 1), import_move = __toESM(require_move2(), 1), import_output_file = __toESM(require_output_file(), 1), import_path_exists = __toESM(require_path_exists(), 1), import_remove = __toESM(require_remove(), 1), copy = import_copy.default.copy, copySync = import_copy.default.copySync, emptyDirSync = import_empty.default.emptyDirSync, emptydirSync = import_empty.default.emptydirSync, emptyDir = import_empty.default.emptyDir, emptydir = import_empty.default.emptydir, createFile = import_ensure.default.createFile, createFileSync = import_ensure.default.createFileSync, ensureFile = import_ensure.default.ensureFile, ensureFileSync = import_ensure.default.ensureFileSync, createLink = import_ensure.default.createLink, createLinkSync = import_ensure.default.createLinkSync, ensureLink = import_ensure.default.ensureLink, ensureLinkSync = import_ensure.default.ensureLinkSync, createSymlink = import_ensure.default.createSymlink, createSymlinkSync = import_ensure.default.createSymlinkSync, ensureSymlink = import_ensure.default.ensureSymlink, ensureSymlinkSync = import_ensure.default.ensureSymlinkSync, readJson = import_json.default.readJson, readJSON = import_json.default.readJSON, readJsonSync = import_json.default.readJsonSync, readJSONSync = import_json.default.readJSONSync, writeJson = import_json.default.writeJson, writeJSON = import_json.default.writeJSON, writeJsonSync = import_json.default.writeJsonSync, writeJSONSync = import_json.default.writeJSONSync, outputJson = import_json.default.outputJson, outputJSON = import_json.default.outputJSON, outputJsonSync = import_json.default.outputJsonSync, outputJSONSync = import_json.default.outputJSONSync, mkdirs = import_mkdirs.default.mkdirs, mkdirsSync = import_mkdirs.default.mkdirsSync, mkdirp = import_mkdirs.default.mkdirp, mkdirpSync = import_mkdirs.default.mkdirpSync, ensureDir = import_mkdirs.default.ensureDir, ensureDirSync = import_mkdirs.default.ensureDirSync, move = import_move.default.move, moveSync = import_move.default.moveSync, outputFile = import_output_file.default.outputFile, outputFileSync = import_output_file.default.outputFileSync, pathExists = import_path_exists.default.pathExists, pathExistsSync = import_path_exists.default.pathExistsSync, remove = import_remove.default.remove, removeSync = import_remove.default.removeSync, esm_default = {
  ...import_copy.default,
  ...import_empty.default,
  ...import_ensure.default,
  ...import_json.default,
  ...import_mkdirs.default,
  ...import_move.default,
  ...import_output_file.default,
  ...import_path_exists.default,
  ...import_remove.default
};

// ../../node_modules/.pnpm/tempy@3.1.0/node_modules/tempy/index.js
init_cjs_shims();
import fs2 from "node:fs";
import fsPromises from "node:fs/promises";
import path2 from "node:path";
import stream from "node:stream";
import { promisify as promisify2 } from "node:util";

// ../../node_modules/.pnpm/unique-string@3.0.0/node_modules/unique-string/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/crypto-random-string@4.0.0/node_modules/crypto-random-string/index.js
init_cjs_shims();
import { promisify } from "util";
import crypto from "crypto";
var randomBytesAsync = promisify(crypto.randomBytes), urlSafeCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~".split(""), numericCharacters = "0123456789".split(""), distinguishableCharacters = "CDEHKMPRTUWXY012458".split(""), asciiPrintableCharacters = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~".split(""), alphanumericCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), generateForCustomCharacters = (length, characters) => {
  let characterCount = characters.length, maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1, entropyLength = 2 * Math.ceil(1.1 * length), string = "", stringLength = 0;
  for (; stringLength < length; ) {
    let entropy = crypto.randomBytes(entropyLength), entropyPosition = 0;
    for (; entropyPosition < entropyLength && stringLength < length; ) {
      let entropyValue = entropy.readUInt16LE(entropyPosition);
      entropyPosition += 2, !(entropyValue > maxValidSelector) && (string += characters[entropyValue % characterCount], stringLength++);
    }
  }
  return string;
}, generateForCustomCharactersAsync = async (length, characters) => {
  let characterCount = characters.length, maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1, entropyLength = 2 * Math.ceil(1.1 * length), string = "", stringLength = 0;
  for (; stringLength < length; ) {
    let entropy = await randomBytesAsync(entropyLength), entropyPosition = 0;
    for (; entropyPosition < entropyLength && stringLength < length; ) {
      let entropyValue = entropy.readUInt16LE(entropyPosition);
      entropyPosition += 2, !(entropyValue > maxValidSelector) && (string += characters[entropyValue % characterCount], stringLength++);
    }
  }
  return string;
}, generateRandomBytes = (byteLength, type, length) => crypto.randomBytes(byteLength).toString(type).slice(0, length), generateRandomBytesAsync = async (byteLength, type, length) => (await randomBytesAsync(byteLength)).toString(type).slice(0, length), allowedTypes = /* @__PURE__ */ new Set([
  void 0,
  "hex",
  "base64",
  "url-safe",
  "numeric",
  "distinguishable",
  "ascii-printable",
  "alphanumeric"
]), createGenerator = (generateForCustomCharacters2, generateRandomBytes2) => ({ length, type, characters }) => {
  if (!(length >= 0 && Number.isFinite(length)))
    throw new TypeError("Expected a `length` to be a non-negative finite number");
  if (type !== void 0 && characters !== void 0)
    throw new TypeError("Expected either `type` or `characters`");
  if (characters !== void 0 && typeof characters != "string")
    throw new TypeError("Expected `characters` to be string");
  if (!allowedTypes.has(type))
    throw new TypeError(`Unknown type: ${type}`);
  if (type === void 0 && characters === void 0 && (type = "hex"), type === "hex" || type === void 0 && characters === void 0)
    return generateRandomBytes2(Math.ceil(length * 0.5), "hex", length);
  if (type === "base64")
    return generateRandomBytes2(Math.ceil(length * 0.75), "base64", length);
  if (type === "url-safe")
    return generateForCustomCharacters2(length, urlSafeCharacters);
  if (type === "numeric")
    return generateForCustomCharacters2(length, numericCharacters);
  if (type === "distinguishable")
    return generateForCustomCharacters2(length, distinguishableCharacters);
  if (type === "ascii-printable")
    return generateForCustomCharacters2(length, asciiPrintableCharacters);
  if (type === "alphanumeric")
    return generateForCustomCharacters2(length, alphanumericCharacters);
  if (characters.length === 0)
    throw new TypeError("Expected `characters` string length to be greater than or equal to 1");
  if (characters.length > 65536)
    throw new TypeError("Expected `characters` string length to be less or equal to 65536");
  return generateForCustomCharacters2(length, characters.split(""));
}, cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);
cryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);
var crypto_random_string_default = cryptoRandomString;

// ../../node_modules/.pnpm/unique-string@3.0.0/node_modules/unique-string/index.js
function uniqueString() {
  return crypto_random_string_default({ length: 32 });
}

// ../../node_modules/.pnpm/temp-dir@3.0.0/node_modules/temp-dir/index.js
init_cjs_shims();
import { promises as fs } from "node:fs";
import os2 from "node:os";
var temporaryDirectory = await fs.realpath(os2.tmpdir()), temp_dir_default = temporaryDirectory;

// ../../node_modules/.pnpm/is-stream@3.0.0/node_modules/is-stream/index.js
init_cjs_shims();
function isStream(stream2) {
  return stream2 !== null && typeof stream2 == "object" && typeof stream2.pipe == "function";
}
function isWritableStream(stream2) {
  return isStream(stream2) && stream2.writable !== !1 && typeof stream2._write == "function" && typeof stream2._writableState == "object";
}

// ../../node_modules/.pnpm/tempy@3.1.0/node_modules/tempy/index.js
var pipeline = promisify2(stream.pipeline), getPath = (prefix = "") => path2.join(temp_dir_default, prefix + uniqueString());
async function runTask(temporaryPath, callback) {
  try {
    return await callback(temporaryPath);
  } finally {
    await fsPromises.rm(temporaryPath, { recursive: !0, force: !0, maxRetries: 2 });
  }
}
function temporaryDirectory2({ prefix = "" } = {}) {
  let directory = getPath(prefix);
  return fs2.mkdirSync(directory), directory;
}
var temporaryDirectoryTask = async (callback, options) => runTask(temporaryDirectory2(options), callback);

// ../../node_modules/.pnpm/find-up@6.3.0/node_modules/find-up/index.js
init_cjs_shims();
import path4 from "node:path";
import { fileURLToPath as fileURLToPath2 } from "node:url";

// ../../node_modules/.pnpm/locate-path@7.2.0/node_modules/locate-path/index.js
init_cjs_shims();
import process3 from "node:process";
import path3 from "node:path";
import fs3, { promises as fsPromises2 } from "node:fs";
import { fileURLToPath } from "node:url";

// ../../node_modules/.pnpm/p-locate@6.0.0/node_modules/p-locate/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/yocto-queue@1.2.1/node_modules/yocto-queue/index.js
init_cjs_shims();
var Node = class {
  value;
  next;
  constructor(value) {
    this.value = value;
  }
}, Queue = class {
  #head;
  #tail;
  #size;
  constructor() {
    this.clear();
  }
  enqueue(value) {
    let node = new Node(value);
    this.#head ? (this.#tail.next = node, this.#tail = node) : (this.#head = node, this.#tail = node), this.#size++;
  }
  dequeue() {
    let current = this.#head;
    if (current)
      return this.#head = this.#head.next, this.#size--, current.value;
  }
  peek() {
    if (this.#head)
      return this.#head.value;
  }
  clear() {
    this.#head = void 0, this.#tail = void 0, this.#size = 0;
  }
  get size() {
    return this.#size;
  }
  *[Symbol.iterator]() {
    let current = this.#head;
    for (; current; )
      yield current.value, current = current.next;
  }
  *drain() {
    for (; this.#head; )
      yield this.dequeue();
  }
};

// ../../node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js
function pLimit(concurrency) {
  if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0))
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  let queue = new Queue(), activeCount = 0, next = () => {
    activeCount--, queue.size > 0 && queue.dequeue()();
  }, run = async (fn, resolve, args) => {
    activeCount++;
    let result = (async () => fn(...args))();
    resolve(result);
    try {
      await result;
    } catch {
    }
    next();
  }, enqueue = (fn, resolve, args) => {
    queue.enqueue(run.bind(void 0, fn, resolve, args)), (async () => (await Promise.resolve(), activeCount < concurrency && queue.size > 0 && queue.dequeue()()))();
  }, generator = (fn, ...args) => new Promise((resolve) => {
    enqueue(fn, resolve, args);
  });
  return Object.defineProperties(generator, {
    activeCount: {
      get: () => activeCount
    },
    pendingCount: {
      get: () => queue.size
    },
    clearQueue: {
      value: () => {
        queue.clear();
      }
    }
  }), generator;
}

// ../../node_modules/.pnpm/p-locate@6.0.0/node_modules/p-locate/index.js
var EndError = class extends Error {
  constructor(value) {
    super(), this.value = value;
  }
}, testElement = async (element, tester) => tester(await element), finder = async (element) => {
  let values = await Promise.all(element);
  if (values[1] === !0)
    throw new EndError(values[0]);
  return !1;
};
async function pLocate(iterable, tester, {
  concurrency = Number.POSITIVE_INFINITY,
  preserveOrder = !0
} = {}) {
  let limit = pLimit(concurrency), items = [...iterable].map((element) => [element, limit(testElement, element, tester)]), checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);
  try {
    await Promise.all(items.map((element) => checkLimit(finder, element)));
  } catch (error) {
    if (error instanceof EndError)
      return error.value;
    throw error;
  }
}

// ../../node_modules/.pnpm/locate-path@7.2.0/node_modules/locate-path/index.js
var typeMappings = {
  directory: "isDirectory",
  file: "isFile"
};
function checkType(type) {
  if (!Object.hasOwnProperty.call(typeMappings, type))
    throw new Error(`Invalid type specified: ${type}`);
}
var matchType = (type, stat) => stat[typeMappings[type]](), toPath = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;
async function locatePath(paths, {
  cwd: cwd3 = process3.cwd(),
  type = "file",
  allowSymlinks = !0,
  concurrency,
  preserveOrder
} = {}) {
  checkType(type), cwd3 = toPath(cwd3);
  let statFunction = allowSymlinks ? fsPromises2.stat : fsPromises2.lstat;
  return pLocate(paths, async (path_) => {
    try {
      let stat = await statFunction(path3.resolve(cwd3, path_));
      return matchType(type, stat);
    } catch {
      return !1;
    }
  }, { concurrency, preserveOrder });
}

// ../../node_modules/.pnpm/path-exists@5.0.0/node_modules/path-exists/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/find-up@6.3.0/node_modules/find-up/index.js
var toPath2 = (urlOrPath) => urlOrPath instanceof URL ? fileURLToPath2(urlOrPath) : urlOrPath, findUpStop = Symbol("findUpStop");
async function findUpMultiple(name, options = {}) {
  let directory = path4.resolve(toPath2(options.cwd) || ""), { root } = path4.parse(directory), stopAt = path4.resolve(directory, options.stopAt || root), limit = options.limit || Number.POSITIVE_INFINITY, paths = [name].flat(), runMatcher = async (locateOptions) => {
    if (typeof name != "function")
      return locatePath(paths, locateOptions);
    let foundPath = await name(locateOptions.cwd);
    return typeof foundPath == "string" ? locatePath([foundPath], locateOptions) : foundPath;
  }, matches = [];
  for (; ; ) {
    let foundPath = await runMatcher({ ...options, cwd: directory });
    if (foundPath === findUpStop || (foundPath && matches.push(path4.resolve(directory, foundPath)), directory === stopAt || matches.length >= limit))
      break;
    directory = path4.dirname(directory);
  }
  return matches;
}
async function findUp(name, options = {}) {
  return (await findUpMultiple(name, { ...options, limit: 1 }))[0];
}

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
init_cjs_shims();
var import_brace_expansion = __toESM(require_brace_expansion(), 1);

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/assert-valid-pattern.js
init_cjs_shims();
var assertValidPattern = (pattern) => {
  if (typeof pattern != "string")
    throw new TypeError("invalid pattern");
  if (pattern.length > 65536)
    throw new TypeError("pattern is too long");
};

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/ast.js
init_cjs_shims();

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/brace-expressions.js
init_cjs_shims();
var posixClasses = {
  "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
  "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
  "[:ascii:]": ["\\x00-\\x7f", !1],
  "[:blank:]": ["\\p{Zs}\\t", !0],
  "[:cntrl:]": ["\\p{Cc}", !0],
  "[:digit:]": ["\\p{Nd}", !0],
  "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
  "[:lower:]": ["\\p{Ll}", !0],
  "[:print:]": ["\\p{C}", !0],
  "[:punct:]": ["\\p{P}", !0],
  "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
  "[:upper:]": ["\\p{Lu}", !0],
  "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
  "[:xdigit:]": ["A-Fa-f0-9", !1]
}, braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&"), regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), rangesToString = (ranges) => ranges.join(""), parseClass = (glob2, position) => {
  let pos = position;
  if (glob2.charAt(pos) !== "[")
    throw new Error("not in a brace expression");
  let ranges = [], negs = [], i = pos + 1, sawStart = !1, uflag = !1, escaping = !1, negate = !1, endPos = pos, rangeStart = "";
  WHILE: for (; i < glob2.length; ) {
    let c = glob2.charAt(i);
    if ((c === "!" || c === "^") && i === pos + 1) {
      negate = !0, i++;
      continue;
    }
    if (c === "]" && sawStart && !escaping) {
      endPos = i + 1;
      break;
    }
    if (sawStart = !0, c === "\\" && !escaping) {
      escaping = !0, i++;
      continue;
    }
    if (c === "[" && !escaping) {
      for (let [cls, [unip, u, neg]] of Object.entries(posixClasses))
        if (glob2.startsWith(cls, i)) {
          if (rangeStart)
            return ["$.", !1, glob2.length - pos, !0];
          i += cls.length, neg ? negs.push(unip) : ranges.push(unip), uflag = uflag || u;
          continue WHILE;
        }
    }
    if (escaping = !1, rangeStart) {
      c > rangeStart ? ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c)) : c === rangeStart && ranges.push(braceEscape(c)), rangeStart = "", i++;
      continue;
    }
    if (glob2.startsWith("-]", i + 1)) {
      ranges.push(braceEscape(c + "-")), i += 2;
      continue;
    }
    if (glob2.startsWith("-", i + 1)) {
      rangeStart = c, i += 2;
      continue;
    }
    ranges.push(braceEscape(c)), i++;
  }
  if (endPos < i)
    return ["", !1, 0, !1];
  if (!ranges.length && !negs.length)
    return ["$.", !1, glob2.length - pos, !0];
  if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
    let r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
    return [regexpEscape(r), !1, endPos - pos, !1];
  }
  let sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]", snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
  return [ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs, uflag, endPos - pos, !0];
};

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/unescape.js
init_cjs_shims();
var unescape2 = (s, { windowsPathsNoEscape = !1 } = {}) => windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/ast.js
var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), isExtglobType = (c) => types.has(c), startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))", startNoDot = "(?!\\.)", addPatternStart = /* @__PURE__ */ new Set(["[", "."]), justDots = /* @__PURE__ */ new Set(["..", "."]), reSpecials = new Set("().*{}+?[]^$\\!"), regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), qmark = "[^/]", star = qmark + "*?", starNoEmpty = qmark + "+?", AST = class _AST {
  type;
  #root;
  #hasMagic;
  #uflag = !1;
  #parts = [];
  #parent;
  #parentIndex;
  #negs;
  #filledNegs = !1;
  #options;
  #toString;
  // set to true if it's an extglob with no children
  // (which really means one child of '')
  #emptyExt = !1;
  constructor(type, parent, options = {}) {
    this.type = type, type && (this.#hasMagic = !0), this.#parent = parent, this.#root = this.#parent ? this.#parent.#root : this, this.#options = this.#root === this ? options : this.#root.#options, this.#negs = this.#root === this ? [] : this.#root.#negs, type === "!" && !this.#root.#filledNegs && this.#negs.push(this), this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
  }
  get hasMagic() {
    if (this.#hasMagic !== void 0)
      return this.#hasMagic;
    for (let p of this.#parts)
      if (typeof p != "string" && (p.type || p.hasMagic))
        return this.#hasMagic = !0;
    return this.#hasMagic;
  }
  // reconstructs the pattern
  toString() {
    return this.#toString !== void 0 ? this.#toString : this.type ? this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")" : this.#toString = this.#parts.map((p) => String(p)).join("");
  }
  #fillNegs() {
    if (this !== this.#root)
      throw new Error("should only call on root");
    if (this.#filledNegs)
      return this;
    this.toString(), this.#filledNegs = !0;
    let n;
    for (; n = this.#negs.pop(); ) {
      if (n.type !== "!")
        continue;
      let p = n, pp = p.#parent;
      for (; pp; ) {
        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++)
          for (let part of n.#parts) {
            if (typeof part == "string")
              throw new Error("string part in extglob AST??");
            part.copyIn(pp.#parts[i]);
          }
        p = pp, pp = p.#parent;
      }
    }
    return this;
  }
  push(...parts) {
    for (let p of parts)
      if (p !== "") {
        if (typeof p != "string" && !(p instanceof _AST && p.#parent === this))
          throw new Error("invalid part: " + p);
        this.#parts.push(p);
      }
  }
  toJSON() {
    let ret = this.type === null ? this.#parts.slice().map((p) => typeof p == "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
    return this.isStart() && !this.type && ret.unshift([]), this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!") && ret.push({}), ret;
  }
  isStart() {
    if (this.#root === this)
      return !0;
    if (!this.#parent?.isStart())
      return !1;
    if (this.#parentIndex === 0)
      return !0;
    let p = this.#parent;
    for (let i = 0; i < this.#parentIndex; i++) {
      let pp = p.#parts[i];
      if (!(pp instanceof _AST && pp.type === "!"))
        return !1;
    }
    return !0;
  }
  isEnd() {
    if (this.#root === this || this.#parent?.type === "!")
      return !0;
    if (!this.#parent?.isEnd())
      return !1;
    if (!this.type)
      return this.#parent?.isEnd();
    let pl = this.#parent ? this.#parent.#parts.length : 0;
    return this.#parentIndex === pl - 1;
  }
  copyIn(part) {
    typeof part == "string" ? this.push(part) : this.push(part.clone(this));
  }
  clone(parent) {
    let c = new _AST(this.type, parent);
    for (let p of this.#parts)
      c.copyIn(p);
    return c;
  }
  static #parseAST(str, ast, pos, opt) {
    let escaping = !1, inBrace = !1, braceStart = -1, braceNeg = !1;
    if (ast.type === null) {
      let i2 = pos, acc2 = "";
      for (; i2 < str.length; ) {
        let c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping, acc2 += c;
          continue;
        }
        if (inBrace) {
          i2 === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i2 === braceStart + 2 && braceNeg) && (inBrace = !1), acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = !0, braceStart = i2, braceNeg = !1, acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2), acc2 = "";
          let ext2 = new _AST(c, ast);
          i2 = _AST.#parseAST(str, ext2, i2, opt), ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      return ast.push(acc2), i2;
    }
    let i = pos + 1, part = new _AST(null, ast), parts = [], acc = "";
    for (; i < str.length; ) {
      let c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping, acc += c;
        continue;
      }
      if (inBrace) {
        i === braceStart + 1 ? (c === "^" || c === "!") && (braceNeg = !0) : c === "]" && !(i === braceStart + 2 && braceNeg) && (inBrace = !1), acc += c;
        continue;
      } else if (c === "[") {
        inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc), acc = "";
        let ext2 = new _AST(c, part);
        part.push(ext2), i = _AST.#parseAST(str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc), acc = "", parts.push(part), part = new _AST(null, ast);
        continue;
      }
      if (c === ")")
        return acc === "" && ast.#parts.length === 0 && (ast.#emptyExt = !0), part.push(acc), acc = "", ast.push(...parts, part), i;
      acc += c;
    }
    return ast.type = null, ast.#hasMagic = void 0, ast.#parts = [str.substring(pos - 1)], i;
  }
  static fromGlob(pattern, options = {}) {
    let ast = new _AST(null, void 0, options);
    return _AST.#parseAST(pattern, ast, 0, options), ast;
  }
  // returns the regular expression if there's magic, or the unescaped
  // string if not.
  toMMPattern() {
    if (this !== this.#root)
      return this.#root.toMMPattern();
    let glob2 = this.toString(), [re, body, hasMagic, uflag] = this.toRegExpSource();
    if (!(hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase()))
      return body;
    let flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
    return Object.assign(new RegExp(`^${re}$`, flags), {
      _src: re,
      _glob: glob2
    });
  }
  get options() {
    return this.#options;
  }
  // returns the string match, the regexp source, whether there's magic
  // in the regexp (so a regular expression is required) and whether or
  // not the uflag is needed for the regular expression (for posix classes)
  // TODO: instead of injecting the start/end at this point, just return
  // the BODY of the regexp, along with the start/end portions suitable
  // for binding the start/end in either a joined full-path makeRe context
  // (where we bind to (^|/), or a standalone matchPart context (where
  // we bind to ^, and not /).  Otherwise slashes get duped!
  //
  // In part-matching mode, the start is:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: ^(?!\.\.?$)
  // - if dots allowed or not possible: ^
  // - if dots possible and not allowed: ^(?!\.)
  // end is:
  // - if not isEnd(): nothing
  // - else: $
  //
  // In full-path matching mode, we put the slash at the START of the
  // pattern, so start is:
  // - if first pattern: same as part-matching mode
  // - if not isStart(): nothing
  // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
  // - if dots allowed or not possible: /
  // - if dots possible and not allowed: /(?!\.)
  // end is:
  // - if last pattern, same as part-matching mode
  // - else nothing
  //
  // Always put the (?:$|/) on negated tails, though, because that has to be
  // there to bind the end of the negated pattern portion, and it's easier to
  // just stick it in now rather than try to inject it later in the middle of
  // the pattern.
  //
  // We can just always return the same end, and leave it up to the caller
  // to know whether it's going to be used joined or in parts.
  // And, if the start is adjusted slightly, can do the same there:
  // - if not isStart: nothing
  // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
  // - if dots allowed or not possible: (?:/|^)
  // - if dots possible and not allowed: (?:/|^)(?!\.)
  //
  // But it's better to have a simpler binding without a conditional, for
  // performance, so probably better to return both start options.
  //
  // Then the caller just ignores the end if it's not the first pattern,
  // and the start always gets applied.
  //
  // But that's always going to be $ if it's the ending pattern, or nothing,
  // so the caller can just attach $ at the end of the pattern when building.
  //
  // So the todo is:
  // - better detect what kind of start is needed
  // - return both flavors of starting pattern
  // - attach $ at the end of the pattern when creating the actual RegExp
  //
  // Ah, but wait, no, that all only applies to the root when the first pattern
  // is not an extglob. If the first pattern IS an extglob, then we need all
  // that dot prevention biz to live in the extglob portions, because eg
  // +(*|.x*) can match .xy but not .yx.
  //
  // So, return the two flavors if it's #root and the first child is not an
  // AST, otherwise leave it to the child AST to handle it, and there,
  // use the (?:^|/) style of start binding.
  //
  // Even simplified further:
  // - Since the start for a join is eg /(?!\.) and the start for a part
  // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
  // or start or whatever) and prepend ^ or / at the Regexp construction.
  toRegExpSource(allowDot) {
    let dot = allowDot ?? !!this.#options.dot;
    if (this.#root === this && this.#fillNegs(), !this.type) {
      let noEmpty = this.isStart() && this.isEnd(), src = this.#parts.map((p) => {
        let [re, _2, hasMagic, uflag] = typeof p == "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
        return this.#hasMagic = this.#hasMagic || hasMagic, this.#uflag = this.#uflag || uflag, re;
      }).join(""), start2 = "";
      if (this.isStart() && typeof this.#parts[0] == "string" && !(this.#parts.length === 1 && justDots.has(this.#parts[0]))) {
        let aps = addPatternStart, needNoTrav = (
          // dots are allowed, and the pattern starts with [ or .
          dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
          src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
          src.startsWith("\\.\\.") && aps.has(src.charAt(4))
        ), needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
        start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
      }
      let end = "";
      return this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!" && (end = "(?:$|\\/)"), [
        start2 + src + end,
        unescape2(src),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    let repeated = this.type === "*" || this.type === "+", start = this.type === "!" ? "(?:(?!(?:" : "(?:", body = this.#partsToRegExp(dot);
    if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
      let s = this.toString();
      return this.#parts = [s], this.type = null, this.#hasMagic = void 0, [s, unescape2(this.toString()), !1, !1];
    }
    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(!0);
    bodyDotAllowed === body && (bodyDotAllowed = ""), bodyDotAllowed && (body = `(?:${body})(?:${bodyDotAllowed})*?`);
    let final = "";
    if (this.type === "!" && this.#emptyExt)
      final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
    else {
      let close = this.type === "!" ? (
        // !() must match something,but !(x) can match ''
        "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
      ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
      final = start + body + close;
    }
    return [
      final,
      unescape2(body),
      this.#hasMagic = !!this.#hasMagic,
      this.#uflag
    ];
  }
  #partsToRegExp(dot) {
    return this.#parts.map((p) => {
      if (typeof p == "string")
        throw new Error("string type in extglob ast??");
      let [re, _2, _hasMagic, uflag] = p.toRegExpSource(dot);
      return this.#uflag = this.#uflag || uflag, re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  }
  static #parseGlob(glob2, hasMagic, noEmpty = !1) {
    let escaping = !1, re = "", uflag = !1;
    for (let i = 0; i < glob2.length; i++) {
      let c = glob2.charAt(i);
      if (escaping) {
        escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        i === glob2.length - 1 ? re += "\\\\" : escaping = !0;
        continue;
      }
      if (c === "[") {
        let [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic = hasMagic || magic;
          continue;
        }
      }
      if (c === "*") {
        noEmpty && glob2 === "*" ? re += starNoEmpty : re += star, hasMagic = !0;
        continue;
      }
      if (c === "?") {
        re += qmark, hasMagic = !0;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape2(glob2), !!hasMagic, uflag];
  }
};

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/escape.js
init_cjs_shims();
var escape = (s, { windowsPathsNoEscape = !1 } = {}) => windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");

// ../../node_modules/.pnpm/minimatch@9.0.5/node_modules/minimatch/dist/esm/index.js
var minimatch = (p, pattern, options = {}) => (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#" ? !1 : new Minimatch(pattern, options).match(p)), starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/, starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2), starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2), starDotExtTestNocase = (ext2) => (ext2 = ext2.toLowerCase(), (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2)), starDotExtTestNocaseDot = (ext2) => (ext2 = ext2.toLowerCase(), (f) => f.toLowerCase().endsWith(ext2)), starDotStarRE = /^\*+\.\*+$/, starDotStarTest = (f) => !f.startsWith(".") && f.includes("."), starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes("."), dotStarRE = /^\.\*+$/, dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith("."), starRE = /^\*+$/, starTest = (f) => f.length !== 0 && !f.startsWith("."), starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..", qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/, qmarksTestNocase = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExt([$0]);
  return ext2 ? (ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2)) : noext;
}, qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExtDot([$0]);
  return ext2 ? (ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2)) : noext;
}, qmarksTestDot = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExtDot([$0]);
  return ext2 ? (f) => noext(f) && f.endsWith(ext2) : noext;
}, qmarksTest = ([$0, ext2 = ""]) => {
  let noext = qmarksTestNoExt([$0]);
  return ext2 ? (f) => noext(f) && f.endsWith(ext2) : noext;
}, qmarksTestNoExt = ([$0]) => {
  let len = $0.length;
  return (f) => f.length === len && !f.startsWith(".");
}, qmarksTestNoExtDot = ([$0]) => {
  let len = $0.length;
  return (f) => f.length === len && f !== "." && f !== "..";
}, defaultPlatform = typeof process == "object" && process ? typeof process.env == "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", path5 = {
  win32: { sep: "\\" },
  posix: { sep: "/" }
}, sep = defaultPlatform === "win32" ? path5.win32.sep : path5.posix.sep;
minimatch.sep = sep;
var GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
var qmark2 = "[^/]", star2 = qmark2 + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
minimatch.filter = filter;
var ext = (a, b = {}) => Object.assign({}, a, b), defaults = (def) => {
  if (!def || typeof def != "object" || !Object.keys(def).length)
    return minimatch;
  let orig = minimatch;
  return Object.assign((p, pattern, options = {}) => orig(p, pattern, ext(def, options)), {
    Minimatch: class extends orig.Minimatch {
      constructor(pattern, options = {}) {
        super(pattern, ext(def, options));
      }
      static defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      }
    },
    AST: class extends orig.AST {
      /* c8 ignore start */
      constructor(type, parent, options = {}) {
        super(type, parent, ext(def, options));
      }
      /* c8 ignore stop */
      static fromGlob(pattern, options = {}) {
        return orig.AST.fromGlob(pattern, ext(def, options));
      }
    },
    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
    escape: (s, options = {}) => orig.escape(s, ext(def, options)),
    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
    defaults: (options) => orig.defaults(ext(def, options)),
    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
    sep: orig.sep,
    GLOBSTAR
  });
};
minimatch.defaults = defaults;
var braceExpand = (pattern, options = {}) => (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern) ? [pattern] : (0, import_brace_expansion.default)(pattern));
minimatch.braceExpand = braceExpand;
var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
minimatch.makeRe = makeRe;
var match = (list, pattern, options = {}) => {
  let mm = new Minimatch(pattern, options);
  return list = list.filter((f) => mm.match(f)), mm.options.nonull && !list.length && list.push(pattern), list;
};
minimatch.match = match;
var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/, regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), Minimatch = class {
  options;
  set;
  pattern;
  windowsPathsNoEscape;
  nonegate;
  negate;
  comment;
  empty;
  preserveMultipleSlashes;
  partial;
  globSet;
  globParts;
  nocase;
  isWindows;
  platform;
  windowsNoMagicRoot;
  regexp;
  constructor(pattern, options = {}) {
    assertValidPattern(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, "/")), this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
  }
  hasMagic() {
    if (this.options.magicalBraces && this.set.length > 1)
      return !0;
    for (let pattern of this.set)
      for (let part of pattern)
        if (typeof part != "string")
          return !0;
    return !1;
  }
  debug(..._2) {
  }
  make() {
    let pattern = this.pattern, options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!pattern) {
      this.empty = !0;
      return;
    }
    this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options.debug && (this.debug = (...args) => console.error(...args)), this.debug(this.pattern, this.globSet);
    let rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
    this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
    let set = this.globParts.map((s, _2, __) => {
      if (this.isWindows && this.windowsNoMagicRoot) {
        let isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]), isDrive = /^[a-z]:/i.test(s[0]);
        if (isUNC)
          return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
        if (isDrive)
          return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
      }
      return s.map((ss) => this.parse(ss));
    });
    if (this.debug(this.pattern, set), this.set = set.filter((s) => s.indexOf(!1) === -1), this.isWindows)
      for (let i = 0; i < this.set.length; i++) {
        let p = this.set[i];
        p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] == "string" && /^[a-z]:$/i.test(p[3]) && (p[2] = "?");
      }
    this.debug(this.pattern, this.set);
  }
  // various transforms to equivalent pattern sets that are
  // faster to process in a filesystem walk.  The goal is to
  // eliminate what we can, and push all ** patterns as far
  // to the right as possible, even if it increases the number
  // of patterns that we have to process.
  preprocess(globParts) {
    if (this.options.noglobstar)
      for (let i = 0; i < globParts.length; i++)
        for (let j = 0; j < globParts[i].length; j++)
          globParts[i][j] === "**" && (globParts[i][j] = "*");
    let { optimizationLevel = 1 } = this.options;
    return optimizationLevel >= 2 ? (globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts)) : optimizationLevel >= 1 ? globParts = this.levelOneOptimize(globParts) : globParts = this.adjascentGlobstarOptimize(globParts), globParts;
  }
  // just get rid of adjascent ** portions
  adjascentGlobstarOptimize(globParts) {
    return globParts.map((parts) => {
      let gs = -1;
      for (; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
        let i = gs;
        for (; parts[i + 1] === "**"; )
          i++;
        i !== gs && parts.splice(gs, i - gs);
      }
      return parts;
    });
  }
  // get rid of adjascent ** and resolve .. portions
  levelOneOptimize(globParts) {
    return globParts.map((parts) => (parts = parts.reduce((set, part) => {
      let prev = set[set.length - 1];
      return part === "**" && prev === "**" ? set : part === ".." && prev && prev !== ".." && prev !== "." && prev !== "**" ? (set.pop(), set) : (set.push(part), set);
    }, []), parts.length === 0 ? [""] : parts));
  }
  levelTwoFileOptimize(parts) {
    Array.isArray(parts) || (parts = this.slashSplit(parts));
    let didSomething = !1;
    do {
      if (didSomething = !1, !this.preserveMultipleSlashes) {
        for (let i = 1; i < parts.length - 1; i++) {
          let p = parts[i];
          i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
        }
        parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
      }
      let dd = 0;
      for (; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
        let p = parts[dd - 1];
        p && p !== "." && p !== ".." && p !== "**" && (didSomething = !0, parts.splice(dd - 1, 2), dd -= 2);
      }
    } while (didSomething);
    return parts.length === 0 ? [""] : parts;
  }
  // First phase: single-pattern processing
  // <pre> is 1 or more portions
  // <rest> is 1 or more portions
  // <p> is any portion other than ., .., '', or **
  // <e> is . or ''
  //
  // **/.. is *brutal* for filesystem walking performance, because
  // it effectively resets the recursive walk each time it occurs,
  // and ** cannot be reduced out by a .. pattern part like a regexp
  // or most strings (other than .., ., and '') can be.
  //
  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
  // <pre>/<e>/<rest> -> <pre>/<rest>
  // <pre>/<p>/../<rest> -> <pre>/<rest>
  // **/**/<rest> -> **/<rest>
  //
  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
  // this WOULD be allowed if ** did follow symlinks, or * didn't
  firstPhasePreProcess(globParts) {
    let didSomething = !1;
    do {
      didSomething = !1;
      for (let parts of globParts) {
        let gs = -1;
        for (; (gs = parts.indexOf("**", gs + 1)) !== -1; ) {
          let gss = gs;
          for (; parts[gss + 1] === "**"; )
            gss++;
          gss > gs && parts.splice(gs + 1, gss - gs);
          let next = parts[gs + 1], p = parts[gs + 2], p2 = parts[gs + 3];
          if (next !== ".." || !p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..")
            continue;
          didSomething = !0, parts.splice(gs, 1);
          let other = parts.slice(0);
          other[gs] = "**", globParts.push(other), gs--;
        }
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            let p = parts[i];
            i === 1 && p === "" && parts[0] === "" || (p === "." || p === "") && (didSomething = !0, parts.splice(i, 1), i--);
          }
          parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "") && (didSomething = !0, parts.pop());
        }
        let dd = 0;
        for (; (dd = parts.indexOf("..", dd + 1)) !== -1; ) {
          let p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = !0;
            let splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
            parts.splice(dd - 1, 2, ...splin), parts.length === 0 && parts.push(""), dd -= 2;
          }
        }
      }
    } while (didSomething);
    return globParts;
  }
  // second phase: multi-pattern dedupes
  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
  //
  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
  // ^-- not valid because ** doens't follow symlinks
  secondPhasePreProcess(globParts) {
    for (let i = 0; i < globParts.length - 1; i++)
      for (let j = i + 1; j < globParts.length; j++) {
        let matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
        if (matched) {
          globParts[i] = [], globParts[j] = matched;
          break;
        }
      }
    return globParts.filter((gs) => gs.length);
  }
  partsMatch(a, b, emptyGSMatch = !1) {
    let ai = 0, bi = 0, result = [], which3 = "";
    for (; ai < a.length && bi < b.length; )
      if (a[ai] === b[bi])
        result.push(which3 === "b" ? b[bi] : a[ai]), ai++, bi++;
      else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1])
        result.push(a[ai]), ai++;
      else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1])
        result.push(b[bi]), bi++;
      else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
        if (which3 === "b")
          return !1;
        which3 = "a", result.push(a[ai]), ai++, bi++;
      } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
        if (which3 === "a")
          return !1;
        which3 = "b", result.push(b[bi]), ai++, bi++;
      } else
        return !1;
    return a.length === b.length && result;
  }
  parseNegate() {
    if (this.nonegate)
      return;
    let pattern = this.pattern, negate = !1, negateOffset = 0;
    for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++)
      negate = !negate, negateOffset++;
    negateOffset && (this.pattern = pattern.slice(negateOffset)), this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern, partial = !1) {
    let options = this.options;
    if (this.isWindows) {
      let fileDrive = typeof file[0] == "string" && /^[a-z]:$/i.test(file[0]), fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]), patternDrive = typeof pattern[0] == "string" && /^[a-z]:$/i.test(pattern[0]), patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] == "string" && /^[a-z]:$/i.test(pattern[3]), fdi = fileUNC ? 3 : fileDrive ? 0 : void 0, pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
      if (typeof fdi == "number" && typeof pdi == "number") {
        let [fd, pd] = [file[fdi], pattern[pdi]];
        fd.toLowerCase() === pd.toLowerCase() && (pattern[pdi] = fd, pdi > fdi ? pattern = pattern.slice(pdi) : fdi > pdi && (file = file.slice(fdi)));
      }
    }
    let { optimizationLevel = 1 } = this.options;
    optimizationLevel >= 2 && (file = this.levelTwoFileOptimize(file)), this.debug("matchOne", this, { file, pattern }), this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi], f = file[fi];
      if (this.debug(pattern, p, f), p === !1)
        return !1;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi, pr = pi + 1;
        if (pr === pl) {
          for (this.debug("** at the end"); fi < fl; fi++)
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return !1;
          return !0;
        }
        for (; fr < fl; ) {
          var swallowee = file[fr];
          if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
            return this.debug("globstar found match!", fr, fl, swallowee), !0;
          if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
            this.debug("dot detected!", file, fr, pattern, pr);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), fr++;
        }
        return !!(partial && (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl));
      }
      let hit;
      if (typeof p == "string" ? (hit = f === p, this.debug("string match", p, f, hit)) : (hit = p.test(f), this.debug("pattern match", p, f, hit)), !hit)
        return !1;
    }
    if (fi === fl && pi === pl)
      return !0;
    if (fi === fl)
      return partial;
    if (pi === pl)
      return fi === fl - 1 && file[fi] === "";
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern) {
    assertValidPattern(pattern);
    let options = this.options;
    if (pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    let m, fastTest = null;
    (m = pattern.match(starRE)) ? fastTest = options.dot ? starTestDot : starTest : (m = pattern.match(starDotExtRE)) ? fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]) : (m = pattern.match(qmarksRE)) ? fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m) : (m = pattern.match(starDotStarRE)) ? fastTest = options.dot ? starDotStarTestDot : starDotStarTest : (m = pattern.match(dotStarRE)) && (fastTest = dotStarTest);
    let re = AST.fromGlob(pattern, this.options).toMMPattern();
    return fastTest && typeof re == "object" && Reflect.defineProperty(re, "test", { value: fastTest }), re;
  }
  makeRe() {
    if (this.regexp || this.regexp === !1)
      return this.regexp;
    let set = this.set;
    if (!set.length)
      return this.regexp = !1, this.regexp;
    let options = this.options, twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot, flags = new Set(options.nocase ? ["i"] : []), re = set.map((pattern) => {
      let pp = pattern.map((p) => {
        if (p instanceof RegExp)
          for (let f of p.flags.split(""))
            flags.add(f);
        return typeof p == "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
      });
      return pp.forEach((p, i) => {
        let next = pp[i + 1], prev = pp[i - 1];
        p !== GLOBSTAR || prev === GLOBSTAR || (prev === void 0 ? next !== void 0 && next !== GLOBSTAR ? pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next : pp[i] = twoStar : next === void 0 ? pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?" : next !== GLOBSTAR && (pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = GLOBSTAR));
      }), pp.filter((p) => p !== GLOBSTAR).join("/");
    }).join("|"), [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
    re = "^" + open + re + close + "$", this.negate && (re = "^(?!" + re + ").+$");
    try {
      this.regexp = new RegExp(re, [...flags].join(""));
    } catch {
      this.regexp = !1;
    }
    return this.regexp;
  }
  slashSplit(p) {
    return this.preserveMultipleSlashes ? p.split("/") : this.isWindows && /^\/\/[^\/]+/.test(p) ? ["", ...p.split(/\/+/)] : p.split(/\/+/);
  }
  match(f, partial = this.partial) {
    if (this.debug("match", f, this.pattern), this.comment)
      return !1;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return !0;
    let options = this.options;
    this.isWindows && (f = f.split("\\").join("/"));
    let ff = this.slashSplit(f);
    this.debug(this.pattern, "split", ff);
    let set = this.set;
    this.debug(this.pattern, "set", set);
    let filename = ff[ff.length - 1];
    if (!filename)
      for (let i = ff.length - 2; !filename && i >= 0; i--)
        filename = ff[i];
    for (let i = 0; i < set.length; i++) {
      let pattern = set[i], file = ff;
      if (options.matchBase && pattern.length === 1 && (file = [filename]), this.matchOne(file, pattern, partial))
        return options.flipNegate ? !0 : !this.negate;
    }
    return options.flipNegate ? !1 : this.negate;
  }
  static defaults(def) {
    return minimatch.defaults(def).Minimatch;
  }
};
minimatch.AST = AST;
minimatch.Minimatch = Minimatch;
minimatch.escape = escape;
minimatch.unescape = unescape2;

// ../cli-kit/dist/public/node/fs.js
import { mkdirSync as fsMkdirSync, readFileSync as fsReadFileSync, writeFileSync as fsWriteFileSync, appendFileSync as fsAppendFileSync, statSync as fsStatSync, createReadStream as fsCreateReadStream, createWriteStream as fsCreateWriteStream, constants as fsConstants, existsSync as fsFileExistsSync, unlinkSync as fsUnlinkSync } from "fs";
import { mkdir as fsMkdir, writeFile as fsWriteFile, readFile as fsReadFile, realpath as fsRealPath, appendFile as fsAppendFile, mkdtemp as fsMkdtemp, stat as fsStat, lstat as fsLstat, chmod as fsChmod, access as fsAccess, rename as fsRename, unlink as fsUnlink, readdir as fsReaddir } from "fs/promises";
async function inTemporaryDirectory(callback) {
  return temporaryDirectoryTask(callback);
}
function tempDirectory() {
  return temporaryDirectory2();
}
async function readFile(path8, options = { encoding: "utf8" }) {
  return outputDebug(outputContent`Reading the content of file at ${outputToken.path(path8)}...`), fsReadFile(path8, options);
}
function readFileSync(path8) {
  return outputDebug(outputContent`Sync-reading the content of file at ${outputToken.path(path8)}...`), fsReadFileSync(path8);
}
async function fileRealPath(path8) {
  return fsRealPath(path8);
}
async function copyFile(from, to) {
  outputDebug(outputContent`Copying file from ${outputToken.path(from)} to ${outputToken.path(to)}...`), await copy(from, to);
}
async function touchFile(path8) {
  outputDebug(outputContent`Creating an empty file at ${outputToken.path(path8)}...`), await ensureFile(path8);
}
async function appendFile(path8, content) {
  outputDebug(outputContent`Appending the following content to ${outputToken.path(path8)}:
    ${content.split(`
`).map((line) => `  ${line}`).join(`
`)}
  `), await fsAppendFile(path8, content);
}
async function writeFile(path8, data, options = { encoding: "utf8" }) {
  outputDebug(outputContent`Writing some content to file at ${outputToken.path(path8)}...`), await fsWriteFile(path8, data, options);
}
function writeFileSync(path8, data) {
  outputDebug(outputContent`File-writing some content to file at ${outputToken.path(path8)}...`), fsWriteFileSync(path8, data);
}
async function mkdir(path8) {
  outputDebug(outputContent`Creating directory at ${outputToken.path(path8)}...`), await fsMkdir(path8, { recursive: !0 });
}
function mkdirSync(path8) {
  outputDebug(outputContent`Sync-creating directory at ${outputToken.path(path8)}...`), fsMkdirSync(path8, { recursive: !0 });
}
async function removeFile(path8) {
  outputDebug(outputContent`Removing file at ${outputToken.path(path8)}...`), await remove(path8);
}
async function renameFile(from, to) {
  outputDebug(outputContent`Renaming file from ${outputToken.path(from)} to ${outputToken.path(to)}...`), await fsRename(from, to);
}
function removeFileSync(path8) {
  outputDebug(outputContent`Sync-removing file at ${outputToken.path(path8)}...`), removeSync(path8);
}
async function rmdir(path8, options = {}) {
  let { default: del } = await import("./del-DNZ7X2HW.js");
  outputDebug(outputContent`Removing directory at ${outputToken.path(path8)}...`), await del(path8, { force: options.force });
}
async function isDirectory(path8) {
  return outputDebug(outputContent`Checking if ${outputToken.path(path8)} is a directory...`), (await fsLstat(path8)).isDirectory();
}
async function fileSize(path8) {
  return outputDebug(outputContent`Getting the size of file file at ${outputToken.path(path8)}...`), (await fsStat(path8)).size;
}
function fileSizeSync(path8) {
  return outputDebug(outputContent`Sync-getting the size of file file at ${outputToken.path(path8)}...`), fsStatSync(path8).size;
}
function unlinkFileSync(path8) {
  fsUnlinkSync(path8);
}
function unlinkFile(path8) {
  return fsUnlink(path8);
}
function createFileReadStream(path8, options) {
  return fsCreateReadStream(path8, options);
}
function createFileWriteStream(path8) {
  return fsCreateWriteStream(path8);
}
async function fileLastUpdated(path8) {
  return outputDebug(outputContent`Getting last updated timestamp for file at ${outputToken.path(path8)}...`), (await fsStat(path8)).ctime;
}
async function fileLastUpdatedTimestamp(path8) {
  try {
    return (await fileLastUpdated(path8)).getTime();
  } catch {
    return;
  }
}
async function moveFile(src, dest, options = {}) {
  await move(src, dest, options);
}
async function chmod(path8, mode) {
  await fsChmod(path8, mode);
}
async function fileHasExecutablePermissions(path8) {
  try {
    return await fsAccess(path8, fsConstants.X_OK), !0;
  } catch {
    return !1;
  }
}
async function fileExists(path8) {
  try {
    return await fsAccess(path8), !0;
  } catch {
    return !1;
  }
}
function fileExistsSync(path8) {
  return fsFileExistsSync(path8);
}
async function generateRandomNameForSubdirectory(options) {
  let generated = `${getRandomName(options.family ?? "business")}-${options.suffix}`, randomDirectoryPath = joinPath(options.directory, generated);
  return await fileExists(randomDirectoryPath) ? generateRandomNameForSubdirectory(options) : generated;
}
async function glob(pattern, options) {
  let { default: fastGlob } = await import("./out-NKJPLKLB.js"), overridenOptions = options;
  return options?.dot == null && (overridenOptions = { ...options, dot: !0 }), fastGlob(pattern, overridenOptions);
}
async function findPathUp(matcher, options) {
  let got = await findUp(matcher, options);
  return got ? normalizePath(got) : void 0;
}
function matchGlob(key, pattern, options) {
  return minimatch(key, pattern, options);
}
function readdir(path8) {
  return fsReaddir(path8);
}
async function copyDirectoryContents(srcDir, destDir) {
  if (!await fileExists(srcDir))
    throw new Error(`Source directory ${srcDir} does not exist`);
  await fileExists(destDir) || await mkdir(destDir);
  let items = await glob(joinPath(srcDir, "**/*")), filesToCopy = [];
  for (let item of items) {
    let relativePath = item.replace(srcDir, "").replace(/^[/\\]/, ""), destPath = joinPath(destDir, relativePath);
    filesToCopy.push(copyFile(item, destPath));
  }
  await Promise.all(filesToCopy);
}

// ../cli-kit/dist/public/node/system.js
init_cjs_shims();

// ../cli-kit/dist/public/node/tree-kill.js
init_cjs_shims();
import { exec, spawn } from "child_process";
function treeKill(pid = process.pid, killSignal = "SIGTERM", killRoot = !0, callback) {
  adaptedTreeKill(pid, killSignal, killRoot, callback ?? ((error) => {
    error && outputDebug(`Failed to kill process ${pid}: ${error}`);
  }));
}
function adaptedTreeKill(pid, killSignal, killRoot, callback) {
  let rootPid = typeof pid == "number" ? pid.toString() : pid;
  if (Number.isNaN(rootPid))
    if (callback) {
      callback(new Error("pid must be a number"));
      return;
    } else
      throw new Error("pid must be a number");
  let tree = {};
  tree[rootPid] = [];
  let pidsToProcess = /* @__PURE__ */ new Set();
  switch (pidsToProcess.add(rootPid), process.platform) {
    case "win32":
      exec(`taskkill /pid ${pid} /T /F`, callback);
      break;
    case "darwin":
      buildProcessTree(rootPid, tree, pidsToProcess, function(parentPid) {
        return spawn("pgrep", ["-lfP", parentPid]);
      }, function() {
        killAll(tree, killSignal, rootPid, killRoot, callback);
      });
      break;
    // Linux
    default:
      buildProcessTree(rootPid, tree, pidsToProcess, function(parentPid) {
        return spawn("ps", ["-o", "pid command", "--no-headers", "--ppid", parentPid]);
      }, function() {
        killAll(tree, killSignal, rootPid, killRoot, callback);
      });
      break;
  }
}
function killAll(tree, killSignal, rootPid, killRoot, callback) {
  let killed = /* @__PURE__ */ new Set();
  try {
    Object.keys(tree).forEach(function(pid) {
      tree[pid].forEach(function(pidpid) {
        killed.has(pidpid) || (killPid(pidpid, killSignal), killed.add(pidpid));
      }), pid === rootPid && killRoot && !killed.has(pid) && (killPid(pid, killSignal), killed.add(pid));
    });
  } catch (err) {
    if (callback) {
      callback(err);
      return;
    } else
      throw err;
  }
  callback && callback();
}
function killPid(pid, killSignal) {
  try {
    process.kill(parseInt(pid, 10), killSignal);
  } catch (err) {
    if (err.code !== "ESRCH")
      throw err;
  }
}
function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
  let ps = spawnChildProcessesList(parentPid), allData = "";
  ps.stdout?.on("data", function(data) {
    let dataStr = data.toString("ascii");
    allData += dataStr;
  });
  let onClose = (code) => {
    if (pidsToProcess.delete(parentPid), code !== 0) {
      if (pidsToProcess.size === 0) {
        cb();
        return;
      }
      return;
    }
    allData.trim().split(`
`).forEach(function(line) {
      let match2 = line.match(/^(\d+)\s(.*)$/);
      if (match2) {
        let pid = match2[1], cmd = match2[2];
        tree[parentPid].push(pid), tree[pid] = [], outputDebug(`Killing process ${pid}: ${cmd}`), pidsToProcess.add(pid), buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
      }
    });
  };
  ps.on("close", onClose);
}

// ../cli-kit/dist/public/node/os.js
init_cjs_shims();

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/index.js
init_cjs_shims();
var import_cross_spawn = __toESM(require_cross_spawn(), 1);
import { Buffer as Buffer3 } from "node:buffer";
import path7 from "node:path";
import childProcess from "node:child_process";
import process7 from "node:process";

// ../../node_modules/.pnpm/strip-final-newline@3.0.0/node_modules/strip-final-newline/index.js
init_cjs_shims();
function stripFinalNewline(input) {
  let LF = typeof input == "string" ? `
` : 10, CR = typeof input == "string" ? "\r" : 13;
  return input[input.length - 1] === LF && (input = input.slice(0, -1)), input[input.length - 1] === CR && (input = input.slice(0, -1)), input;
}

// ../../node_modules/.pnpm/npm-run-path@5.3.0/node_modules/npm-run-path/index.js
init_cjs_shims();
import process4 from "node:process";
import path6 from "node:path";
import { fileURLToPath as fileURLToPath3 } from "node:url";

// ../../node_modules/.pnpm/path-key@4.0.0/node_modules/path-key/index.js
init_cjs_shims();
function pathKey(options = {}) {
  let {
    env: env3 = process.env,
    platform: platform2 = process.platform
  } = options;
  return platform2 !== "win32" ? "PATH" : Object.keys(env3).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
}

// ../../node_modules/.pnpm/npm-run-path@5.3.0/node_modules/npm-run-path/index.js
var npmRunPath = ({
  cwd: cwd3 = process4.cwd(),
  path: pathOption = process4.env[pathKey()],
  preferLocal = !0,
  execPath = process4.execPath,
  addExecPath = !0
} = {}) => {
  let cwdString = cwd3 instanceof URL ? fileURLToPath3(cwd3) : cwd3, cwdPath = path6.resolve(cwdString), result = [];
  return preferLocal && applyPreferLocal(result, cwdPath), addExecPath && applyExecPath(result, execPath, cwdPath), [...result, pathOption].join(path6.delimiter);
}, applyPreferLocal = (result, cwdPath) => {
  let previous;
  for (; previous !== cwdPath; )
    result.push(path6.join(cwdPath, "node_modules/.bin")), previous = cwdPath, cwdPath = path6.resolve(cwdPath, "..");
}, applyExecPath = (result, execPath, cwdPath) => {
  let execPathString = execPath instanceof URL ? fileURLToPath3(execPath) : execPath;
  result.push(path6.resolve(cwdPath, execPathString, ".."));
}, npmRunPathEnv = ({ env: env3 = process4.env, ...options } = {}) => {
  env3 = { ...env3 };
  let pathName = pathKey({ env: env3 });
  return options.path = env3[pathName], env3[pathName] = npmRunPath(options), env3;
};

// ../../node_modules/.pnpm/onetime@6.0.0/node_modules/onetime/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/mimic-fn@4.0.0/node_modules/mimic-fn/index.js
init_cjs_shims();
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype" || property === "arguments" || property === "caller")
    return;
  let toDescriptor = Object.getOwnPropertyDescriptor(to, property), fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  !canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable || Object.defineProperty(to, property, fromDescriptor);
}, canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
}, changePrototype = (to, from) => {
  let fromPrototype = Object.getPrototypeOf(from);
  fromPrototype !== Object.getPrototypeOf(to) && Object.setPrototypeOf(to, fromPrototype);
}, wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`, toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString"), toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"), changeToString = (to, from, name) => {
  let withName = name === "" ? "" : `with ${name.trim()}() `, newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName), Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
};
function mimicFunction(to, from, { ignoreNonConfigurable = !1 } = {}) {
  let { name } = to;
  for (let property of Reflect.ownKeys(from))
    copyProperty(to, from, property, ignoreNonConfigurable);
  return changePrototype(to, from), changeToString(to, from, name), to;
}

// ../../node_modules/.pnpm/onetime@6.0.0/node_modules/onetime/index.js
var calledFunctions = /* @__PURE__ */ new WeakMap(), onetime = (function_, options = {}) => {
  if (typeof function_ != "function")
    throw new TypeError("Expected a function");
  let returnValue, callCount = 0, functionName = function_.displayName || function_.name || "<anonymous>", onetime3 = function(...arguments_) {
    if (calledFunctions.set(onetime3, ++callCount), callCount === 1)
      returnValue = function_.apply(this, arguments_), function_ = null;
    else if (options.throw === !0)
      throw new Error(`Function \`${functionName}\` can only be called once`);
    return returnValue;
  };
  return mimicFunction(onetime3, function_), calledFunctions.set(onetime3, callCount), onetime3;
};
onetime.callCount = (function_) => {
  if (!calledFunctions.has(function_))
    throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
  return calledFunctions.get(function_);
};
var onetime_default = onetime;

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/error.js
init_cjs_shims();
import process5 from "node:process";

// ../../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/main.js
init_cjs_shims();
import { constants as constants2 } from "node:os";

// ../../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/realtime.js
init_cjs_shims();
var getRealtimeSignals = () => {
  let length = SIGRTMAX - SIGRTMIN + 1;
  return Array.from({ length }, getRealtimeSignal);
}, getRealtimeSignal = (value, index) => ({
  name: `SIGRT${index + 1}`,
  number: SIGRTMIN + index,
  action: "terminate",
  description: "Application-specific signal (realtime)",
  standard: "posix"
}), SIGRTMIN = 34, SIGRTMAX = 64;

// ../../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/signals.js
init_cjs_shims();
import { constants } from "node:os";

// ../../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/core.js
init_cjs_shims();
var SIGNALS = [
  {
    name: "SIGHUP",
    number: 1,
    action: "terminate",
    description: "Terminal closed",
    standard: "posix"
  },
  {
    name: "SIGINT",
    number: 2,
    action: "terminate",
    description: "User interruption with CTRL-C",
    standard: "ansi"
  },
  {
    name: "SIGQUIT",
    number: 3,
    action: "core",
    description: "User interruption with CTRL-\\",
    standard: "posix"
  },
  {
    name: "SIGILL",
    number: 4,
    action: "core",
    description: "Invalid machine instruction",
    standard: "ansi"
  },
  {
    name: "SIGTRAP",
    number: 5,
    action: "core",
    description: "Debugger breakpoint",
    standard: "posix"
  },
  {
    name: "SIGABRT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "ansi"
  },
  {
    name: "SIGIOT",
    number: 6,
    action: "core",
    description: "Aborted",
    standard: "bsd"
  },
  {
    name: "SIGBUS",
    number: 7,
    action: "core",
    description: "Bus error due to misaligned, non-existing address or paging error",
    standard: "bsd"
  },
  {
    name: "SIGEMT",
    number: 7,
    action: "terminate",
    description: "Command should be emulated but is not implemented",
    standard: "other"
  },
  {
    name: "SIGFPE",
    number: 8,
    action: "core",
    description: "Floating point arithmetic error",
    standard: "ansi"
  },
  {
    name: "SIGKILL",
    number: 9,
    action: "terminate",
    description: "Forced termination",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGUSR1",
    number: 10,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGSEGV",
    number: 11,
    action: "core",
    description: "Segmentation fault",
    standard: "ansi"
  },
  {
    name: "SIGUSR2",
    number: 12,
    action: "terminate",
    description: "Application-specific signal",
    standard: "posix"
  },
  {
    name: "SIGPIPE",
    number: 13,
    action: "terminate",
    description: "Broken pipe or socket",
    standard: "posix"
  },
  {
    name: "SIGALRM",
    number: 14,
    action: "terminate",
    description: "Timeout or timer",
    standard: "posix"
  },
  {
    name: "SIGTERM",
    number: 15,
    action: "terminate",
    description: "Termination",
    standard: "ansi"
  },
  {
    name: "SIGSTKFLT",
    number: 16,
    action: "terminate",
    description: "Stack is empty or overflowed",
    standard: "other"
  },
  {
    name: "SIGCHLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "posix"
  },
  {
    name: "SIGCLD",
    number: 17,
    action: "ignore",
    description: "Child process terminated, paused or unpaused",
    standard: "other"
  },
  {
    name: "SIGCONT",
    number: 18,
    action: "unpause",
    description: "Unpaused",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGSTOP",
    number: 19,
    action: "pause",
    description: "Paused",
    standard: "posix",
    forced: !0
  },
  {
    name: "SIGTSTP",
    number: 20,
    action: "pause",
    description: 'Paused using CTRL-Z or "suspend"',
    standard: "posix"
  },
  {
    name: "SIGTTIN",
    number: 21,
    action: "pause",
    description: "Background process cannot read terminal input",
    standard: "posix"
  },
  {
    name: "SIGBREAK",
    number: 21,
    action: "terminate",
    description: "User interruption with CTRL-BREAK",
    standard: "other"
  },
  {
    name: "SIGTTOU",
    number: 22,
    action: "pause",
    description: "Background process cannot write to terminal output",
    standard: "posix"
  },
  {
    name: "SIGURG",
    number: 23,
    action: "ignore",
    description: "Socket received out-of-band data",
    standard: "bsd"
  },
  {
    name: "SIGXCPU",
    number: 24,
    action: "core",
    description: "Process timed out",
    standard: "bsd"
  },
  {
    name: "SIGXFSZ",
    number: 25,
    action: "core",
    description: "File too big",
    standard: "bsd"
  },
  {
    name: "SIGVTALRM",
    number: 26,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGPROF",
    number: 27,
    action: "terminate",
    description: "Timeout or timer",
    standard: "bsd"
  },
  {
    name: "SIGWINCH",
    number: 28,
    action: "ignore",
    description: "Terminal window size changed",
    standard: "bsd"
  },
  {
    name: "SIGIO",
    number: 29,
    action: "terminate",
    description: "I/O is available",
    standard: "other"
  },
  {
    name: "SIGPOLL",
    number: 29,
    action: "terminate",
    description: "Watched event",
    standard: "other"
  },
  {
    name: "SIGINFO",
    number: 29,
    action: "ignore",
    description: "Request for process information",
    standard: "other"
  },
  {
    name: "SIGPWR",
    number: 30,
    action: "terminate",
    description: "Device running out of power",
    standard: "systemv"
  },
  {
    name: "SIGSYS",
    number: 31,
    action: "core",
    description: "Invalid system call",
    standard: "other"
  },
  {
    name: "SIGUNUSED",
    number: 31,
    action: "terminate",
    description: "Invalid system call",
    standard: "other"
  }
];

// ../../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/signals.js
var getSignals = () => {
  let realtimeSignals = getRealtimeSignals();
  return [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
}, normalizeSignal = ({
  name,
  number: defaultNumber,
  description,
  action,
  forced = !1,
  standard
}) => {
  let {
    signals: { [name]: constantSignal }
  } = constants, supported = constantSignal !== void 0;
  return { name, number: supported ? constantSignal : defaultNumber, description, supported, action, forced, standard };
};

// ../../node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/main.js
var getSignalsByName = () => {
  let signals = getSignals();
  return Object.fromEntries(signals.map(getSignalByName));
}, getSignalByName = ({
  name,
  number,
  description,
  supported,
  action,
  forced,
  standard
}) => [name, { name, number, description, supported, action, forced, standard }], signalsByName = getSignalsByName(), getSignalsByNumber = () => {
  let signals = getSignals(), length = 65, signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
  return Object.assign({}, ...signalsA);
}, getSignalByNumber = (number, signals) => {
  let signal = findSignalByNumber(number, signals);
  if (signal === void 0)
    return {};
  let { name, description, supported, action, forced, standard } = signal;
  return {
    [number]: {
      name,
      number,
      description,
      supported,
      action,
      forced,
      standard
    }
  };
}, findSignalByNumber = (number, signals) => {
  let signal = signals.find(({ name }) => constants2.signals[name] === number);
  return signal !== void 0 ? signal : signals.find((signalA) => signalA.number === number);
}, signalsByNumber = getSignalsByNumber();

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/error.js
var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => timedOut ? `timed out after ${timeout} milliseconds` : isCanceled ? "was canceled" : errorCode !== void 0 ? `failed with ${errorCode}` : signal !== void 0 ? `was killed with ${signal} (${signalDescription})` : exitCode !== void 0 ? `failed with exit code ${exitCode}` : "failed", makeError = ({
  stdout,
  stderr,
  all,
  error,
  signal,
  exitCode,
  command,
  escapedCommand,
  timedOut,
  isCanceled,
  killed,
  parsed: { options: { timeout, cwd: cwd3 = process5.cwd() } }
}) => {
  exitCode = exitCode === null ? void 0 : exitCode, signal = signal === null ? void 0 : signal;
  let signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description, errorCode = error && error.code, execaMessage = `Command ${getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })}: ${command}`, isError = Object.prototype.toString.call(error) === "[object Error]", shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage, message = [shortMessage, stderr, stdout].filter(Boolean).join(`
`);
  return isError ? (error.originalMessage = error.message, error.message = message) : error = new Error(message), error.shortMessage = shortMessage, error.command = command, error.escapedCommand = escapedCommand, error.exitCode = exitCode, error.signal = signal, error.signalDescription = signalDescription, error.stdout = stdout, error.stderr = stderr, error.cwd = cwd3, all !== void 0 && (error.all = all), "bufferedData" in error && delete error.bufferedData, error.failed = !0, error.timedOut = !!timedOut, error.isCanceled = isCanceled, error.killed = killed && !timedOut, error;
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/stdio.js
init_cjs_shims();
var aliases = ["stdin", "stdout", "stderr"], hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0), normalizeStdio = (options) => {
  if (!options)
    return;
  let { stdio } = options;
  if (stdio === void 0)
    return aliases.map((alias) => options[alias]);
  if (hasAlias(options))
    throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
  if (typeof stdio == "string")
    return stdio;
  if (!Array.isArray(stdio))
    throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
  let length = Math.max(stdio.length, aliases.length);
  return Array.from({ length }, (value, index) => stdio[index]);
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/kill.js
init_cjs_shims();
var import_signal_exit = __toESM(require_signal_exit(), 1);
import os3 from "node:os";
var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5, spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
  let killResult = kill(signal);
  return setKillTimeout(kill, signal, options, killResult), killResult;
}, setKillTimeout = (kill, signal, options, killResult) => {
  if (!shouldForceKill(signal, options, killResult))
    return;
  let timeout = getForceKillAfterTimeout(options), t = setTimeout(() => {
    kill("SIGKILL");
  }, timeout);
  t.unref && t.unref();
}, shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== !1 && killResult, isSigterm = (signal) => signal === os3.constants.signals.SIGTERM || typeof signal == "string" && signal.toUpperCase() === "SIGTERM", getForceKillAfterTimeout = ({ forceKillAfterTimeout = !0 }) => {
  if (forceKillAfterTimeout === !0)
    return DEFAULT_FORCE_KILL_TIMEOUT;
  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0)
    throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
  return forceKillAfterTimeout;
}, spawnedCancel = (spawned, context) => {
  spawned.kill() && (context.isCanceled = !0);
}, timeoutKill = (spawned, signal, reject) => {
  spawned.kill(signal), reject(Object.assign(new Error("Timed out"), { timedOut: !0, signal }));
}, setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
  if (timeout === 0 || timeout === void 0)
    return spawnedPromise;
  let timeoutId, timeoutPromise = new Promise((resolve, reject) => {
    timeoutId = setTimeout(() => {
      timeoutKill(spawned, killSignal, reject);
    }, timeout);
  }), safeSpawnedPromise = spawnedPromise.finally(() => {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
}, validateTimeout = ({ timeout }) => {
  if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0))
    throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
}, setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
  if (!cleanup || detached)
    return timedPromise;
  let removeExitHandler = (0, import_signal_exit.default)(() => {
    spawned.kill();
  });
  return timedPromise.finally(() => {
    removeExitHandler();
  });
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/pipe.js
init_cjs_shims();
import { createWriteStream } from "node:fs";
import { ChildProcess } from "node:child_process";
var isExecaChildProcess = (target) => target instanceof ChildProcess && typeof target.then == "function", pipeToTarget = (spawned, streamName, target) => {
  if (typeof target == "string")
    return spawned[streamName].pipe(createWriteStream(target)), spawned;
  if (isWritableStream(target))
    return spawned[streamName].pipe(target), spawned;
  if (!isExecaChildProcess(target))
    throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
  if (!isWritableStream(target.stdin))
    throw new TypeError("The target child process's stdin must be available.");
  return spawned[streamName].pipe(target.stdin), target;
}, addPipeMethods = (spawned) => {
  spawned.stdout !== null && (spawned.pipeStdout = pipeToTarget.bind(void 0, spawned, "stdout")), spawned.stderr !== null && (spawned.pipeStderr = pipeToTarget.bind(void 0, spawned, "stderr")), spawned.all !== void 0 && (spawned.pipeAll = pipeToTarget.bind(void 0, spawned, "all"));
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/stream.js
init_cjs_shims();
import { createReadStream, readFileSync as readFileSync2 } from "node:fs";
var import_get_stream = __toESM(require_get_stream(), 1), import_merge_stream = __toESM(require_merge_stream(), 1), validateInputOptions = (input) => {
  if (input !== void 0)
    throw new TypeError("The `input` and `inputFile` options cannot be both set.");
}, getInputSync = ({ input, inputFile }) => typeof inputFile != "string" ? input : (validateInputOptions(input), readFileSync2(inputFile)), handleInputSync = (options) => {
  let input = getInputSync(options);
  if (isStream(input))
    throw new TypeError("The `input` option cannot be a stream in sync mode");
  return input;
}, getInput = ({ input, inputFile }) => typeof inputFile != "string" ? input : (validateInputOptions(input), createReadStream(inputFile)), handleInput = (spawned, options) => {
  let input = getInput(options);
  input !== void 0 && (isStream(input) ? input.pipe(spawned.stdin) : spawned.stdin.end(input));
}, makeAllStream = (spawned, { all }) => {
  if (!all || !spawned.stdout && !spawned.stderr)
    return;
  let mixed = (0, import_merge_stream.default)();
  return spawned.stdout && mixed.add(spawned.stdout), spawned.stderr && mixed.add(spawned.stderr), mixed;
}, getBufferedData = async (stream2, streamPromise) => {
  if (!(!stream2 || streamPromise === void 0)) {
    stream2.destroy();
    try {
      return await streamPromise;
    } catch (error) {
      return error.bufferedData;
    }
  }
}, getStreamPromise = (stream2, { encoding, buffer, maxBuffer }) => {
  if (!(!stream2 || !buffer))
    return encoding ? (0, import_get_stream.default)(stream2, { encoding, maxBuffer }) : import_get_stream.default.buffer(stream2, { maxBuffer });
}, getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
  let stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer }), stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer }), allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
  try {
    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
  } catch (error) {
    return Promise.all([
      { error, signal: error.signal, timedOut: error.timedOut },
      getBufferedData(stdout, stdoutPromise),
      getBufferedData(stderr, stderrPromise),
      getBufferedData(all, allPromise)
    ]);
  }
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/promise.js
init_cjs_shims();
var nativePromisePrototype = (async () => {
})().constructor.prototype, descriptors = ["then", "catch", "finally"].map((property) => [
  property,
  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]), mergePromise = (spawned, promise) => {
  for (let [property, descriptor] of descriptors) {
    let value = typeof promise == "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
    Reflect.defineProperty(spawned, property, { ...descriptor, value });
  }
}, getSpawnedPromise = (spawned) => new Promise((resolve, reject) => {
  spawned.on("exit", (exitCode, signal) => {
    resolve({ exitCode, signal });
  }), spawned.on("error", (error) => {
    reject(error);
  }), spawned.stdin && spawned.stdin.on("error", (error) => {
    reject(error);
  });
});

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/command.js
init_cjs_shims();
import { Buffer as Buffer2 } from "node:buffer";
import { ChildProcess as ChildProcess2 } from "node:child_process";
var normalizeArgs = (file, args = []) => Array.isArray(args) ? [file, ...args] : [file], NO_ESCAPE_REGEXP = /^[\w.-]+$/, DOUBLE_QUOTES_REGEXP = /"/g, escapeArg = (arg) => typeof arg != "string" || NO_ESCAPE_REGEXP.test(arg) ? arg : `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`, joinCommand = (file, args) => normalizeArgs(file, args).join(" "), getEscapedCommand = (file, args) => normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(" "), SPACES_REGEXP = / +/g;
var parseExpression = (expression) => {
  let typeOfExpression = typeof expression;
  if (typeOfExpression === "string")
    return expression;
  if (typeOfExpression === "number")
    return String(expression);
  if (typeOfExpression === "object" && expression !== null && !(expression instanceof ChildProcess2) && "stdout" in expression) {
    let typeOfStdout = typeof expression.stdout;
    if (typeOfStdout === "string")
      return expression.stdout;
    if (Buffer2.isBuffer(expression.stdout))
      return expression.stdout.toString();
    throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
  }
  throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
}, concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
  ...tokens.slice(0, -1),
  `${tokens[tokens.length - 1]}${nextTokens[0]}`,
  ...nextTokens.slice(1)
], parseTemplate = ({ templates, expressions, tokens, index, template }) => {
  let templateString = template ?? templates.raw[index], templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean), newTokens = concatTokens(
    tokens,
    templateTokens,
    templateString.startsWith(" ")
  );
  if (index === expressions.length)
    return newTokens;
  let expression = expressions[index], expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
  return concatTokens(
    newTokens,
    expressionTokens,
    templateString.endsWith(" ")
  );
}, parseTemplates = (templates, expressions) => {
  let tokens = [];
  for (let [index, template] of templates.entries())
    tokens = parseTemplate({ templates, expressions, tokens, index, template });
  return tokens;
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/lib/verbose.js
init_cjs_shims();
import { debuglog } from "node:util";
import process6 from "node:process";
var verboseDefault = debuglog("execa").enabled, padField = (field, padding) => String(field).padStart(padding, "0"), getTimestamp = () => {
  let date = /* @__PURE__ */ new Date();
  return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
}, logCommand = (escapedCommand, { verbose }) => {
  verbose && process6.stderr.write(`[${getTimestamp()}] ${escapedCommand}
`);
};

// ../../node_modules/.pnpm/execa@7.2.0/node_modules/execa/index.js
var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100, getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
  let env3 = extendEnv ? { ...process7.env, ...envOption } : envOption;
  return preferLocal ? npmRunPathEnv({ env: env3, cwd: localDir, execPath }) : env3;
}, handleArguments = (file, args, options = {}) => {
  let parsed = import_cross_spawn.default._parse(file, args, options);
  return file = parsed.command, args = parsed.args, options = parsed.options, options = {
    maxBuffer: DEFAULT_MAX_BUFFER,
    buffer: !0,
    stripFinalNewline: !0,
    extendEnv: !0,
    preferLocal: !1,
    localDir: options.cwd || process7.cwd(),
    execPath: process7.execPath,
    encoding: "utf8",
    reject: !0,
    cleanup: !0,
    all: !1,
    windowsHide: !0,
    verbose: verboseDefault,
    ...options
  }, options.env = getEnv(options), options.stdio = normalizeStdio(options), process7.platform === "win32" && path7.basename(file, ".exe") === "cmd" && args.unshift("/q"), { file, args, options, parsed };
}, handleOutput = (options, value, error) => typeof value != "string" && !Buffer3.isBuffer(value) ? error === void 0 ? void 0 : "" : options.stripFinalNewline ? stripFinalNewline(value) : value;
function execa(file, args, options) {
  let parsed = handleArguments(file, args, options), command = joinCommand(file, args), escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options), validateTimeout(parsed.options);
  let spawned;
  try {
    spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
  } catch (error) {
    let dummySpawned = new childProcess.ChildProcess(), errorPromise = Promise.reject(makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    }));
    return mergePromise(dummySpawned, errorPromise), dummySpawned;
  }
  let spawnedPromise = getSpawnedPromise(spawned), timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise), processDone = setExitHandler(spawned, parsed.options, timedPromise), context = { isCanceled: !1 };
  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned)), spawned.cancel = spawnedCancel.bind(null, spawned, context);
  let handlePromiseOnce = onetime_default(async () => {
    let [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone), stdout = handleOutput(parsed.options, stdoutResult), stderr = handleOutput(parsed.options, stderrResult), all = handleOutput(parsed.options, allResult);
    if (error || exitCode !== 0 || signal !== null) {
      let returnedError = makeError({
        error,
        exitCode,
        signal,
        stdout,
        stderr,
        all,
        command,
        escapedCommand,
        parsed,
        timedOut,
        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : !1),
        killed: spawned.killed
      });
      if (!parsed.options.reject)
        return returnedError;
      throw returnedError;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      all,
      failed: !1,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    };
  });
  return handleInput(spawned, parsed.options), spawned.all = makeAllStream(spawned, parsed.options), addPipeMethods(spawned), mergePromise(spawned, handlePromiseOnce), spawned;
}
function execaSync(file, args, options) {
  let parsed = handleArguments(file, args, options), command = joinCommand(file, args), escapedCommand = getEscapedCommand(file, args);
  logCommand(escapedCommand, parsed.options);
  let input = handleInputSync(parsed.options), result;
  try {
    result = childProcess.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
  } catch (error) {
    throw makeError({
      error,
      stdout: "",
      stderr: "",
      all: "",
      command,
      escapedCommand,
      parsed,
      timedOut: !1,
      isCanceled: !1,
      killed: !1
    });
  }
  let stdout = handleOutput(parsed.options, result.stdout, result.error), stderr = handleOutput(parsed.options, result.stderr, result.error);
  if (result.error || result.status !== 0 || result.signal !== null) {
    let error = makeError({
      stdout,
      stderr,
      error: result.error,
      signal: result.signal,
      exitCode: result.status,
      command,
      escapedCommand,
      parsed,
      timedOut: result.error && result.error.code === "ETIMEDOUT",
      isCanceled: !1,
      killed: result.signal !== null
    });
    if (!parsed.options.reject)
      return error;
    throw error;
  }
  return {
    command,
    escapedCommand,
    exitCode: 0,
    stdout,
    stderr,
    failed: !1,
    timedOut: !1,
    isCanceled: !1,
    killed: !1
  };
}
var normalizeScriptStdin = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {}, normalizeScriptOptions = (options = {}) => ({
  preferLocal: !0,
  ...normalizeScriptStdin(options),
  ...options
});
function create$(options) {
  function $2(templatesOrOptions, ...expressions) {
    if (!Array.isArray(templatesOrOptions))
      return create$({ ...options, ...templatesOrOptions });
    let [file, ...args] = parseTemplates(templatesOrOptions, expressions);
    return execa(file, args, normalizeScriptOptions(options));
  }
  return $2.sync = (templates, ...expressions) => {
    if (!Array.isArray(templates))
      throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
    let [file, ...args] = parseTemplates(templates, expressions);
    return execaSync(file, args, normalizeScriptOptions(options));
  }, $2;
}
var $ = create$();

// ../cli-kit/dist/public/node/os.js
import { userInfo as osUserInfo } from "os";
async function username(platform2 = process.platform) {
  outputDebug(outputContent`Obtaining user name...`);
  let environmentVariable = getEnvironmentVariable();
  if (environmentVariable)
    return environmentVariable;
  let userInfoUsername = getUsernameFromOsUserInfo();
  if (userInfoUsername)
    return userInfoUsername;
  try {
    if (platform2 === "win32") {
      let { stdout } = await execa("whoami");
      return cleanWindowsCommand(stdout);
    }
    let { stdout: userId } = await execa("id", ["-u"]);
    try {
      let { stdout } = await execa("id", ["-un", userId]);
      return stdout;
    } catch {
    }
    return makeUsernameFromId(userId);
  } catch {
    return null;
  }
}
function platformAndArch(platform2 = process.platform, arch = process.arch) {
  let archString;
  return arch === "x64" ? archString = "amd64" : arch === "ia32" ? archString = "386" : archString = arch, { platform: platform2.match(/^win.+/) ? "windows" : platform2, arch: archString };
}
function getEnvironmentVariable() {
  let { env: env3 } = process;
  return env3.SUDO_USER || env3.C9_USER || env3.LOGNAME || env3.USER || env3.LNAME || env3.USERNAME;
}
function getUsernameFromOsUserInfo() {
  try {
    return osUserInfo().username;
  } catch {
    return null;
  }
}
function cleanWindowsCommand(value) {
  return value.replace(/^.*\\/, "");
}
function makeUsernameFromId(userId) {
  return `no-username-${userId}`;
}

// ../cli-kit/dist/public/node/system.js
var import_which = __toESM(require_lib2());
async function openURL(url) {
  let externalOpen = await import("./open-BHIF7E3E.js");
  try {
    return await externalOpen.default(url), !0;
  } catch {
    return !1;
  }
}
async function captureOutput(command, args, options) {
  return (await buildExec(command, args, options)).stdout;
}
async function exec2(command, args, options) {
  if (options) {
    let runningOnWindows = platformAndArch().platform === "windows";
    options.background = runningOnWindows ? !1 : options.background;
  }
  let commandProcess = buildExec(command, args, options);
  options?.background && commandProcess.unref(), options?.stderr && options.stderr !== "inherit" && commandProcess.stderr?.pipe(options.stderr, { end: !1 }), options?.stdout && options.stdout !== "inherit" && commandProcess.stdout?.pipe(options.stdout, { end: !1 });
  let aborted = !1;
  options?.signal?.addEventListener("abort", () => {
    let pid = commandProcess.pid;
    pid && (outputDebug(`Killing process ${pid}: ${command} ${args.join(" ")}`), aborted = !0, treeKill(pid, "SIGTERM"));
  });
  try {
    await commandProcess;
  } catch (processError) {
    if (aborted)
      return;
    if (options?.externalErrorHandler)
      await options.externalErrorHandler(processError);
    else {
      let abortError = new ExternalError(processError.message, command, args);
      throw abortError.stack = processError.stack, abortError;
    }
  }
}
function buildExec(command, args, options) {
  let env3 = options?.env ?? process.env;
  shouldDisplayColors() && (env3.FORCE_COLOR = "1");
  let executionCwd = options?.cwd ?? cwd();
  checkCommandSafety(command, { cwd: executionCwd });
  let commandProcess = execa(command, args, {
    env: env3,
    cwd: executionCwd,
    input: options?.input,
    stdio: options?.background ? "ignore" : options?.stdio,
    stdin: options?.stdin,
    stdout: options?.stdout === "inherit" ? "inherit" : void 0,
    stderr: options?.stderr === "inherit" ? "inherit" : void 0,
    // Setting this to false makes it possible to kill the main process
    // and all its sub-processes with Ctrl+C on Windows
    windowsHide: !1,
    detached: options?.background,
    cleanup: !options?.background
  });
  return outputDebug(`Running system process${options?.background ? " in background" : ""}:
  \xB7 Command: ${command} ${args.join(" ")}
  \xB7 Working directory: ${executionCwd}
`), commandProcess;
}
function checkCommandSafety(command, _options) {
  let pathIncludingLocal = `${_options.cwd}${delimiter}${process.env.PATH}`, commandPath = import_which.default.sync(command, {
    nothrow: !0,
    path: pathIncludingLocal
  });
  if (commandPath && dirname(commandPath) === _options.cwd) {
    let headline = ["Skipped run of unsecure binary", { command }, "found in the current directory."], body = "Please remove that file or review your current PATH.";
    throw renderWarning({ headline, body }), new AbortError(headline, body);
  }
}
async function sleep(seconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, 1e3 * seconds);
  });
}
function terminalSupportsPrompting() {
  return isTruthy(process.env.CI) ? !1 : !!(process.stdin.isTTY && process.stdout.isTTY);
}
function isCI() {
  return isTruthy(process.env.CI);
}
async function isWsl() {
  return (await import("./is-wsl-YAJ3DFN7.js")).default;
}

// ../../node_modules/.pnpm/is-interactive@2.0.0/node_modules/is-interactive/index.js
init_cjs_shims();
function isInteractive({ stream: stream2 = process.stdout } = {}) {
  return !!(stream2 && stream2.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env));
}

// ../cli-kit/dist/public/node/context/local.js
var import_macaddress = __toESM(require_macaddress(), 1);
import { homedir as homedir2 } from "os";
function isTerminalInteractive() {
  return isInteractive();
}
function homeDirectory() {
  return homedir2();
}
function isDevelopment(env3 = process.env) {
  return env3[environmentVariables.env] === "development";
}
function isVerbose(env3 = process.env) {
  return isTruthy(env3[environmentVariables.verbose]) || process.argv.includes("--verbose");
}
async function isShopify(env3 = process.env) {
  return Object.prototype.hasOwnProperty.call(env3, environmentVariables.runAsUser) ? !isTruthy(env3[environmentVariables.runAsUser]) : await fileExists(pathConstants.executables.dev);
}
function isUnitTest(env3 = process.env) {
  return isTruthy(env3[environmentVariables.unitTest]);
}
function analyticsDisabled(env3 = process.env) {
  return isTruthy(env3[environmentVariables.noAnalytics]) || isDevelopment(env3);
}
function alwaysLogAnalytics(env3 = process.env) {
  return isTruthy(env3[environmentVariables.alwaysLogAnalytics]);
}
function alwaysLogMetrics(env3 = process.env) {
  return isTruthy(env3[environmentVariables.alwaysLogMetrics]);
}
function firstPartyDev(env3 = process.env) {
  return isTruthy(env3[environmentVariables.firstPartyDev]);
}
function gitpodURL(env3 = process.env) {
  return env3[environmentVariables.gitpod];
}
function codespaceURL(env3 = process.env) {
  return env3[environmentVariables.codespaceName];
}
function codespacePortForwardingDomain(env3 = process.env) {
  return env3[environmentVariables.codespacePortForwardingDomain];
}
function isCloudEnvironment(env3 = process.env) {
  return cloudEnvironment(env3).platform !== "localhost";
}
function themeToken(env3 = process.env) {
  return env3[environmentVariables.themeToken];
}
function cloudEnvironment(env3 = process.env) {
  return isSet(env3[environmentVariables.codespaces]) ? { platform: "codespaces", editor: !0 } : isSet(env3[environmentVariables.gitpod]) ? { platform: "gitpod", editor: !0 } : isSet(env3[environmentVariables.cloudShell]) ? { platform: "cloudShell", editor: !0 } : { platform: "localhost", editor: !1 };
}
async function hasGit() {
  try {
    return await exec2("git", ["--version"]), !0;
  } catch {
    return !1;
  }
}
function ciPlatform(env3 = process.env) {
  if (isTruthy(env3.CI)) {
    let name = "unknown";
    return isSet(env3.BITBUCKET_BUILD_NUMBER) ? name = "bitbucket" : isTruthy(env3.CIRCLECI) ? name = "circleci" : isSet(env3.GITHUB_ACTION) ? name = "github" : isTruthy(env3.GITLAB_CI) ? name = "gitlab" : isSet(env3.BUILDKITE) && (name = "buildkite"), {
      isCI: !0,
      name,
      metadata: getCIMetadata(name, env3)
    };
  } else if (isTruthy(env3.TF_BUILD))
    return {
      isCI: !0,
      name: "azure",
      metadata: getCIMetadata("azure", env3)
    };
  return {
    isCI: !1
  };
}
function macAddress() {
  return import_macaddress.default.one();
}
function getThemeKitAccessDomain(env3 = process.env) {
  let domain = env3[environmentVariables.themeKitAccessDomain];
  return isSet(domain) ? domain : defaultThemeKitAccessDomain;
}
function opentelemetryDomain(env3 = process.env) {
  let domain = env3[environmentVariables.otelURL];
  return isSet(domain) ? domain : "https://otlp-http-production-cli.shopifysvc.com";
}

// ../cli-kit/dist/public/node/is-global.js
init_cjs_shims();

// ../cli-kit/dist/public/node/version.js
init_cjs_shims();
var import_which2 = __toESM(require_lib2(), 1), import_semver = __toESM(require_semver(), 1);
async function localCLIVersion(directory) {
  try {
    return (await captureOutput("npm", ["list", "@shopify/cli"], { cwd: directory })).match(/@shopify\/cli@([\w.-]*)/)?.[1];
  } catch {
    return;
  }
}
async function globalCLIVersion() {
  try {
    let env3 = { ...process.env, SHOPIFY_CLI_NO_ANALYTICS: "1" }, shopifyBinaries = import_which2.default.sync("shopify", { all: !0 }).filter((path8) => !path8.includes("node_modules"));
    if (!shopifyBinaries[0])
      return;
    let versionMatch = (await captureOutput(shopifyBinaries[0], [], { env: env3 })).match(/@shopify\/cli\/([^\s]+)/);
    if (versionMatch && versionMatch[1]) {
      let version = versionMatch[1];
      if ((0, import_semver.satisfies)(version, ">=3.59.0") || isPreReleaseVersion(version))
        return version;
    }
    return;
  } catch {
    return;
  }
}
function isPreReleaseVersion(version) {
  return version.startsWith("0.0.0");
}

// ../cli-kit/dist/public/node/is-global.js
var _isGlobal;
function currentProcessIsGlobal(argv = process.argv) {
  try {
    if (_isGlobal !== void 0 && !isUnitTest())
      return _isGlobal;
    let path8 = sniffForPath() ?? cwd(), npmPrefix = execaSync("npm", ["prefix"], { cwd: path8 }).stdout.trim();
    return _isGlobal = !(argv[1] ?? "").startsWith(npmPrefix.trim()), _isGlobal;
  } catch {
    return !1;
  }
}
async function installGlobalShopifyCLI(packageManager) {
  let args = packageManager === "yarn" ? ["global", "add", "@shopify/cli@latest"] : ["install", "-g", "@shopify/cli@latest"];
  outputInfo(`Running ${packageManager} ${args.join(" ")}...`), await exec2(packageManager, args, { stdio: "inherit" });
}
async function installGlobalCLIPrompt() {
  return terminalSupportsPrompting() ? await globalCLIVersion() ? { install: !1, alreadyInstalled: !0 } : { install: await renderSelectPrompt({
    message: "We recommend installing Shopify CLI globally in your system. Would you like to install it now?",
    choices: [
      { value: "yes", label: "Yes" },
      { value: "no", label: "No, just for this project" }
    ]
  }) === "yes", alreadyInstalled: !1 } : { install: !1, alreadyInstalled: !1 };
}
function inferPackageManagerForGlobalCLI(argv = process.argv) {
  if (!currentProcessIsGlobal(argv))
    return "unknown";
  let processArgv = argv[1] ?? "";
  return processArgv.includes("yarn") ? "yarn" : processArgv.includes("pnpm") ? "pnpm" : processArgv.includes("bun") ? "bun" : "npm";
}

// ../cli-kit/dist/public/node/colors.js
init_cjs_shims();

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/vendor/ansi-styles/index.js
init_cjs_shims();
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, modifierNames = Object.keys(styles.modifier), foregroundColorNames = Object.keys(styles.color), backgroundColorNames = Object.keys(styles.bgColor), colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  let codes = /* @__PURE__ */ new Map();
  for (let [groupName, group] of Object.entries(styles)) {
    for (let [styleName, style] of Object.entries(group))
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      }, group[styleName] = styles[styleName], codes.set(style[0], style[1]);
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: !1
    });
  }
  return Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: !1
  }), styles.color.close = "\x1B[39m", styles.bgColor.close = "\x1B[49m", styles.color.ansi = wrapAnsi16(), styles.color.ansi256 = wrapAnsi256(), styles.color.ansi16m = wrapAnsi16m(), styles.bgColor.ansi = wrapAnsi16(10), styles.bgColor.ansi256 = wrapAnsi256(10), styles.bgColor.ansi16m = wrapAnsi16m(10), Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        return red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(hex) {
        let matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches)
          return [0, 0, 0];
        let [colorString] = matches;
        colorString.length === 3 && (colorString = [...colorString].map((character) => character + character).join(""));
        let integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8)
          return 30 + code;
        if (code < 16)
          return 90 + (code - 8);
        let red, green, blue;
        if (code >= 232)
          red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
        else {
          code -= 16;
          let remainder = code % 36;
          red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
        }
        let value = Math.max(red, green, blue) * 2;
        if (value === 0)
          return 30;
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        return value === 2 && (result += 60), result;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: !1
    }
  }), styles;
}
var ansiStyles = assembleStyles(), ansi_styles_default = ansiStyles;

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/vendor/supports-color/index.js
init_cjs_shims();
import process8 from "node:process";
import os4 from "node:os";
import tty from "node:tty";
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process8.argv) {
  let prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--", position = argv.indexOf(prefix + flag), terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env: env2 } = process8, flagForceColor;
hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never") ? flagForceColor = 0 : (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) && (flagForceColor = 1);
function envForceColor() {
  if ("FORCE_COLOR" in env2)
    return env2.FORCE_COLOR === "true" ? 1 : env2.FORCE_COLOR === "false" ? 0 : env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
}
function translateLevel(level) {
  return level === 0 ? !1 : {
    level,
    hasBasic: !0,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = !0 } = {}) {
  let noFlagForceColor = envForceColor();
  noFlagForceColor !== void 0 && (flagForceColor = noFlagForceColor);
  let forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0)
    return 0;
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor"))
      return 3;
    if (hasFlag("color=256"))
      return 2;
  }
  if ("TF_BUILD" in env2 && "AGENT_NAME" in env2)
    return 1;
  if (haveStream && !streamIsTTY && forceColor === void 0)
    return 0;
  let min = forceColor || 0;
  if (env2.TERM === "dumb")
    return min;
  if (process8.platform === "win32") {
    let osRelease = os4.release().split(".");
    return Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586 ? Number(osRelease[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in env2)
    return ["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((key) => key in env2) ? 3 : ["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship" ? 1 : min;
  if ("TEAMCITY_VERSION" in env2)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
  if (env2.COLORTERM === "truecolor" || env2.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in env2) {
    let version = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env2.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(env2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM) || "COLORTERM" in env2 ? 1 : min;
}
function createSupportsColor(stream2, options = {}) {
  let level = _supportsColor(stream2, {
    streamIsTTY: stream2 && stream2.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
}, supports_color_default = supportsColor;

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/utilities.js
init_cjs_shims();
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1)
    return string;
  let substringLength = substring.length, endIndex = 0, returnValue = "";
  do
    returnValue += string.slice(endIndex, index) + substring + replacer, endIndex = index + substringLength, index = string.indexOf(substring, endIndex);
  while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0, returnValue = "";
  do {
    let gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? `\r
` : `
`) + postfix, endIndex = index + 1, index = string.indexOf(`
`, endIndex);
  } while (index !== -1);
  return returnValue += string.slice(endIndex), returnValue;
}

// ../../node_modules/.pnpm/chalk@5.4.1/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default, GENERATOR = Symbol("GENERATOR"), STYLER = Symbol("STYLER"), IS_EMPTY = Symbol("IS_EMPTY"), levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], styles2 = /* @__PURE__ */ Object.create(null), applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  let chalk2 = (...strings) => strings.join(" ");
  return applyOptions(chalk2, options), Object.setPrototypeOf(chalk2, createChalk.prototype), chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (let [styleName, style] of Object.entries(ansi_styles_default))
  styles2[styleName] = {
    get() {
      let builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      return Object.defineProperty(this, styleName, { value: builder }), builder;
    }
  };
styles2.visible = {
  get() {
    let builder = createBuilder(this, this[STYLER], !0);
    return Object.defineProperty(this, "visible", { value: builder }), builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => model === "rgb" ? level === "ansi16m" ? ansi_styles_default[type].ansi16m(...arguments_) : level === "ansi256" ? ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_)) : ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_)) : model === "hex" ? getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_)) : ansi_styles_default[type][model](...arguments_), usedModels = ["rgb", "hex", "ansi256"];
for (let model of usedModels) {
  styles2[model] = {
    get() {
      let { level } = this;
      return function(...arguments_) {
        let styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  let bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      let { level } = this;
      return function(...arguments_) {
        let styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: !0,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
}), createStyler = (open, close, parent) => {
  let openAll, closeAll;
  return parent === void 0 ? (openAll = open, closeAll = close) : (openAll = parent.openAll + open, closeAll = close + parent.closeAll), {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
}, createBuilder = (self2, _styler, _isEmpty) => {
  let builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  return Object.setPrototypeOf(builder, proto), builder[GENERATOR] = self2, builder[STYLER] = _styler, builder[IS_EMPTY] = _isEmpty, builder;
}, applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string)
    return self2[IS_EMPTY] ? "" : string;
  let styler = self2[STYLER];
  if (styler === void 0)
    return string;
  let { openAll, closeAll } = styler;
  if (string.includes("\x1B"))
    for (; styler !== void 0; )
      string = stringReplaceAll(string, styler.close, styler.open), styler = styler.parent;
  let lfIndex = string.indexOf(`
`);
  return lfIndex !== -1 && (string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex)), openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk(), chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// ../cli-kit/dist/private/node/content-tokens.js
init_cjs_shims();

// ../../node_modules/.pnpm/terminal-link@3.0.0/node_modules/terminal-link/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/ansi-escapes@5.0.0/node_modules/ansi-escapes/index.js
init_cjs_shims();
var ESC = "\x1B[", OSC = "\x1B]", BEL = "\x07", SEP = ";", isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal", ansiEscapes = {};
ansiEscapes.cursorTo = (x, y) => {
  if (typeof x != "number")
    throw new TypeError("The `x` argument is required");
  return typeof y != "number" ? ESC + (x + 1) + "G" : ESC + (y + 1) + ";" + (x + 1) + "H";
};
ansiEscapes.cursorMove = (x, y) => {
  if (typeof x != "number")
    throw new TypeError("The `x` argument is required");
  let returnValue = "";
  return x < 0 ? returnValue += ESC + -x + "D" : x > 0 && (returnValue += ESC + x + "C"), y < 0 ? returnValue += ESC + -y + "A" : y > 0 && (returnValue += ESC + y + "B"), returnValue;
};
ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
ansiEscapes.cursorLeft = ESC + "G";
ansiEscapes.cursorSavePosition = isTerminalApp ? "\x1B7" : ESC + "s";
ansiEscapes.cursorRestorePosition = isTerminalApp ? "\x1B8" : ESC + "u";
ansiEscapes.cursorGetPosition = ESC + "6n";
ansiEscapes.cursorNextLine = ESC + "E";
ansiEscapes.cursorPrevLine = ESC + "F";
ansiEscapes.cursorHide = ESC + "?25l";
ansiEscapes.cursorShow = ESC + "?25h";
ansiEscapes.eraseLines = (count) => {
  let clear = "";
  for (let i = 0; i < count; i++)
    clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
  return count && (clear += ansiEscapes.cursorLeft), clear;
};
ansiEscapes.eraseEndLine = ESC + "K";
ansiEscapes.eraseStartLine = ESC + "1K";
ansiEscapes.eraseLine = ESC + "2K";
ansiEscapes.eraseDown = ESC + "J";
ansiEscapes.eraseUp = ESC + "1J";
ansiEscapes.eraseScreen = ESC + "2J";
ansiEscapes.scrollUp = ESC + "S";
ansiEscapes.scrollDown = ESC + "T";
ansiEscapes.clearScreen = "\x1Bc";
ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : (
  // 1. Erases the screen (Only done in case `2` is not supported)
  // 2. Erases the whole screen including scrollback buffer
  // 3. Moves cursor to the top-left position
  // More info: https://www.real-world-systems.com/docs/ANSIcode.html
  `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`
);
ansiEscapes.beep = BEL;
ansiEscapes.link = (text, url) => [
  OSC,
  "8",
  SEP,
  SEP,
  url,
  BEL,
  text,
  OSC,
  "8",
  SEP,
  SEP,
  BEL
].join("");
ansiEscapes.image = (buffer, options = {}) => {
  let returnValue = `${OSC}1337;File=inline=1`;
  return options.width && (returnValue += `;width=${options.width}`), options.height && (returnValue += `;height=${options.height}`), options.preserveAspectRatio === !1 && (returnValue += ";preserveAspectRatio=0"), returnValue + ":" + buffer.toString("base64") + BEL;
};
ansiEscapes.iTerm = {
  setCwd: (cwd3 = process.cwd()) => `${OSC}50;CurrentDir=${cwd3}${BEL}`,
  annotation: (message, options = {}) => {
    let returnValue = `${OSC}1337;`, hasX = typeof options.x < "u", hasY = typeof options.y < "u";
    if ((hasX || hasY) && !(hasX && hasY && typeof options.length < "u"))
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    return message = message.replace(/\|/g, ""), returnValue += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", options.length > 0 ? returnValue += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|") : returnValue += message, returnValue + BEL;
  }
};
var ansi_escapes_default = ansiEscapes;

// ../../node_modules/.pnpm/terminal-link@3.0.0/node_modules/terminal-link/index.js
var import_supports_hyperlinks = __toESM(require_supports_hyperlinks(), 1);
function terminalLink(text, url, { target = "stdout", ...options } = {}) {
  return import_supports_hyperlinks.default[target] ? ansi_escapes_default.link(text, url) : options.fallback === !1 ? text : typeof options.fallback == "function" ? options.fallback(text, url) : `${text} (\u200B${url}\u200B)`;
}
terminalLink.isSupported = import_supports_hyperlinks.default.stdout;
terminalLink.stderr = (text, url, options = {}) => terminalLink(text, url, { target: "stderr", ...options });
terminalLink.stderr.isSupported = import_supports_hyperlinks.default.stderr;

// ../../node_modules/.pnpm/color-json@3.0.5/node_modules/color-json/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/color-json@3.0.5/node_modules/color-json/lib/supportsColor.js
init_cjs_shims();
function supportsColor2() {
  let onHeroku = !!truth(process.env.DYNO), forceNoColor = !!truth(process.env.FORCE_NO_COLOR), forceColor = !!truth(process.env.FORCE_COLOR);
  return !onHeroku && !forceNoColor || forceColor;
}
function truth(it) {
  return !!(it && it !== "false");
}

// ../../node_modules/.pnpm/color-json@3.0.5/node_modules/color-json/index.js
var defaultColorMap = {
  black: "\x1B[30m",
  red: "\x1B[31m",
  green: "\x1B[32m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  white: "\x1B[37m"
}, defaultColors = {
  separator: "yellow",
  string: "green",
  number: "magenta",
  boolean: "cyan",
  null: "red",
  key: "white"
};
function colorJson(json, colors = defaultColors, colorMap = defaultColorMap, spacing = 2) {
  return supportsColor2() ? (typeof json != "string" ? json = JSON.stringify(json, void 0, spacing) : json = JSON.stringify(JSON.parse(json), void 0, spacing), colorMap[colors.separator] + json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match2) {
    let colorCode = "number";
    return /^"/.test(match2) ? /:$/.test(match2) ? colorCode = "key" : colorCode = "string" : /true|false/.test(match2) ? colorCode = "boolean" : /null/.test(match2) && (colorCode = "null"), `\x1B[0m${colorMap[colors[colorCode]] || ""}${match2}${colorMap[colors.separator]}`;
  }) + "\x1B[0m") : (typeof json != "string" ? json = JSON.stringify(json, void 0, spacing) : json = JSON.stringify(JSON.parse(json), void 0, spacing), json);
}

// ../cli-kit/dist/private/node/content-tokens.js
var ContentToken = class {
  constructor(value) {
    this.value = value;
  }
}, RawContentToken = class extends ContentToken {
  output() {
    return this.value;
  }
}, LinkContentToken = class extends ContentToken {
  constructor(value, link2, fallback) {
    super(value), this.link = link2 ?? stringifyMessage(value), this.fallback = fallback;
  }
  output() {
    let text = source_default.green(stringifyMessage(this.value)), url = this.link ?? "", defaultFallback = this.value === this.link ? text : `${text} ( ${url} )`;
    return terminalLink(text, url, { fallback: () => this.fallback ?? defaultFallback });
  }
}, CommandContentToken = class extends ContentToken {
  output() {
    return `\`${source_default.magentaBright(stringifyMessage(this.value))}\``;
  }
}, JsonContentToken = class extends ContentToken {
  output() {
    try {
      return colorJson(stringifyMessage(this.value) ?? {});
    } catch {
      return JSON.stringify(stringifyMessage(this.value) ?? {}, null, 2);
    }
  }
}, LinesDiffContentToken = class extends ContentToken {
  output() {
    return this.value.map((part) => part.added ? part.value.split(/\n/).filter((line) => line !== "").map((line) => source_default.green(`+ ${line}
`)) : part.removed ? part.value.split(/\n/).filter((line) => line !== "").map((line) => source_default.magenta(`- ${line}
`)) : part.value).flat();
  }
}, ColorContentToken = class extends ContentToken {
  constructor(value, color) {
    super(value), this.color = color;
  }
  output() {
    return this.color(stringifyMessage(this.value));
  }
}, ErrorContentToken = class extends ContentToken {
  output() {
    return source_default.bold.redBright(stringifyMessage(this.value));
  }
}, PathContentToken = class extends ContentToken {
  output() {
    return relativizePath(stringifyMessage(this.value));
  }
}, HeadingContentToken = class extends ContentToken {
  output() {
    return source_default.bold.underline(stringifyMessage(this.value));
  }
}, SubHeadingContentToken = class extends ContentToken {
  output() {
    return source_default.underline(stringifyMessage(this.value));
  }
}, ItalicContentToken = class extends ContentToken {
  output() {
    return source_default.italic(stringifyMessage(this.value));
  }
};

// ../cli-kit/dist/private/node/ui/components/TokenizedText.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Command.js
init_cjs_shims();

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/render.js
init_cjs_shims();
import { Stream } from "node:stream";
import process18 from "node:process";

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/ink.js
init_cjs_shims();
var import_react10 = __toESM(require_react(), 1), import_throttle = __toESM(require_throttle(), 1);
import process17 from "node:process";

// ../../node_modules/.pnpm/ansi-escapes@6.2.1/node_modules/ansi-escapes/index.js
init_cjs_shims();
import process9 from "node:process";
var ESC2 = "\x1B[", OSC2 = "\x1B]", BEL2 = "\x07", SEP2 = ";", isBrowser = typeof window < "u" && typeof window.document < "u", isTerminalApp2 = !isBrowser && process9.env.TERM_PROGRAM === "Apple_Terminal", isWindows = !isBrowser && process9.platform === "win32", cwdFunction = isBrowser ? () => {
  throw new Error("`process.cwd()` only works in Node.js, not the browser.");
} : process9.cwd, ansiEscapes2 = {};
ansiEscapes2.cursorTo = (x, y) => {
  if (typeof x != "number")
    throw new TypeError("The `x` argument is required");
  return typeof y != "number" ? ESC2 + (x + 1) + "G" : ESC2 + (y + 1) + SEP2 + (x + 1) + "H";
};
ansiEscapes2.cursorMove = (x, y) => {
  if (typeof x != "number")
    throw new TypeError("The `x` argument is required");
  let returnValue = "";
  return x < 0 ? returnValue += ESC2 + -x + "D" : x > 0 && (returnValue += ESC2 + x + "C"), y < 0 ? returnValue += ESC2 + -y + "A" : y > 0 && (returnValue += ESC2 + y + "B"), returnValue;
};
ansiEscapes2.cursorUp = (count = 1) => ESC2 + count + "A";
ansiEscapes2.cursorDown = (count = 1) => ESC2 + count + "B";
ansiEscapes2.cursorForward = (count = 1) => ESC2 + count + "C";
ansiEscapes2.cursorBackward = (count = 1) => ESC2 + count + "D";
ansiEscapes2.cursorLeft = ESC2 + "G";
ansiEscapes2.cursorSavePosition = isTerminalApp2 ? "\x1B7" : ESC2 + "s";
ansiEscapes2.cursorRestorePosition = isTerminalApp2 ? "\x1B8" : ESC2 + "u";
ansiEscapes2.cursorGetPosition = ESC2 + "6n";
ansiEscapes2.cursorNextLine = ESC2 + "E";
ansiEscapes2.cursorPrevLine = ESC2 + "F";
ansiEscapes2.cursorHide = ESC2 + "?25l";
ansiEscapes2.cursorShow = ESC2 + "?25h";
ansiEscapes2.eraseLines = (count) => {
  let clear = "";
  for (let i = 0; i < count; i++)
    clear += ansiEscapes2.eraseLine + (i < count - 1 ? ansiEscapes2.cursorUp() : "");
  return count && (clear += ansiEscapes2.cursorLeft), clear;
};
ansiEscapes2.eraseEndLine = ESC2 + "K";
ansiEscapes2.eraseStartLine = ESC2 + "1K";
ansiEscapes2.eraseLine = ESC2 + "2K";
ansiEscapes2.eraseDown = ESC2 + "J";
ansiEscapes2.eraseUp = ESC2 + "1J";
ansiEscapes2.eraseScreen = ESC2 + "2J";
ansiEscapes2.scrollUp = ESC2 + "S";
ansiEscapes2.scrollDown = ESC2 + "T";
ansiEscapes2.clearScreen = "\x1Bc";
ansiEscapes2.clearTerminal = isWindows ? `${ansiEscapes2.eraseScreen}${ESC2}0f` : `${ansiEscapes2.eraseScreen}${ESC2}3J${ESC2}H`;
ansiEscapes2.enterAlternativeScreen = ESC2 + "?1049h";
ansiEscapes2.exitAlternativeScreen = ESC2 + "?1049l";
ansiEscapes2.beep = BEL2;
ansiEscapes2.link = (text, url) => [
  OSC2,
  "8",
  SEP2,
  SEP2,
  url,
  BEL2,
  text,
  OSC2,
  "8",
  SEP2,
  SEP2,
  BEL2
].join("");
ansiEscapes2.image = (buffer, options = {}) => {
  let returnValue = `${OSC2}1337;File=inline=1`;
  return options.width && (returnValue += `;width=${options.width}`), options.height && (returnValue += `;height=${options.height}`), options.preserveAspectRatio === !1 && (returnValue += ";preserveAspectRatio=0"), returnValue + ":" + buffer.toString("base64") + BEL2;
};
ansiEscapes2.iTerm = {
  setCwd: (cwd3 = cwdFunction()) => `${OSC2}50;CurrentDir=${cwd3}${BEL2}`,
  annotation(message, options = {}) {
    let returnValue = `${OSC2}1337;`, hasX = typeof options.x < "u", hasY = typeof options.y < "u";
    if ((hasX || hasY) && !(hasX && hasY && typeof options.length < "u"))
      throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
    return message = message.replace(/\|/g, ""), returnValue += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", options.length > 0 ? returnValue += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|") : returnValue += message, returnValue + BEL2;
  }
};
var ansi_escapes_default2 = ansiEscapes2;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/ink.js
var import_is_ci = __toESM(require_is_ci(), 1);

// ../../node_modules/.pnpm/auto-bind@5.0.1/node_modules/auto-bind/index.js
init_cjs_shims();
var getAllProperties = (object) => {
  let properties = /* @__PURE__ */ new Set();
  do
    for (let key of Reflect.ownKeys(object))
      properties.add([object, key]);
  while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
  return properties;
};
function autoBind(self2, { include, exclude } = {}) {
  let filter2 = (key) => {
    let match2 = (pattern) => typeof pattern == "string" ? key === pattern : pattern.test(key);
    return include ? include.some(match2) : exclude ? !exclude.some(match2) : !0;
  };
  for (let [object, key] of getAllProperties(self2.constructor.prototype)) {
    if (key === "constructor" || !filter2(key))
      continue;
    let descriptor = Reflect.getOwnPropertyDescriptor(object, key);
    descriptor && typeof descriptor.value == "function" && (self2[key] = self2[key].bind(self2));
  }
  return self2;
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/ink.js
var import_signal_exit3 = __toESM(require_signal_exit(), 1);

// ../../node_modules/.pnpm/patch-console@2.0.0/node_modules/patch-console/dist/index.js
init_cjs_shims();
import { PassThrough } from "node:stream";
var consoleMethods = [
  "assert",
  "count",
  "countReset",
  "debug",
  "dir",
  "dirxml",
  "error",
  "group",
  "groupCollapsed",
  "groupEnd",
  "info",
  "log",
  "table",
  "time",
  "timeEnd",
  "timeLog",
  "trace",
  "warn"
], originalMethods = {}, patchConsole = (callback) => {
  let stdout = new PassThrough(), stderr = new PassThrough();
  stdout.write = (data) => {
    callback("stdout", data);
  }, stderr.write = (data) => {
    callback("stderr", data);
  };
  let internalConsole = new console.Console(stdout, stderr);
  for (let method of consoleMethods)
    originalMethods[method] = console[method], console[method] = internalConsole[method];
  return () => {
    for (let method of consoleMethods)
      console[method] = originalMethods[method];
    originalMethods = {};
  };
}, dist_default = patchConsole;

// ../../node_modules/.pnpm/yoga-wasm-web@0.3.3/node_modules/yoga-wasm-web/dist/node.js
init_cjs_shims();
import { readFile as E } from "node:fs/promises";
import { createRequire as _ } from "node:module";

// ../../node_modules/.pnpm/yoga-wasm-web@0.3.3/node_modules/yoga-wasm-web/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/yoga-wasm-web@0.3.3/node_modules/yoga-wasm-web/dist/wrapAsm-f766f97f.js
init_cjs_shims();
var YGEnums = {}, ALIGN_AUTO = YGEnums.ALIGN_AUTO = 0, ALIGN_FLEX_START = YGEnums.ALIGN_FLEX_START = 1, ALIGN_CENTER = YGEnums.ALIGN_CENTER = 2, ALIGN_FLEX_END = YGEnums.ALIGN_FLEX_END = 3, ALIGN_STRETCH = YGEnums.ALIGN_STRETCH = 4, ALIGN_BASELINE = YGEnums.ALIGN_BASELINE = 5, ALIGN_SPACE_BETWEEN = YGEnums.ALIGN_SPACE_BETWEEN = 6, ALIGN_SPACE_AROUND = YGEnums.ALIGN_SPACE_AROUND = 7, DIMENSION_WIDTH = YGEnums.DIMENSION_WIDTH = 0, DIMENSION_HEIGHT = YGEnums.DIMENSION_HEIGHT = 1, DIRECTION_INHERIT = YGEnums.DIRECTION_INHERIT = 0, DIRECTION_LTR = YGEnums.DIRECTION_LTR = 1, DIRECTION_RTL = YGEnums.DIRECTION_RTL = 2, DISPLAY_FLEX = YGEnums.DISPLAY_FLEX = 0, DISPLAY_NONE = YGEnums.DISPLAY_NONE = 1, EDGE_LEFT = YGEnums.EDGE_LEFT = 0, EDGE_TOP = YGEnums.EDGE_TOP = 1, EDGE_RIGHT = YGEnums.EDGE_RIGHT = 2, EDGE_BOTTOM = YGEnums.EDGE_BOTTOM = 3, EDGE_START = YGEnums.EDGE_START = 4, EDGE_END = YGEnums.EDGE_END = 5, EDGE_HORIZONTAL = YGEnums.EDGE_HORIZONTAL = 6, EDGE_VERTICAL = YGEnums.EDGE_VERTICAL = 7, EDGE_ALL = YGEnums.EDGE_ALL = 8, EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS = YGEnums.EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS = 0, EXPERIMENTAL_FEATURE_ABSOLUTE_PERCENTAGE_AGAINST_PADDING_EDGE = YGEnums.EXPERIMENTAL_FEATURE_ABSOLUTE_PERCENTAGE_AGAINST_PADDING_EDGE = 1, EXPERIMENTAL_FEATURE_FIX_ABSOLUTE_TRAILING_COLUMN_MARGIN = YGEnums.EXPERIMENTAL_FEATURE_FIX_ABSOLUTE_TRAILING_COLUMN_MARGIN = 2, FLEX_DIRECTION_COLUMN = YGEnums.FLEX_DIRECTION_COLUMN = 0, FLEX_DIRECTION_COLUMN_REVERSE = YGEnums.FLEX_DIRECTION_COLUMN_REVERSE = 1, FLEX_DIRECTION_ROW = YGEnums.FLEX_DIRECTION_ROW = 2, FLEX_DIRECTION_ROW_REVERSE = YGEnums.FLEX_DIRECTION_ROW_REVERSE = 3, GUTTER_COLUMN = YGEnums.GUTTER_COLUMN = 0, GUTTER_ROW = YGEnums.GUTTER_ROW = 1, GUTTER_ALL = YGEnums.GUTTER_ALL = 2, JUSTIFY_FLEX_START = YGEnums.JUSTIFY_FLEX_START = 0, JUSTIFY_CENTER = YGEnums.JUSTIFY_CENTER = 1, JUSTIFY_FLEX_END = YGEnums.JUSTIFY_FLEX_END = 2, JUSTIFY_SPACE_BETWEEN = YGEnums.JUSTIFY_SPACE_BETWEEN = 3, JUSTIFY_SPACE_AROUND = YGEnums.JUSTIFY_SPACE_AROUND = 4, JUSTIFY_SPACE_EVENLY = YGEnums.JUSTIFY_SPACE_EVENLY = 5, LOG_LEVEL_ERROR = YGEnums.LOG_LEVEL_ERROR = 0, LOG_LEVEL_WARN = YGEnums.LOG_LEVEL_WARN = 1, LOG_LEVEL_INFO = YGEnums.LOG_LEVEL_INFO = 2, LOG_LEVEL_DEBUG = YGEnums.LOG_LEVEL_DEBUG = 3, LOG_LEVEL_VERBOSE = YGEnums.LOG_LEVEL_VERBOSE = 4, LOG_LEVEL_FATAL = YGEnums.LOG_LEVEL_FATAL = 5, MEASURE_MODE_UNDEFINED = YGEnums.MEASURE_MODE_UNDEFINED = 0, MEASURE_MODE_EXACTLY = YGEnums.MEASURE_MODE_EXACTLY = 1, MEASURE_MODE_AT_MOST = YGEnums.MEASURE_MODE_AT_MOST = 2, NODE_TYPE_DEFAULT = YGEnums.NODE_TYPE_DEFAULT = 0, NODE_TYPE_TEXT = YGEnums.NODE_TYPE_TEXT = 1, OVERFLOW_VISIBLE = YGEnums.OVERFLOW_VISIBLE = 0, OVERFLOW_HIDDEN = YGEnums.OVERFLOW_HIDDEN = 1, OVERFLOW_SCROLL = YGEnums.OVERFLOW_SCROLL = 2, POSITION_TYPE_STATIC = YGEnums.POSITION_TYPE_STATIC = 0, POSITION_TYPE_RELATIVE = YGEnums.POSITION_TYPE_RELATIVE = 1, POSITION_TYPE_ABSOLUTE = YGEnums.POSITION_TYPE_ABSOLUTE = 2, PRINT_OPTIONS_LAYOUT = YGEnums.PRINT_OPTIONS_LAYOUT = 1, PRINT_OPTIONS_STYLE = YGEnums.PRINT_OPTIONS_STYLE = 2, PRINT_OPTIONS_CHILDREN = YGEnums.PRINT_OPTIONS_CHILDREN = 4, UNIT_UNDEFINED = YGEnums.UNIT_UNDEFINED = 0, UNIT_POINT = YGEnums.UNIT_POINT = 1, UNIT_PERCENT = YGEnums.UNIT_PERCENT = 2, UNIT_AUTO = YGEnums.UNIT_AUTO = 3, WRAP_NO_WRAP = YGEnums.WRAP_NO_WRAP = 0, WRAP_WRAP = YGEnums.WRAP_WRAP = 1, WRAP_WRAP_REVERSE = YGEnums.WRAP_WRAP_REVERSE = 2;
var wrapAsm = (E2) => {
  function _2(E3, _3, T2) {
    let N2 = E3[_3];
    E3[_3] = function(...E4) {
      return T2.call(this, N2, ...E4);
    };
  }
  for (let T2 of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding"]) {
    let N2 = { [YGEnums.UNIT_POINT]: E2.Node.prototype[T2], [YGEnums.UNIT_PERCENT]: E2.Node.prototype[`${T2}Percent`], [YGEnums.UNIT_AUTO]: E2.Node.prototype[`${T2}Auto`] };
    _2(E2.Node.prototype, T2, function(E3, ..._3) {
      let I, L, O = _3.pop();
      if (O === "auto") I = YGEnums.UNIT_AUTO, L = void 0;
      else if (typeof O == "object") I = O.unit, L = O.valueOf();
      else if (I = typeof O == "string" && O.endsWith("%") ? YGEnums.UNIT_PERCENT : YGEnums.UNIT_POINT, L = parseFloat(O), !Number.isNaN(O) && Number.isNaN(L)) throw Error(`Invalid value ${O} for ${T2}`);
      if (!N2[I]) throw Error(`Failed to execute "${T2}": Unsupported unit '${O}'`);
      return L !== void 0 ? N2[I].call(this, ..._3, L) : N2[I].call(this, ..._3);
    });
  }
  function T(_3) {
    return E2.MeasureCallback.implement({ measure: (...E3) => {
      let { width: T2, height: N2 } = _3(...E3);
      return { width: T2 ?? NaN, height: N2 ?? NaN };
    } });
  }
  function N(_3) {
    return E2.DirtiedCallback.implement({ dirtied: _3 });
  }
  return _2(E2.Node.prototype, "setMeasureFunc", function(E3, _3) {
    return _3 ? E3.call(this, T(_3)) : this.unsetMeasureFunc();
  }), _2(E2.Node.prototype, "setDirtiedFunc", function(E3, _3) {
    E3.call(this, N(_3));
  }), _2(E2.Config.prototype, "free", function() {
    E2.Config.destroy(this);
  }), _2(E2.Node, "create", (_3, T2) => T2 ? E2.Node.createWithConfig(T2) : E2.Node.createDefault()), _2(E2.Node.prototype, "free", function() {
    E2.Node.destroy(this);
  }), _2(E2.Node.prototype, "freeRecursive", function() {
    for (let E3 = 0, _3 = this.getChildCount(); E3 < _3; ++E3) this.getChild(0).freeRecursive();
    this.free();
  }), _2(E2.Node.prototype, "calculateLayout", function(E3, _3 = NaN, T2 = NaN, N2 = YGEnums.DIRECTION_LTR) {
    return E3.call(this, _3, T2, N2);
  }), { Config: E2.Config, Node: E2.Node, ...YGEnums };
};

// ../../node_modules/.pnpm/yoga-wasm-web@0.3.3/node_modules/yoga-wasm-web/dist/index.js
var yoga = (() => {
  var n = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
  return function(t = {}) {
    u || (u = t !== void 0 ? t : {}), u.ready = new Promise(function(n2, t2) {
      c = n2, f = t2;
    });
    var r, e, a = Object.assign({}, u), i = "";
    typeof document < "u" && document.currentScript && (i = document.currentScript.src), n && (i = n), i = i.indexOf("blob:") !== 0 ? i.substr(0, i.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "";
    var o = console.log.bind(console), s = console.warn.bind(console);
    Object.assign(u, a), a = null, typeof WebAssembly != "object" && w("no native wasm support detected");
    var u, c, f, l, h = !1;
    function p(n2, t2, r2) {
      r2 = t2 + r2;
      for (var e2 = ""; !(t2 >= r2); ) {
        var a2 = n2[t2++];
        if (!a2) break;
        if (128 & a2) {
          var i2 = 63 & n2[t2++];
          if ((224 & a2) == 192) e2 += String.fromCharCode((31 & a2) << 6 | i2);
          else {
            var o2 = 63 & n2[t2++];
            65536 > (a2 = (240 & a2) == 224 ? (15 & a2) << 12 | i2 << 6 | o2 : (7 & a2) << 18 | i2 << 12 | o2 << 6 | 63 & n2[t2++]) ? e2 += String.fromCharCode(a2) : (a2 -= 65536, e2 += String.fromCharCode(55296 | a2 >> 10, 56320 | 1023 & a2));
          }
        } else e2 += String.fromCharCode(a2);
      }
      return e2;
    }
    function v() {
      var n2 = l.buffer;
      u.HEAP8 = d = new Int8Array(n2), u.HEAP16 = m = new Int16Array(n2), u.HEAP32 = g = new Int32Array(n2), u.HEAPU8 = y = new Uint8Array(n2), u.HEAPU16 = E2 = new Uint16Array(n2), u.HEAPU32 = _2 = new Uint32Array(n2), u.HEAPF32 = T = new Float32Array(n2), u.HEAPF64 = L = new Float64Array(n2);
    }
    var d, y, m, E2, g, _2, T, L, A, O = [], P = [], b = [], N = 0, I = null;
    function w(n2) {
      throw s(n2 = "Aborted(" + n2 + ")"), h = !0, f(n2 = new WebAssembly.RuntimeError(n2 + ". Build with -sASSERTIONS for more info.")), n2;
    }
    function S() {
      return r.startsWith("data:application/octet-stream;base64,");
    }
    function R() {
      try {
        throw "both async and sync fetching of the wasm failed";
      } catch (n2) {
        w(n2);
      }
    }
    function C(n2) {
      for (; 0 < n2.length; ) n2.shift()(u);
    }
    function W(n2) {
      if (n2 === void 0) return "_unknown";
      var t2 = (n2 = n2.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0);
      return 48 <= t2 && 57 >= t2 ? "_" + n2 : n2;
    }
    function U(n2, t2) {
      return n2 = W(n2), function() {
        return t2.apply(this, arguments);
      };
    }
    r = "yoga.wasm", S() || (r = i + r);
    var M = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }], F = [];
    function D(n2) {
      var t2 = Error, r2 = U(n2, function(t3) {
        this.name = n2, this.message = t3, (t3 = Error(t3).stack) !== void 0 && (this.stack = this.toString() + `
` + t3.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return r2.prototype = Object.create(t2.prototype), r2.prototype.constructor = r2, r2.prototype.toString = function() {
        return this.message === void 0 ? this.name : this.name + ": " + this.message;
      }, r2;
    }
    var k = void 0;
    function V(n2) {
      throw new k(n2);
    }
    var j = (n2) => (n2 || V("Cannot use deleted val. handle = " + n2), M[n2].value), G = (n2) => {
      switch (n2) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          var t2 = F.length ? F.pop() : M.length;
          return M[t2] = { fa: 1, value: n2 }, t2;
      }
    }, Y = void 0, X = void 0;
    function B(n2) {
      for (var t2 = ""; y[n2]; ) t2 += X[y[n2++]];
      return t2;
    }
    var H = [];
    function x() {
      for (; H.length; ) {
        var n2 = H.pop();
        n2.L.Z = !1, n2.delete();
      }
    }
    var z = void 0, $2 = {};
    function Z(n2, t2) {
      for (t2 === void 0 && V("ptr should not be undefined"); n2.P; ) t2 = n2.aa(t2), n2 = n2.P;
      return t2;
    }
    var J = {};
    function q(n2) {
      var t2 = B(n2 = nz(n2));
      return nZ(n2), t2;
    }
    function K(n2, t2) {
      var r2 = J[n2];
      return r2 === void 0 && V(t2 + " has unknown type " + q(n2)), r2;
    }
    function Q() {
    }
    var nn = !1;
    function nt(n2) {
      --n2.count.value, n2.count.value === 0 && (n2.S ? n2.T.V(n2.S) : n2.O.M.V(n2.N));
    }
    var nr = {}, ne = void 0;
    function na(n2) {
      throw new ne(n2);
    }
    function ni(n2, t2) {
      return t2.O && t2.N || na("makeClassHandle requires ptr and ptrType"), !!t2.T != !!t2.S && na("Both smartPtrType and smartPtr must be specified"), t2.count = { value: 1 }, no(Object.create(n2, { L: { value: t2 } }));
    }
    function no(n2) {
      return typeof FinalizationRegistry > "u" ? (no = (n3) => n3, n2) : (nn = new FinalizationRegistry((n3) => {
        nt(n3.L);
      }), no = (n3) => {
        var t2 = n3.L;
        return t2.S && nn.register(n3, { L: t2 }, n3), n3;
      }, Q = (n3) => {
        nn.unregister(n3);
      }, no(n2));
    }
    var ns = {};
    function nu(n2) {
      for (; n2.length; ) {
        var t2 = n2.pop();
        n2.pop()(t2);
      }
    }
    function nc(n2) {
      return this.fromWireType(g[n2 >> 2]);
    }
    var nf = {}, nl = {};
    function nh(n2, t2, r2) {
      function e2(t3) {
        (t3 = r2(t3)).length !== n2.length && na("Mismatched type converter count");
        for (var e3 = 0; e3 < n2.length; ++e3) nv(n2[e3], t3[e3]);
      }
      n2.forEach(function(n3) {
        nl[n3] = t2;
      });
      var a2 = Array(t2.length), i2 = [], o2 = 0;
      t2.forEach((n3, t3) => {
        J.hasOwnProperty(n3) ? a2[t3] = J[n3] : (i2.push(n3), nf.hasOwnProperty(n3) || (nf[n3] = []), nf[n3].push(() => {
          a2[t3] = J[n3], ++o2 === i2.length && e2(a2);
        }));
      }), i2.length === 0 && e2(a2);
    }
    function np(n2) {
      switch (n2) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw TypeError("Unknown type size: " + n2);
      }
    }
    function nv(n2, t2, r2 = {}) {
      if (!("argPackAdvance" in t2)) throw TypeError("registerType registeredInstance requires argPackAdvance");
      var e2 = t2.name;
      if (n2 || V('type "' + e2 + '" must have a positive integer typeid pointer'), J.hasOwnProperty(n2)) {
        if (r2.ta) return;
        V("Cannot register type '" + e2 + "' twice");
      }
      J[n2] = t2, delete nl[n2], nf.hasOwnProperty(n2) && (t2 = nf[n2], delete nf[n2], t2.forEach((n3) => n3()));
    }
    function nd(n2) {
      V(n2.L.O.M.name + " instance already deleted");
    }
    function ny() {
    }
    function nm(n2, t2, r2) {
      if (n2[t2].R === void 0) {
        var e2 = n2[t2];
        n2[t2] = function() {
          return n2[t2].R.hasOwnProperty(arguments.length) || V("Function '" + r2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + n2[t2].R + ")!"), n2[t2].R[arguments.length].apply(this, arguments);
        }, n2[t2].R = [], n2[t2].R[e2.Y] = e2;
      }
    }
    function nE(n2, t2, r2, e2, a2, i2, o2, s2) {
      this.name = n2, this.constructor = t2, this.W = r2, this.V = e2, this.P = a2, this.oa = i2, this.aa = o2, this.ma = s2, this.ia = [];
    }
    function ng(n2, t2, r2) {
      for (; t2 !== r2; ) t2.aa || V("Expected null or instance of " + r2.name + ", got an instance of " + t2.name), n2 = t2.aa(n2), t2 = t2.P;
      return n2;
    }
    function n_(n2, t2) {
      return t2 === null ? (this.da && V("null is not a valid " + this.name), 0) : (t2.L || V('Cannot pass "' + nC(t2) + '" as a ' + this.name), t2.L.N || V("Cannot pass deleted object as a pointer of type " + this.name), ng(t2.L.N, t2.L.O.M, this.M));
    }
    function nT(n2, t2) {
      if (t2 === null) {
        if (this.da && V("null is not a valid " + this.name), this.ca) {
          var r2 = this.ea();
          return n2 !== null && n2.push(this.V, r2), r2;
        }
        return 0;
      }
      if (t2.L || V('Cannot pass "' + nC(t2) + '" as a ' + this.name), t2.L.N || V("Cannot pass deleted object as a pointer of type " + this.name), !this.ba && t2.L.O.ba && V("Cannot convert argument of type " + (t2.L.T ? t2.L.T.name : t2.L.O.name) + " to parameter type " + this.name), r2 = ng(t2.L.N, t2.L.O.M, this.M), this.ca) switch (t2.L.S === void 0 && V("Passing raw pointer to smart pointer is illegal"), this.Aa) {
        case 0:
          t2.L.T === this ? r2 = t2.L.S : V("Cannot convert argument of type " + (t2.L.T ? t2.L.T.name : t2.L.O.name) + " to parameter type " + this.name);
          break;
        case 1:
          r2 = t2.L.S;
          break;
        case 2:
          if (t2.L.T === this) r2 = t2.L.S;
          else {
            var e2 = t2.clone();
            r2 = this.wa(r2, G(function() {
              e2.delete();
            })), n2 !== null && n2.push(this.V, r2);
          }
          break;
        default:
          V("Unsupporting sharing policy");
      }
      return r2;
    }
    function nL(n2, t2) {
      return t2 === null ? (this.da && V("null is not a valid " + this.name), 0) : (t2.L || V('Cannot pass "' + nC(t2) + '" as a ' + this.name), t2.L.N || V("Cannot pass deleted object as a pointer of type " + this.name), t2.L.O.ba && V("Cannot convert argument of type " + t2.L.O.name + " to parameter type " + this.name), ng(t2.L.N, t2.L.O.M, this.M));
    }
    function nA(n2, t2, r2, e2) {
      this.name = n2, this.M = t2, this.da = r2, this.ba = e2, this.ca = !1, this.V = this.wa = this.ea = this.ja = this.Aa = this.va = void 0, t2.P !== void 0 ? this.toWireType = nT : (this.toWireType = e2 ? n_ : nL, this.U = null);
    }
    var nO = [];
    function nP(n2) {
      var t2 = nO[n2];
      return t2 || (n2 >= nO.length && (nO.length = n2 + 1), nO[n2] = t2 = A.get(n2)), t2;
    }
    function nb(n2, t2) {
      var r2, e2, a2 = (n2 = B(n2)).includes("j") ? (r2 = n2, e2 = [], function() {
        if (e2.length = 0, Object.assign(e2, arguments), r2.includes("j")) {
          var n3 = u["dynCall_" + r2];
          n3 = e2 && e2.length ? n3.apply(null, [t2].concat(e2)) : n3.call(null, t2);
        } else n3 = nP(t2).apply(null, e2);
        return n3;
      }) : nP(t2);
      return typeof a2 != "function" && V("unknown function pointer with signature " + n2 + ": " + t2), a2;
    }
    var nN = void 0;
    function nI(n2, t2) {
      var r2 = [], e2 = {};
      throw t2.forEach(function n3(t3) {
        e2[t3] || J[t3] || (nl[t3] ? nl[t3].forEach(n3) : (r2.push(t3), e2[t3] = !0));
      }), new nN(n2 + ": " + r2.map(q).join([", "]));
    }
    function nw(n2, t2, r2, e2, a2) {
      var i2 = t2.length;
      2 > i2 && V("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var o2 = t2[1] !== null && r2 !== null, s2 = !1;
      for (r2 = 1; r2 < t2.length; ++r2) if (t2[r2] !== null && t2[r2].U === void 0) {
        s2 = !0;
        break;
      }
      var u2 = t2[0].name !== "void", c2 = i2 - 2, f2 = Array(c2), l2 = [], h2 = [];
      return function() {
        if (arguments.length !== c2 && V("function " + n2 + " called with " + arguments.length + " arguments, expected " + c2 + " args!"), h2.length = 0, l2.length = o2 ? 2 : 1, l2[0] = a2, o2) {
          var r3 = t2[1].toWireType(h2, this);
          l2[1] = r3;
        }
        for (var i3 = 0; i3 < c2; ++i3) f2[i3] = t2[i3 + 2].toWireType(h2, arguments[i3]), l2.push(f2[i3]);
        if (i3 = e2.apply(null, l2), s2) nu(h2);
        else for (var p2 = o2 ? 1 : 2; p2 < t2.length; p2++) {
          var v2 = p2 === 1 ? r3 : f2[p2 - 2];
          t2[p2].U !== null && t2[p2].U(v2);
        }
        return u2 ? t2[0].fromWireType(i3) : void 0;
      };
    }
    function nS(n2, t2) {
      for (var r2 = [], e2 = 0; e2 < n2; e2++) r2.push(_2[t2 + 4 * e2 >> 2]);
      return r2;
    }
    function nR(n2) {
      4 < n2 && --M[n2].fa == 0 && (M[n2] = void 0, F.push(n2));
    }
    function nC(n2) {
      if (n2 === null) return "null";
      var t2 = typeof n2;
      return t2 === "object" || t2 === "array" || t2 === "function" ? n2.toString() : "" + n2;
    }
    function nW(n2, t2) {
      for (var r2 = "", e2 = 0; !(e2 >= t2 / 2); ++e2) {
        var a2 = m[n2 + 2 * e2 >> 1];
        if (a2 == 0) break;
        r2 += String.fromCharCode(a2);
      }
      return r2;
    }
    function nU(n2, t2, r2) {
      if (r2 === void 0 && (r2 = 2147483647), 2 > r2) return 0;
      r2 -= 2;
      var e2 = t2;
      r2 = r2 < 2 * n2.length ? r2 / 2 : n2.length;
      for (var a2 = 0; a2 < r2; ++a2) m[t2 >> 1] = n2.charCodeAt(a2), t2 += 2;
      return m[t2 >> 1] = 0, t2 - e2;
    }
    function nM(n2) {
      return 2 * n2.length;
    }
    function nF(n2, t2) {
      for (var r2 = 0, e2 = ""; !(r2 >= t2 / 4); ) {
        var a2 = g[n2 + 4 * r2 >> 2];
        if (a2 == 0) break;
        ++r2, 65536 <= a2 ? (a2 -= 65536, e2 += String.fromCharCode(55296 | a2 >> 10, 56320 | 1023 & a2)) : e2 += String.fromCharCode(a2);
      }
      return e2;
    }
    function nD(n2, t2, r2) {
      if (r2 === void 0 && (r2 = 2147483647), 4 > r2) return 0;
      var e2 = t2;
      r2 = e2 + r2 - 4;
      for (var a2 = 0; a2 < n2.length; ++a2) {
        var i2 = n2.charCodeAt(a2);
        if (55296 <= i2 && 57343 >= i2 && (i2 = 65536 + ((1023 & i2) << 10) | 1023 & n2.charCodeAt(++a2)), g[t2 >> 2] = i2, (t2 += 4) + 4 > r2) break;
      }
      return g[t2 >> 2] = 0, t2 - e2;
    }
    function nk(n2) {
      for (var t2 = 0, r2 = 0; r2 < n2.length; ++r2) {
        var e2 = n2.charCodeAt(r2);
        55296 <= e2 && 57343 >= e2 && ++r2, t2 += 4;
      }
      return t2;
    }
    var nV = {};
    function nj(n2) {
      var t2 = nV[n2];
      return t2 === void 0 ? B(n2) : t2;
    }
    var nG = [], nY = [], nX = [null, [], []];
    k = u.BindingError = D("BindingError"), u.count_emval_handles = function() {
      for (var n2 = 0, t2 = 5; t2 < M.length; ++t2) M[t2] !== void 0 && ++n2;
      return n2;
    }, u.get_first_emval = function() {
      for (var n2 = 5; n2 < M.length; ++n2) if (M[n2] !== void 0) return M[n2];
      return null;
    }, Y = u.PureVirtualError = D("PureVirtualError");
    for (var nB = Array(256), nH = 0; 256 > nH; ++nH) nB[nH] = String.fromCharCode(nH);
    X = nB, u.getInheritedInstanceCount = function() {
      return Object.keys($2).length;
    }, u.getLiveInheritedInstances = function() {
      var n2, t2 = [];
      for (n2 in $2) $2.hasOwnProperty(n2) && t2.push($2[n2]);
      return t2;
    }, u.flushPendingDeletes = x, u.setDelayFunction = function(n2) {
      z = n2, H.length && z && z(x);
    }, ne = u.InternalError = D("InternalError"), ny.prototype.isAliasOf = function(n2) {
      if (!(this instanceof ny && n2 instanceof ny)) return !1;
      var t2 = this.L.O.M, r2 = this.L.N, e2 = n2.L.O.M;
      for (n2 = n2.L.N; t2.P; ) r2 = t2.aa(r2), t2 = t2.P;
      for (; e2.P; ) n2 = e2.aa(n2), e2 = e2.P;
      return t2 === e2 && r2 === n2;
    }, ny.prototype.clone = function() {
      if (this.L.N || nd(this), this.L.$) return this.L.count.value += 1, this;
      var n2 = no, t2 = Object, r2 = t2.create, e2 = Object.getPrototypeOf(this), a2 = this.L;
      return n2 = n2(r2.call(t2, e2, { L: { value: { count: a2.count, Z: a2.Z, $: a2.$, N: a2.N, O: a2.O, S: a2.S, T: a2.T } } })), n2.L.count.value += 1, n2.L.Z = !1, n2;
    }, ny.prototype.delete = function() {
      this.L.N || nd(this), this.L.Z && !this.L.$ && V("Object already scheduled for deletion"), Q(this), nt(this.L), this.L.$ || (this.L.S = void 0, this.L.N = void 0);
    }, ny.prototype.isDeleted = function() {
      return !this.L.N;
    }, ny.prototype.deleteLater = function() {
      return this.L.N || nd(this), this.L.Z && !this.L.$ && V("Object already scheduled for deletion"), H.push(this), H.length === 1 && z && z(x), this.L.Z = !0, this;
    }, nA.prototype.pa = function(n2) {
      return this.ja && (n2 = this.ja(n2)), n2;
    }, nA.prototype.ga = function(n2) {
      this.V && this.V(n2);
    }, nA.prototype.argPackAdvance = 8, nA.prototype.readValueFromPointer = nc, nA.prototype.deleteObject = function(n2) {
      n2 !== null && n2.delete();
    }, nA.prototype.fromWireType = function(n2) {
      function t2() {
        return this.ca ? ni(this.M.W, { O: this.va, N: e2, T: this, S: n2 }) : ni(this.M.W, { O: this, N: n2 });
      }
      var r2, e2 = this.pa(n2);
      if (!e2) return this.ga(n2), null;
      var a2 = $2[Z(this.M, e2)];
      if (a2 !== void 0) return a2.L.count.value === 0 ? (a2.L.N = e2, a2.L.S = n2, a2.clone()) : (a2 = a2.clone(), this.ga(n2), a2);
      if (!(a2 = nr[a2 = this.M.oa(e2)])) return t2.call(this);
      a2 = this.ba ? a2.ka : a2.pointerType;
      var i2 = function n3(t3, r3, e3) {
        return r3 === e3 ? t3 : e3.P === void 0 || (t3 = n3(t3, r3, e3.P)) === null ? null : e3.ma(t3);
      }(e2, this.M, a2.M);
      return i2 === null ? t2.call(this) : this.ca ? ni(a2.M.W, { O: a2, N: i2, T: this, S: n2 }) : ni(a2.M.W, { O: a2, N: i2 });
    }, nN = u.UnboundTypeError = D("UnboundTypeError");
    var nx = { q: function(n2, t2, r2) {
      n2 = B(n2), t2 = K(t2, "wrapper"), r2 = j(r2);
      var e2 = [].slice, a2 = t2.M, i2 = a2.W, o2 = a2.P.W, s2 = a2.P.constructor;
      for (var u2 in n2 = U(n2, function() {
        a2.P.ia.forEach(function(n3) {
          if (this[n3] === o2[n3]) throw new Y("Pure virtual function " + n3 + " must be implemented in JavaScript");
        }.bind(this)), Object.defineProperty(this, "__parent", { value: i2 }), this.__construct.apply(this, e2.call(arguments));
      }), i2.__construct = function() {
        this === i2 && V("Pass correct 'this' to __construct");
        var n3 = s2.implement.apply(void 0, [this].concat(e2.call(arguments)));
        Q(n3);
        var t3 = n3.L;
        n3.notifyOnDestruction(), t3.$ = !0, Object.defineProperties(this, { L: { value: t3 } }), no(this), n3 = Z(a2, n3 = t3.N), $2.hasOwnProperty(n3) ? V("Tried to register registered instance: " + n3) : $2[n3] = this;
      }, i2.__destruct = function() {
        this === i2 && V("Pass correct 'this' to __destruct"), Q(this);
        var n3 = this.L.N;
        n3 = Z(a2, n3), $2.hasOwnProperty(n3) ? delete $2[n3] : V("Tried to unregister unregistered instance: " + n3);
      }, n2.prototype = Object.create(i2), r2) n2.prototype[u2] = r2[u2];
      return G(n2);
    }, l: function(n2) {
      var t2 = ns[n2];
      delete ns[n2];
      var r2 = t2.ea, e2 = t2.V, a2 = t2.ha;
      nh([n2], a2.map((n3) => n3.sa).concat(a2.map((n3) => n3.ya)), (n3) => {
        var i2 = {};
        return a2.forEach((t3, r3) => {
          var e3 = n3[r3], o2 = t3.qa, s2 = t3.ra, u2 = n3[r3 + a2.length], c2 = t3.xa, f2 = t3.za;
          i2[t3.na] = { read: (n4) => e3.fromWireType(o2(s2, n4)), write: (n4, t4) => {
            var r4 = [];
            c2(f2, n4, u2.toWireType(r4, t4)), nu(r4);
          } };
        }), [{ name: t2.name, fromWireType: function(n4) {
          var t3, r3 = {};
          for (t3 in i2) r3[t3] = i2[t3].read(n4);
          return e2(n4), r3;
        }, toWireType: function(n4, t3) {
          for (var a3 in i2) if (!(a3 in t3)) throw TypeError('Missing field:  "' + a3 + '"');
          var o2 = r2();
          for (a3 in i2) i2[a3].write(o2, t3[a3]);
          return n4 !== null && n4.push(e2, o2), o2;
        }, argPackAdvance: 8, readValueFromPointer: nc, U: e2 }];
      });
    }, v: function() {
    }, B: function(n2, t2, r2, e2, a2) {
      var i2 = np(r2);
      nv(n2, { name: t2 = B(t2), fromWireType: function(n3) {
        return !!n3;
      }, toWireType: function(n3, t3) {
        return t3 ? e2 : a2;
      }, argPackAdvance: 8, readValueFromPointer: function(n3) {
        if (r2 === 1) var e3 = d;
        else if (r2 === 2) e3 = m;
        else if (r2 === 4) e3 = g;
        else throw TypeError("Unknown boolean type size: " + t2);
        return this.fromWireType(e3[n3 >> i2]);
      }, U: null });
    }, h: function(n2, t2, r2, e2, a2, i2, o2, s2, c2, f2, l2, h2, p2) {
      l2 = B(l2), i2 = nb(a2, i2), s2 && (s2 = nb(o2, s2)), f2 && (f2 = nb(c2, f2)), p2 = nb(h2, p2);
      var v2, d2 = W(l2);
      v2 = function() {
        nI("Cannot construct " + l2 + " due to unbound types", [e2]);
      }, u.hasOwnProperty(d2) ? (V("Cannot register public name '" + d2 + "' twice"), nm(u, d2, d2), u.hasOwnProperty(void 0) && V("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), u[d2].R[void 0] = v2) : u[d2] = v2, nh([n2, t2, r2], e2 ? [e2] : [], function(t3) {
        if (t3 = t3[0], e2) var r3, a3 = t3.M, o3 = a3.W;
        else o3 = ny.prototype;
        t3 = U(d2, function() {
          if (Object.getPrototypeOf(this) !== c3) throw new k("Use 'new' to construct " + l2);
          if (h3.X === void 0) throw new k(l2 + " has no accessible constructor");
          var n3 = h3.X[arguments.length];
          if (n3 === void 0) throw new k("Tried to invoke ctor of " + l2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(h3.X).toString() + ") parameters instead!");
          return n3.apply(this, arguments);
        });
        var c3 = Object.create(o3, { constructor: { value: t3 } });
        t3.prototype = c3;
        var h3 = new nE(l2, t3, c3, p2, a3, i2, s2, f2);
        a3 = new nA(l2, h3, !0, !1), o3 = new nA(l2 + "*", h3, !1, !1);
        var v3 = new nA(l2 + " const*", h3, !1, !0);
        return nr[n2] = { pointerType: o3, ka: v3 }, r3 = t3, u.hasOwnProperty(d2) || na("Replacing nonexistant public symbol"), u[d2] = r3, u[d2].Y = void 0, [a3, o3, v3];
      });
    }, d: function(n2, t2, r2, e2, a2, i2, o2) {
      var s2 = nS(r2, e2);
      t2 = B(t2), i2 = nb(a2, i2), nh([], [n2], function(n3) {
        function e3() {
          nI("Cannot call " + a3 + " due to unbound types", s2);
        }
        var a3 = (n3 = n3[0]).name + "." + t2;
        t2.startsWith("@@") && (t2 = Symbol[t2.substring(2)]);
        var u2 = n3.M.constructor;
        return u2[t2] === void 0 ? (e3.Y = r2 - 1, u2[t2] = e3) : (nm(u2, t2, a3), u2[t2].R[r2 - 1] = e3), nh([], s2, function(n4) {
          return n4 = nw(a3, [n4[0], null].concat(n4.slice(1)), null, i2, o2), u2[t2].R === void 0 ? (n4.Y = r2 - 1, u2[t2] = n4) : u2[t2].R[r2 - 1] = n4, [];
        }), [];
      });
    }, p: function(n2, t2, r2, e2, a2, i2) {
      0 < t2 || w();
      var o2 = nS(t2, r2);
      a2 = nb(e2, a2), nh([], [n2], function(n3) {
        var r3 = "constructor " + (n3 = n3[0]).name;
        if (n3.M.X === void 0 && (n3.M.X = []), n3.M.X[t2 - 1] !== void 0) throw new k("Cannot register multiple constructors with identical number of parameters (" + (t2 - 1) + ") for class '" + n3.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return n3.M.X[t2 - 1] = () => {
          nI("Cannot construct " + n3.name + " due to unbound types", o2);
        }, nh([], o2, function(e3) {
          return e3.splice(1, 0, null), n3.M.X[t2 - 1] = nw(r3, e3, null, a2, i2), [];
        }), [];
      });
    }, a: function(n2, t2, r2, e2, a2, i2, o2, s2) {
      var u2 = nS(r2, e2);
      t2 = B(t2), i2 = nb(a2, i2), nh([], [n2], function(n3) {
        function e3() {
          nI("Cannot call " + a3 + " due to unbound types", u2);
        }
        var a3 = (n3 = n3[0]).name + "." + t2;
        t2.startsWith("@@") && (t2 = Symbol[t2.substring(2)]), s2 && n3.M.ia.push(t2);
        var c2 = n3.M.W, f2 = c2[t2];
        return f2 === void 0 || f2.R === void 0 && f2.className !== n3.name && f2.Y === r2 - 2 ? (e3.Y = r2 - 2, e3.className = n3.name, c2[t2] = e3) : (nm(c2, t2, a3), c2[t2].R[r2 - 2] = e3), nh([], u2, function(e4) {
          return e4 = nw(a3, e4, n3, i2, o2), c2[t2].R === void 0 ? (e4.Y = r2 - 2, c2[t2] = e4) : c2[t2].R[r2 - 2] = e4, [];
        }), [];
      });
    }, A: function(n2, t2) {
      nv(n2, { name: t2 = B(t2), fromWireType: function(n3) {
        var t3 = j(n3);
        return nR(n3), t3;
      }, toWireType: function(n3, t3) {
        return G(t3);
      }, argPackAdvance: 8, readValueFromPointer: nc, U: null });
    }, n: function(n2, t2, r2) {
      r2 = np(r2), nv(n2, { name: t2 = B(t2), fromWireType: function(n3) {
        return n3;
      }, toWireType: function(n3, t3) {
        return t3;
      }, argPackAdvance: 8, readValueFromPointer: function(n3, t3) {
        switch (t3) {
          case 2:
            return function(n4) {
              return this.fromWireType(T[n4 >> 2]);
            };
          case 3:
            return function(n4) {
              return this.fromWireType(L[n4 >> 3]);
            };
          default:
            throw TypeError("Unknown float type: " + n3);
        }
      }(t2, r2), U: null });
    }, e: function(n2, t2, r2, e2, a2) {
      t2 = B(t2), a2 === -1 && (a2 = 4294967295), a2 = np(r2);
      var i2 = (n3) => n3;
      if (e2 === 0) {
        var o2 = 32 - 8 * r2;
        i2 = (n3) => n3 << o2 >>> o2;
      }
      r2 = t2.includes("unsigned") ? function(n3, t3) {
        return t3 >>> 0;
      } : function(n3, t3) {
        return t3;
      }, nv(n2, { name: t2, fromWireType: i2, toWireType: r2, argPackAdvance: 8, readValueFromPointer: function(n3, t3, r3) {
        switch (t3) {
          case 0:
            return r3 ? function(n4) {
              return d[n4];
            } : function(n4) {
              return y[n4];
            };
          case 1:
            return r3 ? function(n4) {
              return m[n4 >> 1];
            } : function(n4) {
              return E2[n4 >> 1];
            };
          case 2:
            return r3 ? function(n4) {
              return g[n4 >> 2];
            } : function(n4) {
              return _2[n4 >> 2];
            };
          default:
            throw TypeError("Unknown integer type: " + n3);
        }
      }(t2, a2, e2 !== 0), U: null });
    }, b: function(n2, t2, r2) {
      function e2(n3) {
        n3 >>= 2;
        var t3 = _2;
        return new a2(t3.buffer, t3[n3 + 1], t3[n3]);
      }
      var a2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][t2];
      nv(n2, { name: r2 = B(r2), fromWireType: e2, argPackAdvance: 8, readValueFromPointer: e2 }, { ta: !0 });
    }, o: function(n2, t2) {
      var r2 = (t2 = B(t2)) === "std::string";
      nv(n2, { name: t2, fromWireType: function(n3) {
        var t3 = _2[n3 >> 2], e2 = n3 + 4;
        if (r2) for (var a2 = e2, i2 = 0; i2 <= t3; ++i2) {
          var o2 = e2 + i2;
          if (i2 == t3 || y[o2] == 0) {
            if (a2 = a2 ? p(y, a2, o2 - a2) : "", s2 === void 0) var s2 = a2;
            else s2 += "\0" + a2;
            a2 = o2 + 1;
          }
        }
        else {
          for (i2 = 0, s2 = Array(t3); i2 < t3; ++i2) s2[i2] = String.fromCharCode(y[e2 + i2]);
          s2 = s2.join("");
        }
        return nZ(n3), s2;
      }, toWireType: function(n3, t3) {
        t3 instanceof ArrayBuffer && (t3 = new Uint8Array(t3));
        var e2, a2 = typeof t3 == "string";
        if (a2 || t3 instanceof Uint8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int8Array || V("Cannot pass non-string to std::string"), r2 && a2) {
          var i2 = 0;
          for (e2 = 0; e2 < t3.length; ++e2) {
            var o2 = t3.charCodeAt(e2);
            127 >= o2 ? i2++ : 2047 >= o2 ? i2 += 2 : 55296 <= o2 && 57343 >= o2 ? (i2 += 4, ++e2) : i2 += 3;
          }
          e2 = i2;
        } else e2 = t3.length;
        if (o2 = (i2 = n$(4 + e2 + 1)) + 4, _2[i2 >> 2] = e2, r2 && a2) {
          if (a2 = o2, o2 = e2 + 1, e2 = y, 0 < o2) {
            o2 = a2 + o2 - 1;
            for (var s2 = 0; s2 < t3.length; ++s2) {
              var u2 = t3.charCodeAt(s2);
              if (55296 <= u2 && 57343 >= u2 && (u2 = 65536 + ((1023 & u2) << 10) | 1023 & t3.charCodeAt(++s2)), 127 >= u2) {
                if (a2 >= o2) break;
                e2[a2++] = u2;
              } else {
                if (2047 >= u2) {
                  if (a2 + 1 >= o2) break;
                  e2[a2++] = 192 | u2 >> 6;
                } else {
                  if (65535 >= u2) {
                    if (a2 + 2 >= o2) break;
                    e2[a2++] = 224 | u2 >> 12;
                  } else {
                    if (a2 + 3 >= o2) break;
                    e2[a2++] = 240 | u2 >> 18, e2[a2++] = 128 | u2 >> 12 & 63;
                  }
                  e2[a2++] = 128 | u2 >> 6 & 63;
                }
                e2[a2++] = 128 | 63 & u2;
              }
            }
            e2[a2] = 0;
          }
        } else if (a2) for (a2 = 0; a2 < e2; ++a2) 255 < (s2 = t3.charCodeAt(a2)) && (nZ(o2), V("String has UTF-16 code units that do not fit in 8 bits")), y[o2 + a2] = s2;
        else for (a2 = 0; a2 < e2; ++a2) y[o2 + a2] = t3[a2];
        return n3 !== null && n3.push(nZ, i2), i2;
      }, argPackAdvance: 8, readValueFromPointer: nc, U: function(n3) {
        nZ(n3);
      } });
    }, k: function(n2, t2, r2) {
      if (r2 = B(r2), t2 === 2) var e2 = nW, a2 = nU, i2 = nM, o2 = () => E2, s2 = 1;
      else t2 === 4 && (e2 = nF, a2 = nD, i2 = nk, o2 = () => _2, s2 = 2);
      nv(n2, { name: r2, fromWireType: function(n3) {
        for (var r3, a3 = _2[n3 >> 2], i3 = o2(), u2 = n3 + 4, c2 = 0; c2 <= a3; ++c2) {
          var f2 = n3 + 4 + c2 * t2;
          (c2 == a3 || i3[f2 >> s2] == 0) && (u2 = e2(u2, f2 - u2), r3 === void 0 ? r3 = u2 : r3 += "\0" + u2, u2 = f2 + t2);
        }
        return nZ(n3), r3;
      }, toWireType: function(n3, e3) {
        typeof e3 != "string" && V("Cannot pass non-string to C++ string type " + r2);
        var o3 = i2(e3), u2 = n$(4 + o3 + t2);
        return _2[u2 >> 2] = o3 >> s2, a2(e3, u2 + 4, o3 + t2), n3 !== null && n3.push(nZ, u2), u2;
      }, argPackAdvance: 8, readValueFromPointer: nc, U: function(n3) {
        nZ(n3);
      } });
    }, m: function(n2, t2, r2, e2, a2, i2) {
      ns[n2] = { name: B(t2), ea: nb(r2, e2), V: nb(a2, i2), ha: [] };
    }, c: function(n2, t2, r2, e2, a2, i2, o2, s2, u2, c2) {
      ns[n2].ha.push({ na: B(t2), sa: r2, qa: nb(e2, a2), ra: i2, ya: o2, xa: nb(s2, u2), za: c2 });
    }, C: function(n2, t2) {
      nv(n2, { ua: !0, name: t2 = B(t2), argPackAdvance: 0, fromWireType: function() {
      }, toWireType: function() {
      } });
    }, t: function(n2, t2, r2, e2, a2) {
      n2 = nG[n2], t2 = j(t2), r2 = nj(r2);
      var i2 = [];
      return _2[e2 >> 2] = G(i2), n2(t2, r2, i2, a2);
    }, j: function(n2, t2, r2, e2) {
      n2 = nG[n2], n2(t2 = j(t2), r2 = nj(r2), null, e2);
    }, f: nR, g: function(n2, t2) {
      var r2, e2, a2 = function(n3, t3) {
        for (var r3 = Array(n3), e3 = 0; e3 < n3; ++e3) r3[e3] = K(_2[t3 + 4 * e3 >> 2], "parameter " + e3);
        return r3;
      }(n2, t2), i2 = a2[0], o2 = nY[t2 = i2.name + "_$" + a2.slice(1).map(function(n3) {
        return n3.name;
      }).join("_") + "$"];
      if (o2 !== void 0) return o2;
      var s2 = Array(n2 - 1);
      return r2 = (t3, r3, e3, o3) => {
        for (var u2 = 0, c2 = 0; c2 < n2 - 1; ++c2) s2[c2] = a2[c2 + 1].readValueFromPointer(o3 + u2), u2 += a2[c2 + 1].argPackAdvance;
        for (c2 = 0, t3 = t3[r3].apply(t3, s2); c2 < n2 - 1; ++c2) a2[c2 + 1].la && a2[c2 + 1].la(s2[c2]);
        if (!i2.ua) return i2.toWireType(e3, t3);
      }, e2 = nG.length, nG.push(r2), o2 = e2, nY[t2] = o2;
    }, r: function(n2) {
      4 < n2 && (M[n2].fa += 1);
    }, s: function(n2) {
      nu(j(n2)), nR(n2);
    }, i: function() {
      w("");
    }, x: function(n2, t2, r2) {
      y.copyWithin(n2, t2, t2 + r2);
    }, w: function(n2) {
      var t2 = y.length;
      if (2147483648 < (n2 >>>= 0)) return !1;
      for (var r2 = 1; 4 >= r2; r2 *= 2) {
        var e2 = t2 * (1 + 0.2 / r2);
        e2 = Math.min(e2, n2 + 100663296);
        var a2 = Math, i2 = a2.min;
        e2 = Math.max(n2, e2), e2 += (65536 - e2 % 65536) % 65536;
        n: {
          var o2 = l.buffer;
          try {
            l.grow(i2.call(a2, 2147483648, e2) - o2.byteLength + 65535 >>> 16), v();
            var s2 = 1;
            break n;
          } catch {
          }
          s2 = void 0;
        }
        if (s2) return !0;
      }
      return !1;
    }, z: function() {
      return 52;
    }, u: function() {
      return 70;
    }, y: function(n2, t2, r2, e2) {
      for (var a2 = 0, i2 = 0; i2 < r2; i2++) {
        var u2 = _2[t2 >> 2], c2 = _2[t2 + 4 >> 2];
        t2 += 8;
        for (var f2 = 0; f2 < c2; f2++) {
          var l2 = y[u2 + f2], h2 = nX[n2];
          l2 === 0 || l2 === 10 ? ((n2 === 1 ? o : s)(p(h2, 0)), h2.length = 0) : h2.push(l2);
        }
        a2 += c2;
      }
      return _2[e2 >> 2] = a2, 0;
    } };
    (function() {
      function n2(n3) {
        u.asm = n3.exports, l = u.asm.D, v(), A = u.asm.I, P.unshift(u.asm.E), --N == 0 && I && (n3 = I, I = null, n3());
      }
      function t2(t3) {
        n2(t3.instance);
      }
      function e2(n3) {
        return (typeof fetch == "function" ? fetch(r, { credentials: "same-origin" }).then(function(n4) {
          if (!n4.ok) throw "failed to load wasm binary file at '" + r + "'";
          return n4.arrayBuffer();
        }).catch(function() {
          return R();
        }) : Promise.resolve().then(function() {
          return R();
        })).then(function(n4) {
          return WebAssembly.instantiate(n4, a2);
        }).then(function(n4) {
          return n4;
        }).then(n3, function(n4) {
          s("failed to asynchronously prepare wasm: " + n4), w(n4);
        });
      }
      var a2 = { a: nx };
      if (N++, u.instantiateWasm) try {
        return u.instantiateWasm(a2, n2);
      } catch (n3) {
        s("Module.instantiateWasm callback failed with error: " + n3), f(n3);
      }
      (typeof WebAssembly.instantiateStreaming != "function" || S() || typeof fetch != "function" ? e2(t2) : fetch(r, { credentials: "same-origin" }).then(function(n3) {
        return WebAssembly.instantiateStreaming(n3, a2).then(t2, function(n4) {
          return s("wasm streaming compile failed: " + n4), s("falling back to ArrayBuffer instantiation"), e2(t2);
        });
      })).catch(f);
    })();
    var nz = u.___getTypeName = function() {
      return (nz = u.___getTypeName = u.asm.F).apply(null, arguments);
    };
    function n$() {
      return (n$ = u.asm.H).apply(null, arguments);
    }
    function nZ() {
      return (nZ = u.asm.J).apply(null, arguments);
    }
    function nJ() {
      0 < N || (C(O), 0 < N || e || (e = !0, u.calledRun = !0, h || (C(P), c(u), C(b))));
    }
    return u.__embind_initialize_bindings = function() {
      return (u.__embind_initialize_bindings = u.asm.G).apply(null, arguments);
    }, u.dynCall_jiji = function() {
      return (u.dynCall_jiji = u.asm.K).apply(null, arguments);
    }, I = function n2() {
      e || nJ(), e || (I = n2);
    }, nJ(), t.ready;
  };
})();
async function initYoga(t) {
  let r = await yoga({ instantiateWasm(n, r2) {
    WebAssembly.instantiate(t, n).then((n2) => {
      n2 instanceof WebAssembly.Instance ? r2(n2) : r2(n2.instance);
    });
  } });
  return wrapAsm(r);
}

// ../../node_modules/.pnpm/yoga-wasm-web@0.3.3/node_modules/yoga-wasm-web/dist/node.js
var Yoga = await initYoga(await E(_(import.meta.url).resolve("./yoga.wasm")));

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/reconciler.js
init_cjs_shims();
var import_react_reconciler = __toESM(require_react_reconciler(), 1), import_constants2 = __toESM(require_constants(), 1);
import process10 from "node:process";

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/dom.js
init_cjs_shims();

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/measure-text.js
init_cjs_shims();

// ../../node_modules/.pnpm/widest-line@4.0.1/node_modules/widest-line/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/string-width@5.1.2/node_modules/string-width/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/ansi-regex@6.1.0/node_modules/ansi-regex/index.js
init_cjs_shims();
function ansiRegex({ onlyFirst = !1 } = {}) {
  let pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
}

// ../../node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js
var regex = ansiRegex();
function stripAnsi(string) {
  if (typeof string != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
  return string.replace(regex, "");
}

// ../../node_modules/.pnpm/string-width@5.1.2/node_modules/string-width/index.js
var import_eastasianwidth = __toESM(require_eastasianwidth(), 1), import_emoji_regex = __toESM(require_emoji_regex(), 1);
function stringWidth(string, options = {}) {
  if (typeof string != "string" || string.length === 0 || (options = {
    ambiguousIsNarrow: !0,
    ...options
  }, string = stripAnsi(string), string.length === 0))
    return 0;
  string = string.replace((0, import_emoji_regex.default)(), "  ");
  let ambiguousCharacterWidth = options.ambiguousIsNarrow ? 1 : 2, width = 0;
  for (let character of string) {
    let codePoint = character.codePointAt(0);
    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159 || codePoint >= 768 && codePoint <= 879)
      continue;
    switch (import_eastasianwidth.default.eastAsianWidth(character)) {
      case "F":
      case "W":
        width += 2;
        break;
      case "A":
        width += ambiguousCharacterWidth;
        break;
      default:
        width += 1;
    }
  }
  return width;
}

// ../../node_modules/.pnpm/widest-line@4.0.1/node_modules/widest-line/index.js
function widestLine(string) {
  let lineWidth = 0;
  for (let line of string.split(`
`))
    lineWidth = Math.max(lineWidth, stringWidth(line));
  return lineWidth;
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/measure-text.js
var cache = {}, measureText = (text) => {
  if (text.length === 0)
    return {
      width: 0,
      height: 0
    };
  let cachedDimensions = cache[text];
  if (cachedDimensions)
    return cachedDimensions;
  let width = widestLine(text), height = text.split(`
`).length;
  return cache[text] = { width, height }, { width, height };
}, measure_text_default = measureText;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/wrap-text.js
init_cjs_shims();

// ../../node_modules/.pnpm/wrap-ansi@8.1.0/node_modules/wrap-ansi/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/ansi-styles@6.2.1/node_modules/ansi-styles/index.js
init_cjs_shims();
var wrapAnsi162 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi2562 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m2 = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles3 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, modifierNames2 = Object.keys(styles3.modifier), foregroundColorNames2 = Object.keys(styles3.color), backgroundColorNames2 = Object.keys(styles3.bgColor), colorNames2 = [...foregroundColorNames2, ...backgroundColorNames2];
function assembleStyles2() {
  let codes = /* @__PURE__ */ new Map();
  for (let [groupName, group] of Object.entries(styles3)) {
    for (let [styleName, style] of Object.entries(group))
      styles3[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      }, group[styleName] = styles3[styleName], codes.set(style[0], style[1]);
    Object.defineProperty(styles3, groupName, {
      value: group,
      enumerable: !1
    });
  }
  return Object.defineProperty(styles3, "codes", {
    value: codes,
    enumerable: !1
  }), styles3.color.close = "\x1B[39m", styles3.bgColor.close = "\x1B[49m", styles3.color.ansi = wrapAnsi162(), styles3.color.ansi256 = wrapAnsi2562(), styles3.color.ansi16m = wrapAnsi16m2(), styles3.bgColor.ansi = wrapAnsi162(10), styles3.bgColor.ansi256 = wrapAnsi2562(10), styles3.bgColor.ansi16m = wrapAnsi16m2(10), Object.defineProperties(styles3, {
    rgbToAnsi256: {
      value: (red, green, blue) => red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5),
      enumerable: !1
    },
    hexToRgb: {
      value: (hex) => {
        let matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches)
          return [0, 0, 0];
        let [colorString] = matches;
        colorString.length === 3 && (colorString = [...colorString].map((character) => character + character).join(""));
        let integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value: (code) => {
        if (code < 8)
          return 30 + code;
        if (code < 16)
          return 90 + (code - 8);
        let red, green, blue;
        if (code >= 232)
          red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
        else {
          code -= 16;
          let remainder = code % 36;
          red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
        }
        let value = Math.max(red, green, blue) * 2;
        if (value === 0)
          return 30;
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        return value === 2 && (result += 60), result;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles3.ansi256ToAnsi(styles3.rgbToAnsi256(red, green, blue)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (hex) => styles3.ansi256ToAnsi(styles3.hexToAnsi256(hex)),
      enumerable: !1
    }
  }), styles3;
}
var ansiStyles2 = assembleStyles2(), ansi_styles_default2 = ansiStyles2;

// ../../node_modules/.pnpm/wrap-ansi@8.1.0/node_modules/wrap-ansi/index.js
var ESCAPES = /* @__PURE__ */ new Set([
  "\x1B",
  "\x9B"
]), END_CODE = 39, ANSI_ESCAPE_BELL = "\x07", ANSI_CSI = "[", ANSI_OSC = "]", ANSI_SGR_TERMINATOR = "m", ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`, wrapAnsiCode = (code) => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`, wrapAnsiHyperlink = (uri) => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`, wordLengths = (string) => string.split(" ").map((character) => stringWidth(character)), wrapWord = (rows, word, columns) => {
  let characters = [...word], isInsideEscape = !1, isInsideLinkEscape = !1, visible = stringWidth(stripAnsi(rows[rows.length - 1]));
  for (let [index, character] of characters.entries()) {
    let characterLength = stringWidth(character);
    if (visible + characterLength <= columns ? rows[rows.length - 1] += character : (rows.push(character), visible = 0), ESCAPES.has(character) && (isInsideEscape = !0, isInsideLinkEscape = characters.slice(index + 1).join("").startsWith(ANSI_ESCAPE_LINK)), isInsideEscape) {
      isInsideLinkEscape ? character === ANSI_ESCAPE_BELL && (isInsideEscape = !1, isInsideLinkEscape = !1) : character === ANSI_SGR_TERMINATOR && (isInsideEscape = !1);
      continue;
    }
    visible += characterLength, visible === columns && index < characters.length - 1 && (rows.push(""), visible = 0);
  }
  !visible && rows[rows.length - 1].length > 0 && rows.length > 1 && (rows[rows.length - 2] += rows.pop());
}, stringVisibleTrimSpacesRight = (string) => {
  let words = string.split(" "), last = words.length;
  for (; last > 0 && !(stringWidth(words[last - 1]) > 0); )
    last--;
  return last === words.length ? string : words.slice(0, last).join(" ") + words.slice(last).join("");
}, exec3 = (string, columns, options = {}) => {
  if (options.trim !== !1 && string.trim() === "")
    return "";
  let returnValue = "", escapeCode, escapeUrl, lengths = wordLengths(string), rows = [""];
  for (let [index, word] of string.split(" ").entries()) {
    options.trim !== !1 && (rows[rows.length - 1] = rows[rows.length - 1].trimStart());
    let rowLength = stringWidth(rows[rows.length - 1]);
    if (index !== 0 && (rowLength >= columns && (options.wordWrap === !1 || options.trim === !1) && (rows.push(""), rowLength = 0), (rowLength > 0 || options.trim === !1) && (rows[rows.length - 1] += " ", rowLength++)), options.hard && lengths[index] > columns) {
      let remainingColumns = columns - rowLength, breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
      Math.floor((lengths[index] - 1) / columns) < breaksStartingThisLine && rows.push(""), wrapWord(rows, word, columns);
      continue;
    }
    if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
      if (options.wordWrap === !1 && rowLength < columns) {
        wrapWord(rows, word, columns);
        continue;
      }
      rows.push("");
    }
    if (rowLength + lengths[index] > columns && options.wordWrap === !1) {
      wrapWord(rows, word, columns);
      continue;
    }
    rows[rows.length - 1] += word;
  }
  options.trim !== !1 && (rows = rows.map((row) => stringVisibleTrimSpacesRight(row)));
  let pre = [...rows.join(`
`)];
  for (let [index, character] of pre.entries()) {
    if (returnValue += character, ESCAPES.has(character)) {
      let { groups } = new RegExp(`(?:\\${ANSI_CSI}(?<code>\\d+)m|\\${ANSI_ESCAPE_LINK}(?<uri>.*)${ANSI_ESCAPE_BELL})`).exec(pre.slice(index).join("")) || { groups: {} };
      if (groups.code !== void 0) {
        let code2 = Number.parseFloat(groups.code);
        escapeCode = code2 === END_CODE ? void 0 : code2;
      } else groups.uri !== void 0 && (escapeUrl = groups.uri.length === 0 ? void 0 : groups.uri);
    }
    let code = ansi_styles_default2.codes.get(Number(escapeCode));
    pre[index + 1] === `
` ? (escapeUrl && (returnValue += wrapAnsiHyperlink("")), escapeCode && code && (returnValue += wrapAnsiCode(code))) : character === `
` && (escapeCode && code && (returnValue += wrapAnsiCode(escapeCode)), escapeUrl && (returnValue += wrapAnsiHyperlink(escapeUrl)));
  }
  return returnValue;
};
function wrapAnsi(string, columns, options) {
  return String(string).normalize().replace(/\r\n/g, `
`).split(`
`).map((line) => exec3(line, columns, options)).join(`
`);
}

// ../../node_modules/.pnpm/cli-truncate@3.1.0/node_modules/cli-truncate/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/slice-ansi@5.0.0/node_modules/slice-ansi/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/is-fullwidth-code-point@4.0.0/node_modules/is-fullwidth-code-point/index.js
init_cjs_shims();
function isFullwidthCodePoint(codePoint) {
  return Number.isInteger(codePoint) ? codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
  codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
  codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
  43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
  44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
  63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
  65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
  110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
  127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= codePoint && codePoint <= 262141) : !1;
}

// ../../node_modules/.pnpm/ansi-styles@6.2.3/node_modules/ansi-styles/index.js
init_cjs_shims();
var wrapAnsi163 = (offset = 0) => (code) => `\x1B[${code + offset}m`, wrapAnsi2563 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`, wrapAnsi16m3 = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`, styles4 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, modifierNames3 = Object.keys(styles4.modifier), foregroundColorNames3 = Object.keys(styles4.color), backgroundColorNames3 = Object.keys(styles4.bgColor), colorNames3 = [...foregroundColorNames3, ...backgroundColorNames3];
function assembleStyles3() {
  let codes = /* @__PURE__ */ new Map();
  for (let [groupName, group] of Object.entries(styles4)) {
    for (let [styleName, style] of Object.entries(group))
      styles4[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      }, group[styleName] = styles4[styleName], codes.set(style[0], style[1]);
    Object.defineProperty(styles4, groupName, {
      value: group,
      enumerable: !1
    });
  }
  return Object.defineProperty(styles4, "codes", {
    value: codes,
    enumerable: !1
  }), styles4.color.close = "\x1B[39m", styles4.bgColor.close = "\x1B[49m", styles4.color.ansi = wrapAnsi163(), styles4.color.ansi256 = wrapAnsi2563(), styles4.color.ansi16m = wrapAnsi16m3(), styles4.bgColor.ansi = wrapAnsi163(10), styles4.bgColor.ansi256 = wrapAnsi2563(10), styles4.bgColor.ansi16m = wrapAnsi16m3(10), Object.defineProperties(styles4, {
    rgbToAnsi256: {
      value(red, green, blue) {
        return red === green && green === blue ? red < 8 ? 16 : red > 248 ? 231 : Math.round((red - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(hex) {
        let matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches)
          return [0, 0, 0];
        let [colorString] = matches;
        colorString.length === 3 && (colorString = [...colorString].map((character) => character + character).join(""));
        let integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (hex) => styles4.rgbToAnsi256(...styles4.hexToRgb(hex)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8)
          return 30 + code;
        if (code < 16)
          return 90 + (code - 8);
        let red, green, blue;
        if (code >= 232)
          red = ((code - 232) * 10 + 8) / 255, green = red, blue = red;
        else {
          code -= 16;
          let remainder = code % 36;
          red = Math.floor(code / 36) / 5, green = Math.floor(remainder / 6) / 5, blue = remainder % 6 / 5;
        }
        let value = Math.max(red, green, blue) * 2;
        if (value === 0)
          return 30;
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        return value === 2 && (result += 60), result;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles4.ansi256ToAnsi(styles4.rgbToAnsi256(red, green, blue)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (hex) => styles4.ansi256ToAnsi(styles4.hexToAnsi256(hex)),
      enumerable: !1
    }
  }), styles4;
}
var ansiStyles3 = assembleStyles3(), ansi_styles_default3 = ansiStyles3;

// ../../node_modules/.pnpm/slice-ansi@5.0.0/node_modules/slice-ansi/index.js
var astralRegex = /^[\uD800-\uDBFF][\uDC00-\uDFFF]$/, ESCAPES2 = [
  "\x1B",
  "\x9B"
], wrapAnsi2 = (code) => `${ESCAPES2[0]}[${code}m`, checkAnsi = (ansiCodes, isEscapes, endAnsiCode) => {
  let output2 = [];
  ansiCodes = [...ansiCodes];
  for (let ansiCode of ansiCodes) {
    let ansiCodeOrigin = ansiCode;
    ansiCode.includes(";") && (ansiCode = ansiCode.split(";")[0][0] + "0");
    let item = ansi_styles_default3.codes.get(Number.parseInt(ansiCode, 10));
    if (item) {
      let indexEscape = ansiCodes.indexOf(item.toString());
      indexEscape === -1 ? output2.push(wrapAnsi2(isEscapes ? item : ansiCodeOrigin)) : ansiCodes.splice(indexEscape, 1);
    } else if (isEscapes) {
      output2.push(wrapAnsi2(0));
      break;
    } else
      output2.push(wrapAnsi2(ansiCodeOrigin));
  }
  if (isEscapes && (output2 = output2.filter((element, index) => output2.indexOf(element) === index), endAnsiCode !== void 0)) {
    let fistEscapeCode = wrapAnsi2(ansi_styles_default3.codes.get(Number.parseInt(endAnsiCode, 10)));
    output2 = output2.reduce((current, next) => next === fistEscapeCode ? [next, ...current] : [...current, next], []);
  }
  return output2.join("");
};
function sliceAnsi(string, begin, end) {
  let characters = [...string], ansiCodes = [], stringEnd = typeof end == "number" ? end : characters.length, isInsideEscape = !1, ansiCode, visible = 0, output2 = "";
  for (let [index, character] of characters.entries()) {
    let leftEscape = !1;
    if (ESCAPES2.includes(character)) {
      let code = /\d[^m]*/.exec(string.slice(index, index + 18));
      ansiCode = code && code.length > 0 ? code[0] : void 0, visible < stringEnd && (isInsideEscape = !0, ansiCode !== void 0 && ansiCodes.push(ansiCode));
    } else isInsideEscape && character === "m" && (isInsideEscape = !1, leftEscape = !0);
    if (!isInsideEscape && !leftEscape && visible++, !astralRegex.test(character) && isFullwidthCodePoint(character.codePointAt()) && (visible++, typeof end != "number" && stringEnd++), visible > begin && visible <= stringEnd)
      output2 += character;
    else if (visible === begin && !isInsideEscape && ansiCode !== void 0)
      output2 = checkAnsi(ansiCodes);
    else if (visible >= stringEnd) {
      output2 += checkAnsi(ansiCodes, !0, ansiCode);
      break;
    }
  }
  return output2;
}

// ../../node_modules/.pnpm/cli-truncate@3.1.0/node_modules/cli-truncate/index.js
function getIndexOfNearestSpace(string, wantedIndex, shouldSearchRight) {
  if (string.charAt(wantedIndex) === " ")
    return wantedIndex;
  for (let index = 1; index <= 3; index++)
    if (shouldSearchRight) {
      if (string.charAt(wantedIndex + index) === " ")
        return wantedIndex + index;
    } else if (string.charAt(wantedIndex - index) === " ")
      return wantedIndex - index;
  return wantedIndex;
}
function cliTruncate(text, columns, options) {
  options = {
    position: "end",
    preferTruncationOnSpace: !1,
    truncationCharacter: "\u2026",
    ...options
  };
  let { position, space, preferTruncationOnSpace } = options, { truncationCharacter } = options;
  if (typeof text != "string")
    throw new TypeError(`Expected \`input\` to be a string, got ${typeof text}`);
  if (typeof columns != "number")
    throw new TypeError(`Expected \`columns\` to be a number, got ${typeof columns}`);
  if (columns < 1)
    return "";
  if (columns === 1)
    return truncationCharacter;
  let length = stringWidth(text);
  if (length <= columns)
    return text;
  if (position === "start") {
    if (preferTruncationOnSpace) {
      let nearestSpace = getIndexOfNearestSpace(text, length - columns + 1, !0);
      return truncationCharacter + sliceAnsi(text, nearestSpace, length).trim();
    }
    return space === !0 && (truncationCharacter += " "), truncationCharacter + sliceAnsi(text, length - columns + stringWidth(truncationCharacter), length);
  }
  if (position === "middle") {
    space === !0 && (truncationCharacter = ` ${truncationCharacter} `);
    let half = Math.floor(columns / 2);
    if (preferTruncationOnSpace) {
      let spaceNearFirstBreakPoint = getIndexOfNearestSpace(text, half), spaceNearSecondBreakPoint = getIndexOfNearestSpace(text, length - (columns - half) + 1, !0);
      return sliceAnsi(text, 0, spaceNearFirstBreakPoint) + truncationCharacter + sliceAnsi(text, spaceNearSecondBreakPoint, length).trim();
    }
    return sliceAnsi(text, 0, half) + truncationCharacter + sliceAnsi(text, length - (columns - half) + stringWidth(truncationCharacter), length);
  }
  if (position === "end") {
    if (preferTruncationOnSpace) {
      let nearestSpace = getIndexOfNearestSpace(text, columns - 1);
      return sliceAnsi(text, 0, nearestSpace) + truncationCharacter;
    }
    return space === !0 && (truncationCharacter = ` ${truncationCharacter}`), sliceAnsi(text, 0, columns - stringWidth(truncationCharacter)) + truncationCharacter;
  }
  throw new Error(`Expected \`options.position\` to be either \`start\`, \`middle\` or \`end\`, got ${position}`);
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/wrap-text.js
var cache2 = {}, wrapText = (text, maxWidth, wrapType) => {
  let cacheKey = text + String(maxWidth) + String(wrapType), cachedText = cache2[cacheKey];
  if (cachedText)
    return cachedText;
  let wrappedText = text;
  if (wrapType === "wrap" && (wrappedText = wrapAnsi(text, maxWidth, {
    trim: !1,
    hard: !0
  })), wrapType.startsWith("truncate")) {
    let position = "end";
    wrapType === "truncate-middle" && (position = "middle"), wrapType === "truncate-start" && (position = "start"), wrappedText = cliTruncate(text, maxWidth, { position });
  }
  return cache2[cacheKey] = wrappedText, wrappedText;
}, wrap_text_default = wrapText;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/squash-text-nodes.js
init_cjs_shims();
var squashTextNodes = (node) => {
  let text = "";
  for (let index = 0; index < node.childNodes.length; index++) {
    let childNode = node.childNodes[index];
    if (childNode === void 0)
      continue;
    let nodeText = "";
    childNode.nodeName === "#text" ? nodeText = childNode.nodeValue : ((childNode.nodeName === "ink-text" || childNode.nodeName === "ink-virtual-text") && (nodeText = squashTextNodes(childNode)), nodeText.length > 0 && typeof childNode.internal_transform == "function" && (nodeText = childNode.internal_transform(nodeText, index))), text += nodeText;
  }
  return text;
}, squash_text_nodes_default = squashTextNodes;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/dom.js
var createNode = (nodeName) => {
  let node = {
    nodeName,
    style: {},
    attributes: {},
    childNodes: [],
    parentNode: void 0,
    yogaNode: nodeName === "ink-virtual-text" ? void 0 : Yoga.Node.create()
  };
  return nodeName === "ink-text" && node.yogaNode?.setMeasureFunc(measureTextNode.bind(null, node)), node;
}, appendChildNode = (node, childNode) => {
  childNode.parentNode && removeChildNode(childNode.parentNode, childNode), childNode.parentNode = node, node.childNodes.push(childNode), childNode.yogaNode && node.yogaNode?.insertChild(childNode.yogaNode, node.yogaNode.getChildCount()), (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") && markNodeAsDirty(node);
}, insertBeforeNode = (node, newChildNode, beforeChildNode) => {
  newChildNode.parentNode && removeChildNode(newChildNode.parentNode, newChildNode), newChildNode.parentNode = node;
  let index = node.childNodes.indexOf(beforeChildNode);
  if (index >= 0) {
    node.childNodes.splice(index, 0, newChildNode), newChildNode.yogaNode && node.yogaNode?.insertChild(newChildNode.yogaNode, index);
    return;
  }
  node.childNodes.push(newChildNode), newChildNode.yogaNode && node.yogaNode?.insertChild(newChildNode.yogaNode, node.yogaNode.getChildCount()), (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") && markNodeAsDirty(node);
}, removeChildNode = (node, removeNode) => {
  removeNode.yogaNode && removeNode.parentNode?.yogaNode?.removeChild(removeNode.yogaNode), removeNode.parentNode = void 0;
  let index = node.childNodes.indexOf(removeNode);
  index >= 0 && node.childNodes.splice(index, 1), (node.nodeName === "ink-text" || node.nodeName === "ink-virtual-text") && markNodeAsDirty(node);
}, setAttribute = (node, key, value) => {
  node.attributes[key] = value;
}, setStyle = (node, style) => {
  node.style = style;
}, createTextNode = (text) => {
  let node = {
    nodeName: "#text",
    nodeValue: text,
    yogaNode: void 0,
    parentNode: void 0,
    style: {}
  };
  return setTextNodeValue(node, text), node;
}, measureTextNode = function(node, width) {
  let text = node.nodeName === "#text" ? node.nodeValue : squash_text_nodes_default(node), dimensions = measure_text_default(text);
  if (dimensions.width <= width || dimensions.width >= 1 && width > 0 && width < 1)
    return dimensions;
  let textWrap = node.style?.textWrap ?? "wrap", wrappedText = wrap_text_default(text, width, textWrap);
  return measure_text_default(wrappedText);
}, findClosestYogaNode = (node) => {
  if (node?.parentNode)
    return node.yogaNode ?? findClosestYogaNode(node.parentNode);
}, markNodeAsDirty = (node) => {
  findClosestYogaNode(node)?.markDirty();
}, setTextNodeValue = (node, text) => {
  typeof text != "string" && (text = String(text)), node.nodeValue = text, markNodeAsDirty(node);
};

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/styles.js
init_cjs_shims();
var applyPositionStyles = (node, style) => {
  "position" in style && node.setPositionType(style.position === "absolute" ? Yoga.POSITION_TYPE_ABSOLUTE : Yoga.POSITION_TYPE_RELATIVE);
}, applyMarginStyles = (node, style) => {
  "margin" in style && node.setMargin(Yoga.EDGE_ALL, style.margin ?? 0), "marginX" in style && node.setMargin(Yoga.EDGE_HORIZONTAL, style.marginX ?? 0), "marginY" in style && node.setMargin(Yoga.EDGE_VERTICAL, style.marginY ?? 0), "marginLeft" in style && node.setMargin(Yoga.EDGE_START, style.marginLeft || 0), "marginRight" in style && node.setMargin(Yoga.EDGE_END, style.marginRight || 0), "marginTop" in style && node.setMargin(Yoga.EDGE_TOP, style.marginTop || 0), "marginBottom" in style && node.setMargin(Yoga.EDGE_BOTTOM, style.marginBottom || 0);
}, applyPaddingStyles = (node, style) => {
  "padding" in style && node.setPadding(Yoga.EDGE_ALL, style.padding ?? 0), "paddingX" in style && node.setPadding(Yoga.EDGE_HORIZONTAL, style.paddingX ?? 0), "paddingY" in style && node.setPadding(Yoga.EDGE_VERTICAL, style.paddingY ?? 0), "paddingLeft" in style && node.setPadding(Yoga.EDGE_LEFT, style.paddingLeft || 0), "paddingRight" in style && node.setPadding(Yoga.EDGE_RIGHT, style.paddingRight || 0), "paddingTop" in style && node.setPadding(Yoga.EDGE_TOP, style.paddingTop || 0), "paddingBottom" in style && node.setPadding(Yoga.EDGE_BOTTOM, style.paddingBottom || 0);
}, applyFlexStyles = (node, style) => {
  "flexGrow" in style && node.setFlexGrow(style.flexGrow ?? 0), "flexShrink" in style && node.setFlexShrink(typeof style.flexShrink == "number" ? style.flexShrink : 1), "flexWrap" in style && (style.flexWrap === "nowrap" && node.setFlexWrap(Yoga.WRAP_NO_WRAP), style.flexWrap === "wrap" && node.setFlexWrap(Yoga.WRAP_WRAP), style.flexWrap === "wrap-reverse" && node.setFlexWrap(Yoga.WRAP_WRAP_REVERSE)), "flexDirection" in style && (style.flexDirection === "row" && node.setFlexDirection(Yoga.FLEX_DIRECTION_ROW), style.flexDirection === "row-reverse" && node.setFlexDirection(Yoga.FLEX_DIRECTION_ROW_REVERSE), style.flexDirection === "column" && node.setFlexDirection(Yoga.FLEX_DIRECTION_COLUMN), style.flexDirection === "column-reverse" && node.setFlexDirection(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)), "flexBasis" in style && (typeof style.flexBasis == "number" ? node.setFlexBasis(style.flexBasis) : typeof style.flexBasis == "string" ? node.setFlexBasisPercent(Number.parseInt(style.flexBasis, 10)) : node.setFlexBasis(Number.NaN)), "alignItems" in style && ((style.alignItems === "stretch" || !style.alignItems) && node.setAlignItems(Yoga.ALIGN_STRETCH), style.alignItems === "flex-start" && node.setAlignItems(Yoga.ALIGN_FLEX_START), style.alignItems === "center" && node.setAlignItems(Yoga.ALIGN_CENTER), style.alignItems === "flex-end" && node.setAlignItems(Yoga.ALIGN_FLEX_END)), "alignSelf" in style && ((style.alignSelf === "auto" || !style.alignSelf) && node.setAlignSelf(Yoga.ALIGN_AUTO), style.alignSelf === "flex-start" && node.setAlignSelf(Yoga.ALIGN_FLEX_START), style.alignSelf === "center" && node.setAlignSelf(Yoga.ALIGN_CENTER), style.alignSelf === "flex-end" && node.setAlignSelf(Yoga.ALIGN_FLEX_END)), "justifyContent" in style && ((style.justifyContent === "flex-start" || !style.justifyContent) && node.setJustifyContent(Yoga.JUSTIFY_FLEX_START), style.justifyContent === "center" && node.setJustifyContent(Yoga.JUSTIFY_CENTER), style.justifyContent === "flex-end" && node.setJustifyContent(Yoga.JUSTIFY_FLEX_END), style.justifyContent === "space-between" && node.setJustifyContent(Yoga.JUSTIFY_SPACE_BETWEEN), style.justifyContent === "space-around" && node.setJustifyContent(Yoga.JUSTIFY_SPACE_AROUND));
}, applyDimensionStyles = (node, style) => {
  "width" in style && (typeof style.width == "number" ? node.setWidth(style.width) : typeof style.width == "string" ? node.setWidthPercent(Number.parseInt(style.width, 10)) : node.setWidthAuto()), "height" in style && (typeof style.height == "number" ? node.setHeight(style.height) : typeof style.height == "string" ? node.setHeightPercent(Number.parseInt(style.height, 10)) : node.setHeightAuto()), "minWidth" in style && (typeof style.minWidth == "string" ? node.setMinWidthPercent(Number.parseInt(style.minWidth, 10)) : node.setMinWidth(style.minWidth ?? 0)), "minHeight" in style && (typeof style.minHeight == "string" ? node.setMinHeightPercent(Number.parseInt(style.minHeight, 10)) : node.setMinHeight(style.minHeight ?? 0));
}, applyDisplayStyles = (node, style) => {
  "display" in style && node.setDisplay(style.display === "flex" ? Yoga.DISPLAY_FLEX : Yoga.DISPLAY_NONE);
}, applyBorderStyles = (node, style) => {
  if ("borderStyle" in style) {
    let borderWidth = style.borderStyle ? 1 : 0;
    style.borderTop !== !1 && node.setBorder(Yoga.EDGE_TOP, borderWidth), style.borderBottom !== !1 && node.setBorder(Yoga.EDGE_BOTTOM, borderWidth), style.borderLeft !== !1 && node.setBorder(Yoga.EDGE_LEFT, borderWidth), style.borderRight !== !1 && node.setBorder(Yoga.EDGE_RIGHT, borderWidth);
  }
}, applyGapStyles = (node, style) => {
  "gap" in style && node.setGap(Yoga.GUTTER_ALL, style.gap ?? 0), "columnGap" in style && node.setGap(Yoga.GUTTER_COLUMN, style.columnGap ?? 0), "rowGap" in style && node.setGap(Yoga.GUTTER_ROW, style.rowGap ?? 0);
}, styles5 = (node, style = {}) => {
  applyPositionStyles(node, style), applyMarginStyles(node, style), applyPaddingStyles(node, style), applyFlexStyles(node, style), applyDimensionStyles(node, style), applyDisplayStyles(node, style), applyBorderStyles(node, style), applyGapStyles(node, style);
}, styles_default = styles5;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/reconciler.js
if (process10.env.DEV === "true")
  try {
    await import("./devtools-LDCSRUXB.js");
  } catch (error) {
    if (error.code === "MODULE_NOT_FOUND")
      console.warn(`
Debugging with React Devtools requires \`react-devtools-core\` dependency to be installed.

$ npm install --save-dev react-devtools-core
				`.trim() + `
`);
    else
      throw error;
  }
var diff = (before, after) => {
  if (before === after)
    return;
  if (!before)
    return after;
  let changed = {}, isChanged = !1;
  for (let key of Object.keys(before))
    (after ? !Object.hasOwnProperty.call(after, key) : !0) && (changed[key] = void 0, isChanged = !0);
  if (after)
    for (let key of Object.keys(after))
      after[key] !== before[key] && (changed[key] = after[key], isChanged = !0);
  return isChanged ? changed : void 0;
}, cleanupYogaNode = (node) => {
  node?.unsetMeasureFunc(), node?.freeRecursive();
}, reconciler_default = (0, import_react_reconciler.default)({
  getRootHostContext: () => ({
    isInsideText: !1
  }),
  prepareForCommit: () => null,
  preparePortalMount: () => null,
  clearContainer: () => !1,
  resetAfterCommit(rootNode) {
    if (typeof rootNode.onComputeLayout == "function" && rootNode.onComputeLayout(), rootNode.isStaticDirty) {
      rootNode.isStaticDirty = !1, typeof rootNode.onImmediateRender == "function" && rootNode.onImmediateRender();
      return;
    }
    typeof rootNode.onRender == "function" && rootNode.onRender();
  },
  getChildHostContext(parentHostContext, type) {
    let previousIsInsideText = parentHostContext.isInsideText, isInsideText = type === "ink-text" || type === "ink-virtual-text";
    return previousIsInsideText === isInsideText ? parentHostContext : { isInsideText };
  },
  shouldSetTextContent: () => !1,
  createInstance(originalType, newProps, _root, hostContext) {
    if (hostContext.isInsideText && originalType === "ink-box")
      throw new Error("<Box> can\u2019t be nested inside <Text> component");
    let type = originalType === "ink-text" && hostContext.isInsideText ? "ink-virtual-text" : originalType, node = createNode(type);
    for (let [key, value] of Object.entries(newProps))
      if (key !== "children") {
        if (key === "style") {
          setStyle(node, value), node.yogaNode && styles_default(node.yogaNode, value);
          continue;
        }
        if (key === "internal_transform") {
          node.internal_transform = value;
          continue;
        }
        if (key === "internal_static") {
          node.internal_static = !0;
          continue;
        }
        setAttribute(node, key, value);
      }
    return node;
  },
  createTextInstance(text, _root, hostContext) {
    if (!hostContext.isInsideText)
      throw new Error(`Text string "${text}" must be rendered inside <Text> component`);
    return createTextNode(text);
  },
  resetTextContent() {
  },
  hideTextInstance(node) {
    setTextNodeValue(node, "");
  },
  unhideTextInstance(node, text) {
    setTextNodeValue(node, text);
  },
  getPublicInstance: (instance) => instance,
  hideInstance(node) {
    node.yogaNode?.setDisplay(Yoga.DISPLAY_NONE);
  },
  unhideInstance(node) {
    node.yogaNode?.setDisplay(Yoga.DISPLAY_FLEX);
  },
  appendInitialChild: appendChildNode,
  appendChild: appendChildNode,
  insertBefore: insertBeforeNode,
  finalizeInitialChildren(node, _type, _props, rootNode) {
    return node.internal_static && (rootNode.isStaticDirty = !0, rootNode.staticNode = node), !1;
  },
  isPrimaryRenderer: !0,
  supportsMutation: !0,
  supportsPersistence: !1,
  supportsHydration: !1,
  scheduleTimeout: setTimeout,
  cancelTimeout: clearTimeout,
  noTimeout: -1,
  getCurrentEventPriority: () => import_constants2.DefaultEventPriority,
  beforeActiveInstanceBlur() {
  },
  afterActiveInstanceBlur() {
  },
  detachDeletedInstance() {
  },
  getInstanceFromNode: () => null,
  prepareScopeUpdate() {
  },
  getInstanceFromScope: () => null,
  appendChildToContainer: appendChildNode,
  insertInContainerBefore: insertBeforeNode,
  removeChildFromContainer(node, removeNode) {
    removeChildNode(node, removeNode), cleanupYogaNode(removeNode.yogaNode);
  },
  prepareUpdate(node, _type, oldProps, newProps, rootNode) {
    node.internal_static && (rootNode.isStaticDirty = !0);
    let props = diff(oldProps, newProps), style = diff(oldProps.style, newProps.style);
    return !props && !style ? null : { props, style };
  },
  commitUpdate(node, { props, style }) {
    if (props)
      for (let [key, value] of Object.entries(props)) {
        if (key === "style") {
          setStyle(node, value);
          continue;
        }
        if (key === "internal_transform") {
          node.internal_transform = value;
          continue;
        }
        if (key === "internal_static") {
          node.internal_static = !0;
          continue;
        }
        setAttribute(node, key, value);
      }
    style && node.yogaNode && styles_default(node.yogaNode, style);
  },
  commitTextUpdate(node, _oldText, newText) {
    setTextNodeValue(node, newText);
  },
  removeChild(node, removeNode) {
    removeChildNode(node, removeNode), cleanupYogaNode(removeNode.yogaNode);
  }
});

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/renderer.js
init_cjs_shims();

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/render-node-to-output.js
init_cjs_shims();

// ../../node_modules/.pnpm/indent-string@5.0.0/node_modules/indent-string/index.js
init_cjs_shims();
function indentString(string, count = 1, options = {}) {
  let {
    indent = " ",
    includeEmptyLines = !1
  } = options;
  if (typeof string != "string")
    throw new TypeError(
      `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
    );
  if (typeof count != "number")
    throw new TypeError(
      `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
    );
  if (count < 0)
    throw new RangeError(
      `Expected \`count\` to be at least 0, got \`${count}\``
    );
  if (typeof indent != "string")
    throw new TypeError(
      `Expected \`options.indent\` to be a \`string\`, got \`${typeof indent}\``
    );
  if (count === 0)
    return string;
  let regex2 = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
  return string.replace(regex2, indent.repeat(count));
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/get-max-width.js
init_cjs_shims();
var getMaxWidth = (yogaNode) => yogaNode.getComputedWidth() - yogaNode.getComputedPadding(Yoga.EDGE_LEFT) - yogaNode.getComputedPadding(Yoga.EDGE_RIGHT) - yogaNode.getComputedBorder(Yoga.EDGE_LEFT) - yogaNode.getComputedBorder(Yoga.EDGE_RIGHT), get_max_width_default = getMaxWidth;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/render-border.js
init_cjs_shims();
var import_cli_boxes = __toESM(require_cli_boxes(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/colorize.js
init_cjs_shims();
var rgbRegex = /^rgb\(\s?(\d+),\s?(\d+),\s?(\d+)\s?\)$/, ansiRegex2 = /^ansi256\(\s?(\d+)\s?\)$/, isNamedColor = (color) => color in source_default, colorize = (str, color, type) => {
  if (!color)
    return str;
  if (isNamedColor(color)) {
    if (type === "foreground")
      return source_default[color](str);
    let methodName = `bg${color[0].toUpperCase() + color.slice(1)}`;
    return source_default[methodName](str);
  }
  if (color.startsWith("#"))
    return type === "foreground" ? source_default.hex(color)(str) : source_default.bgHex(color)(str);
  if (color.startsWith("ansi256")) {
    let matches = ansiRegex2.exec(color);
    if (!matches)
      return str;
    let value = Number(matches[1]);
    return type === "foreground" ? source_default.ansi256(value)(str) : source_default.bgAnsi256(value)(str);
  }
  if (color.startsWith("rgb")) {
    let matches = rgbRegex.exec(color);
    if (!matches)
      return str;
    let firstValue = Number(matches[1]), secondValue = Number(matches[2]), thirdValue = Number(matches[3]);
    return type === "foreground" ? source_default.rgb(firstValue, secondValue, thirdValue)(str) : source_default.bgRgb(firstValue, secondValue, thirdValue)(str);
  }
  return str;
}, colorize_default = colorize;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/render-border.js
var renderBorder = (x, y, node, output2) => {
  if (node.style.borderStyle) {
    let width = node.yogaNode.getComputedWidth(), height = node.yogaNode.getComputedHeight(), box = typeof node.style.borderStyle == "string" ? import_cli_boxes.default[node.style.borderStyle] : node.style.borderStyle, topBorderColor = node.style.borderTopColor ?? node.style.borderColor, bottomBorderColor = node.style.borderBottomColor ?? node.style.borderColor, leftBorderColor = node.style.borderLeftColor ?? node.style.borderColor, rightBorderColor = node.style.borderRightColor ?? node.style.borderColor, dimTopBorderColor = node.style.borderTopDimColor ?? node.style.borderDimColor, dimBottomBorderColor = node.style.borderBottomDimColor ?? node.style.borderDimColor, dimLeftBorderColor = node.style.borderLeftDimColor ?? node.style.borderDimColor, dimRightBorderColor = node.style.borderRightDimColor ?? node.style.borderDimColor, showTopBorder = node.style.borderTop !== !1, showBottomBorder = node.style.borderBottom !== !1, showLeftBorder = node.style.borderLeft !== !1, showRightBorder = node.style.borderRight !== !1, contentWidth = width - (showLeftBorder ? 1 : 0) - (showRightBorder ? 1 : 0), topBorder = showTopBorder ? colorize_default((showLeftBorder ? box.topLeft : "") + box.top.repeat(contentWidth) + (showRightBorder ? box.topRight : ""), topBorderColor, "foreground") : void 0;
    showTopBorder && dimTopBorderColor && (topBorder = source_default.dim(topBorder));
    let verticalBorderHeight = height;
    showTopBorder && (verticalBorderHeight -= 1), showBottomBorder && (verticalBorderHeight -= 1);
    let leftBorder = (colorize_default(box.left, leftBorderColor, "foreground") + `
`).repeat(verticalBorderHeight);
    dimLeftBorderColor && (leftBorder = source_default.dim(leftBorder));
    let rightBorder = (colorize_default(box.right, rightBorderColor, "foreground") + `
`).repeat(verticalBorderHeight);
    dimRightBorderColor && (rightBorder = source_default.dim(rightBorder));
    let bottomBorder = showBottomBorder ? colorize_default((showLeftBorder ? box.bottomLeft : "") + box.bottom.repeat(contentWidth) + (showRightBorder ? box.bottomRight : ""), bottomBorderColor, "foreground") : void 0;
    showBottomBorder && dimBottomBorderColor && (bottomBorder = source_default.dim(bottomBorder));
    let offsetY = showTopBorder ? 1 : 0;
    topBorder && output2.write(x, y, topBorder, { transformers: [] }), showLeftBorder && output2.write(x, y + offsetY, leftBorder, { transformers: [] }), showRightBorder && output2.write(x + width - 1, y + offsetY, rightBorder, {
      transformers: []
    }), bottomBorder && output2.write(x, y + height - 1, bottomBorder, { transformers: [] });
  }
}, render_border_default = renderBorder;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/render-node-to-output.js
var applyPaddingToText = (node, text) => {
  let yogaNode = node.childNodes[0]?.yogaNode;
  if (yogaNode) {
    let offsetX = yogaNode.getComputedLeft(), offsetY = yogaNode.getComputedTop();
    text = `
`.repeat(offsetY) + indentString(text, offsetX);
  }
  return text;
}, renderNodeToOutput = (node, output2, options) => {
  let { offsetX = 0, offsetY = 0, transformers = [], skipStaticElements } = options;
  if (skipStaticElements && node.internal_static)
    return;
  let { yogaNode } = node;
  if (yogaNode) {
    if (yogaNode.getDisplay() === Yoga.DISPLAY_NONE)
      return;
    let x = offsetX + yogaNode.getComputedLeft(), y = offsetY + yogaNode.getComputedTop(), newTransformers = transformers;
    if (typeof node.internal_transform == "function" && (newTransformers = [node.internal_transform, ...transformers]), node.nodeName === "ink-text") {
      let text = squash_text_nodes_default(node);
      if (text.length > 0) {
        let currentWidth = widestLine(text), maxWidth = get_max_width_default(yogaNode);
        if (currentWidth > maxWidth) {
          let textWrap = node.style.textWrap ?? "wrap";
          text = wrap_text_default(text, maxWidth, textWrap);
        }
        text = applyPaddingToText(node, text), output2.write(x, y, text, { transformers: newTransformers });
      }
      return;
    }
    let clipped = !1;
    if (node.nodeName === "ink-box") {
      render_border_default(x, y, node, output2);
      let clipHorizontally = node.style.overflowX === "hidden" || node.style.overflow === "hidden", clipVertically = node.style.overflowY === "hidden" || node.style.overflow === "hidden";
      if (clipHorizontally || clipVertically) {
        let x1 = clipHorizontally ? x + yogaNode.getComputedBorder(Yoga.EDGE_LEFT) : void 0, x2 = clipHorizontally ? x + yogaNode.getComputedWidth() - yogaNode.getComputedBorder(Yoga.EDGE_RIGHT) : void 0, y1 = clipVertically ? y + yogaNode.getComputedBorder(Yoga.EDGE_TOP) : void 0, y2 = clipVertically ? y + yogaNode.getComputedHeight() - yogaNode.getComputedBorder(Yoga.EDGE_BOTTOM) : void 0;
        output2.clip({ x1, x2, y1, y2 }), clipped = !0;
      }
    }
    if (node.nodeName === "ink-root" || node.nodeName === "ink-box") {
      for (let childNode of node.childNodes)
        renderNodeToOutput(childNode, output2, {
          offsetX: x,
          offsetY: y,
          transformers: newTransformers,
          skipStaticElements
        });
      clipped && output2.unclip();
    }
  }
}, render_node_to_output_default = renderNodeToOutput;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/output.js
init_cjs_shims();

// ../../node_modules/.pnpm/slice-ansi@6.0.0/node_modules/slice-ansi/index.js
init_cjs_shims();
var ESCAPES3 = /* @__PURE__ */ new Set([27, 155]), CODE_POINT_0 = "0".codePointAt(0), CODE_POINT_9 = "9".codePointAt(0), endCodesSet = /* @__PURE__ */ new Set(), endCodesMap = /* @__PURE__ */ new Map();
for (let [start, end] of ansi_styles_default2.codes)
  endCodesSet.add(ansi_styles_default2.color.ansi(end)), endCodesMap.set(ansi_styles_default2.color.ansi(start), ansi_styles_default2.color.ansi(end));
function getEndCode(code) {
  if (endCodesSet.has(code))
    return code;
  if (endCodesMap.has(code))
    return endCodesMap.get(code);
  code = code.slice(2), code.includes(";") && (code = code[0] + "0");
  let returnValue = ansi_styles_default2.codes.get(Number.parseInt(code, 10));
  return returnValue ? ansi_styles_default2.color.ansi(returnValue) : ansi_styles_default2.reset.open;
}
function findNumberIndex(string) {
  for (let index = 0; index < string.length; index++) {
    let codePoint = string.codePointAt(index);
    if (codePoint >= CODE_POINT_0 && codePoint <= CODE_POINT_9)
      return index;
  }
  return -1;
}
function parseAnsiCode(string, offset) {
  string = string.slice(offset, offset + 19);
  let startIndex = findNumberIndex(string);
  if (startIndex !== -1) {
    let endIndex = string.indexOf("m", startIndex);
    return endIndex === -1 && (endIndex = string.length), string.slice(0, endIndex + 1);
  }
}
function tokenize(string, endCharacter = Number.POSITIVE_INFINITY) {
  let returnValue = [], index = 0, visibleCount = 0;
  for (; index < string.length; ) {
    let codePoint = string.codePointAt(index);
    if (ESCAPES3.has(codePoint)) {
      let code = parseAnsiCode(string, index);
      if (code) {
        returnValue.push({
          type: "ansi",
          code,
          endCode: getEndCode(code)
        }), index += code.length;
        continue;
      }
    }
    let isFullWidth = isFullwidthCodePoint(codePoint), character = String.fromCodePoint(codePoint);
    if (returnValue.push({
      type: "character",
      value: character,
      isFullWidth
    }), index += character.length, visibleCount += isFullWidth ? 2 : character.length, visibleCount >= endCharacter)
      break;
  }
  return returnValue;
}
function reduceAnsiCodes(codes) {
  let returnValue = [];
  for (let code of codes)
    code.code === ansi_styles_default2.reset.open ? returnValue = [] : endCodesSet.has(code.code) ? returnValue = returnValue.filter((returnValueCode) => returnValueCode.endCode !== code.code) : (returnValue = returnValue.filter((returnValueCode) => returnValueCode.endCode !== code.endCode), returnValue.push(code));
  return returnValue;
}
function undoAnsiCodes(codes) {
  return reduceAnsiCodes(codes).map(({ endCode }) => endCode).reverse().join("");
}
function sliceAnsi2(string, start, end) {
  let tokens = tokenize(string, end), activeCodes = [], position = 0, returnValue = "", include = !1;
  for (let token of tokens) {
    if (end !== void 0 && position >= end)
      break;
    token.type === "ansi" ? (activeCodes.push(token), include && (returnValue += token.code)) : (!include && position >= start && (include = !0, activeCodes = reduceAnsiCodes(activeCodes), returnValue = activeCodes.map(({ code }) => code).join("")), include && (returnValue += token.value), position += token.isFullWidth ? 2 : token.value.length);
  }
  return returnValue += undoAnsiCodes(activeCodes), returnValue;
}

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/ansiCodes.js
init_cjs_shims();
var ESCAPES4 = /* @__PURE__ */ new Set([27, 155]), endCodesSet2 = /* @__PURE__ */ new Set(), endCodesMap2 = /* @__PURE__ */ new Map();
for (let [start, end] of ansi_styles_default2.codes)
  endCodesSet2.add(ansi_styles_default2.color.ansi(end)), endCodesMap2.set(ansi_styles_default2.color.ansi(start), ansi_styles_default2.color.ansi(end));
var linkStartCodePrefix = "\x1B]8;;", linkStartCodePrefixCharCodes = linkStartCodePrefix.split("").map((char) => char.charCodeAt(0)), linkCodeSuffix = "\x07", linkCodeSuffixCharCode = linkCodeSuffix.charCodeAt(0), linkEndCode = `\x1B]8;;${linkCodeSuffix}`;
function getEndCode2(code) {
  if (endCodesSet2.has(code))
    return code;
  if (endCodesMap2.has(code))
    return endCodesMap2.get(code);
  if (code.startsWith(linkStartCodePrefix))
    return linkEndCode;
  code = code.slice(2), code.includes(";") && (code = code[0] + "0");
  let ret = ansi_styles_default2.codes.get(parseInt(code, 10));
  return ret ? ansi_styles_default2.color.ansi(ret) : ansi_styles_default2.reset.open;
}
function ansiCodesToString(codes) {
  return codes.map((code) => code.code).join("");
}

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/diff.js
init_cjs_shims();

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/undo.js
init_cjs_shims();

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/reduce.js
init_cjs_shims();
function reduceAnsiCodes2(codes) {
  return reduceAnsiCodesIncremental([], codes);
}
function reduceAnsiCodesIncremental(codes, newCodes) {
  let ret = [...codes];
  for (let code of newCodes)
    code.code === ansi_styles_default2.reset.open ? ret = [] : endCodesSet2.has(code.code) ? ret = ret.filter((retCode) => retCode.endCode !== code.code) : (ret = ret.filter((retCode) => retCode.endCode !== code.endCode), ret.push(code));
  return ret;
}

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/undo.js
function undoAnsiCodes2(codes) {
  return reduceAnsiCodes2(codes).reverse().map((code) => ({
    ...code,
    code: code.endCode
  }));
}

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/diff.js
function diffAnsiCodes(from, to) {
  let endCodesInTo = new Set(to.map((code) => code.endCode)), startCodesInFrom = new Set(from.map((code) => code.code));
  return [
    // Ignore all styles in `from` that are not overwritten or removed by `to`
    // Disable all styles in `from` that are removed in `to`
    ...undoAnsiCodes2(from.filter((code) => !endCodesInTo.has(code.endCode))),
    // Add all styles in `to` that don't exist in `from`
    ...to.filter((code) => !startCodesInFrom.has(code.code))
  ];
}

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/styledChars.js
init_cjs_shims();
function styledCharsFromTokens(tokens) {
  let codes = [], ret = [];
  for (let token of tokens)
    token.type === "ansi" ? codes = reduceAnsiCodesIncremental(codes, [token]) : token.type === "char" && ret.push({
      ...token,
      styles: [...codes]
    });
  return ret;
}
function styledCharsToString(chars) {
  let ret = "";
  for (let i = 0; i < chars.length; i++) {
    let char = chars[i];
    i === 0 ? ret += ansiCodesToString(char.styles) : ret += ansiCodesToString(diffAnsiCodes(chars[i - 1].styles, char.styles)), ret += char.value, i === chars.length - 1 && (ret += ansiCodesToString(diffAnsiCodes(char.styles, [])));
  }
  return ret;
}

// ../../node_modules/.pnpm/@alcalzone+ansi-tokenize@0.1.3/node_modules/@alcalzone/ansi-tokenize/build/tokenize.js
init_cjs_shims();
function findNumberIndex2(str) {
  for (let index = 0; index < str.length; index++) {
    let charCode = str.charCodeAt(index);
    if (charCode >= 48 && charCode <= 57)
      return index;
  }
  return -1;
}
function parseLinkCode(string, offset) {
  string = string.slice(offset);
  for (let index = 1; index < linkStartCodePrefixCharCodes.length; index++)
    if (string.charCodeAt(index) !== linkStartCodePrefixCharCodes[index])
      return;
  let endIndex = string.indexOf("\x07", linkStartCodePrefix.length);
  if (endIndex !== -1)
    return string.slice(0, endIndex + 1);
}
function parseAnsiCode2(string, offset) {
  string = string.slice(offset, offset + 19);
  let startIndex = findNumberIndex2(string);
  if (startIndex !== -1) {
    let endIndex = string.indexOf("m", startIndex);
    return endIndex === -1 && (endIndex = string.length), string.slice(0, endIndex + 1);
  }
}
function tokenize2(str, endChar = Number.POSITIVE_INFINITY) {
  let ret = [], index = 0, visible = 0;
  for (; index < str.length; ) {
    let codePoint = str.codePointAt(index);
    if (ESCAPES4.has(codePoint)) {
      let code = parseLinkCode(str, index) || parseAnsiCode2(str, index);
      if (code) {
        ret.push({
          type: "ansi",
          code,
          endCode: getEndCode2(code)
        }), index += code.length;
        continue;
      }
    }
    let fullWidth = isFullwidthCodePoint(codePoint), character = String.fromCodePoint(codePoint);
    if (ret.push({
      type: "char",
      value: character,
      fullWidth
    }), index += character.length, visible += fullWidth ? 2 : character.length, visible >= endChar)
      break;
  }
  return ret;
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/output.js
var Output = class {
  constructor(options) {
    Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "operations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
    let { width, height } = options;
    this.width = width, this.height = height;
  }
  write(x, y, text, options) {
    let { transformers } = options;
    text && this.operations.push({
      type: "write",
      x,
      y,
      text,
      transformers
    });
  }
  clip(clip) {
    this.operations.push({
      type: "clip",
      clip
    });
  }
  unclip() {
    this.operations.push({
      type: "unclip"
    });
  }
  get() {
    let output2 = [];
    for (let y = 0; y < this.height; y++) {
      let row = [];
      for (let x = 0; x < this.width; x++)
        row.push({
          type: "char",
          value: " ",
          fullWidth: !1,
          styles: []
        });
      output2.push(row);
    }
    let clips = [];
    for (let operation of this.operations)
      if (operation.type === "clip" && clips.push(operation.clip), operation.type === "unclip" && clips.pop(), operation.type === "write") {
        let { text, transformers } = operation, { x, y } = operation, lines = text.split(`
`), clip = clips[clips.length - 1];
        if (clip) {
          let clipHorizontally = typeof clip?.x1 == "number" && typeof clip?.x2 == "number", clipVertically = typeof clip?.y1 == "number" && typeof clip?.y2 == "number";
          if (clipHorizontally) {
            let width = widestLine(text);
            if (x + width < clip.x1 || x > clip.x2)
              continue;
          }
          if (clipVertically) {
            let height = lines.length;
            if (y + height < clip.y1 || y > clip.y2)
              continue;
          }
          if (clipHorizontally && (lines = lines.map((line) => {
            let from = x < clip.x1 ? clip.x1 - x : 0, width = stringWidth(line), to = x + width > clip.x2 ? clip.x2 - x : width;
            return sliceAnsi2(line, from, to);
          }), x < clip.x1 && (x = clip.x1)), clipVertically) {
            let from = y < clip.y1 ? clip.y1 - y : 0, height = lines.length, to = y + height > clip.y2 ? clip.y2 - y : height;
            lines = lines.slice(from, to), y < clip.y1 && (y = clip.y1);
          }
        }
        let offsetY = 0;
        for (let [index, line] of lines.entries()) {
          let currentLine = output2[y + offsetY];
          if (!currentLine)
            continue;
          for (let transformer of transformers)
            line = transformer(line, index);
          let characters = styledCharsFromTokens(tokenize2(line)), offsetX = x;
          for (let character of characters) {
            currentLine[offsetX] = character;
            let isWideCharacter = character.fullWidth || character.value.length > 1;
            isWideCharacter && (currentLine[offsetX + 1] = {
              type: "char",
              value: "",
              fullWidth: !1,
              styles: character.styles
            }), offsetX += isWideCharacter ? 2 : 1;
          }
          offsetY++;
        }
      }
    return {
      output: output2.map((line) => {
        let lineWithoutEmptyItems = line.filter((item) => item !== void 0);
        return styledCharsToString(lineWithoutEmptyItems).trimEnd();
      }).join(`
`),
      height: output2.length
    };
  }
};

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/renderer.js
var renderer = (node) => {
  if (node.yogaNode) {
    let output2 = new Output({
      width: node.yogaNode.getComputedWidth(),
      height: node.yogaNode.getComputedHeight()
    });
    render_node_to_output_default(node, output2, { skipStaticElements: !0 });
    let staticOutput;
    node.staticNode?.yogaNode && (staticOutput = new Output({
      width: node.staticNode.yogaNode.getComputedWidth(),
      height: node.staticNode.yogaNode.getComputedHeight()
    }), render_node_to_output_default(node.staticNode, staticOutput, {
      skipStaticElements: !1
    }));
    let { output: generatedOutput, height: outputHeight } = output2.get();
    return {
      output: generatedOutput,
      outputHeight,
      // Newline at the end is needed, because static output doesn't have one, so
      // interactive output will override last line of static output
      staticOutput: staticOutput ? `${staticOutput.get().output}
` : ""
    };
  }
  return {
    output: "",
    outputHeight: 0,
    staticOutput: ""
  };
}, renderer_default = renderer;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/log-update.js
init_cjs_shims();

// ../../node_modules/.pnpm/cli-cursor@4.0.0/node_modules/cli-cursor/index.js
init_cjs_shims();
import process12 from "node:process";

// ../../node_modules/.pnpm/restore-cursor@4.0.0/node_modules/restore-cursor/index.js
init_cjs_shims();
var import_onetime2 = __toESM(require_onetime(), 1), import_signal_exit2 = __toESM(require_signal_exit(), 1);
import process11 from "node:process";
var restoreCursor = (0, import_onetime2.default)(() => {
  (0, import_signal_exit2.default)(() => {
    process11.stderr.write("\x1B[?25h");
  }, { alwaysLast: !0 });
}), restore_cursor_default = restoreCursor;

// ../../node_modules/.pnpm/cli-cursor@4.0.0/node_modules/cli-cursor/index.js
var isHidden = !1, cliCursor = {};
cliCursor.show = (writableStream = process12.stderr) => {
  writableStream.isTTY && (isHidden = !1, writableStream.write("\x1B[?25h"));
};
cliCursor.hide = (writableStream = process12.stderr) => {
  writableStream.isTTY && (restore_cursor_default(), isHidden = !0, writableStream.write("\x1B[?25l"));
};
cliCursor.toggle = (force, writableStream) => {
  force !== void 0 && (isHidden = force), isHidden ? cliCursor.show(writableStream) : cliCursor.hide(writableStream);
};
var cli_cursor_default = cliCursor;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/log-update.js
var create = (stream2, { showCursor = !1 } = {}) => {
  let previousLineCount = 0, previousOutput = "", hasHiddenCursor = !1, render3 = (str) => {
    !showCursor && !hasHiddenCursor && (cli_cursor_default.hide(), hasHiddenCursor = !0);
    let output2 = str + `
`;
    output2 !== previousOutput && (previousOutput = output2, stream2.write(ansi_escapes_default2.eraseLines(previousLineCount) + output2), previousLineCount = output2.split(`
`).length);
  };
  return render3.clear = () => {
    stream2.write(ansi_escapes_default2.eraseLines(previousLineCount)), previousOutput = "", previousLineCount = 0;
  }, render3.done = () => {
    previousOutput = "", previousLineCount = 0, showCursor || (cli_cursor_default.show(), hasHiddenCursor = !1);
  }, render3;
}, logUpdate = { create }, log_update_default = logUpdate;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/instances.js
init_cjs_shims();
var instances = /* @__PURE__ */ new WeakMap(), instances_default = instances;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/App.js
init_cjs_shims();
var import_react9 = __toESM(require_react(), 1);
import { EventEmitter as EventEmitter2 } from "node:events";
import process16 from "node:process";

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/AppContext.js
init_cjs_shims();
var import_react = __toESM(require_react(), 1), AppContext = (0, import_react.createContext)({
  exit() {
  }
});
AppContext.displayName = "InternalAppContext";
var AppContext_default = AppContext;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/StdinContext.js
init_cjs_shims();
var import_react2 = __toESM(require_react(), 1);
import { EventEmitter } from "node:events";
import process13 from "node:process";
var StdinContext = (0, import_react2.createContext)({
  stdin: process13.stdin,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  internal_eventEmitter: new EventEmitter(),
  setRawMode() {
  },
  isRawModeSupported: !1,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  internal_exitOnCtrlC: !0
});
StdinContext.displayName = "InternalStdinContext";
var StdinContext_default = StdinContext;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/StdoutContext.js
init_cjs_shims();
var import_react3 = __toESM(require_react(), 1);
import process14 from "node:process";
var StdoutContext = (0, import_react3.createContext)({
  stdout: process14.stdout,
  write() {
  }
});
StdoutContext.displayName = "InternalStdoutContext";
var StdoutContext_default = StdoutContext;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/StderrContext.js
init_cjs_shims();
var import_react4 = __toESM(require_react(), 1);
import process15 from "node:process";
var StderrContext = (0, import_react4.createContext)({
  stderr: process15.stderr,
  write() {
  }
});
StderrContext.displayName = "InternalStderrContext";
var StderrContext_default = StderrContext;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/FocusContext.js
init_cjs_shims();
var import_react5 = __toESM(require_react(), 1), FocusContext = (0, import_react5.createContext)({
  activeId: void 0,
  add() {
  },
  remove() {
  },
  activate() {
  },
  deactivate() {
  },
  enableFocus() {
  },
  disableFocus() {
  },
  focusNext() {
  },
  focusPrevious() {
  },
  focus() {
  }
});
FocusContext.displayName = "InternalFocusContext";
var FocusContext_default = FocusContext;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/ErrorOverview.js
init_cjs_shims();
var import_react8 = __toESM(require_react(), 1), import_stack_utils = __toESM(require_stack_utils(), 1);
import * as fs4 from "node:fs";
import { cwd as cwd2 } from "node:process";

// ../../node_modules/.pnpm/code-excerpt@4.0.0/node_modules/code-excerpt/dist/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/convert-to-spaces@2.0.1/node_modules/convert-to-spaces/dist/index.js
init_cjs_shims();
var convertToSpaces = (input, spaces = 2) => input.replace(/^\t+/gm, ($1) => " ".repeat($1.length * spaces)), dist_default2 = convertToSpaces;

// ../../node_modules/.pnpm/code-excerpt@4.0.0/node_modules/code-excerpt/dist/index.js
var generateLineNumbers = (line, around) => {
  let lineNumbers = [], min = line - around, max = line + around;
  for (let lineNumber = min; lineNumber <= max; lineNumber++)
    lineNumbers.push(lineNumber);
  return lineNumbers;
}, codeExcerpt = (source, line, options = {}) => {
  var _a;
  if (typeof source != "string")
    throw new TypeError("Source code is missing.");
  if (!line || line < 1)
    throw new TypeError("Line number must start from `1`.");
  let lines = dist_default2(source).split(/\r?\n/);
  if (!(line > lines.length))
    return generateLineNumbers(line, (_a = options.around) !== null && _a !== void 0 ? _a : 3).filter((line2) => lines[line2 - 1] !== void 0).map((line2) => ({ line: line2, value: lines[line2 - 1] }));
}, dist_default3 = codeExcerpt;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/Box.js
init_cjs_shims();
var import_react6 = __toESM(require_react(), 1), Box = (0, import_react6.forwardRef)(({ children, ...style }, ref) => import_react6.default.createElement("ink-box", { ref, style: {
  ...style,
  overflowX: style.overflowX ?? style.overflow ?? "visible",
  overflowY: style.overflowY ?? style.overflow ?? "visible"
} }, children));
Box.displayName = "Box";
Box.defaultProps = {
  flexWrap: "nowrap",
  flexDirection: "row",
  flexGrow: 0,
  flexShrink: 1
};
var Box_default = Box;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/Text.js
init_cjs_shims();
var import_react7 = __toESM(require_react(), 1);
function Text({ color, backgroundColor, dimColor = !1, bold = !1, italic = !1, underline = !1, strikethrough = !1, inverse = !1, wrap = "wrap", children }) {
  if (children == null)
    return null;
  let transform = (children2) => (dimColor && (children2 = source_default.dim(children2)), color && (children2 = colorize_default(children2, color, "foreground")), backgroundColor && (children2 = colorize_default(children2, backgroundColor, "background")), bold && (children2 = source_default.bold(children2)), italic && (children2 = source_default.italic(children2)), underline && (children2 = source_default.underline(children2)), strikethrough && (children2 = source_default.strikethrough(children2)), inverse && (children2 = source_default.inverse(children2)), children2);
  return import_react7.default.createElement("ink-text", { style: { flexGrow: 0, flexShrink: 1, flexDirection: "row", textWrap: wrap }, internal_transform: transform }, children);
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/ErrorOverview.js
var cleanupPath = (path8) => path8?.replace(`file://${cwd2()}/`, ""), stackUtils = new import_stack_utils.default({
  cwd: cwd2(),
  internals: import_stack_utils.default.nodeInternals()
});
function ErrorOverview({ error }) {
  let stack = error.stack ? error.stack.split(`
`).slice(1) : void 0, origin = stack ? stackUtils.parseLine(stack[0]) : void 0, filePath = cleanupPath(origin?.file), excerpt, lineWidth = 0;
  if (filePath && origin?.line && fs4.existsSync(filePath)) {
    let sourceCode = fs4.readFileSync(filePath, "utf8");
    if (excerpt = dist_default3(sourceCode, origin.line), excerpt)
      for (let { line } of excerpt)
        lineWidth = Math.max(lineWidth, String(line).length);
  }
  return import_react8.default.createElement(
    Box_default,
    { flexDirection: "column", padding: 1 },
    import_react8.default.createElement(
      Box_default,
      null,
      import_react8.default.createElement(
        Text,
        { backgroundColor: "red", color: "white" },
        " ",
        "ERROR",
        " "
      ),
      import_react8.default.createElement(
        Text,
        null,
        " ",
        error.message
      )
    ),
    origin && filePath && import_react8.default.createElement(
      Box_default,
      { marginTop: 1 },
      import_react8.default.createElement(
        Text,
        { dimColor: !0 },
        filePath,
        ":",
        origin.line,
        ":",
        origin.column
      )
    ),
    origin && excerpt && import_react8.default.createElement(Box_default, { marginTop: 1, flexDirection: "column" }, excerpt.map(({ line, value }) => import_react8.default.createElement(
      Box_default,
      { key: line },
      import_react8.default.createElement(
        Box_default,
        { width: lineWidth + 1 },
        import_react8.default.createElement(
          Text,
          { dimColor: line !== origin.line, backgroundColor: line === origin.line ? "red" : void 0, color: line === origin.line ? "white" : void 0 },
          String(line).padStart(lineWidth, " "),
          ":"
        )
      ),
      import_react8.default.createElement(Text, { key: line, backgroundColor: line === origin.line ? "red" : void 0, color: line === origin.line ? "white" : void 0 }, " " + value)
    ))),
    error.stack && import_react8.default.createElement(Box_default, { marginTop: 1, flexDirection: "column" }, error.stack.split(`
`).slice(1).map((line) => {
      let parsedLine = stackUtils.parseLine(line);
      return parsedLine ? import_react8.default.createElement(
        Box_default,
        { key: line },
        import_react8.default.createElement(Text, { dimColor: !0 }, "- "),
        import_react8.default.createElement(Text, { dimColor: !0, bold: !0 }, parsedLine.function),
        import_react8.default.createElement(
          Text,
          { dimColor: !0, color: "gray" },
          " ",
          "(",
          cleanupPath(parsedLine.file) ?? "",
          ":",
          parsedLine.line,
          ":",
          parsedLine.column,
          ")"
        )
      ) : import_react8.default.createElement(
        Box_default,
        { key: line },
        import_react8.default.createElement(Text, { dimColor: !0 }, "- "),
        import_react8.default.createElement(Text, { dimColor: !0, bold: !0 }, line)
      );
    }))
  );
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/App.js
var tab = "	", shiftTab = "\x1B[Z", escape2 = "\x1B", App = class extends import_react9.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        isFocusEnabled: !0,
        activeFocusId: void 0,
        focusables: [],
        error: void 0
      }
    }), Object.defineProperty(this, "rawModeEnabledCount", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "internal_eventEmitter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new EventEmitter2()
    }), Object.defineProperty(this, "handleSetRawMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (isEnabled) => {
        let { stdin } = this.props;
        if (!this.isRawModeSupported())
          throw stdin === process16.stdin ? new Error(`Raw mode is not supported on the current process.stdin, which Ink uses as input stream by default.
Read about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`) : new Error(`Raw mode is not supported on the stdin provided to Ink.
Read about how to prevent this error on https://github.com/vadimdemedes/ink/#israwmodesupported`);
        if (stdin.setEncoding("utf8"), isEnabled) {
          this.rawModeEnabledCount === 0 && (stdin.ref(), stdin.setRawMode(!0), stdin.addListener("readable", this.handleReadable)), this.rawModeEnabledCount++;
          return;
        }
        --this.rawModeEnabledCount === 0 && (stdin.setRawMode(!1), stdin.removeListener("readable", this.handleReadable), stdin.unref());
      }
    }), Object.defineProperty(this, "handleReadable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        let chunk;
        for (; (chunk = this.props.stdin.read()) !== null; )
          this.handleInput(chunk), this.internal_eventEmitter.emit("input", chunk);
      }
    }), Object.defineProperty(this, "handleInput", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (input) => {
        input === "" && this.props.exitOnCtrlC && this.handleExit(), input === escape2 && this.state.activeFocusId && this.setState({
          activeFocusId: void 0
        }), this.state.isFocusEnabled && this.state.focusables.length > 0 && (input === tab && this.focusNext(), input === shiftTab && this.focusPrevious());
      }
    }), Object.defineProperty(this, "handleExit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (error) => {
        this.isRawModeSupported() && this.handleSetRawMode(!1), this.props.onExit(error);
      }
    }), Object.defineProperty(this, "enableFocus", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.setState({
          isFocusEnabled: !0
        });
      }
    }), Object.defineProperty(this, "disableFocus", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.setState({
          isFocusEnabled: !1
        });
      }
    }), Object.defineProperty(this, "focus", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (id) => {
        this.setState((previousState) => previousState.focusables.some((focusable) => focusable?.id === id) ? { activeFocusId: id } : previousState);
      }
    }), Object.defineProperty(this, "focusNext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.setState((previousState) => {
          let firstFocusableId = previousState.focusables[0]?.id;
          return {
            activeFocusId: this.findNextFocusable(previousState) ?? firstFocusableId
          };
        });
      }
    }), Object.defineProperty(this, "focusPrevious", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.setState((previousState) => {
          let lastFocusableId = previousState.focusables[previousState.focusables.length - 1]?.id;
          return {
            activeFocusId: this.findPreviousFocusable(previousState) ?? lastFocusableId
          };
        });
      }
    }), Object.defineProperty(this, "addFocusable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (id, { autoFocus }) => {
        this.setState((previousState) => {
          let nextFocusId = previousState.activeFocusId;
          return !nextFocusId && autoFocus && (nextFocusId = id), {
            activeFocusId: nextFocusId,
            focusables: [
              ...previousState.focusables,
              {
                id,
                isActive: !0
              }
            ]
          };
        });
      }
    }), Object.defineProperty(this, "removeFocusable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (id) => {
        this.setState((previousState) => ({
          activeFocusId: previousState.activeFocusId === id ? void 0 : previousState.activeFocusId,
          focusables: previousState.focusables.filter((focusable) => focusable.id !== id)
        }));
      }
    }), Object.defineProperty(this, "activateFocusable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (id) => {
        this.setState((previousState) => ({
          focusables: previousState.focusables.map((focusable) => focusable.id !== id ? focusable : {
            id,
            isActive: !0
          })
        }));
      }
    }), Object.defineProperty(this, "deactivateFocusable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (id) => {
        this.setState((previousState) => ({
          activeFocusId: previousState.activeFocusId === id ? void 0 : previousState.activeFocusId,
          focusables: previousState.focusables.map((focusable) => focusable.id !== id ? focusable : {
            id,
            isActive: !1
          })
        }));
      }
    }), Object.defineProperty(this, "findNextFocusable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (state) => {
        let activeIndex = state.focusables.findIndex((focusable) => focusable.id === state.activeFocusId);
        for (let index = activeIndex + 1; index < state.focusables.length; index++) {
          let focusable = state.focusables[index];
          if (focusable?.isActive)
            return focusable.id;
        }
      }
    }), Object.defineProperty(this, "findPreviousFocusable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (state) => {
        let activeIndex = state.focusables.findIndex((focusable) => focusable.id === state.activeFocusId);
        for (let index = activeIndex - 1; index >= 0; index--) {
          let focusable = state.focusables[index];
          if (focusable?.isActive)
            return focusable.id;
        }
      }
    });
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  // Determines if TTY is supported on the provided stdin
  isRawModeSupported() {
    return this.props.stdin.isTTY;
  }
  render() {
    return import_react9.default.createElement(
      AppContext_default.Provider,
      {
        // eslint-disable-next-line react/jsx-no-constructed-context-values
        value: {
          exit: this.handleExit
        }
      },
      import_react9.default.createElement(
        StdinContext_default.Provider,
        {
          // eslint-disable-next-line react/jsx-no-constructed-context-values
          value: {
            stdin: this.props.stdin,
            setRawMode: this.handleSetRawMode,
            isRawModeSupported: this.isRawModeSupported(),
            // eslint-disable-next-line @typescript-eslint/naming-convention
            internal_exitOnCtrlC: this.props.exitOnCtrlC,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            internal_eventEmitter: this.internal_eventEmitter
          }
        },
        import_react9.default.createElement(
          StdoutContext_default.Provider,
          {
            // eslint-disable-next-line react/jsx-no-constructed-context-values
            value: {
              stdout: this.props.stdout,
              write: this.props.writeToStdout
            }
          },
          import_react9.default.createElement(
            StderrContext_default.Provider,
            {
              // eslint-disable-next-line react/jsx-no-constructed-context-values
              value: {
                stderr: this.props.stderr,
                write: this.props.writeToStderr
              }
            },
            import_react9.default.createElement(
              FocusContext_default.Provider,
              {
                // eslint-disable-next-line react/jsx-no-constructed-context-values
                value: {
                  activeId: this.state.activeFocusId,
                  add: this.addFocusable,
                  remove: this.removeFocusable,
                  activate: this.activateFocusable,
                  deactivate: this.deactivateFocusable,
                  enableFocus: this.enableFocus,
                  disableFocus: this.disableFocus,
                  focusNext: this.focusNext,
                  focusPrevious: this.focusPrevious,
                  focus: this.focus
                }
              },
              this.state.error ? import_react9.default.createElement(ErrorOverview, { error: this.state.error }) : this.props.children
            )
          )
        )
      )
    );
  }
  componentDidMount() {
    cli_cursor_default.hide(this.props.stdout);
  }
  componentWillUnmount() {
    cli_cursor_default.show(this.props.stdout), this.isRawModeSupported() && this.handleSetRawMode(!1);
  }
  componentDidCatch(error) {
    this.handleExit(error);
  }
};
Object.defineProperty(App, "displayName", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "InternalApp"
});

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/ink.js
var isCi = process17.env.CI === "false" ? !1 : import_is_ci.default, noop = () => {
}, Ink = class {
  constructor(options) {
    Object.defineProperty(this, "options", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "log", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "throttledLog", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "isUnmounted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lastOutput", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "rootNode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fullStaticOutput", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exitPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "restoreConsole", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "unsubscribeResize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resized", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.calculateLayout(), this.onRender();
      }
    }), Object.defineProperty(this, "resolveExitPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), Object.defineProperty(this, "rejectExitPromise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), Object.defineProperty(this, "unsubscribeExit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
      }
    }), Object.defineProperty(this, "calculateLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        let terminalWidth = this.options.stdout.columns || 80;
        this.rootNode.yogaNode.setWidth(terminalWidth), this.rootNode.yogaNode.calculateLayout(void 0, void 0, Yoga.DIRECTION_LTR);
      }
    }), Object.defineProperty(this, "onRender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        if (this.isUnmounted)
          return;
        let { output: output2, outputHeight, staticOutput } = renderer_default(this.rootNode), hasStaticOutput = staticOutput && staticOutput !== `
`;
        if (this.options.debug) {
          hasStaticOutput && (this.fullStaticOutput += staticOutput), this.options.stdout.write(this.fullStaticOutput + output2);
          return;
        }
        if (isCi) {
          hasStaticOutput && this.options.stdout.write(staticOutput), this.lastOutput = output2;
          return;
        }
        if (hasStaticOutput && (this.fullStaticOutput += staticOutput), outputHeight >= this.options.stdout.rows) {
          this.options.stdout.write(ansi_escapes_default2.clearTerminal + this.fullStaticOutput + output2), this.lastOutput = output2;
          return;
        }
        hasStaticOutput && (this.log.clear(), this.options.stdout.write(staticOutput), this.log(output2)), !hasStaticOutput && output2 !== this.lastOutput && this.throttledLog(output2), this.lastOutput = output2;
      }
    }), autoBind(this), this.options = options, this.rootNode = createNode("ink-root"), this.rootNode.onComputeLayout = this.calculateLayout, this.rootNode.onRender = options.debug ? this.onRender : (0, import_throttle.default)(this.onRender, 32, {
      leading: !0,
      trailing: !0
    }), this.rootNode.onImmediateRender = this.onRender, this.log = log_update_default.create(options.stdout), this.throttledLog = options.debug ? this.log : (0, import_throttle.default)(this.log, void 0, {
      leading: !0,
      trailing: !0
    }), this.isUnmounted = !1, this.lastOutput = "", this.fullStaticOutput = "", this.container = reconciler_default.createContainer(
      this.rootNode,
      // Legacy mode
      0,
      null,
      !1,
      null,
      "id",
      () => {
      },
      null
    ), this.unsubscribeExit = (0, import_signal_exit3.default)(this.unmount, { alwaysLast: !1 }), process17.env.DEV === "true" && reconciler_default.injectIntoDevTools({
      bundleType: 0,
      // Reporting React DOM's version, not Ink's
      // See https://github.com/facebook/react/issues/16666#issuecomment-532639905
      version: "16.13.1",
      rendererPackageName: "ink"
    }), options.patchConsole && this.patchConsole(), isCi || (options.stdout.on("resize", this.resized), this.unsubscribeResize = () => {
      options.stdout.off("resize", this.resized);
    });
  }
  render(node) {
    let tree = import_react10.default.createElement(App, { stdin: this.options.stdin, stdout: this.options.stdout, stderr: this.options.stderr, writeToStdout: this.writeToStdout, writeToStderr: this.writeToStderr, exitOnCtrlC: this.options.exitOnCtrlC, onExit: this.unmount }, node);
    reconciler_default.updateContainer(tree, this.container, null, noop);
  }
  writeToStdout(data) {
    if (!this.isUnmounted) {
      if (this.options.debug) {
        this.options.stdout.write(data + this.fullStaticOutput + this.lastOutput);
        return;
      }
      if (isCi) {
        this.options.stdout.write(data);
        return;
      }
      this.log.clear(), this.options.stdout.write(data), this.log(this.lastOutput);
    }
  }
  writeToStderr(data) {
    if (!this.isUnmounted) {
      if (this.options.debug) {
        this.options.stderr.write(data), this.options.stdout.write(this.fullStaticOutput + this.lastOutput);
        return;
      }
      if (isCi) {
        this.options.stderr.write(data);
        return;
      }
      this.log.clear(), this.options.stderr.write(data), this.log(this.lastOutput);
    }
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  unmount(error) {
    this.isUnmounted || (this.calculateLayout(), this.onRender(), this.unsubscribeExit(), typeof this.restoreConsole == "function" && this.restoreConsole(), typeof this.unsubscribeResize == "function" && this.unsubscribeResize(), isCi ? this.options.stdout.write(this.lastOutput + `
`) : this.options.debug || this.log.done(), this.isUnmounted = !0, reconciler_default.updateContainer(null, this.container, null, noop), instances_default.delete(this.options.stdout), error instanceof Error ? this.rejectExitPromise(error) : this.resolveExitPromise());
  }
  async waitUntilExit() {
    return this.exitPromise || (this.exitPromise = new Promise((resolve, reject) => {
      this.resolveExitPromise = resolve, this.rejectExitPromise = reject;
    })), this.exitPromise;
  }
  clear() {
    !isCi && !this.options.debug && this.log.clear();
  }
  patchConsole() {
    this.options.debug || (this.restoreConsole = dist_default((stream2, data) => {
      stream2 === "stdout" && this.writeToStdout(data), stream2 === "stderr" && (data.startsWith("The above error occurred") || this.writeToStderr(data));
    }));
  }
};

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/render.js
var render = (node, options) => {
  let inkOptions = {
    stdout: process18.stdout,
    stdin: process18.stdin,
    stderr: process18.stderr,
    debug: !1,
    exitOnCtrlC: !0,
    patchConsole: !0,
    ...getOptions(options)
  }, instance = getInstance(inkOptions.stdout, () => new Ink(inkOptions));
  return instance.render(node), {
    rerender: instance.render,
    unmount() {
      instance.unmount();
    },
    waitUntilExit: instance.waitUntilExit,
    cleanup: () => instances_default.delete(inkOptions.stdout),
    clear: instance.clear
  };
}, render_default = render, getOptions = (stdout = {}) => stdout instanceof Stream ? {
  stdout,
  stdin: process18.stdin
} : stdout, getInstance = (stdout, createInstance) => {
  let instance = instances_default.get(stdout);
  return instance || (instance = createInstance(), instances_default.set(stdout, instance)), instance;
};

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/Static.js
init_cjs_shims();
var import_react11 = __toESM(require_react(), 1);
function Static(props) {
  let { items, children: render3, style: customStyle } = props, [index, setIndex] = (0, import_react11.useState)(0), itemsToRender = (0, import_react11.useMemo)(() => items.slice(index), [items, index]);
  (0, import_react11.useLayoutEffect)(() => {
    setIndex(items.length);
  }, [items.length]);
  let children = itemsToRender.map((item, itemIndex) => render3(item, index + itemIndex)), style = (0, import_react11.useMemo)(() => ({
    position: "absolute",
    flexDirection: "column",
    ...customStyle
  }), [customStyle]);
  return import_react11.default.createElement("ink-box", { internal_static: !0, style }, children);
}

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/Transform.js
init_cjs_shims();
var import_react12 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/Newline.js
init_cjs_shims();
var import_react13 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/components/Spacer.js
init_cjs_shims();
var import_react14 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-input.js
init_cjs_shims();
var import_react16 = __toESM(require_react(), 1), import_is_upper_case = __toESM(require_dist16(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/parse-keypress.js
init_cjs_shims();
import { Buffer as Buffer4 } from "node:buffer";
var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/, fnKeyRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/, keyName = {
  /* xterm/gnome ESC O letter */
  OP: "f1",
  OQ: "f2",
  OR: "f3",
  OS: "f4",
  /* xterm/rxvt ESC [ number ~ */
  "[11~": "f1",
  "[12~": "f2",
  "[13~": "f3",
  "[14~": "f4",
  /* from Cygwin and used in libuv */
  "[[A": "f1",
  "[[B": "f2",
  "[[C": "f3",
  "[[D": "f4",
  "[[E": "f5",
  /* common */
  "[15~": "f5",
  "[17~": "f6",
  "[18~": "f7",
  "[19~": "f8",
  "[20~": "f9",
  "[21~": "f10",
  "[23~": "f11",
  "[24~": "f12",
  /* xterm ESC [ letter */
  "[A": "up",
  "[B": "down",
  "[C": "right",
  "[D": "left",
  "[E": "clear",
  "[F": "end",
  "[H": "home",
  /* xterm/gnome ESC O letter */
  OA: "up",
  OB: "down",
  OC: "right",
  OD: "left",
  OE: "clear",
  OF: "end",
  OH: "home",
  /* xterm/rxvt ESC [ number ~ */
  "[1~": "home",
  "[2~": "insert",
  "[3~": "delete",
  "[4~": "end",
  "[5~": "pageup",
  "[6~": "pagedown",
  /* putty */
  "[[5~": "pageup",
  "[[6~": "pagedown",
  /* rxvt */
  "[7~": "home",
  "[8~": "end",
  /* rxvt keys with modifiers */
  "[a": "up",
  "[b": "down",
  "[c": "right",
  "[d": "left",
  "[e": "clear",
  "[2$": "insert",
  "[3$": "delete",
  "[5$": "pageup",
  "[6$": "pagedown",
  "[7$": "home",
  "[8$": "end",
  Oa: "up",
  Ob: "down",
  Oc: "right",
  Od: "left",
  Oe: "clear",
  "[2^": "insert",
  "[3^": "delete",
  "[5^": "pageup",
  "[6^": "pagedown",
  "[7^": "home",
  "[8^": "end",
  /* misc. */
  "[Z": "tab"
}, nonAlphanumericKeys = [...Object.values(keyName), "backspace"], isShiftKey = (code) => [
  "[a",
  "[b",
  "[c",
  "[d",
  "[e",
  "[2$",
  "[3$",
  "[5$",
  "[6$",
  "[7$",
  "[8$",
  "[Z"
].includes(code), isCtrlKey = (code) => [
  "Oa",
  "Ob",
  "Oc",
  "Od",
  "Oe",
  "[2^",
  "[3^",
  "[5^",
  "[6^",
  "[7^",
  "[8^"
].includes(code), parseKeypress = (s = "") => {
  let parts;
  Buffer4.isBuffer(s) ? s[0] > 127 && s[1] === void 0 ? (s[0] -= 128, s = "\x1B" + String(s)) : s = String(s) : s !== void 0 && typeof s != "string" ? s = String(s) : s || (s = "");
  let key = {
    name: "",
    ctrl: !1,
    meta: !1,
    shift: !1,
    option: !1,
    sequence: s,
    raw: s
  };
  if (key.sequence = key.sequence || s || key.name, s === "\r")
    key.raw = void 0, key.name = "return";
  else if (s === `
`)
    key.name = "enter";
  else if (s === "	")
    key.name = "tab";
  else if (s === "\b" || s === "\x1B\b")
    key.name = "backspace", key.meta = s.charAt(0) === "\x1B";
  else if (s === "\x7F" || s === "\x1B\x7F")
    key.name = "delete", key.meta = s.charAt(0) === "\x1B";
  else if (s === "\x1B" || s === "\x1B\x1B")
    key.name = "escape", key.meta = s.length === 2;
  else if (s === " " || s === "\x1B ")
    key.name = "space", key.meta = s.length === 2;
  else if (s <= "")
    key.name = String.fromCharCode(s.charCodeAt(0) + 97 - 1), key.ctrl = !0;
  else if (s.length === 1 && s >= "0" && s <= "9")
    key.name = "number";
  else if (s.length === 1 && s >= "a" && s <= "z")
    key.name = s;
  else if (s.length === 1 && s >= "A" && s <= "Z")
    key.name = s.toLowerCase(), key.shift = !0;
  else if (parts = metaKeyCodeRe.exec(s))
    key.meta = !0, key.shift = /^[A-Z]$/.test(parts[1]);
  else if (parts = fnKeyRe.exec(s)) {
    let segs = [...s];
    segs[0] === "\x1B" && segs[1] === "\x1B" && (key.option = !0);
    let code = [parts[1], parts[2], parts[4], parts[6]].filter(Boolean).join(""), modifier = (parts[3] || parts[5] || 1) - 1;
    key.ctrl = !!(modifier & 4), key.meta = !!(modifier & 10), key.shift = !!(modifier & 1), key.code = code, key.name = keyName[code], key.shift = isShiftKey(code) || key.shift, key.ctrl = isCtrlKey(code) || key.ctrl;
  }
  return key;
}, parse_keypress_default = parseKeypress;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-stdin.js
init_cjs_shims();
var import_react15 = __toESM(require_react(), 1);
var useStdin = () => (0, import_react15.useContext)(StdinContext_default), use_stdin_default = useStdin;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-input.js
var useInput = (inputHandler, options = {}) => {
  let { stdin, setRawMode, internal_exitOnCtrlC, internal_eventEmitter } = use_stdin_default();
  (0, import_react16.useEffect)(() => {
    if (options.isActive !== !1)
      return setRawMode(!0), () => {
        setRawMode(!1);
      };
  }, [options.isActive, setRawMode]), (0, import_react16.useEffect)(() => {
    if (options.isActive === !1)
      return;
    let handleData = (data) => {
      let keypress2 = parse_keypress_default(data), key = {
        upArrow: keypress2.name === "up",
        downArrow: keypress2.name === "down",
        leftArrow: keypress2.name === "left",
        rightArrow: keypress2.name === "right",
        pageDown: keypress2.name === "pagedown",
        pageUp: keypress2.name === "pageup",
        return: keypress2.name === "return",
        escape: keypress2.name === "escape",
        ctrl: keypress2.ctrl,
        shift: keypress2.shift,
        tab: keypress2.name === "tab",
        backspace: keypress2.name === "backspace",
        delete: keypress2.name === "delete",
        // `parseKeypress` parses \u001B\u001B[A (meta + up arrow) as meta = false
        // but with option = true, so we need to take this into account here
        // to avoid breaking changes in Ink.
        // TODO(vadimdemedes): consider removing this in the next major version.
        meta: keypress2.meta || keypress2.name === "escape" || keypress2.option
      }, input = keypress2.ctrl ? keypress2.name : keypress2.sequence;
      nonAlphanumericKeys.includes(keypress2.name) && (input = ""), input.startsWith("\x1B") && (input = input.slice(1)), input.length === 1 && typeof input[0] == "string" && (0, import_is_upper_case.isUpperCase)(input[0]) && (key.shift = !0), (!(input === "c" && key.ctrl) || !internal_exitOnCtrlC) && reconciler_default.batchedUpdates(() => {
        inputHandler(input, key);
      });
    };
    return internal_eventEmitter?.on("input", handleData), () => {
      internal_eventEmitter?.removeListener("input", handleData);
    };
  }, [options.isActive, stdin, internal_exitOnCtrlC, inputHandler]);
}, use_input_default = useInput;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-app.js
init_cjs_shims();
var import_react17 = __toESM(require_react(), 1);
var useApp = () => (0, import_react17.useContext)(AppContext_default), use_app_default = useApp;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-stdout.js
init_cjs_shims();
var import_react18 = __toESM(require_react(), 1);
var useStdout = () => (0, import_react18.useContext)(StdoutContext_default), use_stdout_default = useStdout;

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-stderr.js
init_cjs_shims();
var import_react19 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-focus.js
init_cjs_shims();
var import_react20 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/hooks/use-focus-manager.js
init_cjs_shims();
var import_react21 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/ink@4.4.1_@types+react@17.0.2_react@18.3.1/node_modules/ink/build/measure-element.js
init_cjs_shims();
var measureElement = (node) => ({
  width: node.yogaNode?.getComputedWidth() ?? 0,
  height: node.yogaNode?.getComputedHeight() ?? 0
}), measure_element_default = measureElement;

// ../cli-kit/dist/private/node/ui/components/Command.js
var import_react22 = __toESM(require_react(), 1), Command = ({ command }) => import_react22.default.createElement(
  Text,
  { color: "magentaBright" },
  "`",
  command,
  "`"
);

// ../cli-kit/dist/private/node/ui/components/Link.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/contexts/LinksContext.js
init_cjs_shims();
var import_react23 = __toESM(require_react(), 1), LinksContext = import_react23.default.createContext(null);

// ../cli-kit/dist/private/node/ui/components/Link.js
var import_react24 = __toESM(require_react(), 1);
var import_supports_hyperlinks2 = __toESM(require_supports_hyperlinks(), 1);
function link(label, url, linksContext) {
  if (!import_supports_hyperlinks2.default.stdout) {
    if (url === (label ?? url))
      return url;
    if (linksContext === null)
      return label ? `${label} ${source_default.dim(`( ${url} )`)}` : url;
    let linkId = linksContext.addLink(label, url);
    return `${label ?? url} [${linkId}]`;
  }
  return ansi_escapes_default2.link(label ?? url, url);
}
var Link = ({ label, url }) => {
  let linksContext = (0, import_react24.useContext)(LinksContext);
  return import_react24.default.createElement(Text, null, link(label, url, linksContext));
};

// ../cli-kit/dist/private/node/ui/components/List.js
init_cjs_shims();
var import_react25 = __toESM(require_react(), 1), DOT = "\u2022", List = ({ title, items, margin = !0, ordered = !1, color, bullet = DOT }) => {
  function isCustomListItem(item) {
    return item.item !== void 0;
  }
  function resolveListItem(item, index) {
    let resolvedItem = {
      index,
      color,
      bullet,
      ordered,
      item
    };
    return isCustomListItem(item) ? {
      ...resolvedItem,
      ...item
    } : resolvedItem;
  }
  let ListItem = ({ item, color: color2, bullet: bullet2, index, ordered: ordered2 }) => import_react25.default.createElement(
    Box_default,
    { key: index, marginLeft: margin ? 2 : 0 },
    import_react25.default.createElement(Text, { color: color2 }, ordered2 ? `${index + 1}.` : bullet2),
    import_react25.default.createElement(
      Box_default,
      { flexGrow: 1, marginLeft: 1 },
      import_react25.default.createElement(
        Text,
        { color: color2 },
        import_react25.default.createElement(TokenizedText, { item })
      )
    )
  );
  return import_react25.default.createElement(
    Box_default,
    { flexDirection: "column" },
    title ? import_react25.default.createElement(
      Text,
      { color },
      import_react25.default.createElement(TokenizedText, { item: title })
    ) : null,
    items.map(resolveListItem).map(({ index, item, color: color2, bullet: bullet2, ordered: ordered2 }) => import_react25.default.createElement(ListItem, { key: index, item, color: color2, bullet: bullet2, index, ordered: ordered2 }))
  );
};

// ../cli-kit/dist/private/node/ui/components/UserInput.js
init_cjs_shims();
var import_react26 = __toESM(require_react(), 1), UserInput = ({ userInput }) => import_react26.default.createElement(Text, { color: "cyan" }, userInput);

// ../cli-kit/dist/private/node/ui/components/FilePath.js
init_cjs_shims();
var import_react27 = __toESM(require_react(), 1), FilePath = ({ filePath }) => import_react27.default.createElement(Text, { italic: !0 }, filePath);

// ../cli-kit/dist/private/node/ui/components/Subdued.js
init_cjs_shims();
var import_react28 = __toESM(require_react(), 1), Subdued = ({ subdued }) => import_react28.default.createElement(Text, { dimColor: !0 }, subdued);

// ../cli-kit/dist/private/node/ui/components/TokenizedText.js
var import_react29 = __toESM(require_react(), 1);
function tokenToBlock(token) {
  return {
    display: typeof token != "string" && "list" in token ? "block" : "inline",
    value: token
  };
}
function tokenItemToString(token) {
  return typeof token == "string" ? token : "command" in token ? token.command : "link" in token ? token.link.label || token.link.url : "char" in token ? token.char : "userInput" in token ? token.userInput : "subdued" in token ? token.subdued : "filePath" in token ? token.filePath : "list" in token ? token.list.items.map(tokenItemToString).join(" ") : "bold" in token ? token.bold : "info" in token ? token.info : "warn" in token ? token.warn : "error" in token ? token.error : token.map((item, index) => index !== 0 && !(typeof item != "string" && "char" in item) ? ` ${tokenItemToString(item)}` : tokenItemToString(item)).join("");
}
function appendToTokenItem(token, suffix) {
  return Array.isArray(token) ? [...token, { char: suffix }] : [token, { char: suffix }];
}
function splitByDisplayType(acc, item) {
  if (item.display === "block")
    acc.push([item]);
  else {
    let last = acc[acc.length - 1];
    last && last[0].display === "inline" ? last.push(item) : acc.push([item]);
  }
  return acc;
}
var InlineBlocks = ({ blocks }) => import_react29.default.createElement(Text, null, blocks.map((block, blockIndex) => import_react29.default.createElement(
  Text,
  { key: blockIndex },
  blockIndex !== 0 && !(typeof block.value != "string" && "char" in block.value) && import_react29.default.createElement(Text, null, " "),
  import_react29.default.createElement(TokenizedText, { item: block.value })
))), TokenizedText = ({ item }) => {
  if (typeof item == "string")
    return import_react29.default.createElement(Text, null, item);
  if ("command" in item)
    return import_react29.default.createElement(Command, { command: item.command });
  if ("link" in item)
    return import_react29.default.createElement(Link, { ...item.link });
  if ("char" in item)
    return import_react29.default.createElement(Text, null, item.char[0]);
  if ("userInput" in item)
    return import_react29.default.createElement(UserInput, { userInput: item.userInput });
  if ("subdued" in item)
    return import_react29.default.createElement(Subdued, { subdued: item.subdued });
  if ("filePath" in item)
    return import_react29.default.createElement(FilePath, { filePath: item.filePath });
  if ("list" in item)
    return import_react29.default.createElement(List, { ...item.list });
  if ("bold" in item)
    return import_react29.default.createElement(Text, { bold: !0 }, item.bold);
  if ("info" in item)
    return import_react29.default.createElement(Text, { color: "blue" }, item.info);
  if ("warn" in item)
    return import_react29.default.createElement(Text, { color: "yellow" }, item.warn);
  if ("error" in item)
    return import_react29.default.createElement(Text, { color: "red" }, item.error);
  {
    let groupedItems = item.map(tokenToBlock).reduce(splitByDisplayType, []);
    return groupedItems.length === 1 && groupedItems[0].every((item2) => item2.display === "inline") ? import_react29.default.createElement(InlineBlocks, { blocks: groupedItems[0] }) : import_react29.default.createElement(Box_default, { flexDirection: "column" }, groupedItems.map((items, groupIndex) => items[0].display === "inline" ? import_react29.default.createElement(InlineBlocks, { blocks: items, key: groupIndex }) : import_react29.default.createElement(List, { key: groupIndex, ...items[0].value.list })));
  }
};

// ../cli-kit/dist/private/node/output.js
init_cjs_shims();
function withOrWithoutStyle(message) {
  return shouldDisplayColors() ? message : unstyled(message);
}
function consoleLog(message) {
  process.stdout.write(`${withOrWithoutStyle(message)}
`);
}
function consoleWarn(message) {
  process.stderr.write(`${withOrWithoutStyle(message)}
`);
}
function output(content, logLevel = "info", logger = consoleWarn) {
  isUnitTest() && collectLog(logLevel, content);
  let message = stringifyMessage(content);
  outputWhereAppropriate(logLevel, logger, message);
}

// ../cli-kit/dist/public/node/output.js
import { Writable } from "stream";
var TokenizedString = class {
  constructor(value) {
    this.value = value;
  }
}, outputToken = {
  raw(value) {
    return new RawContentToken(value);
  },
  genericShellCommand(value) {
    return new CommandContentToken(value);
  },
  json(value) {
    return new JsonContentToken(value);
  },
  path(value) {
    return new PathContentToken(value);
  },
  link(value, link2, fallback) {
    return new LinkContentToken(value, link2, fallback);
  },
  heading(value) {
    return new HeadingContentToken(value);
  },
  subheading(value) {
    return new SubHeadingContentToken(value);
  },
  italic(value) {
    return new ItalicContentToken(value);
  },
  errorText(value) {
    return new ErrorContentToken(value);
  },
  cyan(value) {
    return new ColorContentToken(value, source_default.cyan);
  },
  yellow(value) {
    return new ColorContentToken(value, source_default.yellow);
  },
  magenta(value) {
    return new ColorContentToken(value, source_default.magenta);
  },
  green(value) {
    return new ColorContentToken(value, source_default.green);
  },
  gray(value) {
    return new ColorContentToken(value, source_default.gray);
  },
  packagejsonScript(packageManager, scriptName, ...scriptArgs) {
    return new CommandContentToken(formatPackageManagerCommand(packageManager, scriptName, ...scriptArgs));
  },
  successIcon() {
    return new ColorContentToken("\u2714", source_default.green);
  },
  failIcon() {
    return new ErrorContentToken("\u2716");
  },
  linesDiff(value) {
    return new LinesDiffContentToken(value);
  }
};
function formatPackageManagerCommand(packageManager, scriptName, ...scriptArgs) {
  if (currentProcessIsGlobal())
    return [scriptName, ...scriptArgs].join(" ");
  switch (packageManager) {
    case "pnpm":
    case "bun":
    case "yarn":
      return [packageManager, scriptName, ...scriptArgs].join(" ");
    case "npm": {
      let pieces = ["npm", "run", scriptName];
      return scriptArgs.length > 0 && (pieces.push("--"), pieces.push(...scriptArgs)), pieces.join(" ");
    }
    case "unknown":
      return [scriptName, ...scriptArgs].join(" ");
  }
}
function outputContent(strings, ...keys) {
  let output2 = "";
  return strings.forEach((string, i) => {
    if (output2 += string, i >= keys.length)
      return;
    let token = keys[i];
    if (typeof token == "string")
      output2 += token;
    else if (token) {
      let enumTokenOutput = token.output();
      Array.isArray(enumTokenOutput) ? enumTokenOutput.forEach((line) => {
        output2 += line;
      }) : output2 += enumTokenOutput;
    }
  }), new TokenizedString(output2);
}
function logLevelValue(level) {
  switch (level) {
    case "trace":
      return 10;
    case "debug":
      return 20;
    case "info":
      return 30;
    case "warn":
      return 40;
    case "error":
      return 50;
    case "fatal":
      return 60;
    default:
      return 30;
  }
}
function currentLogLevel() {
  return isVerbose() ? "debug" : "info";
}
function shouldOutput(logLevel) {
  if (isUnitTest())
    return !1;
  let currentLogLevelValue = logLevelValue(currentLogLevel());
  return logLevelValue(logLevel) >= currentLogLevelValue;
}
var collectedLogs = {};
function collectLog(key, content) {
  let output2 = collectedLogs.output ?? [], data = collectedLogs[key] ?? [];
  data.push(stripAnsi(stringifyMessage(content) ?? "")), output2.push(stripAnsi(stringifyMessage(content) ?? "")), collectedLogs[key] = data, collectedLogs.output = output2;
}
var clearCollectedLogs = () => {
  collectedLogs = {};
};
function outputResult(content) {
  output(content, "info", consoleLog);
}
function outputInfo(content, logger = consoleWarn) {
  let message = stringifyMessage(content);
  isUnitTest() && collectLog("info", content), outputWhereAppropriate("info", logger, message);
}
function outputSuccess(content, logger = consoleWarn) {
  let message = source_default.bold(`\u2705 Success! ${stringifyMessage(content)}.`);
  isUnitTest() && collectLog("success", content), outputWhereAppropriate("info", logger, message);
}
function outputCompleted(content, logger = consoleWarn) {
  let message = `${source_default.green("\u2714")} ${stringifyMessage(content)}`;
  isUnitTest() && collectLog("completed", content), outputWhereAppropriate("info", logger, message);
}
function outputDebug(content, logger = consoleWarn) {
  isUnitTest() && collectLog("debug", content);
  let message = source_default.gray(stringifyMessage(content));
  outputWhereAppropriate("debug", logger, `${(/* @__PURE__ */ new Date()).toISOString()}: ${message}`);
}
function outputWarn(content, logger = consoleWarn) {
  isUnitTest() && collectLog("warn", content);
  let message = source_default.yellow(stringifyMessage(content));
  outputWhereAppropriate("warn", logger, message);
}
function outputNewline() {
  consoleWarn("");
}
function stringifyMessage(message) {
  return message instanceof TokenizedString ? message.value : message;
}
function itemToString(item) {
  return tokenItemToString(item);
}
function outputWhereAppropriate(logLevel, logger, message) {
  shouldOutput(logLevel) && (logger instanceof Writable ? logger.write(message) : logger(message, logLevel));
}
function unstyled(message) {
  return stripAnsi(message);
}
function shouldDisplayColors(_process = process) {
  let { env: env3, stdout } = _process;
  return Object.hasOwnProperty.call(env3, "FORCE_COLOR") ? isTruthy(env3.FORCE_COLOR) : !!stdout.isTTY;
}
function formatSection(title, body) {
  let formattedTitle = `${title.toUpperCase()}${" ".repeat(35 - title.length)}`;
  return outputContent`${outputToken.heading(formattedTitle)}\n${body}`.value;
}

// ../cli-kit/dist/public/node/error.js
var import_core2 = __toESM(require_lib()), import_ts_error = __toESM(require_cjs()), FatalErrorType;
(function(FatalErrorType2) {
  FatalErrorType2[FatalErrorType2.Abort = 0] = "Abort", FatalErrorType2[FatalErrorType2.AbortSilent = 1] = "AbortSilent", FatalErrorType2[FatalErrorType2.Bug = 2] = "Bug";
})(FatalErrorType || (FatalErrorType = {}));
var CancelExecution = class extends Error {
}, FatalError = class extends Error {
  /**
   * Creates a new FatalError error.
   *
   * @param message - The error message.
   * @param type - The type of fatal error.
   * @param tryMessage - The message that recommends next steps to the user.
   * You can pass a string a {@link TokenizedString} or a {@link TokenItem}
   * if you need to style the message inside the error Banner component.
   * @param nextSteps - Message to show as "next steps" with suggestions to solve the issue.
   * @param customSections - Custom sections to show in the error banner. To be used if nextSteps is not enough.
   */
  constructor(message, type, tryMessage = null, nextSteps, customSections) {
    let messageIsOutputMessage = typeof message == "string" || "value" in message;
    super(messageIsOutputMessage ? stringifyMessage(message) : tokenItemToString(message)), tryMessage ? tryMessage instanceof TokenizedString ? this.tryMessage = stringifyMessage(tryMessage) : this.tryMessage = tryMessage : this.tryMessage = null, this.type = type, this.nextSteps = nextSteps, this.customSections = customSections, this.skipOclifErrorHandling = !0, messageIsOutputMessage || (this.formattedMessage = message);
  }
}, AbortError = class extends FatalError {
  constructor(message, tryMessage = null, nextSteps, customSections) {
    super(message, FatalErrorType.Abort, tryMessage, nextSteps, customSections);
  }
}, ExternalError = class extends FatalError {
  constructor(message, command, args, tryMessage = null) {
    super(message, FatalErrorType.Abort, tryMessage), this.command = command, this.args = args;
  }
}, AbortSilentError = class extends FatalError {
  constructor() {
    super("", FatalErrorType.AbortSilent);
  }
}, BugError = class extends FatalError {
  constructor(message, tryMessage = null) {
    super(message, FatalErrorType.Bug, tryMessage);
  }
};
async function handler(error) {
  let fatal;
  if (isFatal(error))
    fatal = error;
  else if (typeof error == "string")
    fatal = new BugError(error);
  else if (error instanceof Error)
    fatal = new BugError(error.message), fatal.stack = error.stack;
  else {
    let maybeError = error;
    fatal = new BugError(maybeError?.message ?? "Unknown error"), maybeError?.stack && (fatal.stack = maybeError?.stack);
  }
  return renderFatalError(fatal), Promise.resolve(error);
}
function errorMapper(error) {
  if (error instanceof import_core2.Errors.CLIError) {
    let mappedError = new AbortError(error.message);
    return mappedError.stack = error.stack, Promise.resolve(mappedError);
  } else
    return Promise.resolve(error);
}
function isFatal(error) {
  try {
    return Object.prototype.hasOwnProperty.call(error, "type");
  } catch {
    return !1;
  }
}
function shouldReportErrorAsUnexpected(error) {
  if (!isFatal(error)) {
    if (error instanceof Error) {
      let message = error.message;
      return !errorMessageImpliesEnvironmentIssue(message);
    }
    return !0;
  }
  return error.type === FatalErrorType.Bug;
}
function cleanSingleStackTracePath(filePath) {
  return normalizePath(filePath).replace("file:/", "/").replace(/^\/?[A-Z]:/, "");
}
function errorMessageImpliesEnvironmentIssue(message) {
  return [
    "EPERM: operation not permitted, scandir",
    "EPERM: operation not permitted, rename",
    "EACCES: permission denied",
    "EPERM: operation not permitted, symlink",
    "This version of npm supports the following node versions",
    "EBUSY: resource busy or locked",
    "ENOTEMPTY: directory not empty",
    "getaddrinfo ENOTFOUND",
    "Client network socket disconnected before secure TLS connection was established",
    "spawn EPERM",
    "socket hang up"
  ].some((issueMessage) => message.includes(issueMessage));
}

// ../cli-kit/dist/public/node/abort.js
init_cjs_shims();
var import_node_abort_controller = __toESM(require_node_abort_controller(), 1), AbortController = class extends import_node_abort_controller.AbortController {
}, AbortSignal = class extends import_node_abort_controller.AbortSignal {
};

// ../cli-kit/dist/public/node/metadata.js
init_cjs_shims();
import { performance as performance2 } from "node:perf_hooks";
function getMetadataErrorHandlingStrategy() {
  return isUnitTest() ? "bubble" : "mute-and-report";
}
function createRuntimeMetadataContainer(defaultPublicMetadata = {}) {
  let raw = {
    sensitive: {},
    public: {
      ...defaultPublicMetadata
    }
  }, addPublic = (data) => {
    Object.assign(raw.public, data);
  }, addSensitive = (data) => {
    Object.assign(raw.sensitive, data);
  }, addMetadata = async (addFn, getFn, onError) => {
    let errorHandling = onError === "auto" ? getMetadataErrorHandlingStrategy() : onError, getAndSet = async () => {
      let data = await getFn();
      addFn(data);
    };
    if (errorHandling === "bubble")
      await getAndSet();
    else
      try {
        await getAndSet();
      } catch (error) {
        let { sendErrorToBugsnag } = await import("./error-handler-FHZMF7GS.js");
        await sendErrorToBugsnag(error, "unexpected_error");
      }
  }, durationStack = [];
  return {
    getAllPublicMetadata: () => ({ ...raw.public }),
    getAllSensitiveMetadata: () => ({ ...raw.sensitive }),
    addPublicMetadata: async (getData, onError = "auto") => addMetadata(addPublic, getData, onError),
    addSensitiveMetadata: async (getData, onError = "auto") => addMetadata(addSensitive, getData, onError),
    runWithTimer: (field) => async (fn) => {
      durationStack.push(0);
      let start = performance2.now();
      try {
        return await fn();
      } finally {
        let end = performance2.now();
        end = Math.max(start, end);
        let wallClockDuration = Math.max(end - start, 0), childDurations = durationStack.pop(), duration = Math.max(wallClockDuration - childDurations, 0);
        durationStack.length > 0 && (durationStack[durationStack.length - 1] = (durationStack[durationStack.length - 1] ?? 0) + wallClockDuration), performance2.measure(`${field}#measurable`, {
          start,
          duration
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }), performance2.measure(`${field}#wall`, {
          start,
          end
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        });
        let currentValue = raw.public[field] || 0;
        currentValue += duration, raw.public[field] = currentValue;
      }
    }
  };
}
var coreData = createRuntimeMetadataContainer({ cmd_all_timing_network_ms: 0, cmd_all_timing_prompts_ms: 0 }), { getAllPublicMetadata, getAllSensitiveMetadata, addPublicMetadata, addSensitiveMetadata, runWithTimer } = coreData;

// ../cli-kit/dist/private/node/ui/components/ConcurrentOutput.js
init_cjs_shims();
var import_react30 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/figures@5.0.0/node_modules/figures/index.js
init_cjs_shims();
import process20 from "node:process";

// ../../node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js
init_cjs_shims();

// ../../node_modules/.pnpm/is-unicode-supported@1.3.0/node_modules/is-unicode-supported/index.js
init_cjs_shims();
import process19 from "node:process";
function isUnicodeSupported() {
  return process19.platform !== "win32" ? process19.env.TERM !== "linux" : !!process19.env.CI || !!process19.env.WT_SESSION || !!process19.env.TERMINUS_SUBLIME || process19.env.ConEmuTask === "{cmd::Cmder}" || process19.env.TERM_PROGRAM === "Terminus-Sublime" || process19.env.TERM_PROGRAM === "vscode" || process19.env.TERM === "xterm-256color" || process19.env.TERM === "alacritty" || process19.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// ../../node_modules/.pnpm/figures@5.0.0/node_modules/figures/index.js
var { platform } = process20, common = {
  square: "\u2588",
  squareDarkShade: "\u2593",
  squareMediumShade: "\u2592",
  squareLightShade: "\u2591",
  squareTop: "\u2580",
  squareBottom: "\u2584",
  squareLeft: "\u258C",
  squareRight: "\u2590",
  squareCenter: "\u25A0",
  bullet: "\u25CF",
  dot: "\u2024",
  ellipsis: "\u2026",
  pointerSmall: "\u203A",
  triangleUp: "\u25B2",
  triangleUpSmall: "\u25B4",
  triangleDown: "\u25BC",
  triangleDownSmall: "\u25BE",
  triangleLeftSmall: "\u25C2",
  triangleRightSmall: "\u25B8",
  home: "\u2302",
  heart: "\u2665",
  musicNote: "\u266A",
  musicNoteBeamed: "\u266B",
  arrowUp: "\u2191",
  arrowDown: "\u2193",
  arrowLeft: "\u2190",
  arrowRight: "\u2192",
  arrowLeftRight: "\u2194",
  arrowUpDown: "\u2195",
  almostEqual: "\u2248",
  notEqual: "\u2260",
  lessOrEqual: "\u2264",
  greaterOrEqual: "\u2265",
  identical: "\u2261",
  infinity: "\u221E",
  subscriptZero: "\u2080",
  subscriptOne: "\u2081",
  subscriptTwo: "\u2082",
  subscriptThree: "\u2083",
  subscriptFour: "\u2084",
  subscriptFive: "\u2085",
  subscriptSix: "\u2086",
  subscriptSeven: "\u2087",
  subscriptEight: "\u2088",
  subscriptNine: "\u2089",
  oneHalf: "\xBD",
  oneThird: "\u2153",
  oneQuarter: "\xBC",
  oneFifth: "\u2155",
  oneSixth: "\u2159",
  oneEighth: "\u215B",
  twoThirds: "\u2154",
  twoFifths: "\u2156",
  threeQuarters: "\xBE",
  threeFifths: "\u2157",
  threeEighths: "\u215C",
  fourFifths: "\u2158",
  fiveSixths: "\u215A",
  fiveEighths: "\u215D",
  sevenEighths: "\u215E",
  line: "\u2500",
  lineBold: "\u2501",
  lineDouble: "\u2550",
  lineDashed0: "\u2504",
  lineDashed1: "\u2505",
  lineDashed2: "\u2508",
  lineDashed3: "\u2509",
  lineDashed4: "\u254C",
  lineDashed5: "\u254D",
  lineDashed6: "\u2574",
  lineDashed7: "\u2576",
  lineDashed8: "\u2578",
  lineDashed9: "\u257A",
  lineDashed10: "\u257C",
  lineDashed11: "\u257E",
  lineDashed12: "\u2212",
  lineDashed13: "\u2013",
  lineDashed14: "\u2010",
  lineDashed15: "\u2043",
  lineVertical: "\u2502",
  lineVerticalBold: "\u2503",
  lineVerticalDouble: "\u2551",
  lineVerticalDashed0: "\u2506",
  lineVerticalDashed1: "\u2507",
  lineVerticalDashed2: "\u250A",
  lineVerticalDashed3: "\u250B",
  lineVerticalDashed4: "\u254E",
  lineVerticalDashed5: "\u254F",
  lineVerticalDashed6: "\u2575",
  lineVerticalDashed7: "\u2577",
  lineVerticalDashed8: "\u2579",
  lineVerticalDashed9: "\u257B",
  lineVerticalDashed10: "\u257D",
  lineVerticalDashed11: "\u257F",
  lineDownLeft: "\u2510",
  lineDownLeftArc: "\u256E",
  lineDownBoldLeftBold: "\u2513",
  lineDownBoldLeft: "\u2512",
  lineDownLeftBold: "\u2511",
  lineDownDoubleLeftDouble: "\u2557",
  lineDownDoubleLeft: "\u2556",
  lineDownLeftDouble: "\u2555",
  lineDownRight: "\u250C",
  lineDownRightArc: "\u256D",
  lineDownBoldRightBold: "\u250F",
  lineDownBoldRight: "\u250E",
  lineDownRightBold: "\u250D",
  lineDownDoubleRightDouble: "\u2554",
  lineDownDoubleRight: "\u2553",
  lineDownRightDouble: "\u2552",
  lineUpLeft: "\u2518",
  lineUpLeftArc: "\u256F",
  lineUpBoldLeftBold: "\u251B",
  lineUpBoldLeft: "\u251A",
  lineUpLeftBold: "\u2519",
  lineUpDoubleLeftDouble: "\u255D",
  lineUpDoubleLeft: "\u255C",
  lineUpLeftDouble: "\u255B",
  lineUpRight: "\u2514",
  lineUpRightArc: "\u2570",
  lineUpBoldRightBold: "\u2517",
  lineUpBoldRight: "\u2516",
  lineUpRightBold: "\u2515",
  lineUpDoubleRightDouble: "\u255A",
  lineUpDoubleRight: "\u2559",
  lineUpRightDouble: "\u2558",
  lineUpDownLeft: "\u2524",
  lineUpBoldDownBoldLeftBold: "\u252B",
  lineUpBoldDownBoldLeft: "\u2528",
  lineUpDownLeftBold: "\u2525",
  lineUpBoldDownLeftBold: "\u2529",
  lineUpDownBoldLeftBold: "\u252A",
  lineUpDownBoldLeft: "\u2527",
  lineUpBoldDownLeft: "\u2526",
  lineUpDoubleDownDoubleLeftDouble: "\u2563",
  lineUpDoubleDownDoubleLeft: "\u2562",
  lineUpDownLeftDouble: "\u2561",
  lineUpDownRight: "\u251C",
  lineUpBoldDownBoldRightBold: "\u2523",
  lineUpBoldDownBoldRight: "\u2520",
  lineUpDownRightBold: "\u251D",
  lineUpBoldDownRightBold: "\u2521",
  lineUpDownBoldRightBold: "\u2522",
  lineUpDownBoldRight: "\u251F",
  lineUpBoldDownRight: "\u251E",
  lineUpDoubleDownDoubleRightDouble: "\u2560",
  lineUpDoubleDownDoubleRight: "\u255F",
  lineUpDownRightDouble: "\u255E",
  lineDownLeftRight: "\u252C",
  lineDownBoldLeftBoldRightBold: "\u2533",
  lineDownLeftBoldRightBold: "\u252F",
  lineDownBoldLeftRight: "\u2530",
  lineDownBoldLeftBoldRight: "\u2531",
  lineDownBoldLeftRightBold: "\u2532",
  lineDownLeftRightBold: "\u252E",
  lineDownLeftBoldRight: "\u252D",
  lineDownDoubleLeftDoubleRightDouble: "\u2566",
  lineDownDoubleLeftRight: "\u2565",
  lineDownLeftDoubleRightDouble: "\u2564",
  lineUpLeftRight: "\u2534",
  lineUpBoldLeftBoldRightBold: "\u253B",
  lineUpLeftBoldRightBold: "\u2537",
  lineUpBoldLeftRight: "\u2538",
  lineUpBoldLeftBoldRight: "\u2539",
  lineUpBoldLeftRightBold: "\u253A",
  lineUpLeftRightBold: "\u2536",
  lineUpLeftBoldRight: "\u2535",
  lineUpDoubleLeftDoubleRightDouble: "\u2569",
  lineUpDoubleLeftRight: "\u2568",
  lineUpLeftDoubleRightDouble: "\u2567",
  lineUpDownLeftRight: "\u253C",
  lineUpBoldDownBoldLeftBoldRightBold: "\u254B",
  lineUpDownBoldLeftBoldRightBold: "\u2548",
  lineUpBoldDownLeftBoldRightBold: "\u2547",
  lineUpBoldDownBoldLeftRightBold: "\u254A",
  lineUpBoldDownBoldLeftBoldRight: "\u2549",
  lineUpBoldDownLeftRight: "\u2540",
  lineUpDownBoldLeftRight: "\u2541",
  lineUpDownLeftBoldRight: "\u253D",
  lineUpDownLeftRightBold: "\u253E",
  lineUpBoldDownBoldLeftRight: "\u2542",
  lineUpDownLeftBoldRightBold: "\u253F",
  lineUpBoldDownLeftBoldRight: "\u2543",
  lineUpBoldDownLeftRightBold: "\u2544",
  lineUpDownBoldLeftBoldRight: "\u2545",
  lineUpDownBoldLeftRightBold: "\u2546",
  lineUpDoubleDownDoubleLeftDoubleRightDouble: "\u256C",
  lineUpDoubleDownDoubleLeftRight: "\u256B",
  lineUpDownLeftDoubleRightDouble: "\u256A",
  lineCross: "\u2573",
  lineBackslash: "\u2572",
  lineSlash: "\u2571"
}, mainSymbols = {
  ...common,
  // The main symbols for those do not look that good on Ubuntu.
  ...platform === "linux" ? {
    circleQuestionMark: "?\u20DD",
    questionMarkPrefix: "?\u20DD"
  } : {
    circleQuestionMark: "?",
    questionMarkPrefix: "?"
  },
  tick: "\u2714",
  info: "\u2139",
  warning: "\u26A0",
  cross: "\u2718",
  squareSmall: "\u25FB",
  squareSmallFilled: "\u25FC",
  circle: "\u25EF",
  circleFilled: "\u25C9",
  circleDotted: "\u25CC",
  circleDouble: "\u25CE",
  circleCircle: "\u24DE",
  circleCross: "\u24E7",
  circlePipe: "\u24BE",
  radioOn: "\u25C9",
  radioOff: "\u25EF",
  checkboxOn: "\u2612",
  checkboxOff: "\u2610",
  checkboxCircleOn: "\u24E7",
  checkboxCircleOff: "\u24BE",
  pointer: "\u276F",
  triangleUpOutline: "\u25B3",
  triangleLeft: "\u25C0",
  triangleRight: "\u25B6",
  lozenge: "\u25C6",
  lozengeOutline: "\u25C7",
  hamburger: "\u2630",
  smiley: "\u32E1",
  mustache: "\u0DF4",
  star: "\u2605",
  play: "\u25B6",
  nodejs: "\u2B22",
  oneSeventh: "\u2150",
  oneNinth: "\u2151",
  oneTenth: "\u2152"
}, fallbackSymbols = {
  ...common,
  tick: "\u221A",
  info: "i",
  warning: "\u203C",
  cross: "\xD7",
  squareSmall: "\u25A1",
  squareSmallFilled: "\u25A0",
  circle: "( )",
  circleFilled: "(*)",
  circleDotted: "( )",
  circleDouble: "( )",
  circleCircle: "(\u25CB)",
  circleCross: "(\xD7)",
  circlePipe: "(\u2502)",
  circleQuestionMark: "(?)",
  radioOn: "(*)",
  radioOff: "( )",
  checkboxOn: "[\xD7]",
  checkboxOff: "[ ]",
  checkboxCircleOn: "(\xD7)",
  checkboxCircleOff: "( )",
  questionMarkPrefix: "\uFF1F",
  pointer: ">",
  triangleUpOutline: "\u2206",
  triangleLeft: "\u25C4",
  triangleRight: "\u25BA",
  lozenge: "\u2666",
  lozengeOutline: "\u25CA",
  hamburger: "\u2261",
  smiley: "\u263A",
  mustache: "\u250C\u2500\u2510",
  star: "\u2736",
  play: "\u25BA",
  nodejs: "\u2666",
  oneSeventh: "1/7",
  oneNinth: "1/9",
  oneTenth: "1/10"
}, shouldUseMain = isUnicodeSupported(), figures = shouldUseMain ? mainSymbols : fallbackSymbols, figures_default = figures;

// ../cli-kit/dist/private/node/ui/components/ConcurrentOutput.js
import { Writable as Writable2 } from "stream";
import { AsyncLocalStorage } from "node:async_hooks";
function addLeadingZero(number) {
  return number < 10 ? `0${number}` : number.toString();
}
function currentTime() {
  let currentDateTime = /* @__PURE__ */ new Date(), hours = addLeadingZero(currentDateTime.getHours()), minutes = addLeadingZero(currentDateTime.getMinutes()), seconds = addLeadingZero(currentDateTime.getSeconds());
  return `${hours}:${minutes}:${seconds}`;
}
var outputContextStore = new AsyncLocalStorage();
function useConcurrentOutputContext(context, callback) {
  return outputContextStore.run(context, callback);
}
var ConcurrentOutput = ({ processes, prefixColumnSize, abortSignal, showTimestamps = !0, keepRunningAfterProcessesResolve = !1, useAlternativeColorPalette = !1 }) => {
  let [processOutput, setProcessOutput] = (0, import_react30.useState)([]), { exit: unmountInk } = use_app_default(), concurrentColors = (0, import_react30.useMemo)(() => useAlternativeColorPalette ? ["#b994c3", "#e69e19", "#d17a73", "cyan", "magenta", "blue"] : ["yellow", "cyan", "magenta", "green", "blue"], [useAlternativeColorPalette]), calculatedPrefixColumnSize = (0, import_react30.useMemo)(() => {
    let columnSize = prefixColumnSize ?? processes.reduce((maxPrefixLength, process21) => Math.max(maxPrefixLength, process21.prefix.length), 0);
    return Math.min(columnSize, 25);
  }, [processes, prefixColumnSize]), addPrefix = (prefix, prefixes) => {
    let index = prefixes.indexOf(prefix);
    return index !== -1 ? index : (prefixes.push(prefix), prefixes.length - 1);
  }, lineColor = (0, import_react30.useCallback)((index) => {
    let colorIndex = index % concurrentColors.length;
    return concurrentColors[colorIndex];
  }, [concurrentColors]), writableStream = (0, import_react30.useCallback)((process21, prefixes) => new Writable2({
    write(chunk, _encoding, next) {
      let context = outputContextStore.getStore(), prefix = context?.outputPrefix ?? process21.prefix, shouldStripAnsi = context?.stripAnsi ?? !0, log = chunk.toString("utf8").replace(/(\n)$/, ""), index = addPrefix(prefix, prefixes), lines = shouldStripAnsi ? stripAnsi(log).split(/\n/) : log.split(/\n/);
      setProcessOutput((previousProcessOutput) => [
        ...previousProcessOutput,
        {
          color: lineColor(index),
          prefix,
          lines
        }
      ]), next();
    }
  }), [lineColor]), formatPrefix = (prefix) => prefix.length > calculatedPrefixColumnSize ? prefix.substring(0, calculatedPrefixColumnSize) : `${" ".repeat(calculatedPrefixColumnSize - prefix.length)}${prefix}`;
  (0, import_react30.useEffect)(() => {
    (async () => {
      let prefixes = [];
      try {
        await Promise.all(processes.map(async (process21) => {
          let stdout = writableStream(process21, prefixes), stderr = writableStream(process21, prefixes);
          await process21.action(stdout, stderr, abortSignal);
        })), keepRunningAfterProcessesResolve || unmountInk();
      } catch (error) {
        keepRunningAfterProcessesResolve || unmountInk(error);
      }
    })();
  }, [abortSignal, processes, writableStream, unmountInk, keepRunningAfterProcessesResolve]);
  let { lineVertical } = figures_default;
  return import_react30.default.createElement(Static, { items: processOutput }, (chunk, index) => import_react30.default.createElement(Box_default, { flexDirection: "column", key: index }, chunk.lines.map((line, index2) => import_react30.default.createElement(
    Box_default,
    { key: index2, flexDirection: "row" },
    import_react30.default.createElement(
      Text,
      null,
      showTimestamps ? import_react30.default.createElement(
        Text,
        null,
        currentTime(),
        " ",
        lineVertical,
        " "
      ) : null,
      import_react30.default.createElement(Text, { color: chunk.color }, formatPrefix(chunk.prefix)),
      import_react30.default.createElement(
        Text,
        null,
        " ",
        lineVertical,
        " ",
        line
      )
    )
  ))));
};

// ../cli-kit/dist/private/node/ui.js
init_cjs_shims();
import { EventEmitter as EventEmitter3 } from "events";
function renderOnce(element, { logLevel = "info", renderOptions }) {
  let { output: renderedString, unmount } = renderString(element, renderOptions);
  return renderedString && output(renderedString, logLevel), unmount(), renderedString;
}
async function render2(element, options) {
  let { waitUntilExit } = render_default(element, options);
  return await waitUntilExit(), new Promise((resolve) => setImmediate(resolve));
}
var Stdout = class extends EventEmitter3 {
  constructor(options) {
    super(), this.frames = [], this.write = (frame) => {
      this.frames.push(frame), this._lastFrame = frame;
    }, this.lastFrame = () => this._lastFrame, this.columns = options.columns ?? 80, this.rows = options.rows ?? 80;
  }
}, renderString = (element, renderOptions) => {
  let columns = isUnitTest() ? 80 : process.stdout.columns, stdout = renderOptions?.stdout ?? new Stdout({ columns }), instance = render_default(element, {
    stdout,
    debug: !0,
    exitOnCtrlC: !1,
    patchConsole: !1
  });
  return {
    output: stdout.lastFrame(),
    unmount: instance.unmount
  };
};
function handleCtrlC(input, key, exit = () => {
  treeKill(process.pid, "SIGINT");
}) {
  input === "c" && key.ctrl && exit();
}

// ../cli-kit/dist/private/node/ui/alert.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Alert.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Banner.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/hooks/use-layout.js
init_cjs_shims();
var import_react31 = __toESM(require_react(), 1), MIN_FULL_WIDTH = 20, MIN_FRACTION_WIDTH = 80;
function useLayout() {
  let { stdout } = use_stdout_default(), [layout, setLayout] = (0, import_react31.useState)(calculateLayout(stdout));
  return (0, import_react31.useLayoutEffect)(() => {
    if (!stdout)
      return;
    function onResize() {
      setLayout(calculateLayout(stdout));
    }
    return stdout.on("resize", onResize), () => {
      stdout.off("resize", onResize);
    };
  }, []), layout;
}
function calculateLayout(stdout) {
  let fullWidth = stdout?.columns ?? MIN_FRACTION_WIDTH, oneThird = fullWidth, twoThirds = fullWidth;
  return fullWidth <= MIN_FULL_WIDTH ? (fullWidth = MIN_FULL_WIDTH, oneThird = MIN_FULL_WIDTH, twoThirds = MIN_FULL_WIDTH) : fullWidth > MIN_FRACTION_WIDTH && (oneThird = column({ fullWidth, fraction: [1, 3], minWidth: MIN_FRACTION_WIDTH }), twoThirds = column({ fullWidth, fraction: [2, 3], minWidth: MIN_FRACTION_WIDTH })), {
    fullWidth,
    oneThird,
    twoThirds
  };
}
function column({ fullWidth, fraction, minWidth }) {
  let fractionedWidth = Math.floor(fullWidth / fraction[1] * fraction[0]);
  return fractionedWidth < minWidth ? minWidth : fractionedWidth;
}

// ../cli-kit/dist/private/node/ui/components/Banner.js
var import_react32 = __toESM(require_react(), 1);
function typeToColor(type) {
  return {
    success: "green",
    error: "red",
    warning: "yellow",
    info: "dim",
    external_error: "red"
  }[type];
}
var Footnotes = () => {
  let linksContext = (0, import_react32.useContext)(LinksContext);
  if (linksContext === null || linksContext.links.current === null)
    return null;
  let links = linksContext.links.current, linkIds = Object.keys(links);
  return linkIds.length > 0 ? import_react32.default.createElement(Box_default, { marginBottom: 1, marginTop: -1, flexDirection: "column" }, linkIds.map((id) => import_react32.default.createElement(Text, { key: id }, `[${id}] ${links[id]?.url}`))) : null;
}, BoxWithBorder = ({ type, children }) => {
  let { twoThirds } = useLayout(), links = (0, import_react32.useRef)({});
  return import_react32.default.createElement(
    LinksContext.Provider,
    { value: {
      links,
      addLink: (label, url) => {
        let id = Object.keys(links.current).find((id2) => links.current[id2].url === url);
        if (id)
          return id;
        let newId = (Object.keys(links.current).length + 1).toString();
        return links.current = {
          ...links.current,
          [newId]: { label, url }
        }, newId;
      }
    } },
    import_react32.default.createElement(
      Box_default,
      { width: twoThirds, marginBottom: 1, borderStyle: "round", flexDirection: "column", borderColor: typeToColor(type) },
      import_react32.default.createElement(
        Box_default,
        { marginTop: -1, marginLeft: 1 },
        import_react32.default.createElement(Text, null, ` ${type.replace(/_/g, " ")} `)
      ),
      import_react32.default.createElement(Box_default, { flexDirection: "column", paddingY: 1, paddingX: 2, gap: 1 }, children)
    ),
    import_react32.default.createElement(Footnotes, null)
  );
}, BoxWithTopBottomLines = ({ type, children }) => {
  let { twoThirds } = useLayout(), topLineAfterTypeLength = twoThirds - 2 - type.length - 2;
  return topLineAfterTypeLength < 0 && (topLineAfterTypeLength = 0), import_react32.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, gap: 1 },
    import_react32.default.createElement(
      Text,
      null,
      import_react32.default.createElement(Text, { color: typeToColor(type) }, "\u2500".repeat(2)),
      import_react32.default.createElement(Text, null, ` ${type.replace(/_/g, " ")} `),
      import_react32.default.createElement(Text, { color: typeToColor(type) }, "\u2500".repeat(topLineAfterTypeLength))
    ),
    children,
    import_react32.default.createElement(Text, { color: typeToColor(type) }, "\u2500".repeat(twoThirds))
  );
}, Banner = ({ children, ...props }) => props.type === "external_error" ? import_react32.default.createElement(BoxWithTopBottomLines, props, children) : import_react32.default.createElement(BoxWithBorder, props, children);

// ../cli-kit/dist/private/node/ui/components/TabularData.js
init_cjs_shims();
var import_react33 = __toESM(require_react(), 1), TabularData = ({ tabularData: data, firstColumnSubdued }) => {
  let columnWidths = data.reduce((acc, row) => (row.forEach((cell, index) => {
    acc[index] = Math.max(acc[index] ?? 0, unstyled(tokenItemToString(cell)).length);
  }), acc), []);
  return import_react33.default.createElement(Box_default, { flexDirection: "column" }, data.map((row, index) => import_react33.default.createElement(Box_default, { key: index, flexDirection: "row", gap: 2 }, row.map((cell, index2) => import_react33.default.createElement(
    Box_default,
    { key: index2, width: columnWidths[index2] ?? 0, flexShrink: index2 === 0 ? 0 : 1 },
    import_react33.default.createElement(TokenizedText, { item: index2 === 0 && firstColumnSubdued && typeof cell == "string" ? { subdued: cell } : cell })
  )))));
};

// ../cli-kit/dist/private/node/ui/components/Alert.js
var import_react34 = __toESM(require_react(), 1), Alert = ({ type, headline, body, nextSteps, reference, link: link2, customSections, orderedNextSteps = !1 }) => import_react34.default.createElement(
  Banner,
  { type },
  headline ? import_react34.default.createElement(
    Text,
    { bold: !0 },
    import_react34.default.createElement(TokenizedText, { item: headline })
  ) : null,
  body ? import_react34.default.createElement(TokenizedText, { item: body }) : null,
  nextSteps && nextSteps.length > 0 ? import_react34.default.createElement(List, { title: "Next steps", items: nextSteps, ordered: orderedNextSteps }) : null,
  reference && reference.length > 0 ? import_react34.default.createElement(List, { title: "Reference", items: reference }) : null,
  link2 ? import_react34.default.createElement(Link, { url: link2.url, label: link2.label }) : null,
  customSections && customSections.length > 0 ? import_react34.default.createElement(Box_default, { flexDirection: "column", gap: 1 }, customSections.map((section, index) => import_react34.default.createElement(
    Box_default,
    { key: index, flexDirection: "column" },
    section.title ? import_react34.default.createElement(Text, { bold: !0 }, section.title) : null,
    typeof section.body == "object" && "tabularData" in section.body ? import_react34.default.createElement(TabularData, { ...section.body }) : import_react34.default.createElement(TokenizedText, { item: section.body })
  ))) : null
);

// ../cli-kit/dist/private/node/ui/alert.js
var import_react35 = __toESM(require_react(), 1), typeToLogLevel = {
  info: "info",
  warning: "warn",
  success: "info",
  error: "error"
};
function alert({ type, headline, body, nextSteps, reference, link: link2, customSections, orderedNextSteps = !1, renderOptions }) {
  let { type: alertType, ..._eventProps } = arguments[0];
  return renderOnce(import_react35.default.createElement(Alert, { type, headline, body, nextSteps, reference, link: link2, orderedNextSteps, customSections }), { logLevel: typeToLogLevel[type], renderOptions });
}

// ../cli-kit/dist/private/node/ui/components/FatalError.js
init_cjs_shims();
var import_react36 = __toESM(require_react(), 1), import_stacktracey = __toESM(require_stacktracey(), 1), FatalError2 = ({ error }) => {
  let stack, tool;
  return error instanceof BugError && (stack = new import_stacktracey.default(error), stack.items.forEach((item) => {
    item.file = cleanSingleStackTracePath(item.file);
  }), stack = stack.withSources(), stack = stack.filter((entry) => !entry.file.includes("@oclif/core")).map((item) => {
    let fileShortComponents = item.fileShort.split("packages/");
    return item.fileShort = fileShortComponents.length === 2 ? fileShortComponents[1] : fileShortComponents[0], item;
  })), error instanceof ExternalError && (tool = `${error.command} ${error.args.join(" ")}`), import_react36.default.createElement(
    Banner,
    { type: tool ? "external_error" : "error" },
    tool ? import_react36.default.createElement(
      Text,
      null,
      "Error coming from ",
      import_react36.default.createElement(Command, { command: tool })
    ) : null,
    error.formattedMessage ? import_react36.default.createElement(TokenizedText, { item: error.formattedMessage }) : import_react36.default.createElement(Text, null, error.message),
    error.tryMessage ? import_react36.default.createElement(TokenizedText, { item: error.tryMessage }) : null,
    error.nextSteps && error.nextSteps.length > 0 ? import_react36.default.createElement(List, { title: "Next steps", items: error.nextSteps }) : null,
    error.customSections && error.customSections.length > 0 ? import_react36.default.createElement(Box_default, { flexDirection: "column", gap: 1 }, error.customSections.map((section, index) => import_react36.default.createElement(
      Box_default,
      { key: index, flexDirection: "column" },
      section.title ? import_react36.default.createElement(Text, { bold: !0 }, section.title) : null,
      typeof section.body == "object" && "tabularData" in section.body ? import_react36.default.createElement(TabularData, { ...section.body }) : import_react36.default.createElement(TokenizedText, { item: section.body })
    ))) : null,
    stack && stack.items.length !== 0 ? import_react36.default.createElement(
      Box_default,
      { flexDirection: "column" },
      import_react36.default.createElement(Text, null, "To investigate the issue, examine this stack trace:"),
      stack.items.map((item, index) => import_react36.default.createElement(
        Box_default,
        { flexDirection: "column", key: index, paddingLeft: 2 },
        import_react36.default.createElement(
          Text,
          null,
          "at",
          item.calleeShort ? import_react36.default.createElement(Text, { color: "yellow" }, ` ${item.calleeShort}`) : null,
          item.fileShort ? ` (${item.fileShort}:${item.line})` : null
        ),
        import_react36.default.createElement(
          Box_default,
          { paddingLeft: 2 },
          import_react36.default.createElement(Text, { dimColor: !0 }, item.sourceLine?.trim())
        )
      ))
    ) : null
  );
};

// ../cli-kit/dist/private/node/ui/components/Table/Table.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Table/Row.js
init_cjs_shims();
var import_react37 = __toESM(require_react(), 1);
function join(elements, separator) {
  return elements.reduce((elements2, element, index) => elements2.length === 0 ? [element] : [...elements2, separator(index), element], []);
}
var Row = ({ rowKey, columns, data, fillerChar, ignoreColumnColor }) => import_react37.default.createElement(Box_default, { flexDirection: "row" }, ...join(columns.map((column2) => {
  let content = data[column2.name], key = `${rowKey}-cell-${column2.name.toString()}`, marginRight = column2.width - unstyled(String(content ?? "")).length;
  return import_react37.default.createElement(
    Text,
    { key, color: ignoreColumnColor ? void 0 : column2.color },
    content,
    fillerChar.repeat(marginRight)
  );
}), (index) => {
  let key = `${rowKey}-horizontal-separator-${index}`;
  return import_react37.default.createElement(Text, { key }, "  ");
}));

// ../cli-kit/dist/private/node/ui/components/Table/Table.js
var import_react38 = __toESM(require_react(), 1);
function Table({ rows, columns: columnsConfiguration }) {
  let columns = Object.entries(columnsConfiguration).map(([key, { header, color }]) => {
    let headerWidth = String(header || key).length, columnWidths = rows.map((row) => {
      let value = row[key];
      return value == null ? 0 : unstyled(String(value)).length;
    });
    return {
      name: key,
      width: Math.max(...columnWidths, headerWidth),
      color
    };
  }), headings = Object.entries(columnsConfiguration).reduce((headings2, [column2, { header }]) => ({ ...headings2, [column2]: header || column2 }), {});
  return import_react38.default.createElement(
    Box_default,
    { flexDirection: "column" },
    import_react38.default.createElement(Row, { rowKey: "heading", fillerChar: " ", columns, data: headings, ignoreColumnColor: !0 }),
    import_react38.default.createElement(Row, { rowKey: "separator", fillerChar: "\u2500", columns, data: {}, ignoreColumnColor: !0 }),
    rows.map((row, index) => {
      let key = `row-${index}`;
      return import_react38.default.createElement(
        Box_default,
        { flexDirection: "column", key },
        import_react38.default.createElement(Row, { rowKey: `data-${key}`, fillerChar: " ", columns, data: row })
      );
    })
  );
}

// ../cli-kit/dist/private/node/ui/components/DangerousConfirmationPrompt.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/TextInput.js
init_cjs_shims();
var import_react39 = __toESM(require_react(), 1);
var TextInput = ({ value: originalValue, defaultValue = "", onChange, placeholder = "", noColor = !shouldDisplayColors(), color = noColor ? void 0 : "cyan", password = !1, focus = !0 }) => {
  let [cursorOffset, setCursorOffset] = (0, import_react39.useState)((originalValue || "").length);
  (0, import_react39.useEffect)(() => {
    setCursorOffset((previousOffset) => {
      let newValue = originalValue || "";
      return previousOffset > newValue.length - 1 ? newValue.length : previousOffset;
    });
  }, [originalValue]);
  let value = password ? "*".repeat(originalValue.length) : originalValue, renderedValue, renderPlaceholder = (value2) => source_default.inverse(value2[0]) + source_default.dim(value2.slice(1)), cursorChar = figures_default.square, defaultCursor = import_react39.default.createElement(Text, { backgroundColor: color }, cursorChar), placeholderText = defaultValue.length > 0 ? defaultValue : placeholder.length > 0 ? placeholder : "", renderedPlaceholder = placeholderText.length > 0 ? renderPlaceholder(placeholderText) : defaultCursor;
  return renderedValue = value.split("").map((char, index) => index === cursorOffset ? noColor ? cursorChar : source_default.inverse(char) : char).join(""), cursorOffset === value.length && (renderedValue = import_react39.default.createElement(
    Text,
    null,
    renderedValue,
    defaultCursor
  )), use_input_default((input, key) => {
    if (key.upArrow || key.downArrow || key.ctrl && input === "c" || key.shift && key.tab || key.return)
      return;
    if (key.tab && originalValue.length === 0 && placeholderText) {
      onChange(placeholderText), setCursorOffset(placeholderText.length);
      return;
    }
    let nextCursorOffset = cursorOffset, nextValue = originalValue;
    key.leftArrow ? cursorOffset > 0 && nextCursorOffset-- : key.rightArrow ? cursorOffset < originalValue.length && nextCursorOffset++ : key.backspace || key.delete ? cursorOffset > 0 && (nextValue = originalValue.slice(0, cursorOffset - 1) + originalValue.slice(cursorOffset, originalValue.length), nextCursorOffset--) : (nextValue = originalValue.slice(0, cursorOffset) + input + originalValue.slice(cursorOffset, originalValue.length), nextCursorOffset += input.length), setCursorOffset(nextCursorOffset), nextValue !== originalValue && onChange(nextValue);
  }, { isActive: focus }), import_react39.default.createElement(Text, { color }, value.length > 0 ? renderedValue : renderedPlaceholder);
};

// ../cli-kit/dist/private/node/ui/components/Prompts/InfoTable.js
init_cjs_shims();
var import_react40 = __toESM(require_react(), 1), InfoTable = ({ table }) => {
  let sections = Array.isArray(table) ? table : Object.keys(table).map((header) => ({
    header,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    items: table[header],
    color: void 0,
    helperText: void 0,
    bullet: void 0,
    emptyItemsText: void 0
  })), headerColumnWidth = Math.max(...sections.map((section) => Math.max(...section.header.split(`
`).map((line) => line.length))));
  return import_react40.default.createElement(Box_default, { flexDirection: "column" }, sections.map((section, index) => import_react40.default.createElement(
    Box_default,
    { key: index, marginBottom: index === sections.length - 1 ? 0 : 1, flexDirection: "column" },
    section.header.length > 0 && import_react40.default.createElement(
      Box_default,
      { width: headerColumnWidth + 1 },
      import_react40.default.createElement(Text, { color: section.color, bold: !0 }, capitalize(section.header))
    ),
    import_react40.default.createElement(
      Box_default,
      { flexGrow: 1, flexDirection: "column", gap: 1 },
      section.emptyItemsText && section.items.length === 0 ? import_react40.default.createElement(
        Text,
        { color: section.color },
        import_react40.default.createElement(TokenizedText, { item: { subdued: section.emptyItemsText } })
      ) : import_react40.default.createElement(List, { margin: !1, items: section.items, color: section.color, bullet: section.bullet }),
      section.helperText ? import_react40.default.createElement(Text, { color: section.color }, section.helperText) : null
    )
  )));
};

// ../cli-kit/dist/private/node/ui/utilities.js
init_cjs_shims();
function messageWithPunctuation(message) {
  let messageToString = tokenItemToString(message);
  return messageToString.endsWith("?") || messageToString.endsWith(":") || messageToString.endsWith(".") ? message : appendToTokenItem(message, ":");
}

// ../cli-kit/dist/private/node/ui/hooks/use-abort-signal.js
init_cjs_shims();
var import_react41 = __toESM(require_react(), 1), noop2 = () => Promise.resolve();
function useAbortSignal(abortSignal, onAbort = noop2) {
  let { exit: unmountInk } = use_app_default(), [isAborted, setIsAborted] = (0, import_react41.useState)(!1);
  return (0, import_react41.useLayoutEffect)(() => {
    abortSignal?.addEventListener("abort", () => {
      let abortWithError = abortSignal.reason.message === "AbortError" ? void 0 : abortSignal.reason;
      onAbort(abortWithError).then(() => {
        setIsAborted(!0), unmountInk(abortWithError);
      }).catch(() => {
      });
    });
  }, []), { isAborted };
}

// ../cli-kit/dist/private/node/ui/hooks/use-prompt.js
init_cjs_shims();
var import_react42 = __toESM(require_react(), 1), PromptState;
(function(PromptState2) {
  PromptState2.Idle = "idle", PromptState2.Loading = "loading", PromptState2.Submitted = "submitted", PromptState2.Error = "error", PromptState2.Cancelled = "cancelled";
})(PromptState || (PromptState = {}));
function usePrompt({ initialAnswer }) {
  let [promptState, setPromptState] = (0, import_react42.useState)(PromptState.Idle), [answer, setAnswer] = (0, import_react42.useState)(initialAnswer);
  return {
    promptState,
    setPromptState,
    answer,
    setAnswer
  };
}

// ../cli-kit/dist/private/node/ui/components/DangerousConfirmationPrompt.js
var import_react43 = __toESM(require_react(), 1);
var DangerousConfirmationPrompt = ({ message, confirmation, infoTable, onSubmit, abortSignal }) => {
  let validateAnswer = (0, import_react43.useCallback)((value) => value === confirmation ? void 0 : ["Value must be exactly", { userInput: confirmation }], [confirmation]), { oneThird, twoThirds } = useLayout(), { promptState, setPromptState, answer, setAnswer } = usePrompt({
    initialAnswer: ""
  }), { exit: unmountInk } = use_app_default(), [error, setError] = (0, import_react43.useState)(void 0), color = promptState === PromptState.Error ? "red" : "cyan", underline = new Array(oneThird - 3).fill("\u2594"), { isAborted } = useAbortSignal(abortSignal);
  use_input_default((input, key) => {
    if (handleCtrlC(input, key), key.escape && (setPromptState(PromptState.Cancelled), setError(void 0)), key.return) {
      let error2 = validateAnswer(answer);
      error2 ? (setPromptState(PromptState.Error), setError(error2)) : setPromptState(PromptState.Submitted);
    }
  }), (0, import_react43.useEffect)(() => {
    promptState === PromptState.Submitted ? (onSubmit(!0), unmountInk()) : promptState === PromptState.Cancelled && (onSubmit(!1), unmountInk());
  }, [onSubmit, promptState, unmountInk]);
  let completed = promptState === PromptState.Submitted || promptState === PromptState.Cancelled;
  return isAborted ? null : import_react43.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, width: twoThirds },
    import_react43.default.createElement(
      Box_default,
      null,
      import_react43.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react43.default.createElement(Text, null, "?")
      ),
      import_react43.default.createElement(TokenizedText, { item: messageWithPunctuation(message) })
    ),
    completed ? import_react43.default.createElement(CompletedPrompt, { cancelled: promptState === PromptState.Cancelled }) : import_react43.default.createElement(
      import_react43.default.Fragment,
      null,
      import_react43.default.createElement(
        Box_default,
        { flexDirection: "column", gap: 1, marginTop: 1, marginLeft: 3 },
        infoTable ? import_react43.default.createElement(
          Box_default,
          { paddingLeft: 2, borderStyle: "bold", borderLeft: !0, borderRight: !1, borderTop: !1, borderBottom: !1, flexDirection: "column", gap: 1 },
          import_react43.default.createElement(InfoTable, { table: infoTable })
        ) : null,
        import_react43.default.createElement(
          Box_default,
          null,
          import_react43.default.createElement(TokenizedText, { item: ["Type", { userInput: confirmation }, "to confirm, or press Escape to cancel."] })
        )
      ),
      import_react43.default.createElement(
        Box_default,
        { flexDirection: "column", width: oneThird },
        import_react43.default.createElement(
          Box_default,
          null,
          import_react43.default.createElement(
            Box_default,
            { marginRight: 2 },
            import_react43.default.createElement(Text, { color }, ">")
          ),
          import_react43.default.createElement(
            Box_default,
            { flexGrow: 1 },
            import_react43.default.createElement(TextInput, { value: answer, onChange: (answer2) => {
              setAnswer(answer2), setPromptState(PromptState.Idle);
            }, defaultValue: "", color })
          )
        ),
        import_react43.default.createElement(
          Box_default,
          { marginLeft: 3 },
          import_react43.default.createElement(Text, { color }, underline)
        ),
        promptState === PromptState.Error && error ? import_react43.default.createElement(
          Box_default,
          { marginLeft: 3 },
          import_react43.default.createElement(
            Text,
            { color },
            import_react43.default.createElement(TokenizedText, { item: error })
          )
        ) : null
      )
    )
  );
}, CompletedPrompt = ({ cancelled }) => import_react43.default.createElement(
  Box_default,
  null,
  import_react43.default.createElement(Box_default, { marginRight: 2 }, cancelled ? import_react43.default.createElement(Text, { color: "red" }, figures_default.cross) : import_react43.default.createElement(Text, { color: "cyan" }, figures_default.tick)),
  import_react43.default.createElement(Box_default, { flexGrow: 1 }, cancelled ? import_react43.default.createElement(Text, { color: "red" }, "Cancelled") : import_react43.default.createElement(Text, { color: "cyan" }, "Confirmed"))
);

// ../cli-kit/dist/private/node/ui/components/SelectPrompt.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/SelectInput.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Scrollbar.js
init_cjs_shims();
var import_react44 = __toESM(require_react(), 1), BACKGROUND_CHAR = "\u2502", SCROLLBOX_CHAR = "\u2551", Scrollbar = ({ containerHeight, visibleListSectionLength, fullListLength, visibleFromIndex, noColor = !shouldDisplayColors() }) => {
  let displayArrows = containerHeight >= 4 && noColor, visibleToIndex = visibleFromIndex + visibleListSectionLength - 1, fullHeight = displayArrows ? containerHeight - 2 : containerHeight, scrollboxHeight = Math.min(fullHeight - 1, Math.ceil(Math.min(1, visibleListSectionLength / fullListLength) * fullHeight)), topBuffer;
  if (visibleToIndex >= fullListLength - 1)
    topBuffer = fullHeight - scrollboxHeight;
  else {
    let scrollingLength = fullHeight - scrollboxHeight, scrollableIncrements = fullListLength - visibleListSectionLength;
    topBuffer = Math.max(
      // Never go negative, that causes errors!
      0,
      Math.min(
        // Never have more buffer than filling in all spaces above the scrollbox
        fullHeight - scrollboxHeight,
        Math.round(visibleFromIndex / scrollableIncrements * scrollingLength)
      )
    );
  }
  let bottomBuffer = fullHeight - scrollboxHeight - topBuffer, backgroundChar = noColor ? BACKGROUND_CHAR : " ", scrollboxChar = noColor ? SCROLLBOX_CHAR : " ", bgColor = noColor ? void 0 : "gray", scrollboxColor = noColor ? void 0 : "cyan";
  return import_react44.default.createElement(
    Box_default,
    { flexDirection: "column" },
    displayArrows ? import_react44.default.createElement(Text, null, "\u25B3") : null,
    import_react44.default.createElement(
      Box_default,
      { width: 1 },
      import_react44.default.createElement(Text, { backgroundColor: bgColor }, backgroundChar.repeat(topBuffer))
    ),
    import_react44.default.createElement(
      Box_default,
      { width: 1 },
      import_react44.default.createElement(Text, { backgroundColor: scrollboxColor }, scrollboxChar.repeat(scrollboxHeight))
    ),
    import_react44.default.createElement(
      Box_default,
      { width: 1 },
      import_react44.default.createElement(Text, { backgroundColor: bgColor }, backgroundChar.repeat(bottomBuffer))
    ),
    displayArrows ? import_react44.default.createElement(Text, null, "\u25BD") : null
  );
};

// ../cli-kit/dist/private/node/ui/hooks/use-select-state.js
init_cjs_shims();
var import_react45 = __toESM(require_react(), 1);
import { isDeepStrictEqual } from "node:util";
var OptionMap = class extends Map {
  constructor(options) {
    let items = [], firstItem, previous, index = 0;
    for (let option of options) {
      let item = {
        ...option,
        previous,
        next: void 0,
        index
      };
      previous && (previous.next = item), firstItem || (firstItem = item), items.push([option.value, item]), index++, previous = item;
    }
    super(items), this.first = firstItem;
  }
}, reducer = (state, action) => {
  switch (action.type) {
    case "select-next-option": {
      if (typeof state.value > "u")
        return state;
      let item = state.optionMap.get(state.value);
      if (!item)
        return state;
      let next = item.next;
      for (; next && next.disabled; )
        next = next.next;
      if (!next)
        return state;
      if (!(next.index > state.visibleToIndex))
        return {
          ...state,
          value: next.value
        };
      let nextVisibleToIndex = next.index, nextVisibleFromIndex = nextVisibleToIndex - state.visibleOptionCount + 1;
      return {
        ...state,
        value: next.value,
        visibleFromIndex: nextVisibleFromIndex,
        visibleToIndex: nextVisibleToIndex,
        previousValue: state.value
      };
    }
    case "select-previous-option": {
      if (typeof state.value > "u")
        return state;
      let item = state.optionMap.get(state.value);
      if (!item)
        return state;
      let previous = item.previous;
      for (; previous && previous.disabled; )
        previous = previous.previous;
      if (!previous)
        return state;
      if (!(previous.index < state.visibleFromIndex))
        return {
          ...state,
          value: previous.value
        };
      let nextVisibleFromIndex = previous.index, nextVisibleToIndex = nextVisibleFromIndex + state.visibleOptionCount - 1;
      return {
        ...state,
        value: previous.value,
        visibleFromIndex: nextVisibleFromIndex,
        visibleToIndex: nextVisibleToIndex,
        previousValue: state.value
      };
    }
    case "select-option": {
      let item = state.optionMap.get(action.option.value);
      return item ? {
        ...state,
        value: item.value,
        previousValue: state.value
      } : state;
    }
    case "reset":
      return action.state;
    default:
      return state;
  }
}, createDefaultState = ({ visibleOptionCount: customVisibleOptionCount, defaultValue, options }) => {
  let visibleOptionCount = typeof customVisibleOptionCount == "number" ? Math.min(customVisibleOptionCount, options.length) : options.length, optionMap = new OptionMap(options), defaultOption = typeof defaultValue > "u" ? void 0 : optionMap.get(defaultValue), option = defaultOption && !defaultOption.disabled ? defaultOption : optionMap.first;
  for (; option && option.disabled; )
    option = option.next;
  return {
    optionMap,
    visibleOptionCount,
    visibleFromIndex: 0,
    visibleToIndex: visibleOptionCount - 1,
    value: option?.value,
    previousValue: option?.value
  };
}, useSelectState = ({ visibleOptionCount, options, defaultValue }) => {
  let [state, dispatch] = (0, import_react45.useReducer)(reducer, { visibleOptionCount, defaultValue, options }, createDefaultState), [lastOptions, setLastOptions] = (0, import_react45.useState)(options), [lastVisibleOptionCount, setLastVisibleOptionCount] = (0, import_react45.useState)(visibleOptionCount);
  options !== lastOptions && !isDeepStrictEqual(options, lastOptions) && (dispatch({
    type: "reset",
    state: createDefaultState({ visibleOptionCount, defaultValue, options })
  }), setLastOptions(options)), visibleOptionCount !== lastVisibleOptionCount && (dispatch({
    type: "reset",
    state: createDefaultState({ visibleOptionCount, defaultValue, options })
  }), setLastVisibleOptionCount(visibleOptionCount));
  let selectNextOption = (0, import_react45.useCallback)(() => {
    dispatch({
      type: "select-next-option"
    });
  }, []), selectPreviousOption = (0, import_react45.useCallback)(() => {
    dispatch({
      type: "select-previous-option"
    });
  }, []), selectOption = (0, import_react45.useCallback)(({ option }) => {
    dispatch({
      type: "select-option",
      option
    });
  }, []), visibleOptions = (0, import_react45.useMemo)(() => options.slice(state.visibleFromIndex), [options, state.visibleFromIndex]);
  return {
    visibleFromIndex: state.visibleFromIndex,
    visibleToIndex: state.visibleToIndex,
    value: state.value,
    visibleOptions,
    selectNextOption,
    selectPreviousOption,
    selectOption,
    previousValue: state.previousValue
  };
};

// ../cli-kit/dist/private/node/ui/components/SelectInput.js
var import_react46 = __toESM(require_react(), 1);
var import_sortBy = __toESM(require_sortBy(), 1);
function highlightedLabel(label, term) {
  if (!term)
    return label;
  let regex2;
  try {
    regex2 = new RegExp(term, "i");
  } catch {
    return label;
  }
  return label.replace(regex2, (match2) => source_default.bold(match2));
}
function validateKeys(items) {
  if (items.some((item) => (item.key?.length ?? 0) > 1))
    throw new Error("SelectInput: Keys must be a single character");
  if (!items.every((item) => typeof item.key < "u" && item.key.length > 0))
    throw new Error("SelectInput: All items must have keys if one does");
}
function Item({ item, previousItem, isSelected, highlightedTerm, enableShortcuts, items, hasAnyGroup, index }) {
  let label = highlightedLabel(item.label, highlightedTerm), title, labelColor;
  isSelected ? labelColor = "cyan" : item.disabled && (labelColor = "dim"), (typeof previousItem > "u" || item.group !== previousItem.group) && (title = item.group ?? (hasAnyGroup ? "Other" : void 0));
  let showKey = enableShortcuts && item.key && item.key.length > 0;
  return import_react46.default.createElement(
    Box_default,
    { key: index, flexDirection: "column", marginTop: items.indexOf(item) !== 0 && title ? 1 : 0, minHeight: title ? 2 : 1 },
    title ? import_react46.default.createElement(
      Box_default,
      { marginLeft: 3 },
      import_react46.default.createElement(Text, { bold: !0 }, title)
    ) : null,
    import_react46.default.createElement(
      Box_default,
      { key: index, marginLeft: hasAnyGroup ? 3 : 0 },
      import_react46.default.createElement(Box_default, { marginRight: 2 }, isSelected ? import_react46.default.createElement(Text, { color: "cyan" }, ">") : import_react46.default.createElement(Text, null, " ")),
      import_react46.default.createElement(Text, { wrap: "end", color: labelColor }, showKey ? `(${item.key}) ${label}` : label)
    )
  );
}
var MAX_AVAILABLE_LINES = 25;
function SelectInputInner({ items: rawItems, initialItems = rawItems, onChange, enableShortcuts = !0, focus = !0, emptyMessage = "No items to select.", defaultValue, highlightedTerm, loading = !1, errorMessage, hasMorePages = !1, morePagesMessage, availableLines = MAX_AVAILABLE_LINES, onSubmit, inputFixedAreaRef, groupOrder }, ref) {
  let noItems = !1;
  rawItems.length === 0 && (rawItems = [{ label: emptyMessage, value: null, disabled: !0 }], noItems = !0);
  let hasAnyGroup = rawItems.some((item) => typeof item.group < "u"), items = (0, import_sortBy.default)(rawItems, (item) => {
    if (!item.group)
      return Number.MAX_SAFE_INTEGER + 1;
    if (!groupOrder)
      return Number.MAX_SAFE_INTEGER;
    let index = groupOrder.indexOf(item.group);
    return index === -1 ? Number.MAX_SAFE_INTEGER : index;
  }), itemsHaveKeys = items.some((item) => typeof item.key < "u" && item.key.length > 0);
  itemsHaveKeys && validateKeys(items);
  let availableLinesToUse = Math.min(availableLines, MAX_AVAILABLE_LINES);
  function maximumLinesLostToGroups(items2) {
    let numberOfGroups = new Set(items2.map((item) => item.group).filter((group) => group)).size, maxVisibleGroups = Math.ceil(Math.min((availableLinesToUse + 1) / 3, numberOfGroups + 1));
    return numberOfGroups > 0 ? (maxVisibleGroups - 1) * 2 + 1 : 0;
  }
  let maxLinesLostToGroups = maximumLinesLostToGroups(items), limit = Math.max(2, availableLinesToUse - maxLinesLostToGroups), hasLimit = items.length > limit, state = useSelectState({
    visibleOptionCount: limit,
    options: items,
    defaultValue
  });
  (0, import_react46.useEffect)(() => {
    typeof state.value < "u" && state.previousValue !== state.value && onChange?.(items.find((item) => item.value === state.value));
  }, [state.previousValue, state.value, items, onChange]);
  let handleArrows = (key) => {
    key.upArrow ? state.selectPreviousOption() : key.downArrow && state.selectNextOption();
  }, handleShortcuts = (0, import_react46.useCallback)((input) => {
    if (state.visibleOptions.map((item) => item.key).includes(input)) {
      let itemWithKey = state.visibleOptions.find((item2) => item2.key === input), item = items.find((item2) => item2.value === itemWithKey?.value);
      itemWithKey && !itemWithKey.disabled && (onSubmit && item && onSubmit(item), state.selectOption({ option: itemWithKey }));
    }
  }, [items, onSubmit, state]);
  use_input_default((input, key) => {
    if (handleCtrlC(input, key), typeof state.value < "u" && key.return) {
      let item = items.find((item2) => item2.value === state.value);
      item && onSubmit && onSubmit(item);
    }
    enableShortcuts && input.length > 0 && Object.values(key).every((value) => !value) ? handleShortcuts(input) : handleArrows(key);
  }, { isActive: focus });
  let { twoThirds } = useLayout();
  if (loading)
    return import_react46.default.createElement(
      Box_default,
      { marginLeft: 3 },
      import_react46.default.createElement(Text, { dimColor: !0 }, "Loading...")
    );
  if (errorMessage && errorMessage.length > 0)
    return import_react46.default.createElement(
      Box_default,
      { marginLeft: 3 },
      import_react46.default.createElement(Text, { color: "red" }, errorMessage)
    );
  {
    let optionsHeight = initialItems.length + maximumLinesLostToGroups(initialItems), sectionHeight = Math.max(hasAnyGroup ? 5 : 2, Math.min(availableLinesToUse, optionsHeight));
    return import_react46.default.createElement(
      Box_default,
      { flexDirection: "column", ref, gap: 1, width: twoThirds },
      import_react46.default.createElement(
        Box_default,
        { flexDirection: "row", height: sectionHeight, width: "100%" },
        import_react46.default.createElement(Box_default, { flexDirection: "column", overflowY: "hidden", flexGrow: 1 }, state.visibleOptions.map((item, index) => import_react46.default.createElement(Item, { key: index, item, previousItem: state.visibleOptions[index - 1], highlightedTerm, isSelected: item.value === state.value, items: state.visibleOptions, enableShortcuts, hasAnyGroup, index }))),
        hasLimit ? import_react46.default.createElement(Scrollbar, { containerHeight: sectionHeight, visibleListSectionLength: limit, fullListLength: items.length, visibleFromIndex: state.visibleFromIndex }) : null
      ),
      import_react46.default.createElement(Box_default, { ref: inputFixedAreaRef }, noItems ? import_react46.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react46.default.createElement(Text, { dimColor: !0 }, "Try again with a different keyword.")
      ) : import_react46.default.createElement(
        Box_default,
        { marginLeft: 3, flexDirection: "column" },
        import_react46.default.createElement(Text, { dimColor: !0 }, `Press ${figures_default.arrowUp}${figures_default.arrowDown} arrows to select, enter ${itemsHaveKeys ? "or a shortcut " : ""}to confirm.`),
        hasMorePages ? import_react46.default.createElement(
          Text,
          null,
          import_react46.default.createElement(
            Text,
            { bold: !0 },
            "1-",
            items.length,
            " of many"
          ),
          morePagesMessage ? `  ${morePagesMessage}` : null
        ) : null
      ))
    );
  }
}
var SelectInput = (0, import_react46.forwardRef)(SelectInputInner);

// ../cli-kit/dist/private/node/ui/components/Prompts/PromptLayout.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/Prompts/InfoMessage.js
init_cjs_shims();
var import_react47 = __toESM(require_react(), 1), InfoMessage = ({ message: { title: { color, text: title }, body } }) => import_react47.default.createElement(
  Box_default,
  { flexDirection: "column", gap: 1 },
  import_react47.default.createElement(
    Text,
    { color },
    import_react47.default.createElement(TokenizedText, { item: title })
  ),
  import_react47.default.createElement(TokenizedText, { item: body })
);

// ../cli-kit/dist/private/node/ui/components/Prompts/PromptLayout.js
var import_react48 = __toESM(require_react(), 1);
var PromptLayout = ({ message, infoTable, abortSignal, infoMessage, header, state, input, submittedAnswerLabel }) => {
  let { stdout } = use_stdout_default(), [wrapperHeight, setWrapperHeight] = (0, import_react48.useState)(0), [promptAreaHeight, setPromptAreaHeight] = (0, import_react48.useState)(0), [inputFixedAreaHeight, setInputFixedAreaHeight] = (0, import_react48.useState)(0), currentAvailableLines = stdout.rows - promptAreaHeight - inputFixedAreaHeight, [availableLines, setAvailableLines] = (0, import_react48.useState)(currentAvailableLines), wrapperRef = (0, import_react48.useCallback)((node) => {
    if (node !== null) {
      let { height } = measure_element_default(node);
      wrapperHeight !== height && setWrapperHeight(height);
    }
  }, [wrapperHeight]), promptAreaRef = (0, import_react48.useCallback)((node) => {
    if (node !== null) {
      let { height } = measure_element_default(node);
      setPromptAreaHeight(height);
    }
  }, []), inputFixedAreaRef = (0, import_react48.useCallback)((node) => {
    if (node !== null) {
      let { height } = measure_element_default(node);
      setInputFixedAreaHeight(height + 3);
    }
  }, []), inputComponent = (0, import_react48.cloneElement)(input, { availableLines, inputFixedAreaRef });
  (0, import_react48.useLayoutEffect)(() => {
    function onResize() {
      let newAvailableLines = stdout.rows - promptAreaHeight - inputFixedAreaHeight;
      newAvailableLines !== availableLines && setAvailableLines(newAvailableLines);
    }
    return onResize(), stdout.on("resize", onResize), () => {
      stdout.off("resize", onResize);
    };
  }, [wrapperHeight, promptAreaHeight, stdout, availableLines, inputFixedAreaHeight]);
  let { isAborted } = useAbortSignal(abortSignal), showInfoTable = infoTable && Object.keys(infoTable).length > 0;
  return isAborted ? null : import_react48.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, ref: wrapperRef },
    import_react48.default.createElement(
      Box_default,
      { ref: promptAreaRef, flexDirection: "column" },
      import_react48.default.createElement(
        Box_default,
        null,
        import_react48.default.createElement(
          Box_default,
          { marginRight: 2 },
          import_react48.default.createElement(Text, null, "?")
        ),
        import_react48.default.createElement(TokenizedText, { item: messageWithPunctuation(message) }),
        header
      ),
      (showInfoTable || infoMessage) && state !== PromptState.Submitted ? import_react48.default.createElement(
        Box_default,
        { marginTop: 1, marginLeft: 3, paddingLeft: 2, borderStyle: "bold", borderLeft: !0, borderRight: !1, borderTop: !1, borderBottom: !1, flexDirection: "column", gap: 1 },
        infoMessage ? import_react48.default.createElement(InfoMessage, { message: infoMessage }) : null,
        showInfoTable ? import_react48.default.createElement(InfoTable, { table: infoTable }) : null
      ) : null
    ),
    state === PromptState.Submitted && submittedAnswerLabel ? import_react48.default.createElement(
      Box_default,
      null,
      import_react48.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react48.default.createElement(Text, { color: "cyan" }, figures_default.tick)
      ),
      import_react48.default.createElement(Text, { color: "cyan" }, submittedAnswerLabel)
    ) : import_react48.default.createElement(Box_default, { marginTop: 1 }, inputComponent)
  );
};

// ../cli-kit/dist/private/node/ui/components/SelectPrompt.js
var import_react49 = __toESM(require_react(), 1);
function SelectPrompt({ message, choices, infoTable, infoMessage, onSubmit, defaultValue, abortSignal, groupOrder }) {
  if (choices.length === 0)
    throw new Error("SelectPrompt requires at least one choice");
  let { exit: unmountInk } = use_app_default(), { promptState, setPromptState, answer, setAnswer } = usePrompt({
    initialAnswer: void 0
  }), submitAnswer = (0, import_react49.useCallback)((answer2) => {
    setAnswer(answer2), setPromptState(PromptState.Submitted);
  }, [setAnswer, setPromptState]);
  return (0, import_react49.useEffect)(() => {
    promptState === PromptState.Submitted && answer && (unmountInk(), onSubmit(answer.value));
  }, [answer, onSubmit, promptState, unmountInk]), import_react49.default.createElement(PromptLayout, { message, state: promptState, submittedAnswerLabel: answer?.label, infoTable, infoMessage, abortSignal, input: import_react49.default.createElement(SelectInput, { defaultValue, items: choices, onSubmit: submitAnswer, groupOrder }) });
}

// ../cli-kit/dist/private/node/ui/components/Tasks.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/LoadingBar.js
init_cjs_shims();

// ../cli-kit/dist/private/node/ui/components/TextAnimation.js
init_cjs_shims();
var import_react50 = __toESM(require_react(), 1), import_gradient_string = __toESM(require_gradient_string(), 1);
function rainbow(text, frame) {
  let hue = 5 * frame, leftColor = { h: hue % 360, s: 0.8, v: 1 }, rightColor = { h: (hue + 1) % 360, s: 0.8, v: 1 };
  return (0, import_gradient_string.default)(leftColor, rightColor)(text, { interpolation: "hsv", hsvSpin: "long" });
}
function rotated(text, steps) {
  let normalizedSteps = steps % text.length, start = text.slice(-normalizedSteps), end = text.slice(0, -normalizedSteps);
  return start + end;
}
function truncated(text, maxWidth) {
  return maxWidth ? text.slice(0, maxWidth) : text;
}
var TextAnimation = (0, import_react50.memo)(({ text, maxWidth }) => {
  let frame = (0, import_react50.useRef)(0), [renderedFrame, setRenderedFrame] = (0, import_react50.useState)(text), timeout = (0, import_react50.useRef)(), { stdout } = use_stdout_default(), [width, setWidth] = (0, import_react50.useState)(maxWidth ?? Math.floor(stdout.columns * 0.66));
  (0, import_react50.useLayoutEffect)(() => {
    let handleResize = () => {
      setWidth(Math.floor(stdout.columns * 0.66));
    };
    return stdout.on("resize", handleResize), () => {
      stdout.off("resize", handleResize);
    };
  }, [stdout]);
  let renderAnimation = (0, import_react50.useCallback)(() => {
    let newFrame = frame.current + 1;
    frame.current = newFrame, setRenderedFrame(rainbow(truncated(rotated(text, frame.current), width), frame.current)), timeout.current = setTimeout(() => {
      renderAnimation();
    }, 35);
  }, [text, width]);
  return (0, import_react50.useLayoutEffect)(() => (renderAnimation(), () => {
    clearTimeout(timeout.current);
  }), [renderAnimation]), import_react50.default.createElement(Text, null, renderedFrame);
});
TextAnimation.displayName = "TextAnimation";

// ../cli-kit/dist/private/node/ui/components/LoadingBar.js
var import_react51 = __toESM(require_react(), 1);
var loadingBarChar = "\u2580", hillString = "\u2581\u2581\u2582\u2582\u2583\u2583\u2584\u2584\u2585\u2585\u2586\u2586\u2587\u2587\u2588\u2588\u2587\u2587\u2586\u2586\u2585\u2585\u2584\u2584\u2583\u2583\u2582\u2582\u2581\u2581", LoadingBar = ({ title, noColor, noProgressBar }) => {
  let { twoThirds } = useLayout(), loadingBar = new Array(twoThirds).fill(loadingBarChar).join("");
  return (noColor ?? !shouldDisplayColors()) && (loadingBar = hillString.repeat(Math.ceil(twoThirds / hillString.length))), import_react51.default.createElement(
    Box_default,
    { flexDirection: "column" },
    !noProgressBar && import_react51.default.createElement(TextAnimation, { text: loadingBar, maxWidth: twoThirds }),
    import_react51.default.createElement(
      Text,
      null,
      title,
      " ..."
    )
  );
};

// ../cli-kit/dist/private/node/ui/hooks/use-async-and-unmount.js
init_cjs_shims();
var import_react52 = __toESM(require_react(), 1);
function useAsyncAndUnmount(asyncFunction, { onFulfilled = () => {
}, onRejected = () => {
} } = {}) {
  let { exit: unmountInk } = use_app_default();
  (0, import_react52.useEffect)(() => {
    asyncFunction().then(() => {
      onFulfilled(), unmountInk();
    }).catch((error) => {
      onRejected(error), unmountInk(error);
    });
  }, []);
}

// ../cli-kit/dist/private/node/ui/hooks/use-exit-on-ctrl-c.js
init_cjs_shims();
function useExitOnCtrlC() {
  let { isRawModeSupported } = use_stdin_default();
  use_input_default((input, key) => {
    if (handleCtrlC(input, key), key.return)
      return null;
  }, { isActive: !!isRawModeSupported });
}

// ../cli-kit/dist/private/node/ui/components/Tasks.js
var import_react53 = __toESM(require_react(), 1), TasksState;
(function(TasksState2) {
  TasksState2.Loading = "loading", TasksState2.Success = "success", TasksState2.Failure = "failure";
})(TasksState || (TasksState = {}));
async function runTask2(task, ctx) {
  task.retryCount = 0, task.errors = [];
  let retry = task.retry && task.retry > 0 ? task.retry + 1 : 1;
  for (let retries = 1; retries <= retry; retries++)
    try {
      return task.skip?.(ctx) ? void 0 : await task.task(ctx, task);
    } catch (error) {
      if (retries === retry)
        throw error;
      task.errors.push(error), task.retryCount = retries;
    }
}
var noop3 = () => {
};
function Tasks({ tasks, silent = isUnitTest(), onComplete = noop3, abortSignal, noColor, noProgressBar = !1 }) {
  let [currentTask, setCurrentTask] = (0, import_react53.useState)(tasks[0]), [state, setState] = (0, import_react53.useState)(TasksState.Loading), ctx = (0, import_react53.useRef)({});
  useAsyncAndUnmount(async () => {
    for (let task of tasks) {
      setCurrentTask(task);
      let subTasks = await runTask2(task, ctx.current);
      if (Array.isArray(subTasks) && subTasks.length > 0 && subTasks.every((task2) => "task" in task2))
        for (let subTask of subTasks)
          setCurrentTask(subTask), await runTask2(subTask, ctx.current);
    }
  }, {
    onFulfilled: () => {
      setState(TasksState.Success), onComplete(ctx.current);
    },
    onRejected: () => {
      setState(TasksState.Failure);
    }
  }), useExitOnCtrlC();
  let { isAborted } = useAbortSignal(abortSignal);
  return silent ? null : state === TasksState.Loading && !isAborted ? import_react53.default.createElement(LoadingBar, { title: currentTask.title, noColor, noProgressBar }) : null;
}

// ../cli-kit/dist/private/node/ui/components/TextPrompt.js
init_cjs_shims();
var import_react54 = __toESM(require_react(), 1);
var TextPrompt = ({ message, onSubmit, validate, defaultValue = "", password = !1, allowEmpty = !1, emptyDisplayedValue = "(empty)", abortSignal, preview, initialAnswer = "" }) => {
  if (password && defaultValue)
    throw new Error("Can't use defaultValue with password");
  let validateAnswer = (0, import_react54.useCallback)((value) => {
    if (validate)
      return validate(value);
    if (value.length === 0 && !allowEmpty)
      return "Type an answer to the prompt.";
  }, [allowEmpty, validate]), { oneThird } = useLayout(), { promptState, setPromptState, answer, setAnswer } = usePrompt({
    initialAnswer
  }), answerOrDefault = answer.length > 0 ? answer : defaultValue, displayEmptyValue = answerOrDefault === "", displayedAnswer = displayEmptyValue ? emptyDisplayedValue : answerOrDefault, { exit: unmountInk } = use_app_default(), [error, setError] = (0, import_react54.useState)(void 0), color = promptState === PromptState.Error ? "red" : "cyan", underline = new Array(oneThird - 3).fill("\u2594"), { isAborted } = useAbortSignal(abortSignal);
  return use_input_default((input, key) => {
    if (handleCtrlC(input, key), key.return) {
      let error2 = validateAnswer(answerOrDefault);
      error2 ? (setPromptState(PromptState.Error), setError(error2)) : setPromptState(PromptState.Submitted);
    }
  }), (0, import_react54.useEffect)(() => {
    promptState === PromptState.Submitted && (onSubmit(answerOrDefault), unmountInk());
  }, [answerOrDefault, onSubmit, promptState, unmountInk]), isAborted ? null : import_react54.default.createElement(
    Box_default,
    { flexDirection: "column", marginBottom: 1, width: oneThird },
    import_react54.default.createElement(
      Box_default,
      null,
      import_react54.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react54.default.createElement(Text, null, "?")
      ),
      import_react54.default.createElement(TokenizedText, { item: messageWithPunctuation(message) })
    ),
    promptState === PromptState.Submitted ? import_react54.default.createElement(
      Box_default,
      null,
      import_react54.default.createElement(
        Box_default,
        { marginRight: 2 },
        import_react54.default.createElement(Text, { color: "cyan" }, figures_default.tick)
      ),
      import_react54.default.createElement(
        Box_default,
        { flexGrow: 1 },
        import_react54.default.createElement(Text, { color: "cyan", dimColor: displayEmptyValue }, password ? "*".repeat(answer.length) : displayedAnswer)
      )
    ) : import_react54.default.createElement(
      Box_default,
      { flexDirection: "column" },
      import_react54.default.createElement(
        Box_default,
        null,
        import_react54.default.createElement(
          Box_default,
          { marginRight: 2 },
          import_react54.default.createElement(Text, { color }, ">")
        ),
        import_react54.default.createElement(
          Box_default,
          { flexGrow: 1 },
          import_react54.default.createElement(TextInput, { value: answer, onChange: (answer2) => {
            setAnswer(answer2), setPromptState(PromptState.Idle);
          }, defaultValue, color, password })
        )
      ),
      import_react54.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react54.default.createElement(Text, { color }, underline)
      ),
      promptState === PromptState.Error ? import_react54.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react54.default.createElement(Text, { color }, error)
      ) : null,
      promptState !== PromptState.Error && preview ? import_react54.default.createElement(
        Box_default,
        { marginLeft: 3 },
        import_react54.default.createElement(TokenizedText, { item: preview(answerOrDefault) })
      ) : null
    )
  );
};

// ../cli-kit/dist/private/node/ui/components/AutocompletePrompt.js
init_cjs_shims();

// ../cli-kit/dist/public/common/function.js
init_cjs_shims();
var import_memoize = __toESM(require_memoize(), 1), import_debounce = __toESM(require_debounce(), 1), import_throttle2 = __toESM(require_throttle(), 1);
function debounce(func, wait, options) {
  return (0, import_debounce.default)(func, wait, options);
}
function throttle2(func, wait, options) {
  return (0, import_throttle2.default)(func, wait, options);
}

// ../cli-kit/dist/private/node/ui/components/AutocompletePrompt.js
var import_react55 = __toESM(require_react(), 1);
var MIN_NUMBER_OF_ITEMS_FOR_SEARCH = 5;
function AutocompletePrompt({ message, choices, infoTable, onSubmit, search, hasMorePages: initialHasMorePages = !1, abortSignal, infoMessage, groupOrder }) {
  let { exit: unmountInk } = use_app_default(), [searchTerm, setSearchTerm] = (0, import_react55.useState)(""), [searchResults, setSearchResults] = (0, import_react55.useState)(choices), canSearch = choices.length > MIN_NUMBER_OF_ITEMS_FOR_SEARCH, [hasMorePages, setHasMorePages] = (0, import_react55.useState)(initialHasMorePages), { promptState, setPromptState, answer, setAnswer } = usePrompt({
    initialAnswer: void 0
  }), paginatedSearch = (0, import_react55.useCallback)(async (term) => await search(term), [search]), submitAnswer = (0, import_react55.useCallback)((answer2) => {
    promptState === PromptState.Idle && (setAnswer(answer2), setPromptState(PromptState.Submitted));
  }, [promptState, setAnswer, setPromptState]);
  (0, import_react55.useEffect)(() => {
    promptState === PromptState.Submitted && answer && (setSearchTerm(""), unmountInk(), onSubmit(answer.value));
  }, [answer, onSubmit, promptState, unmountInk]);
  let setLoadingWhenSlow = (0, import_react55.useRef)(), searchTermRef = (0, import_react55.useRef)("");
  searchTermRef.current = searchTerm;
  let choicesRef = (0, import_react55.useRef)(choices);
  choicesRef.current = choices;
  let initialHasPagesRef = (0, import_react55.useRef)(initialHasMorePages);
  initialHasPagesRef.current = initialHasMorePages;
  let debounceSearch = import_react55.default.useMemo(() => throttle2((term) => {
    setLoadingWhenSlow.current = setTimeout(() => {
      setPromptState(PromptState.Loading);
    }, 100), paginatedSearch(term).then((result) => {
      searchTermRef.current.length === 0 ? (setSearchResults(choicesRef.current), setHasMorePages(initialHasPagesRef.current)) : (setSearchResults(result.data), setHasMorePages(result.meta?.hasNextPage ?? !1)), setPromptState(PromptState.Idle);
    }).catch(() => {
      setPromptState(PromptState.Error);
    }).finally(() => {
      clearTimeout(setLoadingWhenSlow.current);
    });
  }, 400, { leading: !0, trailing: !0 }), [paginatedSearch, setPromptState]);
  return import_react55.default.createElement(PromptLayout, { message, state: promptState, infoTable, infoMessage, abortSignal, header: promptState !== PromptState.Submitted && canSearch ? import_react55.default.createElement(
    Box_default,
    { marginLeft: 3 },
    import_react55.default.createElement(TextInput, { value: searchTerm, onChange: (term) => {
      setSearchTerm(term), term.length > 0 ? debounceSearch(term) : (debounceSearch.cancel(), setPromptState(PromptState.Idle), setSearchResults(choices));
    }, placeholder: "Type to search..." })
  ) : null, submittedAnswerLabel: answer?.label, input: import_react55.default.createElement(SelectInput, { items: searchResults, initialItems: choices, enableShortcuts: !1, emptyMessage: "No results found.", highlightedTerm: searchTerm, loading: promptState === PromptState.Loading, errorMessage: promptState === PromptState.Error ? "There has been an error while searching. Please try again later." : void 0, hasMorePages, morePagesMessage: "Find what you're looking for by typing its name.", onSubmit: submitAnswer, groupOrder }) });
}

// ../cli-kit/dist/private/node/ui/components/SingleTask.js
init_cjs_shims();
var import_react56 = __toESM(require_react(), 1);
var SingleTask = ({ taskPromise, title, noColor }) => {
  let [isDone, setIsDone] = (0, import_react56.useState)(!1), { exit: unmountInk } = use_app_default();
  return useExitOnCtrlC(), (0, import_react56.useEffect)(() => {
    taskPromise.then(() => {
      setIsDone(!0), unmountInk();
    }).catch((error) => {
      setIsDone(!0), unmountInk(error);
    });
  }, [taskPromise, unmountInk]), isDone ? null : import_react56.default.createElement(LoadingBar, { title, noColor });
};

// ../cli-kit/dist/public/node/ui.js
var import_react57 = __toESM(require_react()), defaultUIDebugOptions = {
  skipTTYCheck: !1
};
async function renderConcurrent({ renderOptions, ...props }) {
  let abortSignal = props.abortSignal ?? new AbortController().signal;
  return render2(import_react57.default.createElement(ConcurrentOutput, { ...props, abortSignal }), renderOptions);
}
function renderInfo(options) {
  return alert({ ...options, type: "info" });
}
function renderSuccess(options) {
  return alert({ ...options, type: "success" });
}
function renderWarning(options) {
  return alert({ ...options, type: "warning" });
}
function renderError(options) {
  return alert({ ...options, type: "error" });
}
function renderFatalError(error, { renderOptions } = {}) {
  return renderOnce(import_react57.default.createElement(FatalError2, { error }), { logLevel: "error", renderOptions });
}
async function renderSelectPrompt({ renderOptions, isConfirmationPrompt, ...props }, uiDebugOptions = defaultUIDebugOptions) {
  return throwInNonTTY({ message: props.message, stdin: renderOptions?.stdin }, uiDebugOptions), runWithTimer("cmd_all_timing_prompts_ms")(async () => {
    let selectedValue;
    return await render2(import_react57.default.createElement(SelectPrompt, { ...props, onSubmit: (value) => {
      selectedValue = value;
    } }), {
      ...renderOptions,
      exitOnCtrlC: !1
    }), selectedValue;
  });
}
async function renderConfirmationPrompt({ message, infoTable, confirmationMessage = "Yes, confirm", cancellationMessage = "No, cancel", renderOptions, defaultValue = !0, abortSignal, infoMessage }) {
  return renderSelectPrompt({
    choices: [
      {
        label: confirmationMessage,
        value: !0,
        key: "y"
      },
      {
        label: cancellationMessage,
        value: !1,
        key: "n"
      }
    ],
    message,
    infoTable,
    renderOptions,
    defaultValue,
    isConfirmationPrompt: !0,
    abortSignal,
    infoMessage
  });
}
async function renderAutocompletePrompt({ renderOptions, ...props }, uiDebugOptions = defaultUIDebugOptions) {
  throwInNonTTY({ message: props.message, stdin: renderOptions?.stdin }, uiDebugOptions);
  let newProps = {
    search(term) {
      let lowerTerm = term.toLowerCase();
      return Promise.resolve({
        data: props.choices.filter((item) => item.label.toLowerCase().includes(lowerTerm) || item.group?.toLowerCase().includes(lowerTerm))
      });
    },
    ...props
  };
  return runWithTimer("cmd_all_timing_prompts_ms")(async () => {
    let selectedValue;
    return await render2(import_react57.default.createElement(AutocompletePrompt, { ...newProps, onSubmit: (value) => {
      selectedValue = value;
    } }), {
      ...renderOptions,
      exitOnCtrlC: !1
    }), selectedValue;
  });
}
function renderTable({ renderOptions, ...props }) {
  return renderOnce(import_react57.default.createElement(Table, { ...props }), { renderOptions });
}
async function renderTasks(tasks, { renderOptions, noProgressBar } = {}) {
  return new Promise((resolve, reject) => {
    render2(import_react57.default.createElement(Tasks, { tasks, onComplete: resolve, noProgressBar }), {
      ...renderOptions,
      exitOnCtrlC: !1
    }).then(() => {
    }).catch(reject);
  });
}
async function renderSingleTask({ title, taskPromise }, { renderOptions } = {}) {
  let promise = typeof taskPromise == "function" ? taskPromise() : taskPromise, [_renderResult, taskResult] = await Promise.all([
    render2(import_react57.default.createElement(SingleTask, { title, taskPromise: promise }), {
      ...renderOptions,
      exitOnCtrlC: !1
    }),
    promise
  ]);
  return taskResult;
}
async function renderTextPrompt({ renderOptions, ...props }, uiDebugOptions = defaultUIDebugOptions) {
  return throwInNonTTY({ message: props.message, stdin: renderOptions?.stdin }, uiDebugOptions), runWithTimer("cmd_all_timing_prompts_ms")(async () => {
    let enteredText = "";
    return await render2(import_react57.default.createElement(TextPrompt, { ...props, onSubmit: (value) => {
      enteredText = value;
    } }), {
      ...renderOptions,
      exitOnCtrlC: !1
    }), enteredText;
  });
}
async function renderDangerousConfirmationPrompt({ renderOptions, ...props }, uiDebugOptions = defaultUIDebugOptions) {
  return throwInNonTTY({ message: props.message, stdin: renderOptions?.stdin }, uiDebugOptions), runWithTimer("cmd_all_timing_prompts_ms")(async () => {
    let confirmed;
    return await render2(import_react57.default.createElement(DangerousConfirmationPrompt, { ...props, onSubmit: (value) => {
      confirmed = value;
    } }), {
      ...renderOptions,
      exitOnCtrlC: !1
    }), confirmed;
  });
}
var keypress = async (stdin = process.stdin, uiDebugOptions = defaultUIDebugOptions) => (throwInNonTTY({ message: "Press any key" }, uiDebugOptions), runWithTimer("cmd_all_timing_prompts_ms")(() => new Promise((resolve, reject) => {
  let handler2 = (buffer) => {
    stdin.setRawMode(!1);
    let bytes = Array.from(buffer);
    bytes.length && bytes[0] === 3 && (outputDebug("Canceled keypress, User pressed CTRL+C"), reject(new AbortSilentError())), stdin.unref(), process.nextTick(resolve);
  };
  stdin.setRawMode(!0), stdin.once("data", handler2), stdin.ref();
})));
function isTTY({ stdin = void 0, uiDebugOptions = defaultUIDebugOptions } = {}) {
  return !!(uiDebugOptions.skipTTYCheck || stdin || terminalSupportsPrompting());
}
function throwInNonTTY({ message, stdin = void 0 }, uiDebugOptions) {
  if (isTTY({ stdin, uiDebugOptions }))
    return;
  let promptText = tokenItemToString(message), errorMessage = `Failed to prompt:

${outputContent`${outputToken.cyan(promptText)}`.value}

This usually happens when running a command non-interactively, for example in a CI environment, or when piping to or from another process.`;
  throw new AbortError(errorMessage, "To resolve this, specify the option in the command, or run the command in an interactive environment such as your local terminal.");
}

export {
  isTruthy,
  envPaths,
  environmentVariables,
  systemEnvironmentVariables,
  sessionConstants,
  bugsnagApiKey,
  reportingRateLimit,
  themeKitAccessDomain,
  AbortController,
  AbortSignal,
  createRuntimeMetadataContainer,
  getAllPublicMetadata,
  getAllSensitiveMetadata,
  addPublicMetadata,
  addSensitiveMetadata,
  runWithTimer,
  require_react,
  require_isObject,
  require_root,
  require_Symbol,
  require_isObjectLike,
  require_throttle,
  ansi_escapes_default2 as ansi_escapes_default,
  autoBind,
  require_signal_exit,
  dist_default,
  Yoga,
  require_scheduler,
  require_react_reconciler,
  require_constants,
  stripAnsi,
  ansi_styles_default3 as ansi_styles_default,
  sliceAnsi,
  indentString,
  require_cli_boxes,
  source_default,
  styledCharsFromTokens,
  styledCharsToString,
  tokenize2 as tokenize,
  cli_cursor_default,
  require_stack_utils,
  dist_default3 as dist_default2,
  Box_default,
  Text,
  Static,
  use_stdin_default,
  use_input_default,
  use_stdout_default,
  measure_element_default,
  figures_default,
  useConcurrentOutputContext,
  ConcurrentOutput,
  treeKill,
  render2 as render,
  handleCtrlC,
  require_supports_hyperlinks,
  Link,
  TabularData,
  Alert,
  require_stacktracey,
  require_eq,
  require_Stack,
  require_Uint8Array,
  require_mapToArray,
  require_arrayPush,
  require_isArray,
  require_baseGetAllKeys,
  require_stubArray,
  require_getSymbols,
  require_isArguments,
  require_isBuffer,
  require_isIndex,
  require_baseUnary,
  require_nodeUtil,
  require_isTypedArray,
  require_arrayLikeKeys,
  require_isPrototype,
  require_overArg,
  require_baseKeys,
  require_isArrayLike,
  require_keys,
  require_getAllKeys,
  require_getTag,
  require_baseIsEqual,
  require_arrayMap,
  require_castPath,
  require_toKey,
  require_baseGet,
  require_get,
  require_baseIteratee,
  require_baseDifference,
  require_baseFlatten,
  require_defineProperty,
  require_baseRest,
  require_isArrayLikeObject,
  getArrayRejectingUndefined,
  getArrayContainsDuplicates,
  uniq,
  uniqBy,
  difference,
  asHumanFriendlyArray,
  tslib_es6_exports,
  init_tslib_es6,
  getRandomName,
  capitalize,
  pluralize,
  tryParseInt,
  linesToColumns,
  slugify,
  camelize,
  hyphenate,
  underscore,
  constantize,
  formatDate,
  formatLocalDate,
  joinWithAnd,
  pascalize,
  normalizeDelimitedString,
  useAbortSignal,
  require_baseForOwn,
  require_baseEach,
  require_source,
  debounce,
  renderConcurrent,
  renderInfo,
  renderSuccess,
  renderWarning,
  renderError,
  renderFatalError,
  renderSelectPrompt,
  renderConfirmationPrompt,
  renderAutocompletePrompt,
  renderTable,
  renderTasks,
  renderSingleTask,
  renderTextPrompt,
  renderDangerousConfirmationPrompt,
  keypress,
  isTTY,
  CancelExecution,
  FatalError,
  AbortError,
  AbortSilentError,
  BugError,
  handler,
  errorMapper,
  shouldReportErrorAsUnexpected,
  cleanSingleStackTracePath,
  import_ts_error,
  require_cross_spawn,
  npmRunPathEnv,
  mimicFunction,
  require_get_stream,
  execaSync,
  username,
  platformAndArch,
  openURL,
  captureOutput,
  exec2 as exec,
  sleep,
  terminalSupportsPrompting,
  isCI,
  isWsl,
  localCLIVersion,
  globalCLIVersion,
  isPreReleaseVersion,
  currentProcessIsGlobal,
  installGlobalShopifyCLI,
  installGlobalCLIPrompt,
  inferPackageManagerForGlobalCLI,
  outputToken,
  formatPackageManagerCommand,
  outputContent,
  collectedLogs,
  collectLog,
  clearCollectedLogs,
  outputResult,
  outputInfo,
  outputSuccess,
  outputCompleted,
  outputDebug,
  outputWarn,
  outputNewline,
  stringifyMessage,
  itemToString,
  unstyled,
  shouldDisplayColors,
  formatSection,
  inTemporaryDirectory,
  tempDirectory,
  readFile,
  readFileSync,
  fileRealPath,
  copyFile,
  touchFile,
  appendFile,
  writeFile,
  writeFileSync,
  mkdir,
  mkdirSync,
  removeFile,
  renameFile,
  removeFileSync,
  rmdir,
  isDirectory,
  fileSize,
  fileSizeSync,
  unlinkFileSync,
  unlinkFile,
  createFileReadStream,
  createFileWriteStream,
  fileLastUpdatedTimestamp,
  moveFile,
  chmod,
  fileHasExecutablePermissions,
  fileExists,
  fileExistsSync,
  generateRandomNameForSubdirectory,
  glob,
  findPathUp,
  matchGlob,
  readdir,
  copyDirectoryContents,
  isTerminalInteractive,
  homeDirectory,
  isDevelopment,
  isVerbose,
  isShopify,
  isUnitTest,
  analyticsDisabled,
  alwaysLogAnalytics,
  alwaysLogMetrics,
  firstPartyDev,
  gitpodURL,
  codespaceURL,
  codespacePortForwardingDomain,
  isCloudEnvironment,
  themeToken,
  cloudEnvironment,
  hasGit,
  ciPlatform,
  macAddress,
  getThemeKitAccessDomain,
  opentelemetryDomain
};
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler.production.min.js:
  (**
   * @license React
   * react-reconciler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler.development.js:
  (**
   * @license React
   * react-reconciler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler-constants.production.min.js:
  (**
   * @license React
   * react-reconciler-constants.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-reconciler/cjs/react-reconciler-constants.development.js:
  (**
   * @license React
   * react-reconciler-constants.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-34TWZ632.js.map
