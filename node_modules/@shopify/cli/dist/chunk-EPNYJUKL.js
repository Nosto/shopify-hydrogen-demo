import {
  getEnvironmentData,
  getLastSeenUserIdAfterAuth,
  getSensitiveEnvironmentData,
  requestIdsCollection
} from "./chunk-VOXGVQ4Y.js";
import {
  fetch
} from "./chunk-W7V5E5TL.js";
import {
  runWithRateLimit
} from "./chunk-UTGZE4KZ.js";
import {
  CLI_KIT_VERSION
} from "./chunk-XXIM3XSO.js";
import {
  alwaysLogAnalytics,
  alwaysLogMetrics,
  analyticsDisabled,
  getAllPublicMetadata,
  getAllSensitiveMetadata,
  getArrayContainsDuplicates,
  getArrayRejectingUndefined,
  isShopify,
  isUnitTest,
  opentelemetryDomain,
  outputContent,
  outputDebug,
  outputToken,
  reportingRateLimit
} from "./chunk-34TWZ632.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  init_cjs_shims
} from "./chunk-PKR7KJ6P.js";

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js
var require_AggregationTemporality = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationTemporality.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AggregationTemporality = void 0;
    var AggregationTemporality2;
    (function(AggregationTemporality3) {
      AggregationTemporality3[AggregationTemporality3.DELTA = 0] = "DELTA", AggregationTemporality3[AggregationTemporality3.CUMULATIVE = 1] = "CUMULATIVE";
    })(AggregationTemporality2 = exports2.AggregationTemporality || (exports2.AggregationTemporality = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js
var require_MetricData = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricData.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DataPointType = void 0;
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2.HISTOGRAM = 0] = "HISTOGRAM", DataPointType2[DataPointType2.EXPONENTIAL_HISTOGRAM = 1] = "EXPONENTIAL_HISTOGRAM", DataPointType2[DataPointType2.GAUGE = 2] = "GAUGE", DataPointType2[DataPointType2.SUM = 3] = "SUM";
    })(DataPointType = exports2.DataPointType || (exports2.DataPointType = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis, init_globalThis = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    init_cjs_shims();
    _globalThis = typeof globalThis == "object" ? globalThis : global;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_cjs_shims();
    init_globalThis();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_cjs_shims();
    init_node();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/version.js
var VERSION, init_version = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/version.js"() {
    init_cjs_shims();
    VERSION = "1.9.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]), rejectedVersions = /* @__PURE__ */ new Set(), myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch)
    return function() {
      return !1;
    };
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null)
    return function(globalVersion) {
      return globalVersion === ownVersion;
    };
  function _reject(v) {
    return rejectedVersions.add(v), !1;
  }
  function _accept(v) {
    return acceptedVersions.add(v), !0;
  }
  return function(globalVersion) {
    if (acceptedVersions.has(globalVersion))
      return !0;
    if (rejectedVersions.has(globalVersion))
      return !1;
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch)
      return _reject(globalVersion);
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    return globalVersionParsed.prerelease != null || ownVersionParsed.major !== globalVersionParsed.major ? _reject(globalVersion) : ownVersionParsed.major === 0 ? ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch ? _accept(globalVersion) : _reject(globalVersion) : ownVersionParsed.minor <= globalVersionParsed.minor ? _accept(globalVersion) : _reject(globalVersion);
  };
}
var re, isCompatible, init_semver = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_cjs_shims();
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  allowOverride === void 0 && (allowOverride = !1);
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    return diag3.error(err.stack || err.message), !1;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    return diag3.error(err.stack || err.message), !1;
  }
  return api[type] = instance, diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + "."), !0;
}
function getGlobal(type) {
  var _a, _b, globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!(!globalVersion || !isCompatible(globalVersion)))
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  api && delete api[type];
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global, init_global_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_cjs_shims();
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0], GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major), _global = _globalThis;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (logger)
    return args.unshift(namespace), logger[funcName].apply(logger, __spreadArray([], __read(args), !1));
}
var __read, __spreadArray, DiagComponentLogger, init_ComponentLogger = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_cjs_shims();
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol == "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          r && !r.done && (m = i.return) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++)
        (ar || !(i in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
      return to.concat(ar || Array.prototype.slice.call(from));
    }, DiagComponentLogger = /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      return DiagComponentLogger2.prototype.debug = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return logProxy("debug", this._namespace, args);
      }, DiagComponentLogger2.prototype.error = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return logProxy("error", this._namespace, args);
      }, DiagComponentLogger2.prototype.info = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return logProxy("info", this._namespace, args);
      }, DiagComponentLogger2.prototype.warn = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return logProxy("warn", this._namespace, args);
      }, DiagComponentLogger2.prototype.verbose = function() {
        for (var args = [], _i = 0; _i < arguments.length; _i++)
          args[_i] = arguments[_i];
        return logProxy("verbose", this._namespace, args);
      }, DiagComponentLogger2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel, init_types = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    init_cjs_shims();
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2.NONE = 0] = "NONE", DiagLogLevel2[DiagLogLevel2.ERROR = 30] = "ERROR", DiagLogLevel2[DiagLogLevel2.WARN = 50] = "WARN", DiagLogLevel2[DiagLogLevel2.INFO = 60] = "INFO", DiagLogLevel2[DiagLogLevel2.DEBUG = 70] = "DEBUG", DiagLogLevel2[DiagLogLevel2.VERBOSE = 80] = "VERBOSE", DiagLogLevel2[DiagLogLevel2.ALL = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  maxLevel < DiagLogLevel.NONE ? maxLevel = DiagLogLevel.NONE : maxLevel > DiagLogLevel.ALL && (maxLevel = DiagLogLevel.ALL), logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    return typeof theFunc == "function" && maxLevel >= theLevel ? theFunc.bind(logger) : function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_cjs_shims();
    init_types();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI, init_diag = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_cjs_shims();
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol == "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          r && !r.done && (m = i.return) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++)
        (ar || !(i in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
      return to.concat(ar || Array.prototype.slice.call(from));
    }, API_NAME = "diag", DiagAPI = /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++)
              args[_i] = arguments[_i];
            var logger = getGlobal("diag");
            if (logger)
              return logger[funcName].apply(logger, __spreadArray2([], __read2(args), !1));
          };
        }
        var self2 = this, setLogger = function(logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0 && (optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }), logger === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            return self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message), !1;
          }
          typeof optionsOrLogLevel == "number" && (optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          });
          var oldLogger = getGlobal("diag"), newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack), newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, !0);
        };
        self2.setLogger = setLogger, self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        }, self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        }, self2.verbose = _logProxy("verbose"), self2.debug = _logProxy("debug"), self2.info = _logProxy("info"), self2.warn = _logProxy("warn"), self2.error = _logProxy("error");
      }
      return DiagAPI2.instance = function() {
        return this._instance || (this._instance = new DiagAPI2()), this._instance;
      }, DiagAPI2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl, init_baggage_impl = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    init_cjs_shims();
    __read3 = function(o, n) {
      var m = typeof Symbol == "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          r && !r.done && (m = i.return) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, __values = function(o) {
      var s = typeof Symbol == "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length == "number") return {
        next: function() {
          return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, BaggageImpl = /** @class */
    function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      return BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (entry)
          return Object.assign({}, entry);
      }, BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read3(_a, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      }, BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        return newBaggage._entries.set(key, entry), newBaggage;
      }, BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        return newBaggage._entries.delete(key), newBaggage;
      }, BaggageImpl2.prototype.removeEntries = function() {
        for (var e_1, _a, keys = [], _i = 0; _i < arguments.length; _i++)
          keys[_i] = arguments[_i];
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            keys_1_1 && !keys_1_1.done && (_a = keys_1.return) && _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      }, BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      }, BaggageImpl2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol, init_symbol = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    init_cjs_shims();
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  return entries === void 0 && (entries = {}), new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  return typeof str != "string" && (diag.error("Cannot create baggage metadata from unknown type: " + typeof str), str = ""), {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag, init_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_cjs_shims();
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT, init_context = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    init_cjs_shims();
    BaseContext = /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map(), self2.getValue = function(key) {
          return self2._currentContext.get(key);
        }, self2.setValue = function(key, value) {
          var context2 = new BaseContext2(self2._currentContext);
          return context2._currentContext.set(key, value), context2;
        }, self2.deleteValue = function(key) {
          var context2 = new BaseContext2(self2._currentContext);
          return context2._currentContext.delete(key), context2;
        };
      }
      return BaseContext2;
    }(), ROOT_CONTEXT = new BaseContext();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger, init_consoleLogger = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    init_cjs_shims();
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ], DiagConsoleLogger = /** @class */
    /* @__PURE__ */ function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++)
              args[_i] = arguments[_i];
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc != "function" && (theFunc = console.log), typeof theFunc == "function")
                return theFunc.apply(console, args);
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++)
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
      return DiagConsoleLogger2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC, init_NoopMeter = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    init_cjs_shims();
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
        }, extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b != "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }(), NoopMeter = /** @class */
    function() {
      function NoopMeter2() {
      }
      return NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      }, NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      }, NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      }, NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      }, NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      }, NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      }, NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }, NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      }, NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      }, NoopMeter2;
    }(), NoopMetric = /** @class */
    /* @__PURE__ */ function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    }(), NoopCounterMetric = /** @class */
    function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      }, NoopCounterMetric2;
    }(NoopMetric), NoopUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      }, NoopUpDownCounterMetric2;
    }(NoopMetric), NoopGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      }, NoopGaugeMetric2;
    }(NoopMetric), NoopHistogramMetric = /** @class */
    function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      }, NoopHistogramMetric2;
    }(NoopMetric), NoopObservableMetric = /** @class */
    function() {
      function NoopObservableMetric2() {
      }
      return NoopObservableMetric2.prototype.addCallback = function(_callback) {
      }, NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      }, NoopObservableMetric2;
    }(), NoopObservableCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    }(NoopObservableMetric), NoopObservableGaugeMetric = /** @class */
    function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    }(NoopObservableMetric), NoopObservableUpDownCounterMetric = /** @class */
    function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    }(NoopObservableMetric), NOOP_METER = new NoopMeter(), NOOP_COUNTER_METRIC = new NoopCounterMetric(), NOOP_GAUGE_METRIC = new NoopGaugeMetric(), NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric(), NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric(), NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric(), NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric(), NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType, init_Metric = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    init_cjs_shims();
    (function(ValueType2) {
      ValueType2[ValueType2.INT = 0] = "INT", ValueType2[ValueType2.DOUBLE = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter, init_TextMapPropagator = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    init_cjs_shims();
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier != null)
          return carrier[key];
      },
      keys: function(carrier) {
        return carrier == null ? [] : Object.keys(carrier);
      }
    }, defaultTextMapSetter = {
      set: function(carrier, key, value) {
        carrier != null && (carrier[key] = value);
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager, init_NoopContextManager = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_cjs_shims();
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol == "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          r && !r.done && (m = i.return) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++)
        (ar || !(i in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
      return to.concat(ar || Array.prototype.slice.call(from));
    }, NoopContextManager = /** @class */
    function() {
      function NoopContextManager2() {
      }
      return NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      }, NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        for (var args = [], _i = 3; _i < arguments.length; _i++)
          args[_i - 3] = arguments[_i];
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), !1));
      }, NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      }, NoopContextManager2.prototype.enable = function() {
        return this;
      }, NoopContextManager2.prototype.disable = function() {
        return this;
      }, NoopContextManager2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI, init_context2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_cjs_shims();
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol == "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          r && !r.done && (m = i.return) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }, __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++)
        (ar || !(i in from)) && (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
      return to.concat(ar || Array.prototype.slice.call(from));
    }, API_NAME2 = "context", NOOP_CONTEXT_MANAGER = new NoopContextManager(), ContextAPI = /** @class */
    function() {
      function ContextAPI2() {
      }
      return ContextAPI2.getInstance = function() {
        return this._instance || (this._instance = new ContextAPI2()), this._instance;
      }, ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      }, ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      }, ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        for (var _a, args = [], _i = 3; _i < arguments.length; _i++)
          args[_i - 3] = arguments[_i];
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read5(args), !1));
      }, ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      }, ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      }, ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable(), unregisterGlobal(API_NAME2, DiagAPI.instance());
      }, ContextAPI2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags, init_trace_flags = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    init_cjs_shims();
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2.NONE = 0] = "NONE", TraceFlags2[TraceFlags2.SAMPLED = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT, init_invalid_span_constants = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_cjs_shims();
    init_trace_flags();
    INVALID_SPANID = "0000000000000000", INVALID_TRACEID = "00000000000000000000000000000000", INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan, init_NonRecordingSpan = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_cjs_shims();
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        _spanContext === void 0 && (_spanContext = INVALID_SPAN_CONTEXT), this._spanContext = _spanContext;
      }
      return NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      }, NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      }, NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      }, NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      }, NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      }, NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      }, NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      }, NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      }, NonRecordingSpan2.prototype.end = function(_endTime) {
      }, NonRecordingSpan2.prototype.isRecording = function() {
        return !1;
      }, NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      }, NonRecordingSpan2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY, init_context_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_cjs_shims();
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX, init_spancontext_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_cjs_shims();
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i, VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext == "object" && typeof spanContext.spanId == "string" && typeof spanContext.traceId == "string" && typeof spanContext.traceFlags == "number";
}
var contextApi, NoopTracer, init_NoopTracer = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_cjs_shims();
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance(), NoopTracer = /** @class */
    function() {
      function NoopTracer2() {
      }
      return NoopTracer2.prototype.startSpan = function(name, options, context2) {
        context2 === void 0 && (context2 = contextApi.active());
        var root = !!options?.root;
        if (root)
          return new NonRecordingSpan();
        var parentFromContext = context2 && getSpanContext(context2);
        return isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext) ? new NonRecordingSpan(parentFromContext) : new NonRecordingSpan();
      }, NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts, ctx, fn;
        if (!(arguments.length < 2)) {
          arguments.length === 2 ? fn = arg2 : arguments.length === 3 ? (opts = arg2, fn = arg3) : (opts = arg2, ctx = arg3, fn = arg4);
          var parentContext = ctx ?? contextApi.active(), span = this.startSpan(name, opts, parentContext), contextWithSpanSet = setSpan(parentContext, span);
          return contextApi.with(contextWithSpanSet, fn, void 0, span);
        }
      }, NoopTracer2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer, init_ProxyTracer = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_cjs_shims();
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer(), ProxyTracer = /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider, this.name = name, this.version = version, this.options = options;
      }
      return ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      }, ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }, ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate)
          return this._delegate;
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        return tracer ? (this._delegate = tracer, this._delegate) : NOOP_TRACER;
      }, ProxyTracer2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider, init_NoopTracerProvider = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_cjs_shims();
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      return NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      }, NoopTracerProvider2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider, init_ProxyTracerProvider = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_cjs_shims();
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider(), ProxyTracerProvider = /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      return ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      }, ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }, ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      }, ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      }, ProxyTracerProvider2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision, init_SamplingResult = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    init_cjs_shims();
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2.NOT_RECORD = 0] = "NOT_RECORD", SamplingDecision2[SamplingDecision2.RECORD = 1] = "RECORD", SamplingDecision2[SamplingDecision2.RECORD_AND_SAMPLED = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind, init_span_kind = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    init_cjs_shims();
    (function(SpanKind2) {
      SpanKind2[SpanKind2.INTERNAL = 0] = "INTERNAL", SpanKind2[SpanKind2.SERVER = 1] = "SERVER", SpanKind2[SpanKind2.CLIENT = 2] = "CLIENT", SpanKind2[SpanKind2.PRODUCER = 3] = "PRODUCER", SpanKind2[SpanKind2.CONSUMER = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode, init_status = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    init_cjs_shims();
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2.UNSET = 0] = "UNSET", SpanStatusCode2[SpanStatusCode2.OK = 1] = "OK", SpanStatusCode2[SpanStatusCode2.ERROR = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX, init_tracestate_validators = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    init_cjs_shims();
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]", VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}", VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}", VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$"), VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl, init_tracestate_impl = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_cjs_shims();
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32, MAX_TRACE_STATE_LEN = 512, LIST_MEMBERS_SEPARATOR = ",", LIST_MEMBER_KEY_VALUE_SPLITTER = "=", TraceStateImpl = /** @class */
    function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map(), rawTraceState && this._parse(rawTraceState);
      }
      return TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }, TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }, TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      }, TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          return agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key)), agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }, TraceStateImpl2.prototype._parse = function(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim(), i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
            validateKey(key) && validateValue(value) && agg.set(key, value);
          }
          return agg;
        }, /* @__PURE__ */ new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS))));
      }, TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      }, TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        return traceState._internalState = new Map(this._internalState), traceState;
      }, TraceStateImpl2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_cjs_shims();
    init_tracestate_impl();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context-api.js
var context, init_context_api = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_cjs_shims();
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2, init_diag_api = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_cjs_shims();
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER, init_NoopMeterProvider = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_cjs_shims();
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    function() {
      function NoopMeterProvider2() {
      }
      return NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      }, NoopMeterProvider2;
    }(), NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI, init_metrics = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_cjs_shims();
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics", MetricsAPI = /** @class */
    function() {
      function MetricsAPI2() {
      }
      return MetricsAPI2.getInstance = function() {
        return this._instance || (this._instance = new MetricsAPI2()), this._instance;
      }, MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      }, MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      }, MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      }, MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      }, MetricsAPI2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics, init_metrics_api = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_cjs_shims();
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator, init_NoopTextMapPropagator = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    init_cjs_shims();
    NoopTextMapPropagator = /** @class */
    function() {
      function NoopTextMapPropagator2() {
      }
      return NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      }, NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      }, NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      }, NoopTextMapPropagator2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY, init_context_helpers = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_cjs_shims();
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI, init_propagation = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_cjs_shims();
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation", NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator(), PropagationAPI = /** @class */
    function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage, this.getBaggage = getBaggage, this.getActiveBaggage = getActiveBaggage, this.setBaggage = setBaggage, this.deleteBaggage = deleteBaggage;
      }
      return PropagationAPI2.getInstance = function() {
        return this._instance || (this._instance = new PropagationAPI2()), this._instance;
      }, PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      }, PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        return setter === void 0 && (setter = defaultTextMapSetter), this._getGlobalPropagator().inject(context2, carrier, setter);
      }, PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        return getter === void 0 && (getter = defaultTextMapGetter), this._getGlobalPropagator().extract(context2, carrier, getter);
      }, PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      }, PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      }, PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      }, PropagationAPI2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation, init_propagation_api = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_cjs_shims();
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI, init_trace = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_cjs_shims();
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace", TraceAPI = /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider(), this.wrapSpanContext = wrapSpanContext, this.isSpanContextValid = isSpanContextValid, this.deleteSpan = deleteSpan, this.getSpan = getSpan, this.getActiveSpan = getActiveSpan, this.getSpanContext = getSpanContext, this.setSpan = setSpan, this.setSpanContext = setSpanContext;
      }
      return TraceAPI2.getInstance = function() {
        return this._instance || (this._instance = new TraceAPI2()), this._instance;
      }, TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        return success && this._proxyTracerProvider.setDelegate(provider), success;
      }, TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      }, TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      }, TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance()), this._proxyTracerProvider = new ProxyTracerProvider();
      }, TraceAPI2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace, init_trace_api = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_cjs_shims();
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default, init_esm = __esm({
  "../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_cjs_shims();
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.equalsCaseInsensitive = exports2.binarySearchUB = exports2.setEquals = exports2.FlatMap = exports2.isPromiseAllSettledRejectionResult = exports2.PromiseAllSettled = exports2.callWithTimeout = exports2.TimeoutError = exports2.instrumentationScopeId = exports2.hashAttributes = exports2.isNotNullish = void 0;
    function isNotNullish(item) {
      return item != null;
    }
    exports2.isNotNullish = isNotNullish;
    function hashAttributes(attributes) {
      let keys = Object.keys(attributes);
      return keys.length === 0 ? "" : (keys = keys.sort(), JSON.stringify(keys.map((key) => [key, attributes[key]])));
    }
    exports2.hashAttributes = hashAttributes;
    function instrumentationScopeId(instrumentationScope2) {
      var _a, _b;
      return `${instrumentationScope2.name}:${(_a = instrumentationScope2.version) !== null && _a !== void 0 ? _a : ""}:${(_b = instrumentationScope2.schemaUrl) !== null && _b !== void 0 ? _b : ""}`;
    }
    exports2.instrumentationScopeId = instrumentationScopeId;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle, timeoutPromise = new Promise(function(_resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => (clearTimeout(timeoutHandle), result), (reason) => {
        throw clearTimeout(timeoutHandle), reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
    async function PromiseAllSettled(promises) {
      return Promise.all(promises.map(async (p) => {
        try {
          return {
            status: "fulfilled",
            value: await p
          };
        } catch (e) {
          return {
            status: "rejected",
            reason: e
          };
        }
      }));
    }
    exports2.PromiseAllSettled = PromiseAllSettled;
    function isPromiseAllSettledRejectionResult(it) {
      return it.status === "rejected";
    }
    exports2.isPromiseAllSettledRejectionResult = isPromiseAllSettledRejectionResult;
    function FlatMap(arr, fn) {
      let result = [];
      return arr.forEach((it) => {
        result.push(...fn(it));
      }), result;
    }
    exports2.FlatMap = FlatMap;
    function setEquals(lhs, rhs) {
      if (lhs.size !== rhs.size)
        return !1;
      for (let item of lhs)
        if (!rhs.has(item))
          return !1;
      return !0;
    }
    exports2.setEquals = setEquals;
    function binarySearchUB(arr, value) {
      let lo = 0, hi = arr.length - 1, ret = arr.length;
      for (; hi >= lo; ) {
        let mid = lo + Math.trunc((hi - lo) / 2);
        arr[mid] < value ? lo = mid + 1 : (ret = mid, hi = mid - 1);
      }
      return ret;
    }
    exports2.binarySearchUB = binarySearchUB;
    function equalsCaseInsensitive(lhs, rhs) {
      return lhs.toLowerCase() === rhs.toLowerCase();
    }
    exports2.equalsCaseInsensitive = equalsCaseInsensitive;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/types.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AggregatorKind = void 0;
    var AggregatorKind;
    (function(AggregatorKind2) {
      AggregatorKind2[AggregatorKind2.DROP = 0] = "DROP", AggregatorKind2[AggregatorKind2.SUM = 1] = "SUM", AggregatorKind2[AggregatorKind2.LAST_VALUE = 2] = "LAST_VALUE", AggregatorKind2[AggregatorKind2.HISTOGRAM = 3] = "HISTOGRAM", AggregatorKind2[AggregatorKind2.EXPONENTIAL_HISTOGRAM = 4] = "EXPONENTIAL_HISTOGRAM";
    })(AggregatorKind = exports2.AggregatorKind || (exports2.AggregatorKind = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js
var require_Drop = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Drop.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DropAggregator = void 0;
    var types_1 = require_types(), DropAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.DROP;
      }
      createAccumulation() {
      }
      merge(_previous, _delta) {
      }
      diff(_previous, _current) {
      }
      toMetricData(_descriptor, _aggregationTemporality, _accumulationByAttributes, _endTime) {
      }
    };
    exports2.DropAggregator = DropAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js
var require_InstrumentDescriptor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/InstrumentDescriptor.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isValidName = exports2.isDescriptorCompatibleWith = exports2.createInstrumentDescriptorWithView = exports2.createInstrumentDescriptor = exports2.InstrumentType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), utils_1 = require_utils(), InstrumentType;
    (function(InstrumentType2) {
      InstrumentType2.COUNTER = "COUNTER", InstrumentType2.GAUGE = "GAUGE", InstrumentType2.HISTOGRAM = "HISTOGRAM", InstrumentType2.UP_DOWN_COUNTER = "UP_DOWN_COUNTER", InstrumentType2.OBSERVABLE_COUNTER = "OBSERVABLE_COUNTER", InstrumentType2.OBSERVABLE_GAUGE = "OBSERVABLE_GAUGE", InstrumentType2.OBSERVABLE_UP_DOWN_COUNTER = "OBSERVABLE_UP_DOWN_COUNTER";
    })(InstrumentType = exports2.InstrumentType || (exports2.InstrumentType = {}));
    function createInstrumentDescriptor(name, type, options) {
      var _a, _b, _c, _d;
      return isValidName(name) || api_1.diag.warn(`Invalid metric name: "${name}". The metric name should be a ASCII string with a length no greater than 255 characters.`), {
        name,
        type,
        description: (_a = options?.description) !== null && _a !== void 0 ? _a : "",
        unit: (_b = options?.unit) !== null && _b !== void 0 ? _b : "",
        valueType: (_c = options?.valueType) !== null && _c !== void 0 ? _c : api_1.ValueType.DOUBLE,
        advice: (_d = options?.advice) !== null && _d !== void 0 ? _d : {}
      };
    }
    exports2.createInstrumentDescriptor = createInstrumentDescriptor;
    function createInstrumentDescriptorWithView(view, instrument) {
      var _a, _b;
      return {
        name: (_a = view.name) !== null && _a !== void 0 ? _a : instrument.name,
        description: (_b = view.description) !== null && _b !== void 0 ? _b : instrument.description,
        type: instrument.type,
        unit: instrument.unit,
        valueType: instrument.valueType,
        advice: instrument.advice
      };
    }
    exports2.createInstrumentDescriptorWithView = createInstrumentDescriptorWithView;
    function isDescriptorCompatibleWith(descriptor, otherDescriptor) {
      return (0, utils_1.equalsCaseInsensitive)(descriptor.name, otherDescriptor.name) && descriptor.unit === otherDescriptor.unit && descriptor.type === otherDescriptor.type && descriptor.valueType === otherDescriptor.valueType;
    }
    exports2.isDescriptorCompatibleWith = isDescriptorCompatibleWith;
    var NAME_REGEXP = /^[a-z][a-z0-9_.\-/]{0,254}$/i;
    function isValidName(name) {
      return name.match(NAME_REGEXP) != null;
    }
    exports2.isValidName = isValidName;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js
var require_Histogram = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Histogram.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.HistogramAggregator = exports2.HistogramAccumulation = void 0;
    var types_1 = require_types(), MetricData_1 = require_MetricData(), InstrumentDescriptor_1 = require_InstrumentDescriptor(), utils_1 = require_utils();
    function createNewEmptyCheckpoint(boundaries) {
      let counts = boundaries.map(() => 0);
      return counts.push(0), {
        buckets: {
          boundaries,
          counts
        },
        sum: 0,
        count: 0,
        hasMinMax: !1,
        min: 1 / 0,
        max: -1 / 0
      };
    }
    var HistogramAccumulation = class {
      constructor(startTime, _boundaries, _recordMinMax = !0, _current = createNewEmptyCheckpoint(_boundaries)) {
        this.startTime = startTime, this._boundaries = _boundaries, this._recordMinMax = _recordMinMax, this._current = _current;
      }
      record(value) {
        if (Number.isNaN(value))
          return;
        this._current.count += 1, this._current.sum += value, this._recordMinMax && (this._current.min = Math.min(value, this._current.min), this._current.max = Math.max(value, this._current.max), this._current.hasMinMax = !0);
        let idx = (0, utils_1.binarySearchUB)(this._boundaries, value);
        this._current.buckets.counts[idx] += 1;
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports2.HistogramAccumulation = HistogramAccumulation;
    var HistogramAggregator = class {
      /**
       * @param _boundaries sorted upper bounds of recorded values.
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(_boundaries, _recordMinMax) {
        this._boundaries = _boundaries, this._recordMinMax = _recordMinMax, this.kind = types_1.AggregatorKind.HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new HistogramAccumulation(startTime, this._boundaries, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two histogram accumulations. As long as one Aggregator
       * instance produces all Accumulations with constant boundaries we don't need to worry about
       * merging accumulations with different boundaries.
       */
      merge(previous, delta) {
        let previousValue = previous.toPointValue(), deltaValue = delta.toPointValue(), previousCounts = previousValue.buckets.counts, deltaCounts = deltaValue.buckets.counts, mergedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++)
          mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];
        let min = 1 / 0, max = -1 / 0;
        return this._recordMinMax && (previousValue.hasMinMax && deltaValue.hasMinMax ? (min = Math.min(previousValue.min, deltaValue.min), max = Math.max(previousValue.max, deltaValue.max)) : previousValue.hasMinMax ? (min = previousValue.min, max = previousValue.max) : deltaValue.hasMinMax && (min = deltaValue.min, max = deltaValue.max)), new HistogramAccumulation(previous.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: mergedCounts
          },
          count: previousValue.count + deltaValue.count,
          sum: previousValue.sum + deltaValue.sum,
          hasMinMax: this._recordMinMax && (previousValue.hasMinMax || deltaValue.hasMinMax),
          min,
          max
        });
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let previousValue = previous.toPointValue(), currentValue = current.toPointValue(), previousCounts = previousValue.buckets.counts, currentCounts = currentValue.buckets.counts, diffedCounts = new Array(previousCounts.length);
        for (let idx = 0; idx < previousCounts.length; idx++)
          diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];
        return new HistogramAccumulation(current.startTime, previousValue.buckets.boundaries, this._recordMinMax, {
          buckets: {
            boundaries: previousValue.buckets.boundaries,
            counts: diffedCounts
          },
          count: currentValue.count - previousValue.count,
          sum: currentValue.sum - previousValue.sum,
          hasMinMax: !1,
          min: 1 / 0,
          max: -1 / 0
        });
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            let pointValue = accumulation.toPointValue(), allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: allowsNegativeValues ? void 0 : pointValue.sum,
                buckets: pointValue.buckets,
                count: pointValue.count
              }
            };
          })
        };
      }
    };
    exports2.HistogramAggregator = HistogramAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js
var require_Buckets = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/Buckets.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Buckets = void 0;
    var Buckets = class _Buckets {
      /**
       * The term index refers to the number of the exponential histogram bucket
       * used to determine its boundaries. The lower boundary of a bucket is
       * determined by base ** index and the upper boundary of a bucket is
       * determined by base ** (index + 1). index values are signed to account
       * for values less than or equal to 1.
       *
       * indexBase is the index of the 0th position in the
       * backing array, i.e., backing[0] is the count
       * in the bucket with index `indexBase`.
       *
       * indexStart is the smallest index value represented
       * in the backing array.
       *
       * indexEnd is the largest index value represented in
       * the backing array.
       */
      constructor(backing = new BucketsBacking(), indexBase = 0, indexStart = 0, indexEnd = 0) {
        this.backing = backing, this.indexBase = indexBase, this.indexStart = indexStart, this.indexEnd = indexEnd;
      }
      /**
       * Offset is the bucket index of the smallest entry in the counts array
       * @returns {number}
       */
      get offset() {
        return this.indexStart;
      }
      /**
       * Buckets is a view into the backing array.
       * @returns {number}
       */
      get length() {
        return this.backing.length === 0 || this.indexEnd === this.indexStart && this.at(0) === 0 ? 0 : this.indexEnd - this.indexStart + 1;
      }
      /**
       * An array of counts, where count[i] carries the count
       * of the bucket at index (offset+i).  count[i] is the count of
       * values greater than base^(offset+i) and less than or equal to
       * base^(offset+i+1).
       * @returns {number} The logical counts based on the backing array
       */
      counts() {
        return Array.from({ length: this.length }, (_, i) => this.at(i));
      }
      /**
       * At returns the count of the bucket at a position in the logical
       * array of counts.
       * @param position
       * @returns {number}
       */
      at(position) {
        let bias = this.indexBase - this.indexStart;
        return position < bias && (position += this.backing.length), position -= bias, this.backing.countAt(position);
      }
      /**
       * incrementBucket increments the backing array index by `increment`
       * @param bucketIndex
       * @param increment
       */
      incrementBucket(bucketIndex, increment) {
        this.backing.increment(bucketIndex, increment);
      }
      /**
       * decrementBucket decrements the backing array index by `decrement`
       * if decrement is greater than the current value, it's set to 0.
       * @param bucketIndex
       * @param decrement
       */
      decrementBucket(bucketIndex, decrement) {
        this.backing.decrement(bucketIndex, decrement);
      }
      /**
       * trim removes leading and / or trailing zero buckets (which can occur
       * after diffing two histos) and rotates the backing array so that the
       * smallest non-zero index is in the 0th position of the backing array
       */
      trim() {
        for (let i = 0; i < this.length; i++)
          if (this.at(i) !== 0) {
            this.indexStart += i;
            break;
          } else if (i === this.length - 1) {
            this.indexStart = this.indexEnd = this.indexBase = 0;
            return;
          }
        for (let i = this.length - 1; i >= 0; i--)
          if (this.at(i) !== 0) {
            this.indexEnd -= this.length - i - 1;
            break;
          }
        this._rotate();
      }
      /**
       * downscale first rotates, then collapses 2**`by`-to-1 buckets.
       * @param by
       */
      downscale(by) {
        this._rotate();
        let size = 1 + this.indexEnd - this.indexStart, each = 1 << by, inpos = 0, outpos = 0;
        for (let pos = this.indexStart; pos <= this.indexEnd; ) {
          let mod2 = pos % each;
          mod2 < 0 && (mod2 += each);
          for (let i = mod2; i < each && inpos < size; i++)
            this._relocateBucket(outpos, inpos), inpos++, pos++;
          outpos++;
        }
        this.indexStart >>= by, this.indexEnd >>= by, this.indexBase = this.indexStart;
      }
      /**
       * Clone returns a deep copy of Buckets
       * @returns {Buckets}
       */
      clone() {
        return new _Buckets(this.backing.clone(), this.indexBase, this.indexStart, this.indexEnd);
      }
      /**
       * _rotate shifts the backing array contents so that indexStart ==
       * indexBase to simplify the downscale logic.
       */
      _rotate() {
        let bias = this.indexBase - this.indexStart;
        bias !== 0 && (bias > 0 ? (this.backing.reverse(0, this.backing.length), this.backing.reverse(0, bias), this.backing.reverse(bias, this.backing.length)) : (this.backing.reverse(0, this.backing.length), this.backing.reverse(0, this.backing.length + bias)), this.indexBase = this.indexStart);
      }
      /**
       * _relocateBucket adds the count in counts[src] to counts[dest] and
       * resets count[src] to zero.
       */
      _relocateBucket(dest, src) {
        dest !== src && this.incrementBucket(dest, this.backing.emptyBucket(src));
      }
    };
    exports2.Buckets = Buckets;
    var BucketsBacking = class _BucketsBacking {
      constructor(_counts = [0]) {
        this._counts = _counts;
      }
      /**
       * length returns the physical size of the backing array, which
       * is >= buckets.length()
       */
      get length() {
        return this._counts.length;
      }
      /**
       * countAt returns the count in a specific bucket
       */
      countAt(pos) {
        return this._counts[pos];
      }
      /**
       * growTo grows a backing array and copies old entries
       * into their correct new positions.
       */
      growTo(newSize, oldPositiveLimit, newPositiveLimit) {
        let tmp = new Array(newSize).fill(0);
        tmp.splice(newPositiveLimit, this._counts.length - oldPositiveLimit, ...this._counts.slice(oldPositiveLimit)), tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit)), this._counts = tmp;
      }
      /**
       * reverse the items in the backing array in the range [from, limit).
       */
      reverse(from, limit) {
        let num = Math.floor((from + limit) / 2) - from;
        for (let i = 0; i < num; i++) {
          let tmp = this._counts[from + i];
          this._counts[from + i] = this._counts[limit - i - 1], this._counts[limit - i - 1] = tmp;
        }
      }
      /**
       * emptyBucket empties the count from a bucket, for
       * moving into another.
       */
      emptyBucket(src) {
        let tmp = this._counts[src];
        return this._counts[src] = 0, tmp;
      }
      /**
       * increments a bucket by `increment`
       */
      increment(bucketIndex, increment) {
        this._counts[bucketIndex] += increment;
      }
      /**
       * decrements a bucket by `decrement`
       */
      decrement(bucketIndex, decrement) {
        this._counts[bucketIndex] >= decrement ? this._counts[bucketIndex] -= decrement : this._counts[bucketIndex] = 0;
      }
      /**
       * clone returns a deep copy of BucketsBacking
       */
      clone() {
        return new _BucketsBacking([...this._counts]);
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js
var require_ieee754 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ieee754.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getSignificand = exports2.getNormalBase2 = exports2.MIN_VALUE = exports2.MAX_NORMAL_EXPONENT = exports2.MIN_NORMAL_EXPONENT = exports2.SIGNIFICAND_WIDTH = void 0;
    exports2.SIGNIFICAND_WIDTH = 52;
    var EXPONENT_MASK = 2146435072, SIGNIFICAND_MASK = 1048575, EXPONENT_BIAS = 1023;
    exports2.MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;
    exports2.MAX_NORMAL_EXPONENT = EXPONENT_BIAS;
    exports2.MIN_VALUE = Math.pow(2, -1022);
    function getNormalBase2(value) {
      let dv = new DataView(new ArrayBuffer(8));
      return dv.setFloat64(0, value), ((dv.getUint32(0) & EXPONENT_MASK) >> 20) - EXPONENT_BIAS;
    }
    exports2.getNormalBase2 = getNormalBase2;
    function getSignificand(value) {
      let dv = new DataView(new ArrayBuffer(8));
      dv.setFloat64(0, value);
      let hiBits = dv.getUint32(0), loBits = dv.getUint32(4);
      return (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32) + loBits;
    }
    exports2.getSignificand = getSignificand;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/util.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.nextGreaterSquare = exports2.ldexp = void 0;
    function ldexp(frac, exp) {
      return frac === 0 || frac === Number.POSITIVE_INFINITY || frac === Number.NEGATIVE_INFINITY || Number.isNaN(frac) ? frac : frac * Math.pow(2, exp);
    }
    exports2.ldexp = ldexp;
    function nextGreaterSquare(v) {
      return v--, v |= v >> 1, v |= v >> 2, v |= v >> 4, v |= v >> 8, v |= v >> 16, v++, v;
    }
    exports2.nextGreaterSquare = nextGreaterSquare;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js
var require_types2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/types.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MappingError = void 0;
    var MappingError = class extends Error {
    };
    exports2.MappingError = MappingError;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js
var require_ExponentMapping = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/ExponentMapping.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ExponentMapping = void 0;
    var ieee754 = require_ieee754(), util = require_util(), types_1 = require_types2(), ExponentMapping = class {
      constructor(scale) {
        this._shift = -scale;
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value < ieee754.MIN_VALUE)
          return this._minNormalLowerBoundaryIndex();
        let exp = ieee754.getNormalBase2(value), correction = this._rightShift(ieee754.getSignificand(value) - 1, ieee754.SIGNIFICAND_WIDTH);
        return exp + correction >> this._shift;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        let minIndex = this._minNormalLowerBoundaryIndex();
        if (index < minIndex)
          throw new types_1.MappingError(`underflow: ${index} is < minimum lower boundary: ${minIndex}`);
        let maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index > maxIndex)
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        return util.ldexp(1, index << this._shift);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._shift === 0 ? 0 : -this._shift;
      }
      _minNormalLowerBoundaryIndex() {
        let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;
        return this._shift < 2 && index--, index;
      }
      _maxNormalLowerBoundaryIndex() {
        return ieee754.MAX_NORMAL_EXPONENT >> this._shift;
      }
      _rightShift(value, shift) {
        return Math.floor(value * Math.pow(2, -shift));
      }
    };
    exports2.ExponentMapping = ExponentMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js
var require_LogarithmMapping = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/LogarithmMapping.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.LogarithmMapping = void 0;
    var ieee754 = require_ieee754(), util = require_util(), types_1 = require_types2(), LogarithmMapping = class {
      constructor(scale) {
        this._scale = scale, this._scaleFactor = util.ldexp(Math.LOG2E, scale), this._inverseFactor = util.ldexp(Math.LN2, -scale);
      }
      /**
       * Maps positive floating point values to indexes corresponding to scale
       * @param value
       * @returns {number} index for provided value at the current scale
       */
      mapToIndex(value) {
        if (value <= ieee754.MIN_VALUE)
          return this._minNormalLowerBoundaryIndex() - 1;
        if (ieee754.getSignificand(value) === 0)
          return (ieee754.getNormalBase2(value) << this._scale) - 1;
        let index = Math.floor(Math.log(value) * this._scaleFactor), maxIndex = this._maxNormalLowerBoundaryIndex();
        return index >= maxIndex ? maxIndex : index;
      }
      /**
       * Returns the lower bucket boundary for the given index for scale
       *
       * @param index
       * @returns {number}
       */
      lowerBoundary(index) {
        let maxIndex = this._maxNormalLowerBoundaryIndex();
        if (index >= maxIndex) {
          if (index === maxIndex)
            return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);
          throw new types_1.MappingError(`overflow: ${index} is > maximum lower boundary: ${maxIndex}`);
        }
        let minIndex = this._minNormalLowerBoundaryIndex();
        if (index <= minIndex) {
          if (index === minIndex)
            return ieee754.MIN_VALUE;
          if (index === minIndex - 1)
            return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;
          throw new types_1.MappingError(`overflow: ${index} is < minimum lower boundary: ${minIndex}`);
        }
        return Math.exp(index * this._inverseFactor);
      }
      /**
       * The scale used by this mapping
       * @returns {number}
       */
      get scale() {
        return this._scale;
      }
      _minNormalLowerBoundaryIndex() {
        return ieee754.MIN_NORMAL_EXPONENT << this._scale;
      }
      _maxNormalLowerBoundaryIndex() {
        return (ieee754.MAX_NORMAL_EXPONENT + 1 << this._scale) - 1;
      }
    };
    exports2.LogarithmMapping = LogarithmMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js
var require_getMapping = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/exponential-histogram/mapping/getMapping.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMapping = void 0;
    var ExponentMapping_1 = require_ExponentMapping(), LogarithmMapping_1 = require_LogarithmMapping(), types_1 = require_types2(), MIN_SCALE = -10, MAX_SCALE = 20, PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => i > 10 ? new LogarithmMapping_1.LogarithmMapping(i - 10) : new ExponentMapping_1.ExponentMapping(i - 10));
    function getMapping(scale) {
      if (scale > MAX_SCALE || scale < MIN_SCALE)
        throw new types_1.MappingError(`expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`);
      return PREBUILT_MAPPINGS[scale + 10];
    }
    exports2.getMapping = getMapping;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js
var require_ExponentialHistogram = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/ExponentialHistogram.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ExponentialHistogramAggregator = exports2.ExponentialHistogramAccumulation = void 0;
    var types_1 = require_types(), MetricData_1 = require_MetricData(), api_1 = (init_esm(), __toCommonJS(esm_exports)), InstrumentDescriptor_1 = require_InstrumentDescriptor(), Buckets_1 = require_Buckets(), getMapping_1 = require_getMapping(), util_1 = require_util(), HighLow = class _HighLow {
      constructor(low, high) {
        this.low = low, this.high = high;
      }
      static combine(h1, h2) {
        return new _HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));
      }
    }, MAX_SCALE = 20, DEFAULT_MAX_SIZE = 160, MIN_MAX_SIZE = 2, ExponentialHistogramAccumulation = class _ExponentialHistogramAccumulation {
      constructor(startTime = startTime, _maxSize = DEFAULT_MAX_SIZE, _recordMinMax = !0, _sum = 0, _count = 0, _zeroCount = 0, _min = Number.POSITIVE_INFINITY, _max = Number.NEGATIVE_INFINITY, _positive = new Buckets_1.Buckets(), _negative = new Buckets_1.Buckets(), _mapping = (0, getMapping_1.getMapping)(MAX_SCALE)) {
        this.startTime = startTime, this._maxSize = _maxSize, this._recordMinMax = _recordMinMax, this._sum = _sum, this._count = _count, this._zeroCount = _zeroCount, this._min = _min, this._max = _max, this._positive = _positive, this._negative = _negative, this._mapping = _mapping, this._maxSize < MIN_MAX_SIZE && (api_1.diag.warn(`Exponential Histogram Max Size set to ${this._maxSize},                 changing to the minimum size of: ${MIN_MAX_SIZE}`), this._maxSize = MIN_MAX_SIZE);
      }
      /**
       * record updates a histogram with a single count
       * @param {Number} value
       */
      record(value) {
        this.updateByIncrement(value, 1);
      }
      /**
       * Sets the start time for this accumulation
       * @param {HrTime} startTime
       */
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      /**
       * Returns the datapoint representation of this accumulation
       * @param {HrTime} startTime
       */
      toPointValue() {
        return {
          hasMinMax: this._recordMinMax,
          min: this.min,
          max: this.max,
          sum: this.sum,
          positive: {
            offset: this.positive.offset,
            bucketCounts: this.positive.counts()
          },
          negative: {
            offset: this.negative.offset,
            bucketCounts: this.negative.counts()
          },
          count: this.count,
          scale: this.scale,
          zeroCount: this.zeroCount
        };
      }
      /**
       * @returns {Number} The sum of values recorded by this accumulation
       */
      get sum() {
        return this._sum;
      }
      /**
       * @returns {Number} The minimum value recorded by this accumulation
       */
      get min() {
        return this._min;
      }
      /**
       * @returns {Number} The maximum value recorded by this accumulation
       */
      get max() {
        return this._max;
      }
      /**
       * @returns {Number} The count of values recorded by this accumulation
       */
      get count() {
        return this._count;
      }
      /**
       * @returns {Number} The number of 0 values recorded by this accumulation
       */
      get zeroCount() {
        return this._zeroCount;
      }
      /**
       * @returns {Number} The scale used by this accumulation
       */
      get scale() {
        return this._count === this._zeroCount ? 0 : this._mapping.scale;
      }
      /**
       * positive holds the positive values
       * @returns {Buckets}
       */
      get positive() {
        return this._positive;
      }
      /**
       * negative holds the negative values by their absolute value
       * @returns {Buckets}
       */
      get negative() {
        return this._negative;
      }
      /**
       * updateByIncr supports updating a histogram with a non-negative
       * increment.
       * @param value
       * @param increment
       */
      updateByIncrement(value, increment) {
        if (!Number.isNaN(value)) {
          if (value > this._max && (this._max = value), value < this._min && (this._min = value), this._count += increment, value === 0) {
            this._zeroCount += increment;
            return;
          }
          this._sum += value * increment, value > 0 ? this._updateBuckets(this._positive, value, increment) : this._updateBuckets(this._negative, -value, increment);
        }
      }
      /**
       * merge combines data from previous value into self
       * @param {ExponentialHistogramAccumulation} previous
       */
      merge(previous) {
        this._count === 0 ? (this._min = previous.min, this._max = previous.max) : previous.count !== 0 && (previous.min < this.min && (this._min = previous.min), previous.max > this.max && (this._max = previous.max)), this.startTime = previous.startTime, this._sum += previous.sum, this._count += previous.count, this._zeroCount += previous.zeroCount;
        let minScale = this._minScale(previous);
        this._downscale(this.scale - minScale), this._mergeBuckets(this.positive, previous, previous.positive, minScale), this._mergeBuckets(this.negative, previous, previous.negative, minScale);
      }
      /**
       * diff subtracts other from self
       * @param {ExponentialHistogramAccumulation} other
       */
      diff(other) {
        this._min = 1 / 0, this._max = -1 / 0, this._sum -= other.sum, this._count -= other.count, this._zeroCount -= other.zeroCount;
        let minScale = this._minScale(other);
        this._downscale(this.scale - minScale), this._diffBuckets(this.positive, other, other.positive, minScale), this._diffBuckets(this.negative, other, other.negative, minScale);
      }
      /**
       * clone returns a deep copy of self
       * @returns {ExponentialHistogramAccumulation}
       */
      clone() {
        return new _ExponentialHistogramAccumulation(this.startTime, this._maxSize, this._recordMinMax, this._sum, this._count, this._zeroCount, this._min, this._max, this.positive.clone(), this.negative.clone(), this._mapping);
      }
      /**
       * _updateBuckets maps the incoming value to a bucket index for the current
       * scale. If the bucket index is outside of the range of the backing array,
       * it will rescale the backing array and update the mapping for the new scale.
       */
      _updateBuckets(buckets, value, increment) {
        let index = this._mapping.mapToIndex(value), rescalingNeeded = !1, high = 0, low = 0;
        if (buckets.length === 0 ? (buckets.indexStart = index, buckets.indexEnd = buckets.indexStart, buckets.indexBase = buckets.indexStart) : index < buckets.indexStart && buckets.indexEnd - index >= this._maxSize ? (rescalingNeeded = !0, low = index, high = buckets.indexEnd) : index > buckets.indexEnd && index - buckets.indexStart >= this._maxSize && (rescalingNeeded = !0, low = buckets.indexStart, high = index), rescalingNeeded) {
          let change = this._changeScale(high, low);
          this._downscale(change), index = this._mapping.mapToIndex(value);
        }
        this._incrementIndexBy(buckets, index, increment);
      }
      /**
       * _incrementIndexBy increments the count of the bucket specified by `index`.
       * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]
       * the boundaries of the backing array will be adjusted and more buckets will
       * be added if needed.
       */
      _incrementIndexBy(buckets, index, increment) {
        if (increment === 0)
          return;
        if (buckets.length === 0 && (buckets.indexStart = buckets.indexEnd = buckets.indexBase = index), index < buckets.indexStart) {
          let span = buckets.indexEnd - index;
          span >= buckets.backing.length && this._grow(buckets, span + 1), buckets.indexStart = index;
        } else if (index > buckets.indexEnd) {
          let span = index - buckets.indexStart;
          span >= buckets.backing.length && this._grow(buckets, span + 1), buckets.indexEnd = index;
        }
        let bucketIndex = index - buckets.indexBase;
        bucketIndex < 0 && (bucketIndex += buckets.backing.length), buckets.incrementBucket(bucketIndex, increment);
      }
      /**
       * grow resizes the backing array by doubling in size up to maxSize.
       * This extends the array with a bunch of zeros and copies the
       * existing counts to the same position.
       */
      _grow(buckets, needed) {
        let size = buckets.backing.length, bias = buckets.indexBase - buckets.indexStart, oldPositiveLimit = size - bias, newSize = (0, util_1.nextGreaterSquare)(needed);
        newSize > this._maxSize && (newSize = this._maxSize);
        let newPositiveLimit = newSize - bias;
        buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);
      }
      /**
       * _changeScale computes how much downscaling is needed by shifting the
       * high and low values until they are separated by no more than size.
       */
      _changeScale(high, low) {
        let change = 0;
        for (; high - low >= this._maxSize; )
          high >>= 1, low >>= 1, change++;
        return change;
      }
      /**
       * _downscale subtracts `change` from the current mapping scale.
       */
      _downscale(change) {
        if (change === 0)
          return;
        if (change < 0)
          throw new Error(`impossible change of scale: ${this.scale}`);
        let newScale = this._mapping.scale - change;
        this._positive.downscale(change), this._negative.downscale(change), this._mapping = (0, getMapping_1.getMapping)(newScale);
      }
      /**
       * _minScale is used by diff and merge to compute an ideal combined scale
       */
      _minScale(other) {
        let minScale = Math.min(this.scale, other.scale), highLowPos = HighLow.combine(this._highLowAtScale(this.positive, this.scale, minScale), this._highLowAtScale(other.positive, other.scale, minScale)), highLowNeg = HighLow.combine(this._highLowAtScale(this.negative, this.scale, minScale), this._highLowAtScale(other.negative, other.scale, minScale));
        return Math.min(minScale - this._changeScale(highLowPos.high, highLowPos.low), minScale - this._changeScale(highLowNeg.high, highLowNeg.low));
      }
      /**
       * _highLowAtScale is used by diff and merge to compute an ideal combined scale.
       */
      _highLowAtScale(buckets, currentScale, newScale) {
        if (buckets.length === 0)
          return new HighLow(0, -1);
        let shift = currentScale - newScale;
        return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);
      }
      /**
       * _mergeBuckets translates index values from another histogram and
       * adds the values into the corresponding buckets of this histogram.
       */
      _mergeBuckets(ours, other, theirs, scale) {
        let theirOffset = theirs.offset, theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++)
          this._incrementIndexBy(ours, theirOffset + i >> theirChange, theirs.at(i));
      }
      /**
       * _diffBuckets translates index values from another histogram and
       * subtracts the values in the corresponding buckets of this histogram.
       */
      _diffBuckets(ours, other, theirs, scale) {
        let theirOffset = theirs.offset, theirChange = other.scale - scale;
        for (let i = 0; i < theirs.length; i++) {
          let bucketIndex = (theirOffset + i >> theirChange) - ours.indexBase;
          bucketIndex < 0 && (bucketIndex += ours.backing.length), ours.decrementBucket(bucketIndex, theirs.at(i));
        }
        ours.trim();
      }
    };
    exports2.ExponentialHistogramAccumulation = ExponentialHistogramAccumulation;
    var ExponentialHistogramAggregator = class {
      /**
       * @param _maxSize Maximum number of buckets for each of the positive
       *    and negative ranges, exclusive of the zero-bucket.
       * @param _recordMinMax If set to true, min and max will be recorded.
       *    Otherwise, min and max will not be recorded.
       */
      constructor(_maxSize, _recordMinMax) {
        this._maxSize = _maxSize, this._recordMinMax = _recordMinMax, this.kind = types_1.AggregatorKind.EXPONENTIAL_HISTOGRAM;
      }
      createAccumulation(startTime) {
        return new ExponentialHistogramAccumulation(startTime, this._maxSize, this._recordMinMax);
      }
      /**
       * Return the result of the merge of two exponential histogram accumulations.
       */
      merge(previous, delta) {
        let result = delta.clone();
        return result.merge(previous), result;
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let result = current.clone();
        return result.diff(previous), result;
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.EXPONENTIAL_HISTOGRAM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {
            let pointValue = accumulation.toPointValue(), allowsNegativeValues = descriptor.type === InstrumentDescriptor_1.InstrumentType.GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE || descriptor.type === InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;
            return {
              attributes,
              startTime: accumulation.startTime,
              endTime,
              value: {
                min: pointValue.hasMinMax ? pointValue.min : void 0,
                max: pointValue.hasMinMax ? pointValue.max : void 0,
                sum: allowsNegativeValues ? void 0 : pointValue.sum,
                positive: {
                  offset: pointValue.positive.offset,
                  bucketCounts: pointValue.positive.bucketCounts
                },
                negative: {
                  offset: pointValue.negative.offset,
                  bucketCounts: pointValue.negative.bucketCounts
                },
                count: pointValue.count,
                scale: pointValue.scale,
                zeroCount: pointValue.zeroCount
              }
            };
          })
        };
      }
    };
    exports2.ExponentialHistogramAggregator = ExponentialHistogramAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isTracingSuppressed = exports2.unsuppressTracing = exports2.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context2) {
      return context2.setValue(SUPPRESS_TRACING_KEY, !0);
    }
    exports2.suppressTracing = suppressTracing;
    function unsuppressTracing(context2) {
      return context2.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports2.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context2) {
      return context2.getValue(SUPPRESS_TRACING_KEY) === !0;
    }
    exports2.isTracingSuppressed = isTracingSuppressed;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports2.BAGGAGE_HEADER = exports2.BAGGAGE_ITEMS_SEPARATOR = exports2.BAGGAGE_PROPERTIES_SEPARATOR = exports2.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports2.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports2.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports2.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports2.BAGGAGE_HEADER = "baggage";
    exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.parseKeyPairsIntoRecord = exports2.parsePairKeyValue = exports2.getKeyPairs = exports2.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), constants_1 = require_constants();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        let value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports2.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        return value.metadata !== void 0 && (entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString()), entry;
      });
    }
    exports2.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      let valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      let keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      let separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      let key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim()), value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim()), metadata;
      return valueProps.length > 0 && (metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR))), { key, value, metadata };
    }
    exports2.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      return typeof value != "string" || value.length === 0 ? {} : value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => parsePairKeyValue(entry)).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => (headers[keyPair.key] = keyPair.value, headers), {});
    }
    exports2.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), suppress_tracing_1 = require_suppress_tracing(), constants_1 = require_constants(), utils_1 = require_utils2(), W3CBaggagePropagator = class {
      inject(context2, carrier, setter) {
        let baggage = api_1.propagation.getBaggage(context2);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context2))
          return;
        let keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS), headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        headerValue.length > 0 && setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
      }
      extract(context2, carrier, getter) {
        let headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER), baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context2;
        let baggage = {};
        return baggageString.length === 0 || (baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
          let keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            let baggageEntry = { value: keyPair.value };
            keyPair.metadata && (baggageEntry.metadata = keyPair.metadata), baggage[keyPair.key] = baggageEntry;
          }
        }), Object.entries(baggage).length === 0) ? context2 : api_1.propagation.setBaggage(context2, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports2.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock, this._epochMillis = systemClock.now(), this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        let delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports2.AnchoredClock = AnchoredClock;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isAttributeValue = exports2.isAttributeKey = exports2.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      let out = {};
      if (typeof attributes != "object" || attributes == null)
        return out;
      for (let [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        Array.isArray(val) ? out[key] = val.slice() : out[key] = val;
      }
      return out;
    }
    exports2.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key == "string" && key.length > 0;
    }
    exports2.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      return val == null ? !0 : Array.isArray(val) ? isHomogeneousAttributeValueArray(val) : isValidPrimitiveAttributeValue(val);
    }
    exports2.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (let element of arr)
        if (element != null) {
          if (!type) {
            if (isValidPrimitiveAttributeValue(element)) {
              type = typeof element;
              continue;
            }
            return !1;
          }
          if (typeof element !== type)
            return !1;
        }
      return !0;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return !0;
      }
      return !1;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports2.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      return typeof ex == "string" ? ex : JSON.stringify(flattenException(ex));
    }
    function flattenException(ex) {
      let result = {}, current = ex;
      for (; current !== null; )
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          let value = current[propertyName];
          value && (result[propertyName] = String(value));
        }), current = Object.getPrototypeOf(current);
      return result;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.globalErrorHandler = exports2.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler(), delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports2.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch {
      }
    }
    exports2.globalErrorHandler = globalErrorHandler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2.AlwaysOff = "always_off", TracesSamplerValues2.AlwaysOn = "always_on", TracesSamplerValues2.ParentBasedAlwaysOff = "parentbased_always_off", TracesSamplerValues2.ParentBasedAlwaysOn = "parentbased_always_on", TracesSamplerValues2.ParentBasedTraceIdRatio = "parentbased_traceidratio", TracesSamplerValues2.TraceIdRatio = "traceidratio";
    })(TracesSamplerValues = exports2.TracesSamplerValues || (exports2.TracesSamplerValues = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.parseEnvironment = exports2.DEFAULT_ENVIRONMENT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), sampling_1 = require_sampling(), DEFAULT_LIST_SEPARATOR = ",", ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS",
      "OTEL_SEMCONV_STABILITY_OPT_IN"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1 / 0;
    exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports2.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: !1,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
      OTEL_SEMCONV_STABILITY_OPT_IN: []
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] > "u")
        return;
      let value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment, values, min = -1 / 0, max = 1 / 0) {
      if (typeof values[name] < "u") {
        let value = Number(values[name]);
        isNaN(value) || (value < min ? environment[name] = min : value > max ? environment[name] = max : environment[name] = value);
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      let givenValue = input[name];
      typeof givenValue == "string" && (output[name] = givenValue.split(separator).map((v) => v.trim()));
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      let value = values[key];
      if (typeof value == "string") {
        let theLevel = logLevelMap[value.toUpperCase()];
        theLevel != null && (environment[key] = theLevel);
      }
    }
    function parseEnvironment(values) {
      let environment = {};
      for (let env in exports2.DEFAULT_ENVIRONMENT) {
        let key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key))
              parseBoolean(key, environment, values);
            else if (isEnvVarANumber(key))
              parseNumber(key, environment, values);
            else if (isEnvVarAList(key))
              parseStringList(key, environment, values);
            else {
              let value = values[key];
              typeof value < "u" && value !== null && (environment[key] = String(value));
            }
        }
      }
      return environment;
    }
    exports2.parseEnvironment = parseEnvironment;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getEnvWithoutDefaults = exports2.getEnv = void 0;
    var environment_1 = require_environment();
    function getEnv() {
      let processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports2.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports2.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis == "object" ? globalThis : global;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.hexToBinary = void 0;
    function intValue(charCode) {
      return charCode >= 48 && charCode <= 57 ? charCode - 48 : charCode >= 97 && charCode <= 102 ? charCode - 87 : charCode - 55;
    }
    function hexToBinary(hexStr) {
      let buf = new Uint8Array(hexStr.length / 2), offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        let hi = intValue(hexStr.charCodeAt(i)), lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports2.hexToBinary = hexToBinary;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports2.hexToBase64 = hexToBase64;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8, TRACE_ID_BYTES = 16, RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES), this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function() {
        for (let i = 0; i < bytes / 4; i++)
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        for (let i = 0; i < bytes && !(SHARED_BUFFER[i] > 0); i++)
          i === bytes - 1 && (SHARED_BUFFER[bytes - 1] = 1);
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports2.otperformance = perf_hooks_1.performance;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/version.js
var require_version = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/version.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.30.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap(values) {
  for (var res = {}, len = values.length, lp = 0; lp < len; lp++) {
    var val = values[lp];
    val && (res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val);
  }
  return res;
}
var init_utils3 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
    init_cjs_shims();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN, TMP_DB_SYSTEM, TMP_DB_CONNECTION_STRING, TMP_DB_USER, TMP_DB_JDBC_DRIVER_CLASSNAME, TMP_DB_NAME, TMP_DB_STATEMENT, TMP_DB_OPERATION, TMP_DB_MSSQL_INSTANCE_NAME, TMP_DB_CASSANDRA_KEYSPACE, TMP_DB_CASSANDRA_PAGE_SIZE, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, TMP_DB_CASSANDRA_TABLE, TMP_DB_CASSANDRA_IDEMPOTENCE, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, TMP_DB_CASSANDRA_COORDINATOR_ID, TMP_DB_CASSANDRA_COORDINATOR_DC, TMP_DB_HBASE_NAMESPACE, TMP_DB_REDIS_DATABASE_INDEX, TMP_DB_MONGODB_COLLECTION, TMP_DB_SQL_TABLE, TMP_EXCEPTION_TYPE, TMP_EXCEPTION_MESSAGE, TMP_EXCEPTION_STACKTRACE, TMP_EXCEPTION_ESCAPED, TMP_FAAS_TRIGGER, TMP_FAAS_EXECUTION, TMP_FAAS_DOCUMENT_COLLECTION, TMP_FAAS_DOCUMENT_OPERATION, TMP_FAAS_DOCUMENT_TIME, TMP_FAAS_DOCUMENT_NAME, TMP_FAAS_TIME, TMP_FAAS_CRON, TMP_FAAS_COLDSTART, TMP_FAAS_INVOKED_NAME, TMP_FAAS_INVOKED_PROVIDER, TMP_FAAS_INVOKED_REGION, TMP_NET_TRANSPORT, TMP_NET_PEER_IP, TMP_NET_PEER_PORT, TMP_NET_PEER_NAME, TMP_NET_HOST_IP, TMP_NET_HOST_PORT, TMP_NET_HOST_NAME, TMP_NET_HOST_CONNECTION_TYPE, TMP_NET_HOST_CONNECTION_SUBTYPE, TMP_NET_HOST_CARRIER_NAME, TMP_NET_HOST_CARRIER_MCC, TMP_NET_HOST_CARRIER_MNC, TMP_NET_HOST_CARRIER_ICC, TMP_PEER_SERVICE, TMP_ENDUSER_ID, TMP_ENDUSER_ROLE, TMP_ENDUSER_SCOPE, TMP_THREAD_ID, TMP_THREAD_NAME, TMP_CODE_FUNCTION, TMP_CODE_NAMESPACE, TMP_CODE_FILEPATH, TMP_CODE_LINENO, TMP_HTTP_METHOD, TMP_HTTP_URL, TMP_HTTP_TARGET, TMP_HTTP_HOST, TMP_HTTP_SCHEME, TMP_HTTP_STATUS_CODE, TMP_HTTP_FLAVOR, TMP_HTTP_USER_AGENT, TMP_HTTP_REQUEST_CONTENT_LENGTH, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_RESPONSE_CONTENT_LENGTH, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_SERVER_NAME, TMP_HTTP_ROUTE, TMP_HTTP_CLIENT_IP, TMP_AWS_DYNAMODB_TABLE_NAMES, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, TMP_AWS_DYNAMODB_CONSISTENT_READ, TMP_AWS_DYNAMODB_PROJECTION, TMP_AWS_DYNAMODB_LIMIT, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, TMP_AWS_DYNAMODB_INDEX_NAME, TMP_AWS_DYNAMODB_SELECT, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, TMP_AWS_DYNAMODB_TABLE_COUNT, TMP_AWS_DYNAMODB_SCAN_FORWARD, TMP_AWS_DYNAMODB_SEGMENT, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, TMP_AWS_DYNAMODB_COUNT, TMP_AWS_DYNAMODB_SCANNED_COUNT, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, TMP_MESSAGING_SYSTEM, TMP_MESSAGING_DESTINATION, TMP_MESSAGING_DESTINATION_KIND, TMP_MESSAGING_TEMP_DESTINATION, TMP_MESSAGING_PROTOCOL, TMP_MESSAGING_PROTOCOL_VERSION, TMP_MESSAGING_URL, TMP_MESSAGING_MESSAGE_ID, TMP_MESSAGING_CONVERSATION_ID, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, TMP_MESSAGING_OPERATION, TMP_MESSAGING_CONSUMER_ID, TMP_MESSAGING_RABBITMQ_ROUTING_KEY, TMP_MESSAGING_KAFKA_MESSAGE_KEY, TMP_MESSAGING_KAFKA_CONSUMER_GROUP, TMP_MESSAGING_KAFKA_CLIENT_ID, TMP_MESSAGING_KAFKA_PARTITION, TMP_MESSAGING_KAFKA_TOMBSTONE, TMP_RPC_SYSTEM, TMP_RPC_SERVICE, TMP_RPC_METHOD, TMP_RPC_GRPC_STATUS_CODE, TMP_RPC_JSONRPC_VERSION, TMP_RPC_JSONRPC_REQUEST_ID, TMP_RPC_JSONRPC_ERROR_CODE, TMP_RPC_JSONRPC_ERROR_MESSAGE, TMP_MESSAGE_TYPE, TMP_MESSAGE_ID, TMP_MESSAGE_COMPRESSED_SIZE, TMP_MESSAGE_UNCOMPRESSED_SIZE, SEMATTRS_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING, SEMATTRS_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME, SEMATTRS_DB_STATEMENT, SEMATTRS_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME, SEMATTRS_FAAS_CRON, SEMATTRS_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT, SEMATTRS_NET_PEER_IP, SEMATTRS_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME, SEMATTRS_NET_HOST_IP, SEMATTRS_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE, SEMATTRS_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE, SEMATTRS_THREAD_ID, SEMATTRS_THREAD_NAME, SEMATTRS_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH, SEMATTRS_CODE_LINENO, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM, SEMATTRS_RPC_SERVICE, SEMATTRS_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes, TMP_DBSYSTEMVALUES_OTHER_SQL, TMP_DBSYSTEMVALUES_MSSQL, TMP_DBSYSTEMVALUES_MYSQL, TMP_DBSYSTEMVALUES_ORACLE, TMP_DBSYSTEMVALUES_DB2, TMP_DBSYSTEMVALUES_POSTGRESQL, TMP_DBSYSTEMVALUES_REDSHIFT, TMP_DBSYSTEMVALUES_HIVE, TMP_DBSYSTEMVALUES_CLOUDSCAPE, TMP_DBSYSTEMVALUES_HSQLDB, TMP_DBSYSTEMVALUES_PROGRESS, TMP_DBSYSTEMVALUES_MAXDB, TMP_DBSYSTEMVALUES_HANADB, TMP_DBSYSTEMVALUES_INGRES, TMP_DBSYSTEMVALUES_FIRSTSQL, TMP_DBSYSTEMVALUES_EDB, TMP_DBSYSTEMVALUES_CACHE, TMP_DBSYSTEMVALUES_ADABAS, TMP_DBSYSTEMVALUES_FIREBIRD, TMP_DBSYSTEMVALUES_DERBY, TMP_DBSYSTEMVALUES_FILEMAKER, TMP_DBSYSTEMVALUES_INFORMIX, TMP_DBSYSTEMVALUES_INSTANTDB, TMP_DBSYSTEMVALUES_INTERBASE, TMP_DBSYSTEMVALUES_MARIADB, TMP_DBSYSTEMVALUES_NETEZZA, TMP_DBSYSTEMVALUES_PERVASIVE, TMP_DBSYSTEMVALUES_POINTBASE, TMP_DBSYSTEMVALUES_SQLITE, TMP_DBSYSTEMVALUES_SYBASE, TMP_DBSYSTEMVALUES_TERADATA, TMP_DBSYSTEMVALUES_VERTICA, TMP_DBSYSTEMVALUES_H2, TMP_DBSYSTEMVALUES_COLDFUSION, TMP_DBSYSTEMVALUES_CASSANDRA, TMP_DBSYSTEMVALUES_HBASE, TMP_DBSYSTEMVALUES_MONGODB, TMP_DBSYSTEMVALUES_REDIS, TMP_DBSYSTEMVALUES_COUCHBASE, TMP_DBSYSTEMVALUES_COUCHDB, TMP_DBSYSTEMVALUES_COSMOSDB, TMP_DBSYSTEMVALUES_DYNAMODB, TMP_DBSYSTEMVALUES_NEO4J, TMP_DBSYSTEMVALUES_GEODE, TMP_DBSYSTEMVALUES_ELASTICSEARCH, TMP_DBSYSTEMVALUES_MEMCACHED, TMP_DBSYSTEMVALUES_COCKROACHDB, DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB, DbSystemValues, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues, TMP_FAASTRIGGERVALUES_DATASOURCE, TMP_FAASTRIGGERVALUES_HTTP, TMP_FAASTRIGGERVALUES_PUBSUB, TMP_FAASTRIGGERVALUES_TIMER, TMP_FAASTRIGGERVALUES_OTHER, FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER, FaasTriggerValues, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, TMP_FAASINVOKEDPROVIDERVALUES_AWS, TMP_FAASINVOKEDPROVIDERVALUES_AZURE, TMP_FAASINVOKEDPROVIDERVALUES_GCP, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues, TMP_NETTRANSPORTVALUES_IP_TCP, TMP_NETTRANSPORTVALUES_IP_UDP, TMP_NETTRANSPORTVALUES_IP, TMP_NETTRANSPORTVALUES_UNIX, TMP_NETTRANSPORTVALUES_PIPE, TMP_NETTRANSPORTVALUES_INPROC, TMP_NETTRANSPORTVALUES_OTHER, NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER, NetTransportValues, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues, TMP_HTTPFLAVORVALUES_HTTP_1_0, TMP_HTTPFLAVORVALUES_HTTP_1_1, TMP_HTTPFLAVORVALUES_HTTP_2_0, TMP_HTTPFLAVORVALUES_SPDY, TMP_HTTPFLAVORVALUES_QUIC, HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC, HttpFlavorValues, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues, TMP_MESSAGINGOPERATIONVALUES_RECEIVE, TMP_MESSAGINGOPERATIONVALUES_PROCESS, MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues, TMP_RPCGRPCSTATUSCODEVALUES_OK, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues, TMP_MESSAGETYPEVALUES_SENT, TMP_MESSAGETYPEVALUES_RECEIVED, MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED, MessageTypeValues, init_SemanticAttributes = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_cjs_shims();
    init_utils3();
    TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn", TMP_DB_SYSTEM = "db.system", TMP_DB_CONNECTION_STRING = "db.connection_string", TMP_DB_USER = "db.user", TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname", TMP_DB_NAME = "db.name", TMP_DB_STATEMENT = "db.statement", TMP_DB_OPERATION = "db.operation", TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name", TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace", TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size", TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level", TMP_DB_CASSANDRA_TABLE = "db.cassandra.table", TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence", TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count", TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id", TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc", TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace", TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index", TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection", TMP_DB_SQL_TABLE = "db.sql.table", TMP_EXCEPTION_TYPE = "exception.type", TMP_EXCEPTION_MESSAGE = "exception.message", TMP_EXCEPTION_STACKTRACE = "exception.stacktrace", TMP_EXCEPTION_ESCAPED = "exception.escaped", TMP_FAAS_TRIGGER = "faas.trigger", TMP_FAAS_EXECUTION = "faas.execution", TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection", TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation", TMP_FAAS_DOCUMENT_TIME = "faas.document.time", TMP_FAAS_DOCUMENT_NAME = "faas.document.name", TMP_FAAS_TIME = "faas.time", TMP_FAAS_CRON = "faas.cron", TMP_FAAS_COLDSTART = "faas.coldstart", TMP_FAAS_INVOKED_NAME = "faas.invoked_name", TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider", TMP_FAAS_INVOKED_REGION = "faas.invoked_region", TMP_NET_TRANSPORT = "net.transport", TMP_NET_PEER_IP = "net.peer.ip", TMP_NET_PEER_PORT = "net.peer.port", TMP_NET_PEER_NAME = "net.peer.name", TMP_NET_HOST_IP = "net.host.ip", TMP_NET_HOST_PORT = "net.host.port", TMP_NET_HOST_NAME = "net.host.name", TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type", TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype", TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name", TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc", TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc", TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc", TMP_PEER_SERVICE = "peer.service", TMP_ENDUSER_ID = "enduser.id", TMP_ENDUSER_ROLE = "enduser.role", TMP_ENDUSER_SCOPE = "enduser.scope", TMP_THREAD_ID = "thread.id", TMP_THREAD_NAME = "thread.name", TMP_CODE_FUNCTION = "code.function", TMP_CODE_NAMESPACE = "code.namespace", TMP_CODE_FILEPATH = "code.filepath", TMP_CODE_LINENO = "code.lineno", TMP_HTTP_METHOD = "http.method", TMP_HTTP_URL = "http.url", TMP_HTTP_TARGET = "http.target", TMP_HTTP_HOST = "http.host", TMP_HTTP_SCHEME = "http.scheme", TMP_HTTP_STATUS_CODE = "http.status_code", TMP_HTTP_FLAVOR = "http.flavor", TMP_HTTP_USER_AGENT = "http.user_agent", TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length", TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed", TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length", TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed", TMP_HTTP_SERVER_NAME = "http.server_name", TMP_HTTP_ROUTE = "http.route", TMP_HTTP_CLIENT_IP = "http.client_ip", TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names", TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity", TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics", TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity", TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity", TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read", TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection", TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit", TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get", TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name", TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select", TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes", TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes", TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table", TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count", TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward", TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment", TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments", TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count", TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count", TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions", TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates", TMP_MESSAGING_SYSTEM = "messaging.system", TMP_MESSAGING_DESTINATION = "messaging.destination", TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind", TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination", TMP_MESSAGING_PROTOCOL = "messaging.protocol", TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version", TMP_MESSAGING_URL = "messaging.url", TMP_MESSAGING_MESSAGE_ID = "messaging.message_id", TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id", TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes", TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes", TMP_MESSAGING_OPERATION = "messaging.operation", TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id", TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key", TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key", TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group", TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id", TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition", TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone", TMP_RPC_SYSTEM = "rpc.system", TMP_RPC_SERVICE = "rpc.service", TMP_RPC_METHOD = "rpc.method", TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code", TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version", TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id", TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code", TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message", TMP_MESSAGE_TYPE = "message.type", TMP_MESSAGE_ID = "message.id", TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size", TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size", SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING, SEMATTRS_DB_USER = TMP_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME = TMP_DB_NAME, SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT, SEMATTRS_DB_OPERATION = TMP_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME = TMP_FAAS_TIME, SEMATTRS_FAAS_CRON = TMP_FAAS_CRON, SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT, SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP, SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME, SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP, SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE, SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE, SEMATTRS_THREAD_ID = TMP_THREAD_ID, SEMATTRS_THREAD_NAME = TMP_THREAD_NAME, SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH, SEMATTRS_CODE_LINENO = TMP_CODE_LINENO, SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD, SEMATTRS_HTTP_URL = TMP_HTTP_URL, SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET, SEMATTRS_HTTP_HOST = TMP_HTTP_HOST, SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM, SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE, SEMATTRS_RPC_METHOD = TMP_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes = /* @__PURE__ */ createConstMap([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]), TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql", TMP_DBSYSTEMVALUES_MSSQL = "mssql", TMP_DBSYSTEMVALUES_MYSQL = "mysql", TMP_DBSYSTEMVALUES_ORACLE = "oracle", TMP_DBSYSTEMVALUES_DB2 = "db2", TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql", TMP_DBSYSTEMVALUES_REDSHIFT = "redshift", TMP_DBSYSTEMVALUES_HIVE = "hive", TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape", TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb", TMP_DBSYSTEMVALUES_PROGRESS = "progress", TMP_DBSYSTEMVALUES_MAXDB = "maxdb", TMP_DBSYSTEMVALUES_HANADB = "hanadb", TMP_DBSYSTEMVALUES_INGRES = "ingres", TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql", TMP_DBSYSTEMVALUES_EDB = "edb", TMP_DBSYSTEMVALUES_CACHE = "cache", TMP_DBSYSTEMVALUES_ADABAS = "adabas", TMP_DBSYSTEMVALUES_FIREBIRD = "firebird", TMP_DBSYSTEMVALUES_DERBY = "derby", TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker", TMP_DBSYSTEMVALUES_INFORMIX = "informix", TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb", TMP_DBSYSTEMVALUES_INTERBASE = "interbase", TMP_DBSYSTEMVALUES_MARIADB = "mariadb", TMP_DBSYSTEMVALUES_NETEZZA = "netezza", TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive", TMP_DBSYSTEMVALUES_POINTBASE = "pointbase", TMP_DBSYSTEMVALUES_SQLITE = "sqlite", TMP_DBSYSTEMVALUES_SYBASE = "sybase", TMP_DBSYSTEMVALUES_TERADATA = "teradata", TMP_DBSYSTEMVALUES_VERTICA = "vertica", TMP_DBSYSTEMVALUES_H2 = "h2", TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion", TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra", TMP_DBSYSTEMVALUES_HBASE = "hbase", TMP_DBSYSTEMVALUES_MONGODB = "mongodb", TMP_DBSYSTEMVALUES_REDIS = "redis", TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase", TMP_DBSYSTEMVALUES_COUCHDB = "couchdb", TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb", TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb", TMP_DBSYSTEMVALUES_NEO4J = "neo4j", TMP_DBSYSTEMVALUES_GEODE = "geode", TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch", TMP_DBSYSTEMVALUES_MEMCACHED = "memcached", TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb", DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB, DbSystemValues = /* @__PURE__ */ createConstMap([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]), TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial", TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial", DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues = /* @__PURE__ */ createConstMap([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]), TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource", TMP_FAASTRIGGERVALUES_HTTP = "http", TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub", TMP_FAASTRIGGERVALUES_TIMER = "timer", TMP_FAASTRIGGERVALUES_OTHER = "other", FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER, FaasTriggerValues = /* @__PURE__ */ createConstMap([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]), TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert", TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit", TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete", FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues = /* @__PURE__ */ createConstMap([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]), TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud", TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws", TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure", TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp", FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues = /* @__PURE__ */ createConstMap([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]), TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp", TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp", TMP_NETTRANSPORTVALUES_IP = "ip", TMP_NETTRANSPORTVALUES_UNIX = "unix", TMP_NETTRANSPORTVALUES_PIPE = "pipe", TMP_NETTRANSPORTVALUES_INPROC = "inproc", TMP_NETTRANSPORTVALUES_OTHER = "other", NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER, NetTransportValues = /* @__PURE__ */ createConstMap([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]), TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi", TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired", TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell", TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable", TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown", NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]), TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa", TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca", NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]), TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0", TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1", TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0", TMP_HTTPFLAVORVALUES_SPDY = "SPDY", TMP_HTTPFLAVORVALUES_QUIC = "QUIC", HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC, HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    }, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue", TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic", MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]), TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive", TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process", MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]), TMP_RPCGRPCSTATUSCODEVALUES_OK = 0, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16, RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    }, TMP_MESSAGETYPEVALUES_SENT = "SENT", TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED", MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED, MessageTypeValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_cjs_shims();
    init_SemanticAttributes();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER, TMP_CLOUD_ACCOUNT_ID, TMP_CLOUD_REGION, TMP_CLOUD_AVAILABILITY_ZONE, TMP_CLOUD_PLATFORM, TMP_AWS_ECS_CONTAINER_ARN, TMP_AWS_ECS_CLUSTER_ARN, TMP_AWS_ECS_LAUNCHTYPE, TMP_AWS_ECS_TASK_ARN, TMP_AWS_ECS_TASK_FAMILY, TMP_AWS_ECS_TASK_REVISION, TMP_AWS_EKS_CLUSTER_ARN, TMP_AWS_LOG_GROUP_NAMES, TMP_AWS_LOG_GROUP_ARNS, TMP_AWS_LOG_STREAM_NAMES, TMP_AWS_LOG_STREAM_ARNS, TMP_CONTAINER_NAME, TMP_CONTAINER_ID, TMP_CONTAINER_RUNTIME, TMP_CONTAINER_IMAGE_NAME, TMP_CONTAINER_IMAGE_TAG, TMP_DEPLOYMENT_ENVIRONMENT, TMP_DEVICE_ID, TMP_DEVICE_MODEL_IDENTIFIER, TMP_DEVICE_MODEL_NAME, TMP_FAAS_NAME, TMP_FAAS_ID, TMP_FAAS_VERSION, TMP_FAAS_INSTANCE, TMP_FAAS_MAX_MEMORY, TMP_HOST_ID, TMP_HOST_NAME, TMP_HOST_TYPE, TMP_HOST_ARCH, TMP_HOST_IMAGE_NAME, TMP_HOST_IMAGE_ID, TMP_HOST_IMAGE_VERSION, TMP_K8S_CLUSTER_NAME, TMP_K8S_NODE_NAME, TMP_K8S_NODE_UID, TMP_K8S_NAMESPACE_NAME, TMP_K8S_POD_UID, TMP_K8S_POD_NAME, TMP_K8S_CONTAINER_NAME, TMP_K8S_REPLICASET_UID, TMP_K8S_REPLICASET_NAME, TMP_K8S_DEPLOYMENT_UID, TMP_K8S_DEPLOYMENT_NAME, TMP_K8S_STATEFULSET_UID, TMP_K8S_STATEFULSET_NAME, TMP_K8S_DAEMONSET_UID, TMP_K8S_DAEMONSET_NAME, TMP_K8S_JOB_UID, TMP_K8S_JOB_NAME, TMP_K8S_CRONJOB_UID, TMP_K8S_CRONJOB_NAME, TMP_OS_TYPE, TMP_OS_DESCRIPTION, TMP_OS_NAME, TMP_OS_VERSION, TMP_PROCESS_PID, TMP_PROCESS_EXECUTABLE_NAME, TMP_PROCESS_EXECUTABLE_PATH, TMP_PROCESS_COMMAND, TMP_PROCESS_COMMAND_LINE, TMP_PROCESS_COMMAND_ARGS, TMP_PROCESS_OWNER, TMP_PROCESS_RUNTIME_NAME, TMP_PROCESS_RUNTIME_VERSION, TMP_PROCESS_RUNTIME_DESCRIPTION, TMP_SERVICE_NAME, TMP_SERVICE_NAMESPACE, TMP_SERVICE_INSTANCE_ID, TMP_SERVICE_VERSION, TMP_TELEMETRY_SDK_NAME, TMP_TELEMETRY_SDK_LANGUAGE, TMP_TELEMETRY_SDK_VERSION, TMP_TELEMETRY_AUTO_VERSION, TMP_WEBENGINE_NAME, TMP_WEBENGINE_VERSION, TMP_WEBENGINE_DESCRIPTION, SEMRESATTRS_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME, SEMRESATTRS_FAAS_ID, SEMRESATTRS_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID, SEMRESATTRS_HOST_NAME, SEMRESATTRS_HOST_TYPE, SEMRESATTRS_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION, SEMRESATTRS_OS_NAME, SEMRESATTRS_OS_VERSION, SEMRESATTRS_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION, SemanticResourceAttributes, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, TMP_CLOUDPROVIDERVALUES_AWS, TMP_CLOUDPROVIDERVALUES_AZURE, TMP_CLOUDPROVIDERVALUES_GCP, CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP, CloudProviderValues, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, TMP_CLOUDPLATFORMVALUES_AWS_EC2, TMP_CLOUDPLATFORMVALUES_AWS_ECS, TMP_CLOUDPLATFORMVALUES_AWS_EKS, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, TMP_CLOUDPLATFORMVALUES_AZURE_VM, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, TMP_CLOUDPLATFORMVALUES_AZURE_AKS, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues, TMP_AWSECSLAUNCHTYPEVALUES_EC2, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues, TMP_HOSTARCHVALUES_AMD64, TMP_HOSTARCHVALUES_ARM32, TMP_HOSTARCHVALUES_ARM64, TMP_HOSTARCHVALUES_IA64, TMP_HOSTARCHVALUES_PPC32, TMP_HOSTARCHVALUES_PPC64, TMP_HOSTARCHVALUES_X86, HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86, HostArchValues, TMP_OSTYPEVALUES_WINDOWS, TMP_OSTYPEVALUES_LINUX, TMP_OSTYPEVALUES_DARWIN, TMP_OSTYPEVALUES_FREEBSD, TMP_OSTYPEVALUES_NETBSD, TMP_OSTYPEVALUES_OPENBSD, TMP_OSTYPEVALUES_DRAGONFLYBSD, TMP_OSTYPEVALUES_HPUX, TMP_OSTYPEVALUES_AIX, TMP_OSTYPEVALUES_SOLARIS, TMP_OSTYPEVALUES_Z_OS, OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS, OsTypeValues, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues, init_SemanticResourceAttributes = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_cjs_shims();
    init_utils3();
    TMP_CLOUD_PROVIDER = "cloud.provider", TMP_CLOUD_ACCOUNT_ID = "cloud.account.id", TMP_CLOUD_REGION = "cloud.region", TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone", TMP_CLOUD_PLATFORM = "cloud.platform", TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn", TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn", TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype", TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn", TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family", TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision", TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn", TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names", TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns", TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names", TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns", TMP_CONTAINER_NAME = "container.name", TMP_CONTAINER_ID = "container.id", TMP_CONTAINER_RUNTIME = "container.runtime", TMP_CONTAINER_IMAGE_NAME = "container.image.name", TMP_CONTAINER_IMAGE_TAG = "container.image.tag", TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment", TMP_DEVICE_ID = "device.id", TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier", TMP_DEVICE_MODEL_NAME = "device.model.name", TMP_FAAS_NAME = "faas.name", TMP_FAAS_ID = "faas.id", TMP_FAAS_VERSION = "faas.version", TMP_FAAS_INSTANCE = "faas.instance", TMP_FAAS_MAX_MEMORY = "faas.max_memory", TMP_HOST_ID = "host.id", TMP_HOST_NAME = "host.name", TMP_HOST_TYPE = "host.type", TMP_HOST_ARCH = "host.arch", TMP_HOST_IMAGE_NAME = "host.image.name", TMP_HOST_IMAGE_ID = "host.image.id", TMP_HOST_IMAGE_VERSION = "host.image.version", TMP_K8S_CLUSTER_NAME = "k8s.cluster.name", TMP_K8S_NODE_NAME = "k8s.node.name", TMP_K8S_NODE_UID = "k8s.node.uid", TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name", TMP_K8S_POD_UID = "k8s.pod.uid", TMP_K8S_POD_NAME = "k8s.pod.name", TMP_K8S_CONTAINER_NAME = "k8s.container.name", TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid", TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name", TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid", TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name", TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid", TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name", TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid", TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name", TMP_K8S_JOB_UID = "k8s.job.uid", TMP_K8S_JOB_NAME = "k8s.job.name", TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid", TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name", TMP_OS_TYPE = "os.type", TMP_OS_DESCRIPTION = "os.description", TMP_OS_NAME = "os.name", TMP_OS_VERSION = "os.version", TMP_PROCESS_PID = "process.pid", TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name", TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path", TMP_PROCESS_COMMAND = "process.command", TMP_PROCESS_COMMAND_LINE = "process.command_line", TMP_PROCESS_COMMAND_ARGS = "process.command_args", TMP_PROCESS_OWNER = "process.owner", TMP_PROCESS_RUNTIME_NAME = "process.runtime.name", TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version", TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description", TMP_SERVICE_NAME = "service.name", TMP_SERVICE_NAMESPACE = "service.namespace", TMP_SERVICE_INSTANCE_ID = "service.instance.id", TMP_SERVICE_VERSION = "service.version", TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name", TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language", TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version", TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version", TMP_WEBENGINE_NAME = "webengine.name", TMP_WEBENGINE_VERSION = "webengine.version", TMP_WEBENGINE_DESCRIPTION = "webengine.description", SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME, SEMRESATTRS_FAAS_ID = TMP_FAAS_ID, SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID = TMP_HOST_ID, SEMRESATTRS_HOST_NAME = TMP_HOST_NAME, SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE, SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE = TMP_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION, SEMRESATTRS_OS_NAME = TMP_OS_NAME, SEMRESATTRS_OS_VERSION = TMP_OS_VERSION, SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION, SemanticResourceAttributes = /* @__PURE__ */ createConstMap([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]), TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud", TMP_CLOUDPROVIDERVALUES_AWS = "aws", TMP_CLOUDPROVIDERVALUES_AZURE = "azure", TMP_CLOUDPROVIDERVALUES_GCP = "gcp", CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP, CloudProviderValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]), TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs", TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc", TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2", TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs", TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks", TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda", TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk", TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm", TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances", TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks", TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions", TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service", TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine", TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run", TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine", TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions", TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine", CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]), TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2", TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate", AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues = /* @__PURE__ */ createConstMap([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]), TMP_HOSTARCHVALUES_AMD64 = "amd64", TMP_HOSTARCHVALUES_ARM32 = "arm32", TMP_HOSTARCHVALUES_ARM64 = "arm64", TMP_HOSTARCHVALUES_IA64 = "ia64", TMP_HOSTARCHVALUES_PPC32 = "ppc32", TMP_HOSTARCHVALUES_PPC64 = "ppc64", TMP_HOSTARCHVALUES_X86 = "x86", HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86, HostArchValues = /* @__PURE__ */ createConstMap([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]), TMP_OSTYPEVALUES_WINDOWS = "windows", TMP_OSTYPEVALUES_LINUX = "linux", TMP_OSTYPEVALUES_DARWIN = "darwin", TMP_OSTYPEVALUES_FREEBSD = "freebsd", TMP_OSTYPEVALUES_NETBSD = "netbsd", TMP_OSTYPEVALUES_OPENBSD = "openbsd", TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd", TMP_OSTYPEVALUES_HPUX = "hpux", TMP_OSTYPEVALUES_AIX = "aix", TMP_OSTYPEVALUES_SOLARIS = "solaris", TMP_OSTYPEVALUES_Z_OS = "z_os", OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS, OsTypeValues = /* @__PURE__ */ createConstMap([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]), TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp", TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet", TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang", TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go", TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java", TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs", TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php", TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python", TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby", TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs", TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues = /* @__PURE__ */ createConstMap([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_cjs_shims();
    init_SemanticResourceAttributes();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED, ATTR_TELEMETRY_SDK_LANGUAGE, TELEMETRY_SDK_LANGUAGE_VALUE_CPP, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG, TELEMETRY_SDK_LANGUAGE_VALUE_GO, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS, TELEMETRY_SDK_LANGUAGE_VALUE_PHP, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY, TELEMETRY_SDK_LANGUAGE_VALUE_RUST, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED, ATTR_ASPNETCORE_RATE_LIMITING_POLICY, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS, ATTR_CLIENT_ADDRESS, ATTR_CLIENT_PORT, ATTR_ERROR_TYPE, ERROR_TYPE_VALUE_OTHER, ATTR_EXCEPTION_ESCAPED, ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_TYPE, ATTR_HTTP_REQUEST_HEADER, ATTR_HTTP_REQUEST_METHOD, HTTP_REQUEST_METHOD_VALUE_OTHER, HTTP_REQUEST_METHOD_VALUE_CONNECT, HTTP_REQUEST_METHOD_VALUE_DELETE, HTTP_REQUEST_METHOD_VALUE_GET, HTTP_REQUEST_METHOD_VALUE_HEAD, HTTP_REQUEST_METHOD_VALUE_OPTIONS, HTTP_REQUEST_METHOD_VALUE_PATCH, HTTP_REQUEST_METHOD_VALUE_POST, HTTP_REQUEST_METHOD_VALUE_PUT, HTTP_REQUEST_METHOD_VALUE_TRACE, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_REQUEST_RESEND_COUNT, ATTR_HTTP_RESPONSE_HEADER, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_HTTP_ROUTE, ATTR_JVM_GC_ACTION, ATTR_JVM_GC_NAME, ATTR_JVM_MEMORY_POOL_NAME, ATTR_JVM_MEMORY_TYPE, JVM_MEMORY_TYPE_VALUE_HEAP, JVM_MEMORY_TYPE_VALUE_NON_HEAP, ATTR_JVM_THREAD_DAEMON, ATTR_JVM_THREAD_STATE, JVM_THREAD_STATE_VALUE_BLOCKED, JVM_THREAD_STATE_VALUE_NEW, JVM_THREAD_STATE_VALUE_RUNNABLE, JVM_THREAD_STATE_VALUE_TERMINATED, JVM_THREAD_STATE_VALUE_TIMED_WAITING, JVM_THREAD_STATE_VALUE_WAITING, ATTR_NETWORK_LOCAL_ADDRESS, ATTR_NETWORK_LOCAL_PORT, ATTR_NETWORK_PEER_ADDRESS, ATTR_NETWORK_PEER_PORT, ATTR_NETWORK_PROTOCOL_NAME, ATTR_NETWORK_PROTOCOL_VERSION, ATTR_NETWORK_TRANSPORT, NETWORK_TRANSPORT_VALUE_PIPE, NETWORK_TRANSPORT_VALUE_QUIC, NETWORK_TRANSPORT_VALUE_TCP, NETWORK_TRANSPORT_VALUE_UDP, NETWORK_TRANSPORT_VALUE_UNIX, ATTR_NETWORK_TYPE, NETWORK_TYPE_VALUE_IPV4, NETWORK_TYPE_VALUE_IPV6, ATTR_OTEL_SCOPE_NAME, ATTR_OTEL_SCOPE_VERSION, ATTR_OTEL_STATUS_CODE, OTEL_STATUS_CODE_VALUE_ERROR, OTEL_STATUS_CODE_VALUE_OK, ATTR_OTEL_STATUS_DESCRIPTION, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION, ATTR_SIGNALR_CONNECTION_STATUS, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT, ATTR_SIGNALR_TRANSPORT, SIGNALR_TRANSPORT_VALUE_LONG_POLLING, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS, ATTR_URL_FRAGMENT, ATTR_URL_FULL, ATTR_URL_PATH, ATTR_URL_QUERY, ATTR_URL_SCHEME, ATTR_USER_AGENT_ORIGINAL, init_stable_attributes = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    init_cjs_shims();
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result", ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired", ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter", ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter", ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled", ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language", TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp", TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet", TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang", TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go", TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java", TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs", TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php", TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python", TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby", TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust", TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift", TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs", ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name", ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version", ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type", ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result", ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted", ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled", ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped", ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled", ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy", ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled", ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback", ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status", ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure", ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success", ATTR_CLIENT_ADDRESS = "client.address", ATTR_CLIENT_PORT = "client.port", ATTR_ERROR_TYPE = "error.type", ERROR_TYPE_VALUE_OTHER = "_OTHER", ATTR_EXCEPTION_ESCAPED = "exception.escaped", ATTR_EXCEPTION_MESSAGE = "exception.message", ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace", ATTR_EXCEPTION_TYPE = "exception.type", ATTR_HTTP_REQUEST_HEADER = function(key) {
      return "http.request.header." + key;
    }, ATTR_HTTP_REQUEST_METHOD = "http.request.method", HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER", HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT", HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE", HTTP_REQUEST_METHOD_VALUE_GET = "GET", HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD", HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS", HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH", HTTP_REQUEST_METHOD_VALUE_POST = "POST", HTTP_REQUEST_METHOD_VALUE_PUT = "PUT", HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE", ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original", ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count", ATTR_HTTP_RESPONSE_HEADER = function(key) {
      return "http.response.header." + key;
    }, ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code", ATTR_HTTP_ROUTE = "http.route", ATTR_JVM_GC_ACTION = "jvm.gc.action", ATTR_JVM_GC_NAME = "jvm.gc.name", ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name", ATTR_JVM_MEMORY_TYPE = "jvm.memory.type", JVM_MEMORY_TYPE_VALUE_HEAP = "heap", JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap", ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon", ATTR_JVM_THREAD_STATE = "jvm.thread.state", JVM_THREAD_STATE_VALUE_BLOCKED = "blocked", JVM_THREAD_STATE_VALUE_NEW = "new", JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable", JVM_THREAD_STATE_VALUE_TERMINATED = "terminated", JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting", JVM_THREAD_STATE_VALUE_WAITING = "waiting", ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address", ATTR_NETWORK_LOCAL_PORT = "network.local.port", ATTR_NETWORK_PEER_ADDRESS = "network.peer.address", ATTR_NETWORK_PEER_PORT = "network.peer.port", ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name", ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version", ATTR_NETWORK_TRANSPORT = "network.transport", NETWORK_TRANSPORT_VALUE_PIPE = "pipe", NETWORK_TRANSPORT_VALUE_QUIC = "quic", NETWORK_TRANSPORT_VALUE_TCP = "tcp", NETWORK_TRANSPORT_VALUE_UDP = "udp", NETWORK_TRANSPORT_VALUE_UNIX = "unix", ATTR_NETWORK_TYPE = "network.type", NETWORK_TYPE_VALUE_IPV4 = "ipv4", NETWORK_TYPE_VALUE_IPV6 = "ipv6", ATTR_OTEL_SCOPE_NAME = "otel.scope.name", ATTR_OTEL_SCOPE_VERSION = "otel.scope.version", ATTR_OTEL_STATUS_CODE = "otel.status_code", OTEL_STATUS_CODE_VALUE_ERROR = "ERROR", OTEL_STATUS_CODE_VALUE_OK = "OK", ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description", ATTR_SERVER_ADDRESS = "server.address", ATTR_SERVER_PORT = "server.port", ATTR_SERVICE_NAME = "service.name", ATTR_SERVICE_VERSION = "service.version", ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status", SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown", SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure", SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout", ATTR_SIGNALR_TRANSPORT = "signalr.transport", SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling", SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events", SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets", ATTR_URL_FRAGMENT = "url.fragment", ATTR_URL_FULL = "url.full", ATTR_URL_PATH = "url.path", ATTR_URL_QUERY = "url.query", ATTR_URL_SCHEME = "url.scheme", ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS, METRIC_HTTP_CLIENT_REQUEST_DURATION, METRIC_HTTP_SERVER_REQUEST_DURATION, METRIC_JVM_CLASS_COUNT, METRIC_JVM_CLASS_LOADED, METRIC_JVM_CLASS_UNLOADED, METRIC_JVM_CPU_COUNT, METRIC_JVM_CPU_RECENT_UTILIZATION, METRIC_JVM_CPU_TIME, METRIC_JVM_GC_DURATION, METRIC_JVM_MEMORY_COMMITTED, METRIC_JVM_MEMORY_LIMIT, METRIC_JVM_MEMORY_USED, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC, METRIC_JVM_THREAD_COUNT, METRIC_KESTREL_ACTIVE_CONNECTIONS, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES, METRIC_KESTREL_CONNECTION_DURATION, METRIC_KESTREL_QUEUED_CONNECTIONS, METRIC_KESTREL_QUEUED_REQUESTS, METRIC_KESTREL_REJECTED_CONNECTIONS, METRIC_KESTREL_TLS_HANDSHAKE_DURATION, METRIC_KESTREL_UPGRADED_CONNECTIONS, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS, METRIC_SIGNALR_SERVER_CONNECTION_DURATION, init_stable_metrics = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    init_cjs_shims();
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions", METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases", METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests", METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue", METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration", METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests", METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts", METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration", METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration", METRIC_JVM_CLASS_COUNT = "jvm.class.count", METRIC_JVM_CLASS_LOADED = "jvm.class.loaded", METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded", METRIC_JVM_CPU_COUNT = "jvm.cpu.count", METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization", METRIC_JVM_CPU_TIME = "jvm.cpu.time", METRIC_JVM_GC_DURATION = "jvm.gc.duration", METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed", METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit", METRIC_JVM_MEMORY_USED = "jvm.memory.used", METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc", METRIC_JVM_THREAD_COUNT = "jvm.thread.count", METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections", METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes", METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration", METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections", METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests", METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections", METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration", METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections", METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections", METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT,
  ATTR_URL_FULL: () => ATTR_URL_FULL,
  ATTR_URL_PATH: () => ATTR_URL_PATH,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC2,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC2,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP,
  CloudPlatformValues: () => CloudPlatformValues,
  CloudProviderValues: () => CloudProviderValues,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB2,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H2,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues,
  DbSystemValues: () => DbSystemValues,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues,
  FaasTriggerValues: () => FaasTriggerValues,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD64,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM32,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM64,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA64,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC32,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC64,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X86,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_0,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_1,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_0,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE,
  HostArchValues: () => HostArchValues,
  HttpFlavorValues: () => HttpFlavorValues,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION,
  MessageTypeValues: () => MessageTypeValues,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues,
  MessagingOperationValues: () => MessagingOperationValues,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV4,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV6,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues,
  NetTransportValues: () => NetTransportValues,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK,
  OsTypeValues: () => OsTypeValues,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS,
  SemanticAttributes: () => SemanticAttributes,
  SemanticResourceAttributes: () => SemanticResourceAttributes,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues
});
var init_esm2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_cjs_shims();
    init_trace2();
    init_resource();
    init_stable_attributes();
    init_stable_metrics();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SDK_INFO = void 0;
    var version_1 = require_version(), semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    exports2.SDK_INFO = {
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports2.unrefTimer = unrefTimer;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.unrefTimer = exports2.SDK_INFO = exports2.otperformance = exports2.RandomIdGenerator = exports2.hexToBase64 = exports2._globalThis = exports2.getEnv = exports2.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment2();
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: !0, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: !0, get: function() {
      return environment_1.getEnv;
    } });
    var globalThis_1 = require_globalThis();
    Object.defineProperty(exports2, "_globalThis", { enumerable: !0, get: function() {
      return globalThis_1._globalThis;
    } });
    var hex_to_base64_1 = require_hex_to_base64();
    Object.defineProperty(exports2, "hexToBase64", { enumerable: !0, get: function() {
      return hex_to_base64_1.hexToBase64;
    } });
    var RandomIdGenerator_1 = require_RandomIdGenerator();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: !0, get: function() {
      return RandomIdGenerator_1.RandomIdGenerator;
    } });
    var performance_1 = require_performance();
    Object.defineProperty(exports2, "otperformance", { enumerable: !0, get: function() {
      return performance_1.otperformance;
    } });
    var sdk_info_1 = require_sdk_info();
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: !0, get: function() {
      return sdk_info_1.SDK_INFO;
    } });
    var timer_util_1 = require_timer_util();
    Object.defineProperty(exports2, "unrefTimer", { enumerable: !0, get: function() {
      return timer_util_1.unrefTimer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/platform/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.unrefTimer = exports2.otperformance = exports2.hexToBase64 = exports2.getEnvWithoutDefaults = exports2.getEnv = exports2._globalThis = exports2.SDK_INFO = exports2.RandomIdGenerator = void 0;
    var node_1 = require_node();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: !0, get: function() {
      return node_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: !0, get: function() {
      return node_1.SDK_INFO;
    } });
    Object.defineProperty(exports2, "_globalThis", { enumerable: !0, get: function() {
      return node_1._globalThis;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: !0, get: function() {
      return node_1.getEnv;
    } });
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: !0, get: function() {
      return node_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "hexToBase64", { enumerable: !0, get: function() {
      return node_1.hexToBase64;
    } });
    Object.defineProperty(exports2, "otperformance", { enumerable: !0, get: function() {
      return node_1.otperformance;
    } });
    Object.defineProperty(exports2, "unrefTimer", { enumerable: !0, get: function() {
      return node_1.unrefTimer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/common/time.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.addHrTimes = exports2.isTimeInput = exports2.isTimeInputHrTime = exports2.hrTimeToMicroseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToNanoseconds = exports2.hrTimeToTimeStamp = exports2.hrTimeDuration = exports2.timeInputToHrTime = exports2.hrTime = exports2.getTimeOrigin = exports2.millisToHrTime = void 0;
    var platform_1 = require_platform(), NANOSECOND_DIGITS = 9, NANOSECOND_DIGITS_IN_MILLIS = 6, MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS), SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      let epochSeconds = epochMillis / 1e3, seconds = Math.trunc(epochSeconds), nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports2.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin != "number") {
        let perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports2.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      let timeOrigin = millisToHrTime(getTimeOrigin()), now = millisToHrTime(typeof performanceNow == "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports2.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time))
        return time;
      if (typeof time == "number")
        return time < getTimeOrigin() ? hrTime(time) : millisToHrTime(time);
      if (time instanceof Date)
        return millisToHrTime(time.getTime());
      throw TypeError("Invalid input type");
    }
    exports2.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0], nanos = endTime[1] - startTime[1];
      return nanos < 0 && (seconds -= 1, nanos += SECOND_TO_NANOSECONDS), [seconds, nanos];
    }
    exports2.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      let precision = NANOSECOND_DIGITS, tmp = `${"0".repeat(precision)}${time[1]}Z`, nanoString = tmp.substring(tmp.length - precision - 1);
      return new Date(time[0] * 1e3).toISOString().replace("000Z", nanoString);
    }
    exports2.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports2.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports2.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports2.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] == "number" && typeof value[1] == "number";
    }
    exports2.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value == "number" || value instanceof Date;
    }
    exports2.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      let out = [time1[0] + time2[0], time1[1] + time2[1]];
      return out[1] >= SECOND_TO_NANOSECONDS && (out[1] -= SECOND_TO_NANOSECONDS, out[0] += 1), out;
    }
    exports2.addHrTimes = addHrTimes;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ExportResultCode = void 0;
    var ExportResultCode3;
    (function(ExportResultCode4) {
      ExportResultCode4[ExportResultCode4.SUCCESS = 0] = "SUCCESS", ExportResultCode4[ExportResultCode4.FAILED = 1] = "FAILED";
    })(ExportResultCode3 = exports2.ExportResultCode || (exports2.ExportResultCode = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [], this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields == "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context2, carrier, setter) {
        for (let propagator of this._propagators)
          try {
            propagator.inject(context2, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context2, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context2);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports2.CompositePropagator = CompositePropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]", VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`, VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`, VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`), VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/, INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports2.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports2.validateValue = validateValue2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TraceState = void 0;
    var validators_1 = require_validators(), MAX_TRACE_STATE_ITEMS2 = 32, MAX_TRACE_STATE_LEN2 = 512, LIST_MEMBERS_SEPARATOR2 = ",", LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=", TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map(), rawTraceState && this._parse(rawTraceState);
      }
      set(key, value) {
        let traceState = this._clone();
        return traceState._internalState.has(key) && traceState._internalState.delete(key), traceState._internalState.set(key, value), traceState;
      }
      unset(key) {
        let traceState = this._clone();
        return traceState._internalState.delete(key), traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => (agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key)), agg), []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        rawTraceState.length > MAX_TRACE_STATE_LEN2 || (this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          let listMember = part.trim(), i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            let key = listMember.slice(0, i), value = listMember.slice(i + 1, part.length);
            (0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value) && agg.set(key, value);
          }
          return agg;
        }, /* @__PURE__ */ new Map()), this._internalState.size > MAX_TRACE_STATE_ITEMS2 && (this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2))));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let traceState = new _TraceState();
        return traceState._internalState = new Map(this._internalState), traceState;
      }
    };
    exports2.TraceState = TraceState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.W3CTraceContextPropagator = exports2.parseTraceParent = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), suppress_tracing_1 = require_suppress_tracing(), TraceState_1 = require_TraceState();
    exports2.TRACE_PARENT_HEADER = "traceparent";
    exports2.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00", VERSION_PART = "(?!ff)[\\da-f]{2}", TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}", PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}", FLAGS_PART = "[\\da-f]{2}", TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      let match = TRACE_PARENT_REGEX.exec(traceParent);
      return !match || match[1] === "00" && match[5] ? null : {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports2.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context2, carrier, setter) {
        let spanContext = api_1.trace.getSpanContext(context2);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context2) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        let traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports2.TRACE_PARENT_HEADER, traceParent), spanContext.traceState && setter.set(carrier, exports2.TRACE_STATE_HEADER, spanContext.traceState.serialize());
      }
      extract(context2, carrier, getter) {
        let traceParentHeader = getter.get(carrier, exports2.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context2;
        let traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent != "string")
          return context2;
        let spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context2;
        spanContext.isRemote = !0;
        let traceStateHeader = getter.get(carrier, exports2.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          let state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state == "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context2, spanContext);
      }
      fields() {
        return [exports2.TRACE_PARENT_HEADER, exports2.TRACE_STATE_HEADER];
      }
    };
    exports2.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.setRPCMetadata = exports2.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA"), RPCType;
    (function(RPCType2) {
      RPCType2.HTTP = "http";
    })(RPCType = exports2.RPCType || (exports2.RPCType = {}));
    function setRPCMetadata(context2, meta) {
      return context2.setValue(RPC_METADATA_KEY, meta);
    }
    exports2.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context2) {
      return context2.deleteValue(RPC_METADATA_KEY);
    }
    exports2.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context2) {
      return context2.getValue(RPC_METADATA_KEY);
    }
    exports2.getRPCMetadata = getRPCMetadata;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), global_error_handler_1 = require_global_error_handler(), AlwaysOffSampler_1 = require_AlwaysOffSampler(), AlwaysOnSampler_1 = require_AlwaysOnSampler(), ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root, this._root || ((0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured")), this._root = new AlwaysOnSampler_1.AlwaysOnSampler()), this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler(), this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler(), this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler(), this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context2, traceId, spanName, spanKind, attributes, links) {
        let parentContext = api_1.trace.getSpanContext(context2);
        return !parentContext || !(0, api_1.isSpanContextValid)(parentContext) ? this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links) : parentContext.isRemote ? parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links) : this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links) : parentContext.traceFlags & api_1.TraceFlags.SAMPLED ? this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links) : this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio, this._ratio = this._normalize(_ratio), this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context2, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        return typeof ratio != "number" || isNaN(ratio) ? 0 : ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          let pos = i * 8, part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isPlainObject = void 0;
    var objectTag = "[object Object]", nullTag = "[object Null]", undefinedTag = "[object Undefined]", funcProto = Function.prototype, funcToString = funcProto.toString, objectCtorString = funcToString.call(Object), getPrototype = overArg(Object.getPrototypeOf, Object), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, symToStringTag = Symbol ? Symbol.toStringTag : void 0, nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag)
        return !1;
      let proto = getPrototype(value);
      if (proto === null)
        return !0;
      let Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports2.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      return value == null ? value === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      let isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag], unmasked = !1;
      try {
        value[symToStringTag] = void 0, unmasked = !0;
      } catch {
      }
      let result = nativeObjectToString.call(value);
      return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.merge = void 0;
    var lodash_merge_1 = require_lodash_merge(), MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift(), objects = /* @__PURE__ */ new WeakMap();
      for (; args.length > 0; )
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      return result;
    }
    exports2.merge = merge;
    function takeValue(value) {
      return isArray(value) ? value.slice() : value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (!(level > MAX_LEVEL)) {
        if (level++, isPrimitive(one) || isPrimitive(two) || isFunction(two))
          result = takeValue(two);
        else if (isArray(one)) {
          if (result = one.slice(), isArray(two))
            for (let i = 0, j = two.length; i < j; i++)
              result.push(takeValue(two[i]));
          else if (isObject(two)) {
            let keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
              let key = keys[i];
              result[key] = takeValue(two[key]);
            }
          }
        } else if (isObject(one))
          if (isObject(two)) {
            if (!shouldMerge(one, two))
              return two;
            result = Object.assign({}, one);
            let keys = Object.keys(two);
            for (let i = 0, j = keys.length; i < j; i++) {
              let key = keys[i], twoValue = two[key];
              if (isPrimitive(twoValue))
                typeof twoValue > "u" ? delete result[key] : result[key] = twoValue;
              else {
                let obj1 = result[key], obj2 = twoValue;
                if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects))
                  delete result[key];
                else {
                  if (isObject(obj1) && isObject(obj2)) {
                    let arr1 = objects.get(obj1) || [], arr2 = objects.get(obj2) || [];
                    arr1.push({ obj: one, key }), arr2.push({ obj: two, key }), objects.set(obj1, arr1), objects.set(obj2, arr2);
                  }
                  result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                }
              }
            }
          } else
            result = two;
        return result;
      }
    }
    function wasObjectReferenced(obj, key, objects) {
      let arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        let info = arr[i];
        if (info.key === key && info.obj === obj)
          return !0;
      }
      return !1;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value == "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value == "object";
    }
    function isPrimitive(value) {
      return typeof value == "string" || typeof value == "number" || typeof value == "boolean" || typeof value > "u" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      return !(!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two));
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.callWithTimeout = exports2.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message), Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle, timeoutPromise = new Promise(function(_resolve, reject) {
        timeoutHandle = setTimeout(function() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => (clearTimeout(timeoutHandle), result), (reason) => {
        throw clearTimeout(timeoutHandle), reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/url.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isUrlIgnored = exports2.urlMatches = void 0;
    function urlMatches(url2, urlToMatch) {
      return typeof urlToMatch == "string" ? url2 === urlToMatch : !!url2.match(urlToMatch);
    }
    exports2.urlMatches = urlMatches;
    function isUrlIgnored(url2, ignoredUrls) {
      if (!ignoredUrls)
        return !1;
      for (let ignoreUrl of ignoredUrls)
        if (urlMatches(url2, ignoreUrl))
          return !0;
      return !1;
    }
    exports2.isUrlIgnored = isUrlIgnored;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isWrapped = void 0;
    function isWrapped(func) {
      return typeof func == "function" && typeof func.__original == "function" && typeof func.__unwrap == "function" && func.__wrapped === !0;
    }
    exports2.isWrapped = isWrapped;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve, this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports2.Deferred = Deferred;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BindOnceFuture = void 0;
    var promise_1 = require_promise(), BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback, this._that = _that, this._isCalled = !1, this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = !0;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports2.BindOnceFuture = BindOnceFuture;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    exports2._export = _export;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+core@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/src/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.TraceState = exports2.unsuppressTracing = exports2.suppressTracing = exports2.isTracingSuppressed = exports2.TraceIdRatioBasedSampler = exports2.ParentBasedSampler = exports2.AlwaysOnSampler = exports2.AlwaysOffSampler = exports2.setRPCMetadata = exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.RPCType = exports2.parseTraceParent = exports2.W3CTraceContextPropagator = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = exports2.CompositePropagator = exports2.unrefTimer = exports2.otperformance = exports2.hexToBase64 = exports2.getEnvWithoutDefaults = exports2.getEnv = exports2._globalThis = exports2.SDK_INFO = exports2.RandomIdGenerator = exports2.baggageUtils = exports2.ExportResultCode = exports2.hexToBinary = exports2.timeInputToHrTime = exports2.millisToHrTime = exports2.isTimeInputHrTime = exports2.isTimeInput = exports2.hrTimeToTimeStamp = exports2.hrTimeToNanoseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToMicroseconds = exports2.hrTimeDuration = exports2.hrTime = exports2.getTimeOrigin = exports2.addHrTimes = exports2.loggingErrorHandler = exports2.setGlobalErrorHandler = exports2.globalErrorHandler = exports2.sanitizeAttributes = exports2.isAttributeValue = exports2.isAttributeKey = exports2.AnchoredClock = exports2.W3CBaggagePropagator = void 0;
    exports2.internal = exports2.VERSION = exports2.BindOnceFuture = exports2.isWrapped = exports2.urlMatches = exports2.isUrlIgnored = exports2.callWithTimeout = exports2.TimeoutError = exports2.TracesSamplerValues = exports2.merge = exports2.parseEnvironment = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ENVIRONMENT = void 0;
    var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
    Object.defineProperty(exports2, "W3CBaggagePropagator", { enumerable: !0, get: function() {
      return W3CBaggagePropagator_1.W3CBaggagePropagator;
    } });
    var anchored_clock_1 = require_anchored_clock();
    Object.defineProperty(exports2, "AnchoredClock", { enumerable: !0, get: function() {
      return anchored_clock_1.AnchoredClock;
    } });
    var attributes_1 = require_attributes();
    Object.defineProperty(exports2, "isAttributeKey", { enumerable: !0, get: function() {
      return attributes_1.isAttributeKey;
    } });
    Object.defineProperty(exports2, "isAttributeValue", { enumerable: !0, get: function() {
      return attributes_1.isAttributeValue;
    } });
    Object.defineProperty(exports2, "sanitizeAttributes", { enumerable: !0, get: function() {
      return attributes_1.sanitizeAttributes;
    } });
    var global_error_handler_1 = require_global_error_handler();
    Object.defineProperty(exports2, "globalErrorHandler", { enumerable: !0, get: function() {
      return global_error_handler_1.globalErrorHandler;
    } });
    Object.defineProperty(exports2, "setGlobalErrorHandler", { enumerable: !0, get: function() {
      return global_error_handler_1.setGlobalErrorHandler;
    } });
    var logging_error_handler_1 = require_logging_error_handler();
    Object.defineProperty(exports2, "loggingErrorHandler", { enumerable: !0, get: function() {
      return logging_error_handler_1.loggingErrorHandler;
    } });
    var time_1 = require_time();
    Object.defineProperty(exports2, "addHrTimes", { enumerable: !0, get: function() {
      return time_1.addHrTimes;
    } });
    Object.defineProperty(exports2, "getTimeOrigin", { enumerable: !0, get: function() {
      return time_1.getTimeOrigin;
    } });
    Object.defineProperty(exports2, "hrTime", { enumerable: !0, get: function() {
      return time_1.hrTime;
    } });
    Object.defineProperty(exports2, "hrTimeDuration", { enumerable: !0, get: function() {
      return time_1.hrTimeDuration;
    } });
    Object.defineProperty(exports2, "hrTimeToMicroseconds", { enumerable: !0, get: function() {
      return time_1.hrTimeToMicroseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToMilliseconds", { enumerable: !0, get: function() {
      return time_1.hrTimeToMilliseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToNanoseconds", { enumerable: !0, get: function() {
      return time_1.hrTimeToNanoseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToTimeStamp", { enumerable: !0, get: function() {
      return time_1.hrTimeToTimeStamp;
    } });
    Object.defineProperty(exports2, "isTimeInput", { enumerable: !0, get: function() {
      return time_1.isTimeInput;
    } });
    Object.defineProperty(exports2, "isTimeInputHrTime", { enumerable: !0, get: function() {
      return time_1.isTimeInputHrTime;
    } });
    Object.defineProperty(exports2, "millisToHrTime", { enumerable: !0, get: function() {
      return time_1.millisToHrTime;
    } });
    Object.defineProperty(exports2, "timeInputToHrTime", { enumerable: !0, get: function() {
      return time_1.timeInputToHrTime;
    } });
    var hex_to_binary_1 = require_hex_to_binary();
    Object.defineProperty(exports2, "hexToBinary", { enumerable: !0, get: function() {
      return hex_to_binary_1.hexToBinary;
    } });
    var ExportResult_1 = require_ExportResult();
    Object.defineProperty(exports2, "ExportResultCode", { enumerable: !0, get: function() {
      return ExportResult_1.ExportResultCode;
    } });
    var utils_1 = require_utils2();
    exports2.baggageUtils = {
      getKeyPairs: utils_1.getKeyPairs,
      serializeKeyPairs: utils_1.serializeKeyPairs,
      parseKeyPairsIntoRecord: utils_1.parseKeyPairsIntoRecord,
      parsePairKeyValue: utils_1.parsePairKeyValue
    };
    var platform_1 = require_platform();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: !0, get: function() {
      return platform_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: !0, get: function() {
      return platform_1.SDK_INFO;
    } });
    Object.defineProperty(exports2, "_globalThis", { enumerable: !0, get: function() {
      return platform_1._globalThis;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: !0, get: function() {
      return platform_1.getEnv;
    } });
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: !0, get: function() {
      return platform_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "hexToBase64", { enumerable: !0, get: function() {
      return platform_1.hexToBase64;
    } });
    Object.defineProperty(exports2, "otperformance", { enumerable: !0, get: function() {
      return platform_1.otperformance;
    } });
    Object.defineProperty(exports2, "unrefTimer", { enumerable: !0, get: function() {
      return platform_1.unrefTimer;
    } });
    var composite_1 = require_composite();
    Object.defineProperty(exports2, "CompositePropagator", { enumerable: !0, get: function() {
      return composite_1.CompositePropagator;
    } });
    var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
    Object.defineProperty(exports2, "TRACE_PARENT_HEADER", { enumerable: !0, get: function() {
      return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
    } });
    Object.defineProperty(exports2, "TRACE_STATE_HEADER", { enumerable: !0, get: function() {
      return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
    } });
    Object.defineProperty(exports2, "W3CTraceContextPropagator", { enumerable: !0, get: function() {
      return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
    } });
    Object.defineProperty(exports2, "parseTraceParent", { enumerable: !0, get: function() {
      return W3CTraceContextPropagator_1.parseTraceParent;
    } });
    var rpc_metadata_1 = require_rpc_metadata();
    Object.defineProperty(exports2, "RPCType", { enumerable: !0, get: function() {
      return rpc_metadata_1.RPCType;
    } });
    Object.defineProperty(exports2, "deleteRPCMetadata", { enumerable: !0, get: function() {
      return rpc_metadata_1.deleteRPCMetadata;
    } });
    Object.defineProperty(exports2, "getRPCMetadata", { enumerable: !0, get: function() {
      return rpc_metadata_1.getRPCMetadata;
    } });
    Object.defineProperty(exports2, "setRPCMetadata", { enumerable: !0, get: function() {
      return rpc_metadata_1.setRPCMetadata;
    } });
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    Object.defineProperty(exports2, "AlwaysOffSampler", { enumerable: !0, get: function() {
      return AlwaysOffSampler_1.AlwaysOffSampler;
    } });
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    Object.defineProperty(exports2, "AlwaysOnSampler", { enumerable: !0, get: function() {
      return AlwaysOnSampler_1.AlwaysOnSampler;
    } });
    var ParentBasedSampler_1 = require_ParentBasedSampler();
    Object.defineProperty(exports2, "ParentBasedSampler", { enumerable: !0, get: function() {
      return ParentBasedSampler_1.ParentBasedSampler;
    } });
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
    Object.defineProperty(exports2, "TraceIdRatioBasedSampler", { enumerable: !0, get: function() {
      return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
    } });
    var suppress_tracing_1 = require_suppress_tracing();
    Object.defineProperty(exports2, "isTracingSuppressed", { enumerable: !0, get: function() {
      return suppress_tracing_1.isTracingSuppressed;
    } });
    Object.defineProperty(exports2, "suppressTracing", { enumerable: !0, get: function() {
      return suppress_tracing_1.suppressTracing;
    } });
    Object.defineProperty(exports2, "unsuppressTracing", { enumerable: !0, get: function() {
      return suppress_tracing_1.unsuppressTracing;
    } });
    var TraceState_1 = require_TraceState();
    Object.defineProperty(exports2, "TraceState", { enumerable: !0, get: function() {
      return TraceState_1.TraceState;
    } });
    var environment_1 = require_environment();
    Object.defineProperty(exports2, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", { enumerable: !0, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", { enumerable: !0, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_ENVIRONMENT", { enumerable: !0, get: function() {
      return environment_1.DEFAULT_ENVIRONMENT;
    } });
    Object.defineProperty(exports2, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", { enumerable: !0, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", { enumerable: !0, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "parseEnvironment", { enumerable: !0, get: function() {
      return environment_1.parseEnvironment;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports2, "merge", { enumerable: !0, get: function() {
      return merge_1.merge;
    } });
    var sampling_1 = require_sampling();
    Object.defineProperty(exports2, "TracesSamplerValues", { enumerable: !0, get: function() {
      return sampling_1.TracesSamplerValues;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: !0, get: function() {
      return timeout_1.TimeoutError;
    } });
    Object.defineProperty(exports2, "callWithTimeout", { enumerable: !0, get: function() {
      return timeout_1.callWithTimeout;
    } });
    var url_1 = require_url();
    Object.defineProperty(exports2, "isUrlIgnored", { enumerable: !0, get: function() {
      return url_1.isUrlIgnored;
    } });
    Object.defineProperty(exports2, "urlMatches", { enumerable: !0, get: function() {
      return url_1.urlMatches;
    } });
    var wrap_1 = require_wrap();
    Object.defineProperty(exports2, "isWrapped", { enumerable: !0, get: function() {
      return wrap_1.isWrapped;
    } });
    var callback_1 = require_callback();
    Object.defineProperty(exports2, "BindOnceFuture", { enumerable: !0, get: function() {
      return callback_1.BindOnceFuture;
    } });
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: !0, get: function() {
      return version_1.VERSION;
    } });
    var exporter_1 = require_exporter();
    exports2.internal = {
      _export: exporter_1._export
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js
var require_LastValue = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/LastValue.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.LastValueAggregator = exports2.LastValueAccumulation = void 0;
    var types_1 = require_types(), core_1 = require_src(), MetricData_1 = require_MetricData(), LastValueAccumulation = class {
      constructor(startTime, _current = 0, sampleTime = [0, 0]) {
        this.startTime = startTime, this._current = _current, this.sampleTime = sampleTime;
      }
      record(value) {
        this._current = value, this.sampleTime = (0, core_1.millisToHrTime)(Date.now());
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports2.LastValueAccumulation = LastValueAccumulation;
    var LastValueAggregator = class {
      constructor() {
        this.kind = types_1.AggregatorKind.LAST_VALUE;
      }
      createAccumulation(startTime) {
        return new LastValueAccumulation(startTime);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       *
       * Return the newly captured (delta) accumulation for LastValueAggregator.
       */
      merge(previous, delta) {
        let latestAccumulation = (0, core_1.hrTimeToMicroseconds)(delta.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? delta : previous;
        return new LastValueAccumulation(previous.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       *
       * A delta aggregation is not meaningful to LastValueAggregator, just return
       * the newly captured (delta) accumulation for LastValueAggregator.
       */
      diff(previous, current) {
        let latestAccumulation = (0, core_1.hrTimeToMicroseconds)(current.sampleTime) >= (0, core_1.hrTimeToMicroseconds)(previous.sampleTime) ? current : previous;
        return new LastValueAccumulation(current.startTime, latestAccumulation.toPointValue(), latestAccumulation.sampleTime);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.GAUGE,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => ({
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          }))
        };
      }
    };
    exports2.LastValueAggregator = LastValueAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js
var require_Sum = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/Sum.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SumAggregator = exports2.SumAccumulation = void 0;
    var types_1 = require_types(), MetricData_1 = require_MetricData(), SumAccumulation = class {
      constructor(startTime, monotonic, _current = 0, reset = !1) {
        this.startTime = startTime, this.monotonic = monotonic, this._current = _current, this.reset = reset;
      }
      record(value) {
        this.monotonic && value < 0 || (this._current += value);
      }
      setStartTime(startTime) {
        this.startTime = startTime;
      }
      toPointValue() {
        return this._current;
      }
    };
    exports2.SumAccumulation = SumAccumulation;
    var SumAggregator = class {
      constructor(monotonic) {
        this.monotonic = monotonic, this.kind = types_1.AggregatorKind.SUM;
      }
      createAccumulation(startTime) {
        return new SumAccumulation(startTime, this.monotonic);
      }
      /**
       * Returns the result of the merge of the given accumulations.
       */
      merge(previous, delta) {
        let prevPv = previous.toPointValue(), deltaPv = delta.toPointValue();
        return delta.reset ? new SumAccumulation(delta.startTime, this.monotonic, deltaPv, delta.reset) : new SumAccumulation(previous.startTime, this.monotonic, prevPv + deltaPv);
      }
      /**
       * Returns a new DELTA aggregation by comparing two cumulative measurements.
       */
      diff(previous, current) {
        let prevPv = previous.toPointValue(), currPv = current.toPointValue();
        return this.monotonic && prevPv > currPv ? new SumAccumulation(current.startTime, this.monotonic, currPv, !0) : new SumAccumulation(current.startTime, this.monotonic, currPv - prevPv);
      }
      toMetricData(descriptor, aggregationTemporality, accumulationByAttributes, endTime) {
        return {
          descriptor,
          aggregationTemporality,
          dataPointType: MetricData_1.DataPointType.SUM,
          dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => ({
            attributes,
            startTime: accumulation.startTime,
            endTime,
            value: accumulation.toPointValue()
          })),
          isMonotonic: this.monotonic
        };
      }
    };
    exports2.SumAggregator = SumAggregator;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js
var require_aggregator = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/aggregator/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SumAggregator = exports2.SumAccumulation = exports2.LastValueAggregator = exports2.LastValueAccumulation = exports2.ExponentialHistogramAggregator = exports2.ExponentialHistogramAccumulation = exports2.HistogramAggregator = exports2.HistogramAccumulation = exports2.DropAggregator = void 0;
    var Drop_1 = require_Drop();
    Object.defineProperty(exports2, "DropAggregator", { enumerable: !0, get: function() {
      return Drop_1.DropAggregator;
    } });
    var Histogram_1 = require_Histogram();
    Object.defineProperty(exports2, "HistogramAccumulation", { enumerable: !0, get: function() {
      return Histogram_1.HistogramAccumulation;
    } });
    Object.defineProperty(exports2, "HistogramAggregator", { enumerable: !0, get: function() {
      return Histogram_1.HistogramAggregator;
    } });
    var ExponentialHistogram_1 = require_ExponentialHistogram();
    Object.defineProperty(exports2, "ExponentialHistogramAccumulation", { enumerable: !0, get: function() {
      return ExponentialHistogram_1.ExponentialHistogramAccumulation;
    } });
    Object.defineProperty(exports2, "ExponentialHistogramAggregator", { enumerable: !0, get: function() {
      return ExponentialHistogram_1.ExponentialHistogramAggregator;
    } });
    var LastValue_1 = require_LastValue();
    Object.defineProperty(exports2, "LastValueAccumulation", { enumerable: !0, get: function() {
      return LastValue_1.LastValueAccumulation;
    } });
    Object.defineProperty(exports2, "LastValueAggregator", { enumerable: !0, get: function() {
      return LastValue_1.LastValueAggregator;
    } });
    var Sum_1 = require_Sum();
    Object.defineProperty(exports2, "SumAccumulation", { enumerable: !0, get: function() {
      return Sum_1.SumAccumulation;
    } });
    Object.defineProperty(exports2, "SumAggregator", { enumerable: !0, get: function() {
      return Sum_1.SumAggregator;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js
var require_Aggregation = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Aggregation.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DefaultAggregation = exports2.ExponentialHistogramAggregation = exports2.ExplicitBucketHistogramAggregation = exports2.HistogramAggregation = exports2.LastValueAggregation = exports2.SumAggregation = exports2.DropAggregation = exports2.Aggregation = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports)), aggregator_1 = require_aggregator(), InstrumentDescriptor_1 = require_InstrumentDescriptor(), Aggregation = class {
      static Drop() {
        return DROP_AGGREGATION;
      }
      static Sum() {
        return SUM_AGGREGATION;
      }
      static LastValue() {
        return LAST_VALUE_AGGREGATION;
      }
      static Histogram() {
        return HISTOGRAM_AGGREGATION;
      }
      static ExponentialHistogram() {
        return EXPONENTIAL_HISTOGRAM_AGGREGATION;
      }
      static Default() {
        return DEFAULT_AGGREGATION;
      }
    };
    exports2.Aggregation = Aggregation;
    var DropAggregation = class _DropAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _DropAggregation.DEFAULT_INSTANCE;
      }
    };
    exports2.DropAggregation = DropAggregation;
    DropAggregation.DEFAULT_INSTANCE = new aggregator_1.DropAggregator();
    var SumAggregation = class _SumAggregation extends Aggregation {
      createAggregator(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM:
            return _SumAggregation.MONOTONIC_INSTANCE;
          default:
            return _SumAggregation.NON_MONOTONIC_INSTANCE;
        }
      }
    };
    exports2.SumAggregation = SumAggregation;
    SumAggregation.MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(!0);
    SumAggregation.NON_MONOTONIC_INSTANCE = new aggregator_1.SumAggregator(!1);
    var LastValueAggregation = class _LastValueAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _LastValueAggregation.DEFAULT_INSTANCE;
      }
    };
    exports2.LastValueAggregation = LastValueAggregation;
    LastValueAggregation.DEFAULT_INSTANCE = new aggregator_1.LastValueAggregator();
    var HistogramAggregation = class _HistogramAggregation extends Aggregation {
      createAggregator(_instrument) {
        return _HistogramAggregation.DEFAULT_INSTANCE;
      }
    };
    exports2.HistogramAggregation = HistogramAggregation;
    HistogramAggregation.DEFAULT_INSTANCE = new aggregator_1.HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1e3, 2500, 5e3, 7500, 1e4], !0);
    var ExplicitBucketHistogramAggregation2 = class extends Aggregation {
      /**
       * @param boundaries the bucket boundaries of the histogram aggregation
       * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.
       */
      constructor(boundaries, _recordMinMax = !0) {
        if (super(), this._recordMinMax = _recordMinMax, boundaries == null)
          throw new Error("ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array");
        boundaries = boundaries.concat(), boundaries = boundaries.sort((a, b) => a - b);
        let minusInfinityIndex = boundaries.lastIndexOf(-1 / 0), infinityIndex = boundaries.indexOf(1 / 0);
        infinityIndex === -1 && (infinityIndex = void 0), this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);
      }
      createAggregator(_instrument) {
        return new aggregator_1.HistogramAggregator(this._boundaries, this._recordMinMax);
      }
    };
    exports2.ExplicitBucketHistogramAggregation = ExplicitBucketHistogramAggregation2;
    var ExponentialHistogramAggregation = class extends Aggregation {
      constructor(_maxSize = 160, _recordMinMax = !0) {
        super(), this._maxSize = _maxSize, this._recordMinMax = _recordMinMax;
      }
      createAggregator(_instrument) {
        return new aggregator_1.ExponentialHistogramAggregator(this._maxSize, this._recordMinMax);
      }
    };
    exports2.ExponentialHistogramAggregation = ExponentialHistogramAggregation;
    var DefaultAggregation = class extends Aggregation {
      _resolve(instrument) {
        switch (instrument.type) {
          case InstrumentDescriptor_1.InstrumentType.COUNTER:
          case InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
            return SUM_AGGREGATION;
          case InstrumentDescriptor_1.InstrumentType.GAUGE:
          case InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE:
            return LAST_VALUE_AGGREGATION;
          case InstrumentDescriptor_1.InstrumentType.HISTOGRAM:
            return instrument.advice.explicitBucketBoundaries ? new ExplicitBucketHistogramAggregation2(instrument.advice.explicitBucketBoundaries) : HISTOGRAM_AGGREGATION;
        }
        return api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`), DROP_AGGREGATION;
      }
      createAggregator(instrument) {
        return this._resolve(instrument).createAggregator(instrument);
      }
    };
    exports2.DefaultAggregation = DefaultAggregation;
    var DROP_AGGREGATION = new DropAggregation(), SUM_AGGREGATION = new SumAggregation(), LAST_VALUE_AGGREGATION = new LastValueAggregation(), HISTOGRAM_AGGREGATION = new HistogramAggregation(), EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation(), DEFAULT_AGGREGATION = new DefaultAggregation();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js
var require_AggregationSelector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/AggregationSelector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = exports2.DEFAULT_AGGREGATION_SELECTOR = void 0;
    var Aggregation_1 = require_Aggregation(), AggregationTemporality_1 = require_AggregationTemporality(), DEFAULT_AGGREGATION_SELECTOR = (_instrumentType) => Aggregation_1.Aggregation.Default();
    exports2.DEFAULT_AGGREGATION_SELECTOR = DEFAULT_AGGREGATION_SELECTOR;
    var DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = (_instrumentType) => AggregationTemporality_1.AggregationTemporality.CUMULATIVE;
    exports2.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR = DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js
var require_MetricReader = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/MetricReader.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MetricReader = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports)), utils_1 = require_utils(), AggregationSelector_1 = require_AggregationSelector(), MetricReader2 = class {
      constructor(options) {
        var _a, _b, _c;
        this._shutdown = !1, this._aggregationSelector = (_a = options?.aggregationSelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_SELECTOR, this._aggregationTemporalitySelector = (_b = options?.aggregationTemporalitySelector) !== null && _b !== void 0 ? _b : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR, this._metricProducers = (_c = options?.metricProducers) !== null && _c !== void 0 ? _c : [], this._cardinalitySelector = options?.cardinalitySelector;
      }
      /**
       * Set the {@link MetricProducer} used by this instance. **This should only be called by the
       * SDK and should be considered internal.**
       *
       * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the
       * constructor as {@link MetricReaderOptions.metricProducers}.
       *
       * @internal
       * @param metricProducer
       */
      setMetricProducer(metricProducer) {
        if (this._sdkMetricProducer)
          throw new Error("MetricReader can not be bound to a MeterProvider again.");
        this._sdkMetricProducer = metricProducer, this.onInitialized();
      }
      /**
       * Select the {@link Aggregation} for the given {@link InstrumentType} for this
       * reader.
       */
      selectAggregation(instrumentType) {
        return this._aggregationSelector(instrumentType);
      }
      /**
       * Select the {@link AggregationTemporality} for the given
       * {@link InstrumentType} for this reader.
       */
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
      /**
       * Select the cardinality limit for the given {@link InstrumentType} for this
       * reader.
       */
      selectCardinalityLimit(instrumentType) {
        return this._cardinalitySelector ? this._cardinalitySelector(instrumentType) : 2e3;
      }
      /**
       * Handle once the SDK has initialized this {@link MetricReader}
       * Overriding this method is optional.
       */
      onInitialized() {
      }
      /**
       * Collect all metrics from the associated {@link MetricProducer}
       */
      async collect(options) {
        if (this._sdkMetricProducer === void 0)
          throw new Error("MetricReader is not bound to a MetricProducer");
        if (this._shutdown)
          throw new Error("MetricReader is shutdown");
        let [sdkCollectionResults, ...additionalCollectionResults] = await Promise.all([
          this._sdkMetricProducer.collect({
            timeoutMillis: options?.timeoutMillis
          }),
          ...this._metricProducers.map((producer) => producer.collect({
            timeoutMillis: options?.timeoutMillis
          }))
        ]), errors = sdkCollectionResults.errors.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.errors)), resource = sdkCollectionResults.resourceMetrics.resource, scopeMetrics = sdkCollectionResults.resourceMetrics.scopeMetrics.concat((0, utils_1.FlatMap)(additionalCollectionResults, (result) => result.resourceMetrics.scopeMetrics));
        return {
          resourceMetrics: {
            resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api.diag.error("Cannot call shutdown twice.");
          return;
        }
        options?.timeoutMillis == null ? await this.onShutdown() : await (0, utils_1.callWithTimeout)(this.onShutdown(), options.timeoutMillis), this._shutdown = !0;
      }
      /**
       * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.
       *
       * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.
       * @param options options with timeout.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api.diag.warn("Cannot forceFlush on already shutdown MetricReader.");
          return;
        }
        if (options?.timeoutMillis == null) {
          await this.onForceFlush();
          return;
        }
        await (0, utils_1.callWithTimeout)(this.onForceFlush(), options.timeoutMillis);
      }
    };
    exports2.MetricReader = MetricReader2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js
var require_PeriodicExportingMetricReader = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/PeriodicExportingMetricReader.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.PeriodicExportingMetricReader = void 0;
    var api = (init_esm(), __toCommonJS(esm_exports)), core_1 = require_src(), MetricReader_1 = require_MetricReader(), utils_1 = require_utils(), PeriodicExportingMetricReader = class extends MetricReader_1.MetricReader {
      constructor(options) {
        var _a, _b, _c, _d;
        if (super({
          aggregationSelector: (_a = options.exporter.selectAggregation) === null || _a === void 0 ? void 0 : _a.bind(options.exporter),
          aggregationTemporalitySelector: (_b = options.exporter.selectAggregationTemporality) === null || _b === void 0 ? void 0 : _b.bind(options.exporter),
          metricProducers: options.metricProducers
        }), options.exportIntervalMillis !== void 0 && options.exportIntervalMillis <= 0)
          throw Error("exportIntervalMillis must be greater than 0");
        if (options.exportTimeoutMillis !== void 0 && options.exportTimeoutMillis <= 0)
          throw Error("exportTimeoutMillis must be greater than 0");
        if (options.exportTimeoutMillis !== void 0 && options.exportIntervalMillis !== void 0 && options.exportIntervalMillis < options.exportTimeoutMillis)
          throw Error("exportIntervalMillis must be greater than or equal to exportTimeoutMillis");
        this._exportInterval = (_c = options.exportIntervalMillis) !== null && _c !== void 0 ? _c : 6e4, this._exportTimeout = (_d = options.exportTimeoutMillis) !== null && _d !== void 0 ? _d : 3e4, this._exporter = options.exporter;
      }
      async _runOnce() {
        try {
          await (0, utils_1.callWithTimeout)(this._doRun(), this._exportTimeout);
        } catch (err) {
          if (err instanceof utils_1.TimeoutError) {
            api.diag.error("Export took longer than %s milliseconds and timed out.", this._exportTimeout);
            return;
          }
          (0, core_1.globalErrorHandler)(err);
        }
      }
      async _doRun() {
        var _a, _b;
        let { resourceMetrics, errors } = await this.collect({
          timeoutMillis: this._exportTimeout
        });
        if (errors.length > 0 && api.diag.error("PeriodicExportingMetricReader: metrics collection errors", ...errors), resourceMetrics.resource.asyncAttributesPending)
          try {
            await ((_b = (_a = resourceMetrics.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a));
          } catch (e) {
            api.diag.debug("Error while resolving async portion of resource: ", e), (0, core_1.globalErrorHandler)(e);
          }
        let result = await core_1.internal._export(this._exporter, resourceMetrics);
        if (result.code !== core_1.ExportResultCode.SUCCESS)
          throw new Error(`PeriodicExportingMetricReader: metrics export failed (error ${result.error})`);
      }
      onInitialized() {
        this._interval = setInterval(() => {
          this._runOnce();
        }, this._exportInterval), (0, core_1.unrefTimer)(this._interval);
      }
      async onForceFlush() {
        await this._runOnce(), await this._exporter.forceFlush();
      }
      async onShutdown() {
        this._interval && clearInterval(this._interval), await this.onForceFlush(), await this._exporter.shutdown();
      }
    };
    exports2.PeriodicExportingMetricReader = PeriodicExportingMetricReader;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js
var require_InMemoryMetricExporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/InMemoryMetricExporter.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.InMemoryMetricExporter = void 0;
    var core_1 = require_src(), InMemoryMetricExporter = class {
      constructor(aggregationTemporality) {
        this._shutdown = !1, this._metrics = [], this._aggregationTemporality = aggregationTemporality;
      }
      /**
       * @inheritedDoc
       */
      export(metrics2, resultCallback) {
        if (this._shutdown) {
          setTimeout(() => resultCallback({ code: core_1.ExportResultCode.FAILED }), 0);
          return;
        }
        this._metrics.push(metrics2), setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      /**
       * Returns all the collected resource metrics
       * @returns ResourceMetrics[]
       */
      getMetrics() {
        return this._metrics;
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._metrics = [];
      }
      selectAggregationTemporality(_instrumentType) {
        return this._aggregationTemporality;
      }
      shutdown() {
        return this._shutdown = !0, Promise.resolve();
      }
    };
    exports2.InMemoryMetricExporter = InMemoryMetricExporter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js
var require_ConsoleMetricExporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/export/ConsoleMetricExporter.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ConsoleMetricExporter = void 0;
    var core_1 = require_src(), AggregationSelector_1 = require_AggregationSelector(), ConsoleMetricExporter2 = class _ConsoleMetricExporter {
      constructor(options) {
        var _a;
        this._shutdown = !1, this._temporalitySelector = (_a = options?.temporalitySelector) !== null && _a !== void 0 ? _a : AggregationSelector_1.DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;
      }
      export(metrics2, resultCallback) {
        if (this._shutdown) {
          setImmediate(resultCallback, { code: core_1.ExportResultCode.FAILED });
          return;
        }
        return _ConsoleMetricExporter._sendMetrics(metrics2, resultCallback);
      }
      forceFlush() {
        return Promise.resolve();
      }
      selectAggregationTemporality(_instrumentType) {
        return this._temporalitySelector(_instrumentType);
      }
      shutdown() {
        return this._shutdown = !0, Promise.resolve();
      }
      static _sendMetrics(metrics2, done) {
        for (let scopeMetrics of metrics2.scopeMetrics)
          for (let metric of scopeMetrics.metrics)
            console.dir({
              descriptor: metric.descriptor,
              dataPointType: metric.dataPointType,
              dataPoints: metric.dataPoints
            }, { depth: null });
        done({ code: core_1.ExportResultCode.SUCCESS });
      }
    };
    exports2.ConsoleMetricExporter = ConsoleMetricExporter2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports2.defaultServiceName = defaultServiceName;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.defaultServiceName = void 0;
    var default_service_name_1 = require_default_service_name();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: !0, get: function() {
      return default_service_name_1.defaultServiceName;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.defaultServiceName = void 0;
    var node_1 = require_node2();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: !0, get: function() {
      return node_1.defaultServiceName;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/Resource.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Resource = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), core_1 = require_src(), platform_1 = require_platform2(), Resource2 = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a;
        this._attributes = attributes, this.asyncAttributesPending = asyncAttributesPromise != null, this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {}, this._asyncAttributesPromise = asyncAttributesPromise?.then((asyncAttributes) => (this._attributes = Object.assign({}, this._attributes, asyncAttributes), this.asyncAttributesPending = !1, asyncAttributes), (err) => (api_1.diag.debug("a resource's async attributes promise rejected: %s", err), this.asyncAttributesPending = !1, {}));
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SEMRESATTRS_SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a;
        return this.asyncAttributesPending && api_1.diag.error("Accessing resource attributes before async attributes settled"), (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        this.asyncAttributesPending && await this._asyncAttributesPromise;
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a;
        if (!other)
          return this;
        let mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise)
          return new _Resource(mergedSyncAttributes);
        let mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a2;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports2.Resource = Resource2;
    Resource2.EMPTY = new Resource2({});
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js
var require_utils3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.normalizeType = exports2.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports2.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports2.normalizeType = normalizeType;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/execAsync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.execAsync = void 0;
    var child_process = __require("child_process"), util = __require("util");
    exports2.execAsync = util.promisify(child_process.exec);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-darwin.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMachineId = void 0;
    var execAsync_1 = require_execAsync(), api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        let idLine = (await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"')).stdout.split(`
`).find((line) => line.includes("IOPlatformUUID"));
        if (!idLine)
          return "";
        let parts = idLine.split('" = "');
        if (parts.length === 2)
          return parts[1].slice(0, -1);
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-linux.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMachineId = void 0;
    var fs_1 = __require("fs"), api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      let paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (let path of paths)
        try {
          return (await fs_1.promises.readFile(path, { encoding: "utf8" })).trim();
        } catch (e) {
          api_1.diag.debug(`error reading machine id: ${e}`);
        }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-bsd.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMachineId = void 0;
    var fs_1 = __require("fs"), execAsync_1 = require_execAsync(), api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      try {
        return (await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" })).trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      try {
        return (await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid")).stdout.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-win.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMachineId = void 0;
    var process2 = __require("process"), execAsync_1 = require_execAsync(), api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      let args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid", command = "%windir%\\System32\\REG.exe";
      process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env && (command = "%windir%\\sysnative\\cmd.exe /c " + command);
      try {
        let parts = (await (0, execAsync_1.execAsync)(`${command} ${args}`)).stdout.split("REG_SZ");
        if (parts.length === 2)
          return parts[1].trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId-unsupported.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMachineId = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    async function getMachineId() {
      return api_1.diag.debug("could not read machine-id: unsupported platform"), "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/machine-id/getMachineId.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getMachineId = void 0;
    var process2 = __require("process"), getMachineId;
    exports2.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports2.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
        break;
      case "linux":
        exports2.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
        break;
      case "freebsd":
        exports2.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
        break;
      case "win32":
        exports2.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
        break;
      default:
        exports2.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetectorSync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.hostDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), Resource_1 = require_Resource(), os_1 = __require("os"), utils_1 = require_utils3(), getMachineId_1 = require_getMachineId(), HostDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SEMRESATTRS_HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SEMRESATTRS_HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          let attributes = {};
          return machineId && (attributes[semantic_conventions_1.SEMRESATTRS_HOST_ID] = machineId), attributes;
        });
      }
    };
    exports2.hostDetectorSync = new HostDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js
var require_HostDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/HostDetector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync(), HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports2.hostDetector = new HostDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetectorSync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.osDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), Resource_1 = require_Resource(), os_1 = __require("os"), utils_1 = require_utils3(), OSDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SEMRESATTRS_OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SEMRESATTRS_OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.osDetectorSync = new OSDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js
var require_OSDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/OSDetector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync(), OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports2.osDetector = new OSDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetectorSync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.processDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), Resource_1 = require_Resource(), os = __require("os"), ProcessDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_PID]: process.pid,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        process.argv.length > 1 && (attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_COMMAND] = process.argv[1]);
        try {
          let userInfo = os.userInfo();
          attributes[semantic_conventions_1.SEMRESATTRS_PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.processDetectorSync = new ProcessDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ProcessDetector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync(), ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports2.processDetector = new ProcessDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js
var require_ServiceInstanceIdDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/ServiceInstanceIdDetectorSync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.serviceInstanceIdDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), Resource_1 = require_Resource(), crypto_1 = __require("crypto"), ServiceInstanceIdDetectorSync = class {
      detect(_config) {
        let attributes = {
          [semantic_conventions_1.SEMRESATTRS_SERVICE_INSTANCE_ID]: (0, crypto_1.randomUUID)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.serviceInstanceIdDetectorSync = new ServiceInstanceIdDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js
var require_node3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/node/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var HostDetector_1 = require_HostDetector();
    Object.defineProperty(exports2, "hostDetector", { enumerable: !0, get: function() {
      return HostDetector_1.hostDetector;
    } });
    var HostDetectorSync_1 = require_HostDetectorSync();
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: !0, get: function() {
      return HostDetectorSync_1.hostDetectorSync;
    } });
    var OSDetector_1 = require_OSDetector();
    Object.defineProperty(exports2, "osDetector", { enumerable: !0, get: function() {
      return OSDetector_1.osDetector;
    } });
    var OSDetectorSync_1 = require_OSDetectorSync();
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: !0, get: function() {
      return OSDetectorSync_1.osDetectorSync;
    } });
    var ProcessDetector_1 = require_ProcessDetector();
    Object.defineProperty(exports2, "processDetector", { enumerable: !0, get: function() {
      return ProcessDetector_1.processDetector;
    } });
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: !0, get: function() {
      return ProcessDetectorSync_1.processDetectorSync;
    } });
    var ServiceInstanceIdDetectorSync_1 = require_ServiceInstanceIdDetectorSync();
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: !0, get: function() {
      return ServiceInstanceIdDetectorSync_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js
var require_platform3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/platform/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var node_1 = require_node3();
    Object.defineProperty(exports2, "hostDetector", { enumerable: !0, get: function() {
      return node_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: !0, get: function() {
      return node_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: !0, get: function() {
      return node_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: !0, get: function() {
      return node_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: !0, get: function() {
      return node_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: !0, get: function() {
      return node_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: !0, get: function() {
      return node_1.serviceInstanceIdDetectorSync;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.browserDetectorSync = void 0;
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), api_1 = (init_esm(), __toCommonJS(esm_exports)), Resource_1 = require_Resource(), BrowserDetectorSync = class {
      detect(config) {
        var _a, _b, _c;
        if (!(typeof navigator < "u" && ((_b = (_a = global.process) === null || _a === void 0 ? void 0 : _a.versions) === null || _b === void 0 ? void 0 : _b.node) === void 0 && // Node.js v21 adds `navigator`
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore don't have Bun types
        ((_c = global.Bun) === null || _c === void 0 ? void 0 : _c.version) === void 0))
          return Resource_1.Resource.empty();
        let browserResource = {
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        return browserResource[semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_VERSION] === "" ? (api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. "), Resource_1.Resource.empty()) : new Resource_1.Resource(Object.assign({}, browserResource));
      }
    };
    exports2.browserDetectorSync = new BrowserDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.browserDetector = void 0;
    var BrowserDetectorSync_1 = require_BrowserDetectorSync(), BrowserDetector = class {
      detect(config) {
        return Promise.resolve(BrowserDetectorSync_1.browserDetectorSync.detect(config));
      }
    };
    exports2.browserDetector = new BrowserDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.envDetectorSync = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), core_1 = require_src(), semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2)), Resource_1 = require_Resource(), EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255, this._COMMA_SEPARATOR = ",", this._LABEL_KEY_VALUE_SPLITTER = "=", this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.", this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        let attributes = {}, env = (0, core_1.getEnv)(), rawAttributes = env.OTEL_RESOURCE_ATTRIBUTES, serviceName = env.OTEL_SERVICE_NAME;
        if (rawAttributes)
          try {
            let parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e) {
            api_1.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        return serviceName && (attributes[semantic_conventions_1.SEMRESATTRS_SERVICE_NAME] = serviceName), new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. “key1=val1,key2=val2”. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespace, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-separated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        let attributes = {}, rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (let rawAttribute of rawAttributes) {
          let keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2)
            continue;
          let [key, value] = keyValuePair;
          if (key = key.trim(), value = value.trim().split(/^"|"$/).join(""), !this._isValidAndNotEmpty(key))
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          if (!this._isValid(value))
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isBaggageOctetString(name);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          let ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126)
            return !1;
        }
        return !0;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports2.envDetectorSync = new EnvDetectorSync();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync(), EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports2.envDetector = new EnvDetector();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.envDetectorSync = exports2.browserDetectorSync = exports2.envDetector = exports2.browserDetector = exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = void 0;
    var platform_1 = require_platform3();
    Object.defineProperty(exports2, "hostDetector", { enumerable: !0, get: function() {
      return platform_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: !0, get: function() {
      return platform_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: !0, get: function() {
      return platform_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: !0, get: function() {
      return platform_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: !0, get: function() {
      return platform_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: !0, get: function() {
      return platform_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: !0, get: function() {
      return platform_1.serviceInstanceIdDetectorSync;
    } });
    var BrowserDetector_1 = require_BrowserDetector();
    Object.defineProperty(exports2, "browserDetector", { enumerable: !0, get: function() {
      return BrowserDetector_1.browserDetector;
    } });
    var EnvDetector_1 = require_EnvDetector();
    Object.defineProperty(exports2, "envDetector", { enumerable: !0, get: function() {
      return EnvDetector_1.envDetector;
    } });
    var BrowserDetectorSync_1 = require_BrowserDetectorSync();
    Object.defineProperty(exports2, "browserDetectorSync", { enumerable: !0, get: function() {
      return BrowserDetectorSync_1.browserDetectorSync;
    } });
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    Object.defineProperty(exports2, "envDetectorSync", { enumerable: !0, get: function() {
      return EnvDetectorSync_1.envDetectorSync;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isPromiseLike = void 0;
    var isPromiseLike = (val) => val !== null && typeof val == "object" && typeof val.then == "function";
    exports2.isPromiseLike = isPromiseLike;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.detectResourcesSync = exports2.detectResources = void 0;
    var Resource_1 = require_Resource(), api_1 = (init_esm(), __toCommonJS(esm_exports)), utils_1 = require_utils4(), detectResources = async (config = {}) => {
      let resources = await Promise.all((config.detectors || []).map(async (d) => {
        try {
          let resource = await d.detect(config);
          return api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }));
      return logResources(resources), resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports2.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a;
      let resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map((d) => {
        try {
          let resourceOrPromise = d.detect(config), resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            let createPromise = async () => {
              var _a2;
              let resolvedResource = await resourceOrPromise;
              return await ((_a2 = resolvedResource.waitForAsyncAttributes) === null || _a2 === void 0 ? void 0 : _a2.call(resolvedResource)), resolvedResource.attributes;
            };
            resource = new Resource_1.Resource({}, createPromise());
          } else
            resource = resourceOrPromise;
          return resource.waitForAsyncAttributes ? resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource)) : api_1.diag.debug(`${d.constructor.name} found resource.`, resource), resource;
        } catch (e) {
          return api_1.diag.error(`${d.constructor.name} failed: ${e.message}`), Resource_1.Resource.empty();
        }
      }), mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      return mergedResources.waitForAsyncAttributes && mergedResources.waitForAsyncAttributes().then(() => {
        logResources(resources);
      }), mergedResources;
    };
    exports2.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          let resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+resources@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/src/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.detectResources = exports2.detectResourcesSync = exports2.serviceInstanceIdDetectorSync = exports2.processDetectorSync = exports2.processDetector = exports2.osDetectorSync = exports2.osDetector = exports2.hostDetectorSync = exports2.hostDetector = exports2.envDetectorSync = exports2.envDetector = exports2.browserDetectorSync = exports2.browserDetector = exports2.defaultServiceName = exports2.Resource = void 0;
    var Resource_1 = require_Resource();
    Object.defineProperty(exports2, "Resource", { enumerable: !0, get: function() {
      return Resource_1.Resource;
    } });
    var platform_1 = require_platform2();
    Object.defineProperty(exports2, "defaultServiceName", { enumerable: !0, get: function() {
      return platform_1.defaultServiceName;
    } });
    var detectors_1 = require_detectors();
    Object.defineProperty(exports2, "browserDetector", { enumerable: !0, get: function() {
      return detectors_1.browserDetector;
    } });
    Object.defineProperty(exports2, "browserDetectorSync", { enumerable: !0, get: function() {
      return detectors_1.browserDetectorSync;
    } });
    Object.defineProperty(exports2, "envDetector", { enumerable: !0, get: function() {
      return detectors_1.envDetector;
    } });
    Object.defineProperty(exports2, "envDetectorSync", { enumerable: !0, get: function() {
      return detectors_1.envDetectorSync;
    } });
    Object.defineProperty(exports2, "hostDetector", { enumerable: !0, get: function() {
      return detectors_1.hostDetector;
    } });
    Object.defineProperty(exports2, "hostDetectorSync", { enumerable: !0, get: function() {
      return detectors_1.hostDetectorSync;
    } });
    Object.defineProperty(exports2, "osDetector", { enumerable: !0, get: function() {
      return detectors_1.osDetector;
    } });
    Object.defineProperty(exports2, "osDetectorSync", { enumerable: !0, get: function() {
      return detectors_1.osDetectorSync;
    } });
    Object.defineProperty(exports2, "processDetector", { enumerable: !0, get: function() {
      return detectors_1.processDetector;
    } });
    Object.defineProperty(exports2, "processDetectorSync", { enumerable: !0, get: function() {
      return detectors_1.processDetectorSync;
    } });
    Object.defineProperty(exports2, "serviceInstanceIdDetectorSync", { enumerable: !0, get: function() {
      return detectors_1.serviceInstanceIdDetectorSync;
    } });
    var detect_resources_1 = require_detect_resources();
    Object.defineProperty(exports2, "detectResourcesSync", { enumerable: !0, get: function() {
      return detect_resources_1.detectResourcesSync;
    } });
    Object.defineProperty(exports2, "detectResources", { enumerable: !0, get: function() {
      return detect_resources_1.detectResources;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js
var require_ViewRegistry = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/ViewRegistry.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ViewRegistry = void 0;
    var ViewRegistry = class {
      constructor() {
        this._registeredViews = [];
      }
      addView(view) {
        this._registeredViews.push(view);
      }
      findViews(instrument, meter) {
        return this._registeredViews.filter((registeredView) => this._matchInstrument(registeredView.instrumentSelector, instrument) && this._matchMeter(registeredView.meterSelector, meter));
      }
      _matchInstrument(selector, instrument) {
        return (selector.getType() === void 0 || instrument.type === selector.getType()) && selector.getNameFilter().match(instrument.name) && selector.getUnitFilter().match(instrument.unit);
      }
      _matchMeter(selector, meter) {
        return selector.getNameFilter().match(meter.name) && (meter.version === void 0 || selector.getVersionFilter().match(meter.version)) && (meter.schemaUrl === void 0 || selector.getSchemaUrlFilter().match(meter.schemaUrl));
      }
    };
    exports2.ViewRegistry = ViewRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js
var require_Instruments = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/Instruments.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.isObservableInstrument = exports2.ObservableUpDownCounterInstrument = exports2.ObservableGaugeInstrument = exports2.ObservableCounterInstrument = exports2.ObservableInstrument = exports2.HistogramInstrument = exports2.GaugeInstrument = exports2.CounterInstrument = exports2.UpDownCounterInstrument = exports2.SyncInstrument = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), core_1 = require_src(), SyncInstrument = class {
      constructor(_writableMetricStorage, _descriptor) {
        this._writableMetricStorage = _writableMetricStorage, this._descriptor = _descriptor;
      }
      _record(value, attributes = {}, context2 = api_1.context.active()) {
        if (typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._descriptor.name}: ${value}`);
          return;
        }
        this._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || this._writableMetricStorage.record(value, attributes, context2, (0, core_1.millisToHrTime)(Date.now()));
      }
    };
    exports2.SyncInstrument = SyncInstrument;
    var UpDownCounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may be negative.
       */
      add(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports2.UpDownCounterInstrument = UpDownCounterInstrument;
    var CounterInstrument = class extends SyncInstrument {
      /**
       * Increment value of counter by the input. Inputs may not be negative.
       */
      add(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to counter ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports2.CounterInstrument = CounterInstrument;
    var GaugeInstrument = class extends SyncInstrument {
      /**
       * Records a measurement.
       */
      record(value, attributes, ctx) {
        this._record(value, attributes, ctx);
      }
    };
    exports2.GaugeInstrument = GaugeInstrument;
    var HistogramInstrument = class extends SyncInstrument {
      /**
       * Records a measurement. Value of the measurement must not be negative.
       */
      record(value, attributes, ctx) {
        if (value < 0) {
          api_1.diag.warn(`negative value provided to histogram ${this._descriptor.name}: ${value}`);
          return;
        }
        this._record(value, attributes, ctx);
      }
    };
    exports2.HistogramInstrument = HistogramInstrument;
    var ObservableInstrument = class {
      constructor(descriptor, metricStorages, _observableRegistry) {
        this._observableRegistry = _observableRegistry, this._descriptor = descriptor, this._metricStorages = metricStorages;
      }
      /**
       * @see {Observable.addCallback}
       */
      addCallback(callback) {
        this._observableRegistry.addCallback(callback, this);
      }
      /**
       * @see {Observable.removeCallback}
       */
      removeCallback(callback) {
        this._observableRegistry.removeCallback(callback, this);
      }
    };
    exports2.ObservableInstrument = ObservableInstrument;
    var ObservableCounterInstrument = class extends ObservableInstrument {
    };
    exports2.ObservableCounterInstrument = ObservableCounterInstrument;
    var ObservableGaugeInstrument = class extends ObservableInstrument {
    };
    exports2.ObservableGaugeInstrument = ObservableGaugeInstrument;
    var ObservableUpDownCounterInstrument = class extends ObservableInstrument {
    };
    exports2.ObservableUpDownCounterInstrument = ObservableUpDownCounterInstrument;
    function isObservableInstrument(it) {
      return it instanceof ObservableInstrument;
    }
    exports2.isObservableInstrument = isObservableInstrument;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js
var require_Meter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/Meter.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.Meter = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), Instruments_1 = require_Instruments(), Meter = class {
      constructor(_meterSharedState) {
        this._meterSharedState = _meterSharedState;
      }
      /**
       * Create a {@link Gauge} instrument.
       */
      createGauge(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.GAUGE, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.GaugeInstrument(storage, descriptor);
      }
      /**
       * Create a {@link Histogram} instrument.
       */
      createHistogram(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.HISTOGRAM, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.HistogramInstrument(storage, descriptor);
      }
      /**
       * Create a {@link Counter} instrument.
       */
      createCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.COUNTER, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.CounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link UpDownCounter} instrument.
       */
      createUpDownCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.UP_DOWN_COUNTER, options), storage = this._meterSharedState.registerMetricStorage(descriptor);
        return new Instruments_1.UpDownCounterInstrument(storage, descriptor);
      }
      /**
       * Create a {@link ObservableGauge} instrument.
       */
      createObservableGauge(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_GAUGE, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableGaugeInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableCounter} instrument.
       */
      createObservableCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_COUNTER, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * Create a {@link ObservableUpDownCounter} instrument.
       */
      createObservableUpDownCounter(name, options) {
        let descriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(name, InstrumentDescriptor_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER, options), storages = this._meterSharedState.registerAsyncMetricStorage(descriptor);
        return new Instruments_1.ObservableUpDownCounterInstrument(descriptor, storages, this._meterSharedState.observableRegistry);
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.addBatchCallback(callback, observables);
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(callback, observables) {
        this._meterSharedState.observableRegistry.removeBatchCallback(callback, observables);
      }
    };
    exports2.Meter = Meter;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js
var require_MetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorage.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MetricStorage = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), MetricStorage = class {
      constructor(_instrumentDescriptor) {
        this._instrumentDescriptor = _instrumentDescriptor;
      }
      getInstrumentDescriptor() {
        return this._instrumentDescriptor;
      }
      updateDescription(description) {
        this._instrumentDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptor)(this._instrumentDescriptor.name, this._instrumentDescriptor.type, {
          description,
          valueType: this._instrumentDescriptor.valueType,
          unit: this._instrumentDescriptor.unit,
          advice: this._instrumentDescriptor.advice
        });
      }
    };
    exports2.MetricStorage = MetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js
var require_HashMap = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/HashMap.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AttributeHashMap = exports2.HashMap = void 0;
    var utils_1 = require_utils(), HashMap = class {
      constructor(_hash) {
        this._hash = _hash, this._valueMap = /* @__PURE__ */ new Map(), this._keyMap = /* @__PURE__ */ new Map();
      }
      get(key, hashCode) {
        return hashCode ?? (hashCode = this._hash(key)), this._valueMap.get(hashCode);
      }
      getOrDefault(key, defaultFactory) {
        let hash = this._hash(key);
        if (this._valueMap.has(hash))
          return this._valueMap.get(hash);
        let val = defaultFactory();
        return this._keyMap.has(hash) || this._keyMap.set(hash, key), this._valueMap.set(hash, val), val;
      }
      set(key, value, hashCode) {
        hashCode ?? (hashCode = this._hash(key)), this._keyMap.has(hashCode) || this._keyMap.set(hashCode, key), this._valueMap.set(hashCode, value);
      }
      has(key, hashCode) {
        return hashCode ?? (hashCode = this._hash(key)), this._valueMap.has(hashCode);
      }
      *keys() {
        let keyIterator = this._keyMap.entries(), next = keyIterator.next();
        for (; next.done !== !0; )
          yield [next.value[1], next.value[0]], next = keyIterator.next();
      }
      *entries() {
        let valueIterator = this._valueMap.entries(), next = valueIterator.next();
        for (; next.done !== !0; )
          yield [this._keyMap.get(next.value[0]), next.value[1], next.value[0]], next = valueIterator.next();
      }
      get size() {
        return this._valueMap.size;
      }
    };
    exports2.HashMap = HashMap;
    var AttributeHashMap = class extends HashMap {
      constructor() {
        super(utils_1.hashAttributes);
      }
    };
    exports2.AttributeHashMap = AttributeHashMap;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js
var require_DeltaMetricProcessor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/DeltaMetricProcessor.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DeltaMetricProcessor = void 0;
    var utils_1 = require_utils(), HashMap_1 = require_HashMap(), DeltaMetricProcessor = class {
      constructor(_aggregator, aggregationCardinalityLimit) {
        this._aggregator = _aggregator, this._activeCollectionStorage = new HashMap_1.AttributeHashMap(), this._cumulativeMemoStorage = new HashMap_1.AttributeHashMap(), this._overflowAttributes = { "otel.metric.overflow": !0 }, this._cardinalityLimit = (aggregationCardinalityLimit ?? 2e3) - 1, this._overflowHashCode = (0, utils_1.hashAttributes)(this._overflowAttributes);
      }
      record(value, attributes, _context, collectionTime) {
        let accumulation = this._activeCollectionStorage.get(attributes);
        if (!accumulation) {
          if (this._activeCollectionStorage.size >= this._cardinalityLimit) {
            let overflowAccumulation = this._activeCollectionStorage.getOrDefault(this._overflowAttributes, () => this._aggregator.createAccumulation(collectionTime));
            overflowAccumulation?.record(value);
            return;
          }
          accumulation = this._aggregator.createAccumulation(collectionTime), this._activeCollectionStorage.set(attributes, accumulation);
        }
        accumulation?.record(value);
      }
      batchCumulate(measurements, collectionTime) {
        Array.from(measurements.entries()).forEach(([attributes, value, hashCode]) => {
          let accumulation = this._aggregator.createAccumulation(collectionTime);
          accumulation?.record(value);
          let delta = accumulation;
          if (this._cumulativeMemoStorage.has(attributes, hashCode)) {
            let previous = this._cumulativeMemoStorage.get(attributes, hashCode);
            delta = this._aggregator.diff(previous, accumulation);
          } else if (this._cumulativeMemoStorage.size >= this._cardinalityLimit && (attributes = this._overflowAttributes, hashCode = this._overflowHashCode, this._cumulativeMemoStorage.has(attributes, hashCode))) {
            let previous = this._cumulativeMemoStorage.get(attributes, hashCode);
            delta = this._aggregator.diff(previous, accumulation);
          }
          if (this._activeCollectionStorage.has(attributes, hashCode)) {
            let active = this._activeCollectionStorage.get(attributes, hashCode);
            delta = this._aggregator.merge(active, delta);
          }
          this._cumulativeMemoStorage.set(attributes, accumulation, hashCode), this._activeCollectionStorage.set(attributes, delta, hashCode);
        });
      }
      /**
       * Returns a collection of delta metrics. Start time is the when first
       * time event collected.
       */
      collect() {
        let unreportedDelta = this._activeCollectionStorage;
        return this._activeCollectionStorage = new HashMap_1.AttributeHashMap(), unreportedDelta;
      }
    };
    exports2.DeltaMetricProcessor = DeltaMetricProcessor;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js
var require_TemporalMetricProcessor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/TemporalMetricProcessor.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TemporalMetricProcessor = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality(), HashMap_1 = require_HashMap(), TemporalMetricProcessor = class _TemporalMetricProcessor {
      constructor(_aggregator, collectorHandles) {
        this._aggregator = _aggregator, this._unreportedAccumulations = /* @__PURE__ */ new Map(), this._reportHistory = /* @__PURE__ */ new Map(), collectorHandles.forEach((handle) => {
          this._unreportedAccumulations.set(handle, []);
        });
      }
      /**
       * Builds the {@link MetricData} streams to report against a specific MetricCollector.
       * @param collector The information of the MetricCollector.
       * @param collectors The registered collectors.
       * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.
       * @param currentAccumulations The current accumulation of metric data from instruments.
       * @param collectionTime The current collection timestamp.
       * @returns The {@link MetricData} points or `null`.
       */
      buildMetrics(collector, instrumentDescriptor, currentAccumulations, collectionTime) {
        this._stashAccumulations(currentAccumulations);
        let unreportedAccumulations = this._getMergedUnreportedAccumulations(collector), result = unreportedAccumulations, aggregationTemporality;
        if (this._reportHistory.has(collector)) {
          let last = this._reportHistory.get(collector), lastCollectionTime = last.collectionTime;
          aggregationTemporality = last.aggregationTemporality, aggregationTemporality === AggregationTemporality_1.AggregationTemporality.CUMULATIVE ? result = _TemporalMetricProcessor.merge(last.accumulations, unreportedAccumulations, this._aggregator) : result = _TemporalMetricProcessor.calibrateStartTime(last.accumulations, unreportedAccumulations, lastCollectionTime);
        } else
          aggregationTemporality = collector.selectAggregationTemporality(instrumentDescriptor.type);
        this._reportHistory.set(collector, {
          accumulations: result,
          collectionTime,
          aggregationTemporality
        });
        let accumulationRecords = AttributesMapToAccumulationRecords(result);
        if (accumulationRecords.length !== 0)
          return this._aggregator.toMetricData(
            instrumentDescriptor,
            aggregationTemporality,
            accumulationRecords,
            /* endTime */
            collectionTime
          );
      }
      _stashAccumulations(currentAccumulation) {
        let registeredCollectors = this._unreportedAccumulations.keys();
        for (let collector of registeredCollectors) {
          let stash = this._unreportedAccumulations.get(collector);
          stash === void 0 && (stash = [], this._unreportedAccumulations.set(collector, stash)), stash.push(currentAccumulation);
        }
      }
      _getMergedUnreportedAccumulations(collector) {
        let result = new HashMap_1.AttributeHashMap(), unreportedList = this._unreportedAccumulations.get(collector);
        if (this._unreportedAccumulations.set(collector, []), unreportedList === void 0)
          return result;
        for (let it of unreportedList)
          result = _TemporalMetricProcessor.merge(result, it, this._aggregator);
        return result;
      }
      static merge(last, current, aggregator) {
        let result = last, iterator = current.entries(), next = iterator.next();
        for (; next.done !== !0; ) {
          let [key, record, hash] = next.value;
          if (last.has(key, hash)) {
            let lastAccumulation = last.get(key, hash), accumulation = aggregator.merge(lastAccumulation, record);
            result.set(key, accumulation, hash);
          } else
            result.set(key, record, hash);
          next = iterator.next();
        }
        return result;
      }
      /**
       * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves
       * the new stream to be the initial observation time unchanged.
       */
      static calibrateStartTime(last, current, lastCollectionTime) {
        for (let [key, hash] of last.keys()) {
          let currentAccumulation = current.get(key, hash);
          currentAccumulation?.setStartTime(lastCollectionTime);
        }
        return current;
      }
    };
    exports2.TemporalMetricProcessor = TemporalMetricProcessor;
    function AttributesMapToAccumulationRecords(map) {
      return Array.from(map.entries());
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js
var require_AsyncMetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/AsyncMetricStorage.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AsyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage(), DeltaMetricProcessor_1 = require_DeltaMetricProcessor(), TemporalMetricProcessor_1 = require_TemporalMetricProcessor(), HashMap_1 = require_HashMap(), AsyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(_instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
        super(_instrumentDescriptor), this._attributesProcessor = _attributesProcessor, this._aggregationCardinalityLimit = _aggregationCardinalityLimit, this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator, this._aggregationCardinalityLimit), this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(measurements, observationTime) {
        let processed = new HashMap_1.AttributeHashMap();
        Array.from(measurements.entries()).forEach(([attributes, value]) => {
          processed.set(this._attributesProcessor.process(attributes), value);
        }), this._deltaMetricStorage.batchCumulate(processed, observationTime);
      }
      /**
       * Collects the metrics from this storage. The ObservableCallback is invoked
       * during the collection.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        let accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports2.AsyncMetricStorage = AsyncMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js
var require_RegistrationConflicts = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/RegistrationConflicts.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getConflictResolutionRecipe = exports2.getDescriptionResolutionRecipe = exports2.getTypeConflictResolutionRecipe = exports2.getUnitConflictResolutionRecipe = exports2.getValueTypeConflictResolutionRecipe = exports2.getIncompatibilityDetails = void 0;
    function getIncompatibilityDetails(existing, otherDescriptor) {
      let incompatibility = "";
      return existing.unit !== otherDescriptor.unit && (incompatibility += `	- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'
`), existing.type !== otherDescriptor.type && (incompatibility += `	- Type '${existing.type}' does not match '${otherDescriptor.type}'
`), existing.valueType !== otherDescriptor.valueType && (incompatibility += `	- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'
`), existing.description !== otherDescriptor.description && (incompatibility += `	- Description '${existing.description}' does not match '${otherDescriptor.description}'
`), incompatibility;
    }
    exports2.getIncompatibilityDetails = getIncompatibilityDetails;
    function getValueTypeConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports2.getValueTypeConflictResolutionRecipe = getValueTypeConflictResolutionRecipe;
    function getUnitConflictResolutionRecipe(existing, otherDescriptor) {
      return `	- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;
    }
    exports2.getUnitConflictResolutionRecipe = getUnitConflictResolutionRecipe;
    function getTypeConflictResolutionRecipe(existing, otherDescriptor) {
      let selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      }, selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;
    }
    exports2.getTypeConflictResolutionRecipe = getTypeConflictResolutionRecipe;
    function getDescriptionResolutionRecipe(existing, otherDescriptor) {
      let selector = {
        name: otherDescriptor.name,
        type: otherDescriptor.type,
        unit: otherDescriptor.unit
      }, selectorString = JSON.stringify(selector);
      return `	- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'
    	- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}
    	- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;
    }
    exports2.getDescriptionResolutionRecipe = getDescriptionResolutionRecipe;
    function getConflictResolutionRecipe(existing, otherDescriptor) {
      return existing.valueType !== otherDescriptor.valueType ? getValueTypeConflictResolutionRecipe(existing, otherDescriptor) : existing.unit !== otherDescriptor.unit ? getUnitConflictResolutionRecipe(existing, otherDescriptor) : existing.type !== otherDescriptor.type ? getTypeConflictResolutionRecipe(existing, otherDescriptor) : existing.description !== otherDescriptor.description ? getDescriptionResolutionRecipe(existing, otherDescriptor) : "";
    }
    exports2.getConflictResolutionRecipe = getConflictResolutionRecipe;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js
var require_MetricStorageRegistry = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricStorageRegistry.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MetricStorageRegistry = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), api = (init_esm(), __toCommonJS(esm_exports)), RegistrationConflicts_1 = require_RegistrationConflicts(), MetricStorageRegistry = class _MetricStorageRegistry {
      constructor() {
        this._sharedRegistry = /* @__PURE__ */ new Map(), this._perCollectorRegistry = /* @__PURE__ */ new Map();
      }
      static create() {
        return new _MetricStorageRegistry();
      }
      getStorages(collector) {
        let storages = [];
        for (let metricStorages of this._sharedRegistry.values())
          storages = storages.concat(metricStorages);
        let perCollectorStorages = this._perCollectorRegistry.get(collector);
        if (perCollectorStorages != null)
          for (let metricStorages of perCollectorStorages.values())
            storages = storages.concat(metricStorages);
        return storages;
      }
      register(storage) {
        this._registerStorage(storage, this._sharedRegistry);
      }
      registerForCollector(collector, storage) {
        let storageMap = this._perCollectorRegistry.get(collector);
        storageMap == null && (storageMap = /* @__PURE__ */ new Map(), this._perCollectorRegistry.set(collector, storageMap)), this._registerStorage(storage, storageMap);
      }
      findOrUpdateCompatibleStorage(expectedDescriptor) {
        let storages = this._sharedRegistry.get(expectedDescriptor.name);
        return storages === void 0 ? null : this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      findOrUpdateCompatibleCollectorStorage(collector, expectedDescriptor) {
        let storageMap = this._perCollectorRegistry.get(collector);
        if (storageMap === void 0)
          return null;
        let storages = storageMap.get(expectedDescriptor.name);
        return storages === void 0 ? null : this._findOrUpdateCompatibleStorage(expectedDescriptor, storages);
      }
      _registerStorage(storage, storageMap) {
        let descriptor = storage.getInstrumentDescriptor(), storages = storageMap.get(descriptor.name);
        if (storages === void 0) {
          storageMap.set(descriptor.name, [storage]);
          return;
        }
        storages.push(storage);
      }
      _findOrUpdateCompatibleStorage(expectedDescriptor, existingStorages) {
        let compatibleStorage = null;
        for (let existingStorage of existingStorages) {
          let existingDescriptor = existingStorage.getInstrumentDescriptor();
          (0, InstrumentDescriptor_1.isDescriptorCompatibleWith)(existingDescriptor, expectedDescriptor) ? (existingDescriptor.description !== expectedDescriptor.description && (expectedDescriptor.description.length > existingDescriptor.description.length && existingStorage.updateDescription(expectedDescriptor.description), api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered, but has a different description and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `The longer description will be used.
To resolve the conflict:`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor))), compatibleStorage = existingStorage) : api.diag.warn("A view or instrument with the name ", expectedDescriptor.name, ` has already been registered and is incompatible with another registered view.
`, `Details:
`, (0, RegistrationConflicts_1.getIncompatibilityDetails)(existingDescriptor, expectedDescriptor), `To resolve the conflict:
`, (0, RegistrationConflicts_1.getConflictResolutionRecipe)(existingDescriptor, expectedDescriptor));
        }
        return compatibleStorage;
      }
    };
    exports2.MetricStorageRegistry = MetricStorageRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js
var require_MultiWritableMetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MultiWritableMetricStorage.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MultiMetricStorage = void 0;
    var MultiMetricStorage = class {
      constructor(_backingStorages) {
        this._backingStorages = _backingStorages;
      }
      record(value, attributes, context2, recordTime) {
        this._backingStorages.forEach((it) => {
          it.record(value, attributes, context2, recordTime);
        });
      }
    };
    exports2.MultiMetricStorage = MultiMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js
var require_ObservableResult = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/ObservableResult.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.BatchObservableResultImpl = exports2.ObservableResultImpl = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), HashMap_1 = require_HashMap(), Instruments_1 = require_Instruments(), ObservableResultImpl = class {
      constructor(_instrumentName, _valueType) {
        this._instrumentName = _instrumentName, this._valueType = _valueType, this._buffer = new HashMap_1.AttributeHashMap();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(value, attributes = {}) {
        if (typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${this._instrumentName}: ${value}`);
          return;
        }
        this._valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || this._buffer.set(attributes, value);
      }
    };
    exports2.ObservableResultImpl = ObservableResultImpl;
    var BatchObservableResultImpl = class {
      constructor() {
        this._buffer = /* @__PURE__ */ new Map();
      }
      /**
       * Observe a measurement of the value associated with the given attributes.
       */
      observe(metric, value, attributes = {}) {
        if (!(0, Instruments_1.isObservableInstrument)(metric))
          return;
        let map = this._buffer.get(metric);
        if (map == null && (map = new HashMap_1.AttributeHashMap(), this._buffer.set(metric, map)), typeof value != "number") {
          api_1.diag.warn(`non-number value provided to metric ${metric._descriptor.name}: ${value}`);
          return;
        }
        metric._descriptor.valueType === api_1.ValueType.INT && !Number.isInteger(value) && (api_1.diag.warn(`INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`), value = Math.trunc(value), !Number.isInteger(value)) || map.set(attributes, value);
      }
    };
    exports2.BatchObservableResultImpl = BatchObservableResultImpl;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js
var require_ObservableRegistry = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/ObservableRegistry.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ObservableRegistry = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), Instruments_1 = require_Instruments(), ObservableResult_1 = require_ObservableResult(), utils_1 = require_utils(), ObservableRegistry = class {
      constructor() {
        this._callbacks = [], this._batchCallbacks = [];
      }
      addCallback(callback, instrument) {
        this._findCallback(callback, instrument) >= 0 || this._callbacks.push({ callback, instrument });
      }
      removeCallback(callback, instrument) {
        let idx = this._findCallback(callback, instrument);
        idx < 0 || this._callbacks.splice(idx, 1);
      }
      addBatchCallback(callback, instruments) {
        let observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument));
        if (observableInstruments.size === 0) {
          api_1.diag.error("BatchObservableCallback is not associated with valid instruments", instruments);
          return;
        }
        this._findBatchCallback(callback, observableInstruments) >= 0 || this._batchCallbacks.push({ callback, instruments: observableInstruments });
      }
      removeBatchCallback(callback, instruments) {
        let observableInstruments = new Set(instruments.filter(Instruments_1.isObservableInstrument)), idx = this._findBatchCallback(callback, observableInstruments);
        idx < 0 || this._batchCallbacks.splice(idx, 1);
      }
      /**
       * @returns a promise of rejected reasons for invoking callbacks.
       */
      async observe(collectionTime, timeoutMillis) {
        let callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis), batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);
        return (await (0, utils_1.PromiseAllSettled)([
          ...callbackFutures,
          ...batchCallbackFutures
        ])).filter(utils_1.isPromiseAllSettledRejectionResult).map((it) => it.reason);
      }
      _observeCallbacks(observationTime, timeoutMillis) {
        return this._callbacks.map(async ({ callback, instrument }) => {
          let observableResult = new ObservableResult_1.ObservableResultImpl(instrument._descriptor.name, instrument._descriptor.valueType), callPromise = Promise.resolve(callback(observableResult));
          timeoutMillis != null && (callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis)), await callPromise, instrument._metricStorages.forEach((metricStorage) => {
            metricStorage.record(observableResult._buffer, observationTime);
          });
        });
      }
      _observeBatchCallbacks(observationTime, timeoutMillis) {
        return this._batchCallbacks.map(async ({ callback, instruments }) => {
          let observableResult = new ObservableResult_1.BatchObservableResultImpl(), callPromise = Promise.resolve(callback(observableResult));
          timeoutMillis != null && (callPromise = (0, utils_1.callWithTimeout)(callPromise, timeoutMillis)), await callPromise, instruments.forEach((instrument) => {
            let buffer = observableResult._buffer.get(instrument);
            buffer != null && instrument._metricStorages.forEach((metricStorage) => {
              metricStorage.record(buffer, observationTime);
            });
          });
        });
      }
      _findCallback(callback, instrument) {
        return this._callbacks.findIndex((record) => record.callback === callback && record.instrument === instrument);
      }
      _findBatchCallback(callback, instruments) {
        return this._batchCallbacks.findIndex((record) => record.callback === callback && (0, utils_1.setEquals)(record.instruments, instruments));
      }
    };
    exports2.ObservableRegistry = ObservableRegistry;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js
var require_SyncMetricStorage = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/SyncMetricStorage.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.SyncMetricStorage = void 0;
    var MetricStorage_1 = require_MetricStorage(), DeltaMetricProcessor_1 = require_DeltaMetricProcessor(), TemporalMetricProcessor_1 = require_TemporalMetricProcessor(), SyncMetricStorage = class extends MetricStorage_1.MetricStorage {
      constructor(instrumentDescriptor, aggregator, _attributesProcessor, collectorHandles, _aggregationCardinalityLimit) {
        super(instrumentDescriptor), this._attributesProcessor = _attributesProcessor, this._aggregationCardinalityLimit = _aggregationCardinalityLimit, this._deltaMetricStorage = new DeltaMetricProcessor_1.DeltaMetricProcessor(aggregator, this._aggregationCardinalityLimit), this._temporalMetricStorage = new TemporalMetricProcessor_1.TemporalMetricProcessor(aggregator, collectorHandles);
      }
      record(value, attributes, context2, recordTime) {
        attributes = this._attributesProcessor.process(attributes, context2), this._deltaMetricStorage.record(value, attributes, context2, recordTime);
      }
      /**
       * Collects the metrics from this storage.
       *
       * Note: This is a stateful operation and may reset any interval-related
       * state for the MetricCollector.
       */
      collect(collector, collectionTime) {
        let accumulations = this._deltaMetricStorage.collect();
        return this._temporalMetricStorage.buildMetrics(collector, this._instrumentDescriptor, accumulations, collectionTime);
      }
    };
    exports2.SyncMetricStorage = SyncMetricStorage;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js
var require_AttributesProcessor = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/AttributesProcessor.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.FilteringAttributesProcessor = exports2.NoopAttributesProcessor = exports2.AttributesProcessor = void 0;
    var AttributesProcessor = class {
      static Noop() {
        return NOOP;
      }
    };
    exports2.AttributesProcessor = AttributesProcessor;
    var NoopAttributesProcessor = class extends AttributesProcessor {
      process(incoming, _context) {
        return incoming;
      }
    };
    exports2.NoopAttributesProcessor = NoopAttributesProcessor;
    var FilteringAttributesProcessor = class extends AttributesProcessor {
      constructor(_allowedAttributeNames) {
        super(), this._allowedAttributeNames = _allowedAttributeNames;
      }
      process(incoming, _context) {
        let filteredAttributes = {};
        return Object.keys(incoming).filter((attributeName) => this._allowedAttributeNames.includes(attributeName)).forEach((attributeName) => filteredAttributes[attributeName] = incoming[attributeName]), filteredAttributes;
      }
    };
    exports2.FilteringAttributesProcessor = FilteringAttributesProcessor;
    var NOOP = new NoopAttributesProcessor();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js
var require_MeterSharedState = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterSharedState.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MeterSharedState = void 0;
    var InstrumentDescriptor_1 = require_InstrumentDescriptor(), Meter_1 = require_Meter(), utils_1 = require_utils(), AsyncMetricStorage_1 = require_AsyncMetricStorage(), MetricStorageRegistry_1 = require_MetricStorageRegistry(), MultiWritableMetricStorage_1 = require_MultiWritableMetricStorage(), ObservableRegistry_1 = require_ObservableRegistry(), SyncMetricStorage_1 = require_SyncMetricStorage(), AttributesProcessor_1 = require_AttributesProcessor(), MeterSharedState = class {
      constructor(_meterProviderSharedState, _instrumentationScope) {
        this._meterProviderSharedState = _meterProviderSharedState, this._instrumentationScope = _instrumentationScope, this.metricStorageRegistry = new MetricStorageRegistry_1.MetricStorageRegistry(), this.observableRegistry = new ObservableRegistry_1.ObservableRegistry(), this.meter = new Meter_1.Meter(this);
      }
      registerMetricStorage(descriptor) {
        let storages = this._registerMetricStorage(descriptor, SyncMetricStorage_1.SyncMetricStorage);
        return storages.length === 1 ? storages[0] : new MultiWritableMetricStorage_1.MultiMetricStorage(storages);
      }
      registerAsyncMetricStorage(descriptor) {
        return this._registerMetricStorage(descriptor, AsyncMetricStorage_1.AsyncMetricStorage);
      }
      /**
       * @param collector opaque handle of {@link MetricCollector} which initiated the collection.
       * @param collectionTime the HrTime at which the collection was initiated.
       * @param options options for collection.
       * @returns the list of metric data collected.
       */
      async collect(collector, collectionTime, options) {
        let errors = await this.observableRegistry.observe(collectionTime, options?.timeoutMillis), storages = this.metricStorageRegistry.getStorages(collector);
        if (storages.length === 0)
          return null;
        let metricDataList = storages.map((metricStorage) => metricStorage.collect(collector, collectionTime)).filter(utils_1.isNotNullish);
        return metricDataList.length === 0 ? { errors } : {
          scopeMetrics: {
            scope: this._instrumentationScope,
            metrics: metricDataList
          },
          errors
        };
      }
      _registerMetricStorage(descriptor, MetricStorageType) {
        let storages = this._meterProviderSharedState.viewRegistry.findViews(descriptor, this._instrumentationScope).map((view) => {
          let viewDescriptor = (0, InstrumentDescriptor_1.createInstrumentDescriptorWithView)(view, descriptor), compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleStorage(viewDescriptor);
          if (compatibleStorage != null)
            return compatibleStorage;
          let aggregator = view.aggregation.createAggregator(viewDescriptor), viewStorage = new MetricStorageType(viewDescriptor, aggregator, view.attributesProcessor, this._meterProviderSharedState.metricCollectors, view.aggregationCardinalityLimit);
          return this.metricStorageRegistry.register(viewStorage), viewStorage;
        });
        if (storages.length === 0) {
          let collectorStorages = this._meterProviderSharedState.selectAggregations(descriptor.type).map(([collector, aggregation]) => {
            let compatibleStorage = this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage(collector, descriptor);
            if (compatibleStorage != null)
              return compatibleStorage;
            let aggregator = aggregation.createAggregator(descriptor), cardinalityLimit = collector.selectCardinalityLimit(descriptor.type), storage = new MetricStorageType(descriptor, aggregator, AttributesProcessor_1.AttributesProcessor.Noop(), [collector], cardinalityLimit);
            return this.metricStorageRegistry.registerForCollector(collector, storage), storage;
          });
          storages = storages.concat(collectorStorages);
        }
        return storages;
      }
    };
    exports2.MeterSharedState = MeterSharedState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js
var require_MeterProviderSharedState = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MeterProviderSharedState.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MeterProviderSharedState = void 0;
    var utils_1 = require_utils(), ViewRegistry_1 = require_ViewRegistry(), MeterSharedState_1 = require_MeterSharedState(), MeterProviderSharedState = class {
      constructor(resource) {
        this.resource = resource, this.viewRegistry = new ViewRegistry_1.ViewRegistry(), this.metricCollectors = [], this.meterSharedStates = /* @__PURE__ */ new Map();
      }
      getMeterSharedState(instrumentationScope2) {
        let id = (0, utils_1.instrumentationScopeId)(instrumentationScope2), meterSharedState = this.meterSharedStates.get(id);
        return meterSharedState == null && (meterSharedState = new MeterSharedState_1.MeterSharedState(this, instrumentationScope2), this.meterSharedStates.set(id, meterSharedState)), meterSharedState;
      }
      selectAggregations(instrumentType) {
        let result = [];
        for (let collector of this.metricCollectors)
          result.push([collector, collector.selectAggregation(instrumentType)]);
        return result;
      }
    };
    exports2.MeterProviderSharedState = MeterProviderSharedState;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js
var require_MetricCollector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/state/MetricCollector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MetricCollector = void 0;
    var core_1 = require_src(), MetricCollector = class {
      constructor(_sharedState, _metricReader) {
        this._sharedState = _sharedState, this._metricReader = _metricReader;
      }
      async collect(options) {
        let collectionTime = (0, core_1.millisToHrTime)(Date.now()), scopeMetrics = [], errors = [], meterCollectionPromises = Array.from(this._sharedState.meterSharedStates.values()).map(async (meterSharedState) => {
          let current = await meterSharedState.collect(this, collectionTime, options);
          current?.scopeMetrics != null && scopeMetrics.push(current.scopeMetrics), current?.errors != null && errors.push(...current.errors);
        });
        return await Promise.all(meterCollectionPromises), {
          resourceMetrics: {
            resource: this._sharedState.resource,
            scopeMetrics
          },
          errors
        };
      }
      /**
       * Delegates for MetricReader.forceFlush.
       */
      async forceFlush(options) {
        await this._metricReader.forceFlush(options);
      }
      /**
       * Delegates for MetricReader.shutdown.
       */
      async shutdown(options) {
        await this._metricReader.shutdown(options);
      }
      selectAggregationTemporality(instrumentType) {
        return this._metricReader.selectAggregationTemporality(instrumentType);
      }
      selectAggregation(instrumentType) {
        return this._metricReader.selectAggregation(instrumentType);
      }
      /**
       * Select the cardinality limit for the given {@link InstrumentType} for this
       * collector.
       */
      selectCardinalityLimit(instrumentType) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this._metricReader).selectCardinalityLimit) === null || _b === void 0 ? void 0 : _b.call(_a, instrumentType)) !== null && _c !== void 0 ? _c : 2e3;
      }
    };
    exports2.MetricCollector = MetricCollector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js
var require_MeterProvider = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/MeterProvider.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MeterProvider = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), resources_1 = require_src2(), MeterProviderSharedState_1 = require_MeterProviderSharedState(), MetricCollector_1 = require_MetricCollector();
    function prepareResource(mergeWithDefaults, providedResource) {
      let resource = providedResource ?? resources_1.Resource.empty();
      return mergeWithDefaults ? resources_1.Resource.default().merge(resource) : resource;
    }
    var MeterProvider2 = class {
      constructor(options) {
        var _a;
        if (this._shutdown = !1, this._sharedState = new MeterProviderSharedState_1.MeterProviderSharedState(prepareResource((_a = options?.mergeResourceWithDefaults) !== null && _a !== void 0 ? _a : !0, options?.resource)), options?.views != null && options.views.length > 0)
          for (let view of options.views)
            this._sharedState.viewRegistry.addView(view);
        if (options?.readers != null && options.readers.length > 0)
          for (let metricReader of options.readers)
            this.addMetricReader(metricReader);
      }
      /**
       * Get a meter with the configuration of the MeterProvider.
       */
      getMeter(name, version = "", options = {}) {
        return this._shutdown ? (api_1.diag.warn("A shutdown MeterProvider cannot provide a Meter"), (0, api_1.createNoopMeter)()) : this._sharedState.getMeterSharedState({
          name,
          version,
          schemaUrl: options.schemaUrl
        }).meter;
      }
      /**
       * Register a {@link MetricReader} to the meter provider. After the
       * registration, the MetricReader can start metrics collection.
       *
       * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.
       * A {@link MetricReader} instance registered later may receive no or incomplete metric data.
       *
       * @param metricReader the metric reader to be registered.
       *
       * @deprecated This method will be removed in SDK 2.0. Please use
       * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead
       */
      addMetricReader(metricReader) {
        let collector = new MetricCollector_1.MetricCollector(this._sharedState, metricReader);
        metricReader.setMetricProducer(collector), this._sharedState.metricCollectors.push(collector);
      }
      /**
       * Shut down the MeterProvider and all registered
       * MetricReaders.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async shutdown(options) {
        if (this._shutdown) {
          api_1.diag.warn("shutdown may only be called once per MeterProvider");
          return;
        }
        this._shutdown = !0, await Promise.all(this._sharedState.metricCollectors.map((collector) => collector.shutdown(options)));
      }
      /**
       * Notifies all registered MetricReaders to flush any buffered data.
       *
       * Returns a promise which is resolved when all flushes are complete.
       */
      async forceFlush(options) {
        if (this._shutdown) {
          api_1.diag.warn("invalid attempt to force flush after MeterProvider shutdown");
          return;
        }
        await Promise.all(this._sharedState.metricCollectors.map((collector) => collector.forceFlush(options)));
      }
    };
    exports2.MeterProvider = MeterProvider2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js
var require_Predicate = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/Predicate.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ExactPredicate = exports2.PatternPredicate = void 0;
    var ESCAPE = /[\^$\\.+?()[\]{}|]/g, PatternPredicate = class _PatternPredicate {
      constructor(pattern) {
        pattern === "*" ? (this._matchAll = !0, this._regexp = /.*/) : (this._matchAll = !1, this._regexp = new RegExp(_PatternPredicate.escapePattern(pattern)));
      }
      match(str) {
        return this._matchAll ? !0 : this._regexp.test(str);
      }
      static escapePattern(pattern) {
        return `^${pattern.replace(ESCAPE, "\\$&").replace("*", ".*")}$`;
      }
      static hasWildcard(pattern) {
        return pattern.includes("*");
      }
    };
    exports2.PatternPredicate = PatternPredicate;
    var ExactPredicate = class {
      constructor(pattern) {
        this._matchAll = pattern === void 0, this._pattern = pattern;
      }
      match(str) {
        return !!(this._matchAll || str === this._pattern);
      }
    };
    exports2.ExactPredicate = ExactPredicate;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js
var require_InstrumentSelector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/InstrumentSelector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.InstrumentSelector = void 0;
    var Predicate_1 = require_Predicate(), InstrumentSelector = class {
      constructor(criteria) {
        var _a;
        this._nameFilter = new Predicate_1.PatternPredicate((_a = criteria?.name) !== null && _a !== void 0 ? _a : "*"), this._type = criteria?.type, this._unitFilter = new Predicate_1.ExactPredicate(criteria?.unit);
      }
      getType() {
        return this._type;
      }
      getNameFilter() {
        return this._nameFilter;
      }
      getUnitFilter() {
        return this._unitFilter;
      }
    };
    exports2.InstrumentSelector = InstrumentSelector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js
var require_MeterSelector = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/MeterSelector.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MeterSelector = void 0;
    var Predicate_1 = require_Predicate(), MeterSelector = class {
      constructor(criteria) {
        this._nameFilter = new Predicate_1.ExactPredicate(criteria?.name), this._versionFilter = new Predicate_1.ExactPredicate(criteria?.version), this._schemaUrlFilter = new Predicate_1.ExactPredicate(criteria?.schemaUrl);
      }
      getNameFilter() {
        return this._nameFilter;
      }
      /**
       * TODO: semver filter? no spec yet.
       */
      getVersionFilter() {
        return this._versionFilter;
      }
      getSchemaUrlFilter() {
        return this._schemaUrlFilter;
      }
    };
    exports2.MeterSelector = MeterSelector;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js
var require_View = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/view/View.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.View = void 0;
    var Predicate_1 = require_Predicate(), AttributesProcessor_1 = require_AttributesProcessor(), InstrumentSelector_1 = require_InstrumentSelector(), MeterSelector_1 = require_MeterSelector(), Aggregation_1 = require_Aggregation();
    function isSelectorNotProvided(options) {
      return options.instrumentName == null && options.instrumentType == null && options.instrumentUnit == null && options.meterName == null && options.meterVersion == null && options.meterSchemaUrl == null;
    }
    var View2 = class {
      /**
       * Create a new {@link View} instance.
       *
       * Parameters can be categorized as two types:
       *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.
       *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).
       *
       *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.
       *
       * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.
       * @param viewOptions.name
       * Alters the metric stream:
       *  This will be used as the name of the metrics stream.
       *  If not provided, the original Instrument name will be used.
       * @param viewOptions.description
       * Alters the metric stream:
       *  This will be used as the description of the metrics stream.
       *  If not provided, the original Instrument description will be used by default.
       * @param viewOptions.attributeKeys
       * Alters the metric stream:
       *  If provided, the attributes that are not in the list will be ignored.
       *  If not provided, all attribute keys will be used by default.
       * @param viewOptions.aggregationCardinalityLimit
       * Alters the metric stream:
       *  Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.
       *  If not provided, the default limit of 2000 will be used.
       * @param viewOptions.aggregation
       * Alters the metric stream:
       *  Alters the {@link Aggregation} of the metric stream.
       * @param viewOptions.instrumentName
       * Instrument selection criteria:
       *  Original name of the Instrument(s) with wildcard support.
       * @param viewOptions.instrumentType
       * Instrument selection criteria:
       *  The original type of the Instrument(s).
       * @param viewOptions.instrumentUnit
       * Instrument selection criteria:
       *  The unit of the Instrument(s).
       * @param viewOptions.meterName
       * Instrument selection criteria:
       *  The name of the Meter. No wildcard support, name must match the meter exactly.
       * @param viewOptions.meterVersion
       * Instrument selection criteria:
       *  The version of the Meter. No wildcard support, version must match exactly.
       * @param viewOptions.meterSchemaUrl
       * Instrument selection criteria:
       *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.
       *
       * @example
       * // Create a view that changes the Instrument 'my.instrument' to use to an
       * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]
       * new View({
       *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),
       *   instrumentName: 'my.instrument'
       * })
       */
      constructor(viewOptions) {
        var _a;
        if (isSelectorNotProvided(viewOptions))
          throw new Error("Cannot create view with no selector arguments supplied");
        if (viewOptions.name != null && (viewOptions?.instrumentName == null || Predicate_1.PatternPredicate.hasWildcard(viewOptions.instrumentName)))
          throw new Error("Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.");
        viewOptions.attributeKeys != null ? this.attributesProcessor = new AttributesProcessor_1.FilteringAttributesProcessor(viewOptions.attributeKeys) : this.attributesProcessor = AttributesProcessor_1.AttributesProcessor.Noop(), this.name = viewOptions.name, this.description = viewOptions.description, this.aggregation = (_a = viewOptions.aggregation) !== null && _a !== void 0 ? _a : Aggregation_1.Aggregation.Default(), this.instrumentSelector = new InstrumentSelector_1.InstrumentSelector({
          name: viewOptions.instrumentName,
          type: viewOptions.instrumentType,
          unit: viewOptions.instrumentUnit
        }), this.meterSelector = new MeterSelector_1.MeterSelector({
          name: viewOptions.meterName,
          version: viewOptions.meterVersion,
          schemaUrl: viewOptions.meterSchemaUrl
        }), this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;
      }
    };
    exports2.View = View2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+sdk-metrics@1.30.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-metrics/build/src/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.TimeoutError = exports2.View = exports2.Aggregation = exports2.SumAggregation = exports2.LastValueAggregation = exports2.HistogramAggregation = exports2.DropAggregation = exports2.ExponentialHistogramAggregation = exports2.ExplicitBucketHistogramAggregation = exports2.DefaultAggregation = exports2.MeterProvider = exports2.InstrumentType = exports2.ConsoleMetricExporter = exports2.InMemoryMetricExporter = exports2.PeriodicExportingMetricReader = exports2.MetricReader = exports2.DataPointType = exports2.AggregationTemporality = void 0;
    var AggregationTemporality_1 = require_AggregationTemporality();
    Object.defineProperty(exports2, "AggregationTemporality", { enumerable: !0, get: function() {
      return AggregationTemporality_1.AggregationTemporality;
    } });
    var MetricData_1 = require_MetricData();
    Object.defineProperty(exports2, "DataPointType", { enumerable: !0, get: function() {
      return MetricData_1.DataPointType;
    } });
    var MetricReader_1 = require_MetricReader();
    Object.defineProperty(exports2, "MetricReader", { enumerable: !0, get: function() {
      return MetricReader_1.MetricReader;
    } });
    var PeriodicExportingMetricReader_1 = require_PeriodicExportingMetricReader();
    Object.defineProperty(exports2, "PeriodicExportingMetricReader", { enumerable: !0, get: function() {
      return PeriodicExportingMetricReader_1.PeriodicExportingMetricReader;
    } });
    var InMemoryMetricExporter_1 = require_InMemoryMetricExporter();
    Object.defineProperty(exports2, "InMemoryMetricExporter", { enumerable: !0, get: function() {
      return InMemoryMetricExporter_1.InMemoryMetricExporter;
    } });
    var ConsoleMetricExporter_1 = require_ConsoleMetricExporter();
    Object.defineProperty(exports2, "ConsoleMetricExporter", { enumerable: !0, get: function() {
      return ConsoleMetricExporter_1.ConsoleMetricExporter;
    } });
    var InstrumentDescriptor_1 = require_InstrumentDescriptor();
    Object.defineProperty(exports2, "InstrumentType", { enumerable: !0, get: function() {
      return InstrumentDescriptor_1.InstrumentType;
    } });
    var MeterProvider_1 = require_MeterProvider();
    Object.defineProperty(exports2, "MeterProvider", { enumerable: !0, get: function() {
      return MeterProvider_1.MeterProvider;
    } });
    var Aggregation_1 = require_Aggregation();
    Object.defineProperty(exports2, "DefaultAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.DefaultAggregation;
    } });
    Object.defineProperty(exports2, "ExplicitBucketHistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.ExplicitBucketHistogramAggregation;
    } });
    Object.defineProperty(exports2, "ExponentialHistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.ExponentialHistogramAggregation;
    } });
    Object.defineProperty(exports2, "DropAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.DropAggregation;
    } });
    Object.defineProperty(exports2, "HistogramAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.HistogramAggregation;
    } });
    Object.defineProperty(exports2, "LastValueAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.LastValueAggregation;
    } });
    Object.defineProperty(exports2, "SumAggregation", { enumerable: !0, get: function() {
      return Aggregation_1.SumAggregation;
    } });
    Object.defineProperty(exports2, "Aggregation", { enumerable: !0, get: function() {
      return Aggregation_1.Aggregation;
    } });
    var View_1 = require_View();
    Object.defineProperty(exports2, "View", { enumerable: !0, get: function() {
      return View_1.View;
    } });
    var utils_1 = require_utils();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: !0, get: function() {
      return utils_1.TimeoutError;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterOptions.js
var require_OTLPMetricExporterOptions = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterOptions.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.AggregationTemporalityPreference = void 0;
    var AggregationTemporalityPreference;
    (function(AggregationTemporalityPreference2) {
      AggregationTemporalityPreference2[AggregationTemporalityPreference2.DELTA = 0] = "DELTA", AggregationTemporalityPreference2[AggregationTemporalityPreference2.CUMULATIVE = 1] = "CUMULATIVE", AggregationTemporalityPreference2[AggregationTemporalityPreference2.LOWMEMORY = 2] = "LOWMEMORY";
    })(AggregationTemporalityPreference = exports2.AggregationTemporalityPreference || (exports2.AggregationTemporalityPreference = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js
var OTLPExporterBase, init_OTLPExporterBase = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js"() {
    init_cjs_shims();
    OTLPExporterBase = /** @class */
    function() {
      function OTLPExporterBase2(_delegate) {
        this._delegate = _delegate;
      }
      return OTLPExporterBase2.prototype.export = function(items, resultCallback) {
        this._delegate.export(items, resultCallback);
      }, OTLPExporterBase2.prototype.forceFlush = function() {
        return this._delegate.forceFlush();
      }, OTLPExporterBase2.prototype.shutdown = function() {
        return this._delegate.shutdown();
      }, OTLPExporterBase2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js
var __extends2, OTLPExporterError, init_types2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js"() {
    init_cjs_shims();
    __extends2 = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) Object.prototype.hasOwnProperty.call(b2, p) && (d2[p] = b2[p]);
        }, extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b != "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }(), OTLPExporterError = /** @class */
    function(_super) {
      __extends2(OTLPExporterError2, _super);
      function OTLPExporterError2(message, code, data) {
        var _this = _super.call(this, message) || this;
        return _this.name = "OTLPExporterError", _this.data = data, _this.code = code, _this;
      }
      return OTLPExporterError2;
    }(Error);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-configuration.js
function validateTimeoutMillis(timeoutMillis) {
  if (!Number.isNaN(timeoutMillis) && Number.isFinite(timeoutMillis) && timeoutMillis > 0)
    return timeoutMillis;
  throw new Error("Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '" + timeoutMillis + "')");
}
function wrapStaticHeadersInFunction(headers) {
  if (headers != null)
    return function() {
      return headers;
    };
}
function mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
  var _a, _b, _c, _d, _e, _f;
  return {
    timeoutMillis: validateTimeoutMillis((_b = (_a = userProvidedConfiguration.timeoutMillis) !== null && _a !== void 0 ? _a : fallbackConfiguration.timeoutMillis) !== null && _b !== void 0 ? _b : defaultConfiguration.timeoutMillis),
    concurrencyLimit: (_d = (_c = userProvidedConfiguration.concurrencyLimit) !== null && _c !== void 0 ? _c : fallbackConfiguration.concurrencyLimit) !== null && _d !== void 0 ? _d : defaultConfiguration.concurrencyLimit,
    compression: (_f = (_e = userProvidedConfiguration.compression) !== null && _e !== void 0 ? _e : fallbackConfiguration.compression) !== null && _f !== void 0 ? _f : defaultConfiguration.compression
  };
}
function getSharedConfigurationDefaults() {
  return {
    timeoutMillis: 1e4,
    concurrencyLimit: 30,
    compression: "none"
  };
}
var init_shared_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-configuration.js"() {
    init_cjs_shims();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/legacy-node-configuration.js
var CompressionAlgorithm, init_legacy_node_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/legacy-node-configuration.js"() {
    init_cjs_shims();
    (function(CompressionAlgorithm2) {
      CompressionAlgorithm2.NONE = "none", CompressionAlgorithm2.GZIP = "gzip";
    })(CompressionAlgorithm || (CompressionAlgorithm = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/bounded-queue-export-promise-handler.js
function createBoundedQueueExportPromiseHandler(options) {
  return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);
}
var __awaiter, __generator, BoundedQueueExportPromiseHandler, init_bounded_queue_export_promise_handler = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/bounded-queue-export-promise-handler.js"() {
    init_cjs_shims();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        for (; _; ) try {
          if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              return _.label++, { value: op[1], done: !1 };
            case 5:
              _.label++, y = op[1], op = [0];
              continue;
            case 7:
              op = _.ops.pop(), _.trys.pop();
              continue;
            default:
              if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1], t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2], _.ops.push(op);
                break;
              }
              t[2] && _.ops.pop(), _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e], y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, BoundedQueueExportPromiseHandler = /** @class */
    function() {
      function BoundedQueueExportPromiseHandler2(concurrencyLimit) {
        this._sendingPromises = [], this._concurrencyLimit = concurrencyLimit;
      }
      return BoundedQueueExportPromiseHandler2.prototype.pushPromise = function(promise) {
        var _this = this;
        if (this.hasReachedLimit())
          throw new Error("Concurrency Limit reached");
        this._sendingPromises.push(promise);
        var popPromise = function() {
          var index = _this._sendingPromises.indexOf(promise);
          _this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
      }, BoundedQueueExportPromiseHandler2.prototype.hasReachedLimit = function() {
        return this._sendingPromises.length >= this._concurrencyLimit;
      }, BoundedQueueExportPromiseHandler2.prototype.awaitAll = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, Promise.all(this._sendingPromises)];
              case 1:
                return _a.sent(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, BoundedQueueExportPromiseHandler2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/logging-response-handler.js
function isPartialSuccessResponse(response) {
  return Object.prototype.hasOwnProperty.call(response, "partialSuccess");
}
function createLoggingPartialSuccessResponseHandler() {
  return {
    handleResponse: function(response) {
      response == null || !isPartialSuccessResponse(response) || response.partialSuccess == null || Object.keys(response.partialSuccess).length === 0 || diag2.warn("Received Partial Success response:", JSON.stringify(response.partialSuccess));
    }
  };
}
var init_logging_response_handler = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/logging-response-handler.js"() {
    init_cjs_shims();
    init_esm();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-export-delegate.js
function createOtlpExportDelegate(components, settings) {
  return new OTLPExportDelegate(components.transport, components.serializer, createLoggingPartialSuccessResponseHandler(), components.promiseHandler, settings.timeout);
}
var import_core2, __awaiter2, __generator2, OTLPExportDelegate, init_otlp_export_delegate = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-export-delegate.js"() {
    init_cjs_shims();
    import_core2 = __toESM(require_src());
    init_types2();
    init_logging_response_handler();
    init_esm();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator2 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        for (; _; ) try {
          if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              return _.label++, { value: op[1], done: !1 };
            case 5:
              _.label++, y = op[1], op = [0];
              continue;
            case 7:
              op = _.ops.pop(), _.trys.pop();
              continue;
            default:
              if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1], t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2], _.ops.push(op);
                break;
              }
              t[2] && _.ops.pop(), _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e], y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, OTLPExportDelegate = /** @class */
    function() {
      function OTLPExportDelegate2(_transport, _serializer, _responseHandler, _promiseQueue, _timeout) {
        this._transport = _transport, this._serializer = _serializer, this._responseHandler = _responseHandler, this._promiseQueue = _promiseQueue, this._timeout = _timeout, this._diagLogger = diag2.createComponentLogger({
          namespace: "OTLPExportDelegate"
        });
      }
      return OTLPExportDelegate2.prototype.export = function(internalRepresentation, resultCallback) {
        var _this = this;
        if (this._diagLogger.debug("items to be sent", internalRepresentation), this._promiseQueue.hasReachedLimit()) {
          resultCallback({
            code: import_core2.ExportResultCode.FAILED,
            error: new Error("Concurrent export limit reached")
          });
          return;
        }
        var serializedRequest = this._serializer.serializeRequest(internalRepresentation);
        if (serializedRequest == null) {
          resultCallback({
            code: import_core2.ExportResultCode.FAILED,
            error: new Error("Nothing to send")
          });
          return;
        }
        this._promiseQueue.pushPromise(this._transport.send(serializedRequest, this._timeout).then(function(response) {
          if (response.status === "success") {
            if (response.data != null)
              try {
                _this._responseHandler.handleResponse(_this._serializer.deserializeResponse(response.data));
              } catch (e) {
                _this._diagLogger.warn("Export succeeded but could not deserialize response - is the response specification compliant?", e, response.data);
              }
            resultCallback({
              code: import_core2.ExportResultCode.SUCCESS
            });
            return;
          } else if (response.status === "failure" && response.error) {
            resultCallback({
              code: import_core2.ExportResultCode.FAILED,
              error: response.error
            });
            return;
          } else response.status === "retryable" ? resultCallback({
            code: import_core2.ExportResultCode.FAILED,
            error: new OTLPExporterError("Export failed with retryable status")
          }) : resultCallback({
            code: import_core2.ExportResultCode.FAILED,
            error: new OTLPExporterError("Export failed with unknown error")
          });
        }, function(reason) {
          return resultCallback({
            code: import_core2.ExportResultCode.FAILED,
            error: reason
          });
        }));
      }, OTLPExportDelegate2.prototype.forceFlush = function() {
        return this._promiseQueue.awaitAll();
      }, OTLPExportDelegate2.prototype.shutdown = function() {
        return __awaiter2(this, void 0, void 0, function() {
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                return this._diagLogger.debug("shutdown started"), [4, this.forceFlush()];
              case 1:
                return _a.sent(), this._transport.shutdown(), [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, OTLPExportDelegate2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-network-export-delegate.js
function createOtlpNetworkExportDelegate(options, serializer, transport) {
  return createOtlpExportDelegate({
    transport,
    serializer,
    promiseHandler: createBoundedQueueExportPromiseHandler(options)
  }, { timeout: options.timeoutMillis });
}
var init_otlp_network_export_delegate = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-network-export-delegate.js"() {
    init_cjs_shims();
    init_bounded_queue_export_promise_handler();
    init_otlp_export_delegate();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  CompressionAlgorithm: () => CompressionAlgorithm,
  OTLPExporterBase: () => OTLPExporterBase,
  OTLPExporterError: () => OTLPExporterError,
  createOtlpNetworkExportDelegate: () => createOtlpNetworkExportDelegate,
  getSharedConfigurationDefaults: () => getSharedConfigurationDefaults,
  mergeOtlpSharedConfigurationWithDefaults: () => mergeOtlpSharedConfigurationWithDefaults
});
var init_esm3 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index.js"() {
    init_cjs_shims();
    init_OTLPExporterBase();
    init_types2();
    init_shared_configuration();
    init_legacy_node_configuration();
    init_otlp_network_export_delegate();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterBase.js
var require_OTLPMetricExporterBase = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/OTLPMetricExporterBase.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OTLPMetricExporterBase = exports2.LowMemoryTemporalitySelector = exports2.DeltaTemporalitySelector = exports2.CumulativeTemporalitySelector = void 0;
    var core_1 = require_src(), sdk_metrics_1 = require_src3(), OTLPMetricExporterOptions_1 = require_OTLPMetricExporterOptions(), otlp_exporter_base_1 = (init_esm3(), __toCommonJS(esm_exports3)), api_1 = (init_esm(), __toCommonJS(esm_exports)), CumulativeTemporalitySelector = () => sdk_metrics_1.AggregationTemporality.CUMULATIVE;
    exports2.CumulativeTemporalitySelector = CumulativeTemporalitySelector;
    var DeltaTemporalitySelector = (instrumentType) => {
      switch (instrumentType) {
        case sdk_metrics_1.InstrumentType.COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_COUNTER:
        case sdk_metrics_1.InstrumentType.GAUGE:
        case sdk_metrics_1.InstrumentType.HISTOGRAM:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_GAUGE:
          return sdk_metrics_1.AggregationTemporality.DELTA;
        case sdk_metrics_1.InstrumentType.UP_DOWN_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
          return sdk_metrics_1.AggregationTemporality.CUMULATIVE;
      }
    };
    exports2.DeltaTemporalitySelector = DeltaTemporalitySelector;
    var LowMemoryTemporalitySelector = (instrumentType) => {
      switch (instrumentType) {
        case sdk_metrics_1.InstrumentType.COUNTER:
        case sdk_metrics_1.InstrumentType.HISTOGRAM:
          return sdk_metrics_1.AggregationTemporality.DELTA;
        case sdk_metrics_1.InstrumentType.GAUGE:
        case sdk_metrics_1.InstrumentType.UP_DOWN_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_COUNTER:
        case sdk_metrics_1.InstrumentType.OBSERVABLE_GAUGE:
          return sdk_metrics_1.AggregationTemporality.CUMULATIVE;
      }
    };
    exports2.LowMemoryTemporalitySelector = LowMemoryTemporalitySelector;
    function chooseTemporalitySelectorFromEnvironment() {
      let env = (0, core_1.getEnv)(), configuredTemporality = env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE.trim().toLowerCase();
      return configuredTemporality === "cumulative" ? exports2.CumulativeTemporalitySelector : configuredTemporality === "delta" ? exports2.DeltaTemporalitySelector : configuredTemporality === "lowmemory" ? exports2.LowMemoryTemporalitySelector : (api_1.diag.warn(`OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE is set to '${env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE}', but only 'cumulative' and 'delta' are allowed. Using default ('cumulative') instead.`), exports2.CumulativeTemporalitySelector);
    }
    function chooseTemporalitySelector(temporalityPreference) {
      return temporalityPreference != null ? temporalityPreference === OTLPMetricExporterOptions_1.AggregationTemporalityPreference.DELTA ? exports2.DeltaTemporalitySelector : temporalityPreference === OTLPMetricExporterOptions_1.AggregationTemporalityPreference.LOWMEMORY ? exports2.LowMemoryTemporalitySelector : exports2.CumulativeTemporalitySelector : chooseTemporalitySelectorFromEnvironment();
    }
    function chooseAggregationSelector(config) {
      return config?.aggregationPreference ? config.aggregationPreference : (_instrumentType) => sdk_metrics_1.Aggregation.Default();
    }
    var OTLPMetricExporterBase = class extends otlp_exporter_base_1.OTLPExporterBase {
      constructor(delegate, config) {
        super(delegate), this._aggregationSelector = chooseAggregationSelector(config), this._aggregationTemporalitySelector = chooseTemporalitySelector(config?.temporalityPreference);
      }
      selectAggregation(instrumentType) {
        return this._aggregationSelector(instrumentType);
      }
      selectAggregationTemporality(instrumentType) {
        return this._aggregationTemporalitySelector(instrumentType);
      }
    };
    exports2.OTLPMetricExporterBase = OTLPMetricExporterBase;
  }
});

// ../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      for (var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = !0; index < arguments.length; )
        params[offset++] = arguments[index++];
      return new Promise(function(resolve, reject) {
        params[offset] = function(err) {
          if (pending)
            if (pending = !1, err)
              reject(err);
            else {
              for (var params2 = new Array(arguments.length - 1), offset2 = 0; offset2 < params2.length; )
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          pending && (pending = !1, reject(err));
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var base64 = exports2;
    base64.length = function(string) {
      var p = string.length;
      if (!p)
        return 0;
      for (var n = 0; --p % 4 > 1 && string.charAt(p) === "="; )
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64), s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function(buffer, start, end) {
      for (var parts = null, chunk = [], i2 = 0, j = 0, t; start < end; ) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2], t = (b & 3) << 4, j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4], t = (b & 15) << 2, j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6], chunk[i2++] = b64[b & 63], j = 0;
            break;
        }
        i2 > 8191 && ((parts || (parts = [])).push(String.fromCharCode.apply(String, chunk)), i2 = 0);
      }
      return j && (chunk[i2++] = b64[t], chunk[i2++] = 61, j === 1 && (chunk[i2++] = 61)), parts ? (i2 && parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2))), parts.join("")) : String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function(string, buffer, offset) {
      for (var start = offset, j = 0, t, i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c, j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4, t = c, j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2, t = c, j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c, j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function(evt, fn, ctx) {
      return (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      }), this;
    };
    EventEmitter.prototype.off = function(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else if (fn === void 0)
        this._listeners[evt] = [];
      else
        for (var listeners = this._listeners[evt], i = 0; i < listeners.length; )
          listeners[i].fn === fn ? listeners.splice(i, 1) : ++i;
      return this;
    };
    EventEmitter.prototype.emit = function(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        for (var args = [], i = 1; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = factory(factory);
    function factory(exports3) {
      return typeof Float32Array < "u" ? function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val, buf[pos] = f8b[0], buf[pos + 1] = f8b[1], buf[pos + 2] = f8b[2], buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val, buf[pos] = f8b[3], buf[pos + 1] = f8b[2], buf[pos + 2] = f8b[1], buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev, exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          return f8b[0] = buf[pos], f8b[1] = buf[pos + 1], f8b[2] = buf[pos + 2], f8b[3] = buf[pos + 3], f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          return f8b[3] = buf[pos], f8b[2] = buf[pos + 1], f8b[1] = buf[pos + 2], f8b[0] = buf[pos + 3], f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev, exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      }() : function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign && (val = -val), val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE), exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * (1 / 0) : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE), exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      }(), typeof Float64Array < "u" ? function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val, buf[pos] = f8b[0], buf[pos + 1] = f8b[1], buf[pos + 2] = f8b[2], buf[pos + 3] = f8b[3], buf[pos + 4] = f8b[4], buf[pos + 5] = f8b[5], buf[pos + 6] = f8b[6], buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val, buf[pos] = f8b[7], buf[pos + 1] = f8b[6], buf[pos + 2] = f8b[5], buf[pos + 3] = f8b[4], buf[pos + 4] = f8b[3], buf[pos + 5] = f8b[2], buf[pos + 6] = f8b[1], buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev, exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          return f8b[0] = buf[pos], f8b[1] = buf[pos + 1], f8b[2] = buf[pos + 2], f8b[3] = buf[pos + 3], f8b[4] = buf[pos + 4], f8b[5] = buf[pos + 5], f8b[6] = buf[pos + 6], f8b[7] = buf[pos + 7], f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          return f8b[7] = buf[pos], f8b[6] = buf[pos + 1], f8b[5] = buf[pos + 2], f8b[4] = buf[pos + 3], f8b[3] = buf[pos + 4], f8b[2] = buf[pos + 5], f8b[1] = buf[pos + 6], f8b[0] = buf[pos + 7], f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev, exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      }() : function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign && (val = -val), val === 0)
            writeUint(0, buf, pos + off0), writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          else if (isNaN(val))
            writeUint(0, buf, pos + off0), writeUint(2146959360, buf, pos + off1);
          else if (val > 17976931348623157e292)
            writeUint(0, buf, pos + off0), writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          else {
            var mantissa;
            if (val < 22250738585072014e-324)
              mantissa = val / 5e-324, writeUint(mantissa >>> 0, buf, pos + off0), writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              exponent === 1024 && (exponent = 1023), mantissa = val * Math.pow(2, -exponent), writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0), writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4), exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1), sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * (1 / 0) : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4), exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      }(), exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255, buf[pos + 1] = val >>> 8 & 255, buf[pos + 2] = val >>> 16 & 255, buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24, buf[pos + 1] = val >>> 16 & 255, buf[pos + 2] = val >>> 8 & 255, buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var utf8 = exports2;
    utf8.length = function(string) {
      for (var len = 0, c = 0, i = 0; i < string.length; ++i)
        c = string.charCodeAt(i), c < 128 ? len += 1 : c < 2048 ? len += 2 : (c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320 ? (++i, len += 4) : len += 3;
      return len;
    };
    utf8.read = function(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      for (var parts = null, chunk = [], i = 0, t; start < end; )
        t = buffer[start++], t < 128 ? chunk[i++] = t : t > 191 && t < 224 ? chunk[i++] = (t & 31) << 6 | buffer[start++] & 63 : t > 239 && t < 365 ? (t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536, chunk[i++] = 55296 + (t >> 10), chunk[i++] = 56320 + (t & 1023)) : chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63, i > 8191 && ((parts || (parts = [])).push(String.fromCharCode.apply(String, chunk)), i = 0);
      return parts ? (i && parts.push(String.fromCharCode.apply(String, chunk.slice(0, i))), parts.join("")) : String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function(string, buffer, offset) {
      for (var start = offset, c1, c2, i = 0; i < string.length; ++i)
        c1 = string.charCodeAt(i), c1 < 128 ? buffer[offset++] = c1 : c1 < 2048 ? (buffer[offset++] = c1 >> 6 | 192, buffer[offset++] = c1 & 63 | 128) : (c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320 ? (c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023), ++i, buffer[offset++] = c1 >> 18 | 240, buffer[offset++] = c1 >> 12 & 63 | 128, buffer[offset++] = c1 >> 6 & 63 | 128, buffer[offset++] = c1 & 63 | 128) : (buffer[offset++] = c1 >> 12 | 224, buffer[offset++] = c1 >> 6 & 63 | 128, buffer[offset++] = c1 & 63 | 128);
      return offset - start;
    };
  }
});

// ../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192, MAX = SIZE >>> 1, slab = null, offset = SIZE;
      return function(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        offset + size2 > SIZE && (slab = alloc(SIZE), offset = 0);
        var buf = slice.call(slab, offset, offset += size2);
        return offset & 7 && (offset = (offset | 7) + 1), buf;
      };
    }
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0, this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      sign && (value = -value);
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      return sign && (hi = ~hi >>> 0, lo = ~lo >>> 0, ++lo > 4294967295 && (lo = 0, ++hi > 4294967295 && (hi = 0))), new LongBits(lo, hi);
    };
    LongBits.from = function(value) {
      if (typeof value == "number")
        return LongBits.fromNumber(value);
      if (util.isString(value))
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        return lo || (hi = hi + 1 >>> 0), -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, !!unsigned) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!unsigned };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function(hash) {
      return hash === zeroHash ? zero : new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function() {
      var mask = this.hi >> 31;
      return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0, this.lo = (this.lo << 1 ^ mask) >>> 0, this;
    };
    LongBits.prototype.zzDecode = function() {
      var mask = -(this.lo & 1);
      return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0, this.hi = (this.hi >>> 1 ^ mask) >>> 0, this;
    };
    LongBits.prototype.length = function() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = !!(typeof global < "u" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window < "u" && window || typeof self < "u" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function(value) {
      return typeof value == "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function(value) {
      return typeof value == "string" || value instanceof String;
    };
    util.isObject = function(value) {
      return value && typeof value == "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function(obj, prop) {
      var value = obj[prop];
      return value != null && obj.hasOwnProperty(prop) ? typeof value != "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0 : !1;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function(sizeOrArray) {
      return typeof sizeOrArray == "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array > "u" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array < "u" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      return util.Long ? util.Long.fromBits(bits.lo, bits.hi, unsigned) : bits.toNumber(!!unsigned);
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        (dst[keys[i]] === void 0 || !ifNotSet) && (dst[keys[i]] = src[keys[i]]);
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, CustomError) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), properties && merge(this, properties);
      }
      return CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: !0,
          enumerable: !1,
          configurable: !0
        },
        name: {
          get: function() {
            return name;
          },
          set: void 0,
          enumerable: !1,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: !0
        },
        toString: {
          value: function() {
            return this.name + ": " + this.message;
          },
          writable: !0,
          enumerable: !1,
          configurable: !0
        }
      }), CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function(fieldNames) {
      for (var fieldMap = {}, i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          fieldNames[i] !== name && delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function(value, encoding) {
        return new Buffer2(value, encoding);
      }, util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Writer;
    var util = require_minimal(), BufferWriter, LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn, this.len = len, this.next = void 0, this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head, this.tail = writer.tail, this.len = writer.len, this.next = writer.states;
    }
    function Writer() {
      this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;
    }
    var create = function() {
      return util.Buffer ? function() {
        return (Writer.create = function() {
          return new BufferWriter();
        })();
      } : function() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function(size) {
      return new util.Array(size);
    };
    util.Array !== Array && (Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray));
    Writer.prototype._push = function(fn, len, val) {
      return this.tail = this.tail.next = new Op(fn, len, val), this.len += len, this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      for (; val > 127; )
        buf[pos++] = val & 127 | 128, val >>>= 7;
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len, this.next = void 0, this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function(value) {
      return this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len, this;
    };
    Writer.prototype.int32 = function(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      for (; val.hi; )
        buf[pos++] = val.lo & 127 | 128, val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0, val.hi >>>= 7;
      for (; val.lo > 127; )
        buf[pos++] = val.lo & 127 | 128, val.lo = val.lo >>> 7;
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255, buf[pos + 1] = val >>> 8 & 255, buf[pos + 2] = val >>> 16 & 255, buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function(val, buf, pos) {
      buf.set(val, pos);
    } : function(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0), value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function() {
      return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;
    };
    Writer.prototype.reset = function() {
      return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;
    };
    Writer.prototype.ldelim = function() {
      var head = this.head, tail = this.tail, len = this.len;
      return this.reset().uint32(len), len && (this.tail.next = head.next, this.tail = tail, this.len += len), this;
    };
    Writer.prototype.finish = function() {
      for (var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0; head; )
        head.fn(head.val, buf, pos), pos += head.len, head = head.next;
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_, Writer.create = create(), BufferWriter._configure();
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function(val, buf, pos) {
        buf.set(val, pos);
      } : function(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function(value) {
      util.isString(value) && (value = util._Buffer_from(value, "base64"));
      var len = value.length >>> 0;
      return this.uint32(len), len && this._push(BufferWriter.writeBytesBuffer, len, value), this;
    };
    function writeStringBuffer(val, buf, pos) {
      val.length < 40 ? util.utf8.write(val, buf, pos) : buf.utf8Write ? buf.utf8Write(val, pos) : buf.write(val, pos);
    }
    BufferWriter.prototype.string = function(value) {
      var len = util.Buffer.byteLength(value);
      return this.uint32(len), len && this._push(writeStringBuffer, len, value), this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Reader;
    var util = require_minimal(), BufferReader, LongBits = util.LongBits, utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer, this.pos = 0, this.len = buffer.length;
    }
    var create_array = typeof Uint8Array < "u" ? function(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }, create = function() {
      return util.Buffer ? function(buffer) {
        return (Reader.create = function(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ function() {
      var value = 4294967295;
      return function() {
        if (value = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (value = (value | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (value = (value | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (value = (value | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (value = (value | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128)) return value;
        if ((this.pos += 5) > this.len)
          throw this.pos = this.len, indexOutOfRange(this, 10);
        return value;
      };
    }();
    Reader.prototype.int32 = function() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0), i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i)
          if (bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0, this.buf[this.pos++] < 128)
            return bits;
        if (bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0, bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          if (bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0, this.buf[this.pos++] < 128)
            return bits;
        }
        return bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0, bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i)
          if (bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
            return bits;
      } else
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          if (bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
            return bits;
        }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      return this.pos += 4, value;
    };
    Reader.prototype.double = function() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      return this.pos += 8, value;
    };
    Reader.prototype.bytes = function() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      if (this.pos += length, Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function(length) {
      if (typeof length == "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else
        do
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        while (this.buf[this.pos++] & 128);
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          for (; (wireType = this.uint32() & 7) !== 4; )
            this.skipType(wireType);
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_, Reader.create = create(), BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function() {
          return readLongVarint.call(this)[fn](!1);
        },
        uint64: function() {
          return readLongVarint.call(this)[fn](!0);
        },
        sint64: function() {
          return readLongVarint.call(this).zzDecode()[fn](!1);
        },
        fixed64: function() {
          return readFixed64.call(this)[fn](!0);
        },
        sfixed64: function() {
          return readFixed64.call(this)[fn](!1);
        }
      });
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      util.Buffer && (BufferReader.prototype._slice = util.Buffer.prototype.slice);
    };
    BufferReader.prototype.string = function() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl != "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this), this.rpcImpl = rpcImpl, this.requestDelimited = !!requestDelimited, this.responseDelimited = !!responseDelimited;
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request3, callback) {
      if (!request3)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request3);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request3).finish(),
          function(err, response) {
            if (err)
              return self2.emit("error", err, method), callback(err);
            if (response === null) {
              self2.end(
                /* endedByRPC */
                !0
              );
              return;
            }
            if (!(response instanceof responseCtor))
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                return self2.emit("error", err2, method), callback(err2);
              }
            return self2.emit("data", response, method), callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method), setTimeout(function() {
          callback(err);
        }, 0);
        return;
      }
    };
    Service.prototype.end = function(endedByRPC) {
      return this.rpcImpl && (endedByRPC || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
    };
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = {};
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure(), protobuf.Writer._configure(protobuf.BufferWriter), protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/.pnpm/protobufjs@7.5.3/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/generated/root.js
var require_root = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/generated/root.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var $protobuf = require_minimal2(), $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util, $root = $protobuf.roots.default || ($protobuf.roots.default = {});
    $root.opentelemetry = function() {
      var opentelemetry = {};
      return opentelemetry.proto = function() {
        var proto = {};
        return proto.common = function() {
          var common = {};
          return common.v1 = function() {
            var v1 = {};
            return v1.AnyValue = function() {
              function AnyValue(properties) {
                if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              AnyValue.prototype.stringValue = null, AnyValue.prototype.boolValue = null, AnyValue.prototype.intValue = null, AnyValue.prototype.doubleValue = null, AnyValue.prototype.arrayValue = null, AnyValue.prototype.kvlistValue = null, AnyValue.prototype.bytesValue = null;
              var $oneOfFields;
              return Object.defineProperty(AnyValue.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["stringValue", "boolValue", "intValue", "doubleValue", "arrayValue", "kvlistValue", "bytesValue"]),
                set: $util.oneOfSetter($oneOfFields)
              }), AnyValue.create = function(properties) {
                return new AnyValue(properties);
              }, AnyValue.encode = function(message, writer) {
                return writer || (writer = $Writer.create()), message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue") && writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.stringValue), message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue") && writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).bool(message.boolValue), message.intValue != null && Object.hasOwnProperty.call(message, "intValue") && writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int64(message.intValue), message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue") && writer.uint32(
                  /* id 4, wireType 1 =*/
                  33
                ).double(message.doubleValue), message.arrayValue != null && Object.hasOwnProperty.call(message, "arrayValue") && $root.opentelemetry.proto.common.v1.ArrayValue.encode(message.arrayValue, writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).fork()).ldelim(), message.kvlistValue != null && Object.hasOwnProperty.call(message, "kvlistValue") && $root.opentelemetry.proto.common.v1.KeyValueList.encode(message.kvlistValue, writer.uint32(
                  /* id 6, wireType 2 =*/
                  50
                ).fork()).ldelim(), message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue") && writer.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).bytes(message.bytesValue), writer;
              }, AnyValue.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, AnyValue.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.AnyValue(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.stringValue = reader.string();
                      break;
                    }
                    case 2: {
                      message.boolValue = reader.bool();
                      break;
                    }
                    case 3: {
                      message.intValue = reader.int64();
                      break;
                    }
                    case 4: {
                      message.doubleValue = reader.double();
                      break;
                    }
                    case 5: {
                      message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.decode(reader, reader.uint32());
                      break;
                    }
                    case 6: {
                      message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.decode(reader, reader.uint32());
                      break;
                    }
                    case 7: {
                      message.bytesValue = reader.bytes();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, AnyValue.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, AnyValue.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.stringValue != null && message.hasOwnProperty("stringValue") && (properties.value = 1, !$util.isString(message.stringValue)))
                  return "stringValue: string expected";
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  if (properties.value = 1, typeof message.boolValue != "boolean")
                    return "boolValue: boolean expected";
                }
                if (message.intValue != null && message.hasOwnProperty("intValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  if (properties.value = 1, !$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
                    return "intValue: integer|Long expected";
                }
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  if (properties.value = 1, typeof message.doubleValue != "number")
                    return "doubleValue: number expected";
                }
                if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  {
                    var error = $root.opentelemetry.proto.common.v1.ArrayValue.verify(message.arrayValue);
                    if (error)
                      return "arrayValue." + error;
                  }
                }
                if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  properties.value = 1;
                  {
                    var error = $root.opentelemetry.proto.common.v1.KeyValueList.verify(message.kvlistValue);
                    if (error)
                      return "kvlistValue." + error;
                  }
                }
                if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  if (properties.value = 1, !(message.bytesValue && typeof message.bytesValue.length == "number" || $util.isString(message.bytesValue)))
                    return "bytesValue: buffer expected";
                }
                return null;
              }, AnyValue.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.common.v1.AnyValue)
                  return object;
                var message = new $root.opentelemetry.proto.common.v1.AnyValue();
                if (object.stringValue != null && (message.stringValue = String(object.stringValue)), object.boolValue != null && (message.boolValue = !!object.boolValue), object.intValue != null && ($util.Long ? (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = !1 : typeof object.intValue == "string" ? message.intValue = parseInt(object.intValue, 10) : typeof object.intValue == "number" ? message.intValue = object.intValue : typeof object.intValue == "object" && (message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber())), object.doubleValue != null && (message.doubleValue = Number(object.doubleValue)), object.arrayValue != null) {
                  if (typeof object.arrayValue != "object")
                    throw TypeError(".opentelemetry.proto.common.v1.AnyValue.arrayValue: object expected");
                  message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.fromObject(object.arrayValue);
                }
                if (object.kvlistValue != null) {
                  if (typeof object.kvlistValue != "object")
                    throw TypeError(".opentelemetry.proto.common.v1.AnyValue.kvlistValue: object expected");
                  message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.fromObject(object.kvlistValue);
                }
                return object.bytesValue != null && (typeof object.bytesValue == "string" ? $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0) : object.bytesValue.length >= 0 && (message.bytesValue = object.bytesValue)), message;
              }, AnyValue.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                return message.stringValue != null && message.hasOwnProperty("stringValue") && (object.stringValue = message.stringValue, options.oneofs && (object.value = "stringValue")), message.boolValue != null && message.hasOwnProperty("boolValue") && (object.boolValue = message.boolValue, options.oneofs && (object.value = "boolValue")), message.intValue != null && message.hasOwnProperty("intValue") && (typeof message.intValue == "number" ? object.intValue = options.longs === String ? String(message.intValue) : message.intValue : object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue, options.oneofs && (object.value = "intValue")), message.doubleValue != null && message.hasOwnProperty("doubleValue") && (object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue, options.oneofs && (object.value = "doubleValue")), message.arrayValue != null && message.hasOwnProperty("arrayValue") && (object.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.toObject(message.arrayValue, options), options.oneofs && (object.value = "arrayValue")), message.kvlistValue != null && message.hasOwnProperty("kvlistValue") && (object.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.toObject(message.kvlistValue, options), options.oneofs && (object.value = "kvlistValue")), message.bytesValue != null && message.hasOwnProperty("bytesValue") && (object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue, options.oneofs && (object.value = "bytesValue")), object;
              }, AnyValue.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, AnyValue.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.common.v1.AnyValue";
              }, AnyValue;
            }(), v1.ArrayValue = function() {
              function ArrayValue(properties) {
                if (this.values = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ArrayValue.prototype.values = $util.emptyArray, ArrayValue.create = function(properties) {
                return new ArrayValue(properties);
              }, ArrayValue.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.values != null && message.values.length)
                  for (var i = 0; i < message.values.length; ++i)
                    $root.opentelemetry.proto.common.v1.AnyValue.encode(message.values[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, ArrayValue.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ArrayValue.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.ArrayValue(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.values && message.values.length || (message.values = []), message.values.push($root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ArrayValue.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ArrayValue.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                  if (!Array.isArray(message.values))
                    return "values: array expected";
                  for (var i = 0; i < message.values.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.values[i]);
                    if (error)
                      return "values." + error;
                  }
                }
                return null;
              }, ArrayValue.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.common.v1.ArrayValue)
                  return object;
                var message = new $root.opentelemetry.proto.common.v1.ArrayValue();
                if (object.values) {
                  if (!Array.isArray(object.values))
                    throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: array expected");
                  message.values = [];
                  for (var i = 0; i < object.values.length; ++i) {
                    if (typeof object.values[i] != "object")
                      throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: object expected");
                    message.values[i] = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.values[i]);
                  }
                }
                return message;
              }, ArrayValue.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.values = []), message.values && message.values.length) {
                  object.values = [];
                  for (var j = 0; j < message.values.length; ++j)
                    object.values[j] = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.values[j], options);
                }
                return object;
              }, ArrayValue.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ArrayValue.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.common.v1.ArrayValue";
              }, ArrayValue;
            }(), v1.KeyValueList = function() {
              function KeyValueList(properties) {
                if (this.values = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return KeyValueList.prototype.values = $util.emptyArray, KeyValueList.create = function(properties) {
                return new KeyValueList(properties);
              }, KeyValueList.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.values != null && message.values.length)
                  for (var i = 0; i < message.values.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.values[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, KeyValueList.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, KeyValueList.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValueList(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.values && message.values.length || (message.values = []), message.values.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, KeyValueList.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, KeyValueList.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                  if (!Array.isArray(message.values))
                    return "values: array expected";
                  for (var i = 0; i < message.values.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.values[i]);
                    if (error)
                      return "values." + error;
                  }
                }
                return null;
              }, KeyValueList.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.common.v1.KeyValueList)
                  return object;
                var message = new $root.opentelemetry.proto.common.v1.KeyValueList();
                if (object.values) {
                  if (!Array.isArray(object.values))
                    throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: array expected");
                  message.values = [];
                  for (var i = 0; i < object.values.length; ++i) {
                    if (typeof object.values[i] != "object")
                      throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: object expected");
                    message.values[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.values[i]);
                  }
                }
                return message;
              }, KeyValueList.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.values = []), message.values && message.values.length) {
                  object.values = [];
                  for (var j = 0; j < message.values.length; ++j)
                    object.values[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.values[j], options);
                }
                return object;
              }, KeyValueList.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, KeyValueList.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValueList";
              }, KeyValueList;
            }(), v1.KeyValue = function() {
              function KeyValue(properties) {
                if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return KeyValue.prototype.key = null, KeyValue.prototype.value = null, KeyValue.create = function(properties) {
                return new KeyValue(properties);
              }, KeyValue.encode = function(message, writer) {
                return writer || (writer = $Writer.create()), message.key != null && Object.hasOwnProperty.call(message, "key") && writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.key), message.value != null && Object.hasOwnProperty.call(message, "value") && $root.opentelemetry.proto.common.v1.AnyValue.encode(message.value, writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).fork()).ldelim(), writer;
              }, KeyValue.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, KeyValue.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValue(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.key = reader.string();
                      break;
                    }
                    case 2: {
                      message.value = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, KeyValue.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, KeyValue.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.key != null && message.hasOwnProperty("key") && !$util.isString(message.key))
                  return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                  var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.value);
                  if (error)
                    return "value." + error;
                }
                return null;
              }, KeyValue.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.common.v1.KeyValue)
                  return object;
                var message = new $root.opentelemetry.proto.common.v1.KeyValue();
                if (object.key != null && (message.key = String(object.key)), object.value != null) {
                  if (typeof object.value != "object")
                    throw TypeError(".opentelemetry.proto.common.v1.KeyValue.value: object expected");
                  message.value = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.value);
                }
                return message;
              }, KeyValue.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                return options.defaults && (object.key = "", object.value = null), message.key != null && message.hasOwnProperty("key") && (object.key = message.key), message.value != null && message.hasOwnProperty("value") && (object.value = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.value, options)), object;
              }, KeyValue.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, KeyValue.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValue";
              }, KeyValue;
            }(), v1.InstrumentationScope = function() {
              function InstrumentationScope(properties) {
                if (this.attributes = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return InstrumentationScope.prototype.name = null, InstrumentationScope.prototype.version = null, InstrumentationScope.prototype.attributes = $util.emptyArray, InstrumentationScope.prototype.droppedAttributesCount = null, InstrumentationScope.create = function(properties) {
                return new InstrumentationScope(properties);
              }, InstrumentationScope.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.name != null && Object.hasOwnProperty.call(message, "name") && writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.name), message.version != null && Object.hasOwnProperty.call(message, "version") && writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.version), message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 3, wireType 2 =*/
                      26
                    ).fork()).ldelim();
                return message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount") && writer.uint32(
                  /* id 4, wireType 0 =*/
                  32
                ).uint32(message.droppedAttributesCount), writer;
              }, InstrumentationScope.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, InstrumentationScope.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.InstrumentationScope(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.name = reader.string();
                      break;
                    }
                    case 2: {
                      message.version = reader.string();
                      break;
                    }
                    case 3: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 4: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, InstrumentationScope.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, InstrumentationScope.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.name != null && message.hasOwnProperty("name") && !$util.isString(message.name))
                  return "name: string expected";
                if (message.version != null && message.hasOwnProperty("version") && !$util.isString(message.version))
                  return "version: string expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && !$util.isInteger(message.droppedAttributesCount) ? "droppedAttributesCount: integer expected" : null;
              }, InstrumentationScope.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.common.v1.InstrumentationScope)
                  return object;
                var message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();
                if (object.name != null && (message.name = String(object.name)), object.version != null && (message.version = String(object.version)), object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                return object.droppedAttributesCount != null && (message.droppedAttributesCount = object.droppedAttributesCount >>> 0), message;
              }, InstrumentationScope.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.attributes = []), options.defaults && (object.name = "", object.version = "", object.droppedAttributesCount = 0), message.name != null && message.hasOwnProperty("name") && (object.name = message.name), message.version != null && message.hasOwnProperty("version") && (object.version = message.version), message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && (object.droppedAttributesCount = message.droppedAttributesCount), object;
              }, InstrumentationScope.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, InstrumentationScope.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.common.v1.InstrumentationScope";
              }, InstrumentationScope;
            }(), v1;
          }(), common;
        }(), proto.resource = function() {
          var resource = {};
          return resource.v1 = function() {
            var v1 = {};
            return v1.Resource = function() {
              function Resource2(properties) {
                if (this.attributes = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Resource2.prototype.attributes = $util.emptyArray, Resource2.prototype.droppedAttributesCount = null, Resource2.create = function(properties) {
                return new Resource2(properties);
              }, Resource2.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount") && writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).uint32(message.droppedAttributesCount), writer;
              }, Resource2.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Resource2.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.resource.v1.Resource(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Resource2.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Resource2.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && !$util.isInteger(message.droppedAttributesCount) ? "droppedAttributesCount: integer expected" : null;
              }, Resource2.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.resource.v1.Resource)
                  return object;
                var message = new $root.opentelemetry.proto.resource.v1.Resource();
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                return object.droppedAttributesCount != null && (message.droppedAttributesCount = object.droppedAttributesCount >>> 0), message;
              }, Resource2.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.attributes = []), options.defaults && (object.droppedAttributesCount = 0), message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && (object.droppedAttributesCount = message.droppedAttributesCount), object;
              }, Resource2.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Resource2.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.resource.v1.Resource";
              }, Resource2;
            }(), v1;
          }(), resource;
        }(), proto.trace = function() {
          var trace2 = {};
          return trace2.v1 = function() {
            var v1 = {};
            return v1.TracesData = function() {
              function TracesData(properties) {
                if (this.resourceSpans = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return TracesData.prototype.resourceSpans = $util.emptyArray, TracesData.create = function(properties) {
                return new TracesData(properties);
              }, TracesData.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.resourceSpans != null && message.resourceSpans.length)
                  for (var i = 0; i < message.resourceSpans.length; ++i)
                    $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, TracesData.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, TracesData.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.TracesData(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.resourceSpans && message.resourceSpans.length || (message.resourceSpans = []), message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, TracesData.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, TracesData.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
                  if (!Array.isArray(message.resourceSpans))
                    return "resourceSpans: array expected";
                  for (var i = 0; i < message.resourceSpans.length; ++i) {
                    var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);
                    if (error)
                      return "resourceSpans." + error;
                  }
                }
                return null;
              }, TracesData.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.TracesData)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.TracesData();
                if (object.resourceSpans) {
                  if (!Array.isArray(object.resourceSpans))
                    throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: array expected");
                  message.resourceSpans = [];
                  for (var i = 0; i < object.resourceSpans.length; ++i) {
                    if (typeof object.resourceSpans[i] != "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: object expected");
                    message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);
                  }
                }
                return message;
              }, TracesData.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.resourceSpans = []), message.resourceSpans && message.resourceSpans.length) {
                  object.resourceSpans = [];
                  for (var j = 0; j < message.resourceSpans.length; ++j)
                    object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);
                }
                return object;
              }, TracesData.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, TracesData.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.TracesData";
              }, TracesData;
            }(), v1.ResourceSpans = function() {
              function ResourceSpans(properties) {
                if (this.scopeSpans = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ResourceSpans.prototype.resource = null, ResourceSpans.prototype.scopeSpans = $util.emptyArray, ResourceSpans.prototype.schemaUrl = null, ResourceSpans.create = function(properties) {
                return new ResourceSpans(properties);
              }, ResourceSpans.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.resource != null && Object.hasOwnProperty.call(message, "resource") && $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim(), message.scopeSpans != null && message.scopeSpans.length)
                  for (var i = 0; i < message.scopeSpans.length; ++i)
                    $root.opentelemetry.proto.trace.v1.ScopeSpans.encode(message.scopeSpans[i], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                return message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.schemaUrl), writer;
              }, ResourceSpans.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ResourceSpans.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ResourceSpans(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      message.scopeSpans && message.scopeSpans.length || (message.scopeSpans = []), message.scopeSpans.push($root.opentelemetry.proto.trace.v1.ScopeSpans.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ResourceSpans.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ResourceSpans.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                  var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                  if (error)
                    return "resource." + error;
                }
                if (message.scopeSpans != null && message.hasOwnProperty("scopeSpans")) {
                  if (!Array.isArray(message.scopeSpans))
                    return "scopeSpans: array expected";
                  for (var i = 0; i < message.scopeSpans.length; ++i) {
                    var error = $root.opentelemetry.proto.trace.v1.ScopeSpans.verify(message.scopeSpans[i]);
                    if (error)
                      return "scopeSpans." + error;
                  }
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && !$util.isString(message.schemaUrl) ? "schemaUrl: string expected" : null;
              }, ResourceSpans.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.ResourceSpans)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();
                if (object.resource != null) {
                  if (typeof object.resource != "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.resource: object expected");
                  message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
                }
                if (object.scopeSpans) {
                  if (!Array.isArray(object.scopeSpans))
                    throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: array expected");
                  message.scopeSpans = [];
                  for (var i = 0; i < object.scopeSpans.length; ++i) {
                    if (typeof object.scopeSpans[i] != "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: object expected");
                    message.scopeSpans[i] = $root.opentelemetry.proto.trace.v1.ScopeSpans.fromObject(object.scopeSpans[i]);
                  }
                }
                return object.schemaUrl != null && (message.schemaUrl = String(object.schemaUrl)), message;
              }, ResourceSpans.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.scopeSpans = []), options.defaults && (object.resource = null, object.schemaUrl = ""), message.resource != null && message.hasOwnProperty("resource") && (object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options)), message.scopeSpans && message.scopeSpans.length) {
                  object.scopeSpans = [];
                  for (var j = 0; j < message.scopeSpans.length; ++j)
                    object.scopeSpans[j] = $root.opentelemetry.proto.trace.v1.ScopeSpans.toObject(message.scopeSpans[j], options);
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && (object.schemaUrl = message.schemaUrl), object;
              }, ResourceSpans.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ResourceSpans.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.ResourceSpans";
              }, ResourceSpans;
            }(), v1.ScopeSpans = function() {
              function ScopeSpans(properties) {
                if (this.spans = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ScopeSpans.prototype.scope = null, ScopeSpans.prototype.spans = $util.emptyArray, ScopeSpans.prototype.schemaUrl = null, ScopeSpans.create = function(properties) {
                return new ScopeSpans(properties);
              }, ScopeSpans.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.scope != null && Object.hasOwnProperty.call(message, "scope") && $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim(), message.spans != null && message.spans.length)
                  for (var i = 0; i < message.spans.length; ++i)
                    $root.opentelemetry.proto.trace.v1.Span.encode(message.spans[i], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                return message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.schemaUrl), writer;
              }, ScopeSpans.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ScopeSpans.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ScopeSpans(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      message.spans && message.spans.length || (message.spans = []), message.spans.push($root.opentelemetry.proto.trace.v1.Span.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ScopeSpans.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ScopeSpans.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                  var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                  if (error)
                    return "scope." + error;
                }
                if (message.spans != null && message.hasOwnProperty("spans")) {
                  if (!Array.isArray(message.spans))
                    return "spans: array expected";
                  for (var i = 0; i < message.spans.length; ++i) {
                    var error = $root.opentelemetry.proto.trace.v1.Span.verify(message.spans[i]);
                    if (error)
                      return "spans." + error;
                  }
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && !$util.isString(message.schemaUrl) ? "schemaUrl: string expected" : null;
              }, ScopeSpans.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.ScopeSpans)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();
                if (object.scope != null) {
                  if (typeof object.scope != "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.scope: object expected");
                  message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
                }
                if (object.spans) {
                  if (!Array.isArray(object.spans))
                    throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: array expected");
                  message.spans = [];
                  for (var i = 0; i < object.spans.length; ++i) {
                    if (typeof object.spans[i] != "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: object expected");
                    message.spans[i] = $root.opentelemetry.proto.trace.v1.Span.fromObject(object.spans[i]);
                  }
                }
                return object.schemaUrl != null && (message.schemaUrl = String(object.schemaUrl)), message;
              }, ScopeSpans.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.spans = []), options.defaults && (object.scope = null, object.schemaUrl = ""), message.scope != null && message.hasOwnProperty("scope") && (object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options)), message.spans && message.spans.length) {
                  object.spans = [];
                  for (var j = 0; j < message.spans.length; ++j)
                    object.spans[j] = $root.opentelemetry.proto.trace.v1.Span.toObject(message.spans[j], options);
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && (object.schemaUrl = message.schemaUrl), object;
              }, ScopeSpans.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ScopeSpans.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.ScopeSpans";
              }, ScopeSpans;
            }(), v1.Span = function() {
              function Span(properties) {
                if (this.attributes = [], this.events = [], this.links = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Span.prototype.traceId = null, Span.prototype.spanId = null, Span.prototype.traceState = null, Span.prototype.parentSpanId = null, Span.prototype.name = null, Span.prototype.kind = null, Span.prototype.startTimeUnixNano = null, Span.prototype.endTimeUnixNano = null, Span.prototype.attributes = $util.emptyArray, Span.prototype.droppedAttributesCount = null, Span.prototype.events = $util.emptyArray, Span.prototype.droppedEventsCount = null, Span.prototype.links = $util.emptyArray, Span.prototype.droppedLinksCount = null, Span.prototype.status = null, Span.create = function(properties) {
                return new Span(properties);
              }, Span.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.traceId != null && Object.hasOwnProperty.call(message, "traceId") && writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).bytes(message.traceId), message.spanId != null && Object.hasOwnProperty.call(message, "spanId") && writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).bytes(message.spanId), message.traceState != null && Object.hasOwnProperty.call(message, "traceState") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.traceState), message.parentSpanId != null && Object.hasOwnProperty.call(message, "parentSpanId") && writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).bytes(message.parentSpanId), message.name != null && Object.hasOwnProperty.call(message, "name") && writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).string(message.name), message.kind != null && Object.hasOwnProperty.call(message, "kind") && writer.uint32(
                  /* id 6, wireType 0 =*/
                  48
                ).int32(message.kind), message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano") && writer.uint32(
                  /* id 7, wireType 1 =*/
                  57
                ).fixed64(message.startTimeUnixNano), message.endTimeUnixNano != null && Object.hasOwnProperty.call(message, "endTimeUnixNano") && writer.uint32(
                  /* id 8, wireType 1 =*/
                  65
                ).fixed64(message.endTimeUnixNano), message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 9, wireType 2 =*/
                      74
                    ).fork()).ldelim();
                if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount") && writer.uint32(
                  /* id 10, wireType 0 =*/
                  80
                ).uint32(message.droppedAttributesCount), message.events != null && message.events.length)
                  for (var i = 0; i < message.events.length; ++i)
                    $root.opentelemetry.proto.trace.v1.Span.Event.encode(message.events[i], writer.uint32(
                      /* id 11, wireType 2 =*/
                      90
                    ).fork()).ldelim();
                if (message.droppedEventsCount != null && Object.hasOwnProperty.call(message, "droppedEventsCount") && writer.uint32(
                  /* id 12, wireType 0 =*/
                  96
                ).uint32(message.droppedEventsCount), message.links != null && message.links.length)
                  for (var i = 0; i < message.links.length; ++i)
                    $root.opentelemetry.proto.trace.v1.Span.Link.encode(message.links[i], writer.uint32(
                      /* id 13, wireType 2 =*/
                      106
                    ).fork()).ldelim();
                return message.droppedLinksCount != null && Object.hasOwnProperty.call(message, "droppedLinksCount") && writer.uint32(
                  /* id 14, wireType 0 =*/
                  112
                ).uint32(message.droppedLinksCount), message.status != null && Object.hasOwnProperty.call(message, "status") && $root.opentelemetry.proto.trace.v1.Status.encode(message.status, writer.uint32(
                  /* id 15, wireType 2 =*/
                  122
                ).fork()).ldelim(), writer;
              }, Span.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Span.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    case 2: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    case 3: {
                      message.traceState = reader.string();
                      break;
                    }
                    case 4: {
                      message.parentSpanId = reader.bytes();
                      break;
                    }
                    case 5: {
                      message.name = reader.string();
                      break;
                    }
                    case 6: {
                      message.kind = reader.int32();
                      break;
                    }
                    case 7: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 8: {
                      message.endTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 9: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 10: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    case 11: {
                      message.events && message.events.length || (message.events = []), message.events.push($root.opentelemetry.proto.trace.v1.Span.Event.decode(reader, reader.uint32()));
                      break;
                    }
                    case 12: {
                      message.droppedEventsCount = reader.uint32();
                      break;
                    }
                    case 13: {
                      message.links && message.links.length || (message.links = []), message.links.push($root.opentelemetry.proto.trace.v1.Span.Link.decode(reader, reader.uint32()));
                      break;
                    }
                    case 14: {
                      message.droppedLinksCount = reader.uint32();
                      break;
                    }
                    case 15: {
                      message.status = $root.opentelemetry.proto.trace.v1.Status.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Span.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Span.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.traceId != null && message.hasOwnProperty("traceId") && !(message.traceId && typeof message.traceId.length == "number" || $util.isString(message.traceId)))
                  return "traceId: buffer expected";
                if (message.spanId != null && message.hasOwnProperty("spanId") && !(message.spanId && typeof message.spanId.length == "number" || $util.isString(message.spanId)))
                  return "spanId: buffer expected";
                if (message.traceState != null && message.hasOwnProperty("traceState") && !$util.isString(message.traceState))
                  return "traceState: string expected";
                if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId") && !(message.parentSpanId && typeof message.parentSpanId.length == "number" || $util.isString(message.parentSpanId)))
                  return "parentSpanId: buffer expected";
                if (message.name != null && message.hasOwnProperty("name") && !$util.isString(message.name))
                  return "name: string expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                  switch (message.kind) {
                    default:
                      return "kind: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                      break;
                  }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && !$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
                if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano") && !$util.isInteger(message.endTimeUnixNano) && !(message.endTimeUnixNano && $util.isInteger(message.endTimeUnixNano.low) && $util.isInteger(message.endTimeUnixNano.high)))
                  return "endTimeUnixNano: integer|Long expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && !$util.isInteger(message.droppedAttributesCount))
                  return "droppedAttributesCount: integer expected";
                if (message.events != null && message.hasOwnProperty("events")) {
                  if (!Array.isArray(message.events))
                    return "events: array expected";
                  for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.opentelemetry.proto.trace.v1.Span.Event.verify(message.events[i]);
                    if (error)
                      return "events." + error;
                  }
                }
                if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount") && !$util.isInteger(message.droppedEventsCount))
                  return "droppedEventsCount: integer expected";
                if (message.links != null && message.hasOwnProperty("links")) {
                  if (!Array.isArray(message.links))
                    return "links: array expected";
                  for (var i = 0; i < message.links.length; ++i) {
                    var error = $root.opentelemetry.proto.trace.v1.Span.Link.verify(message.links[i]);
                    if (error)
                      return "links." + error;
                  }
                }
                if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount") && !$util.isInteger(message.droppedLinksCount))
                  return "droppedLinksCount: integer expected";
                if (message.status != null && message.hasOwnProperty("status")) {
                  var error = $root.opentelemetry.proto.trace.v1.Status.verify(message.status);
                  if (error)
                    return "status." + error;
                }
                return null;
              }, Span.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.Span)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.Span();
                switch (object.traceId != null && (typeof object.traceId == "string" ? $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0) : object.traceId.length >= 0 && (message.traceId = object.traceId)), object.spanId != null && (typeof object.spanId == "string" ? $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0) : object.spanId.length >= 0 && (message.spanId = object.spanId)), object.traceState != null && (message.traceState = String(object.traceState)), object.parentSpanId != null && (typeof object.parentSpanId == "string" ? $util.base64.decode(object.parentSpanId, message.parentSpanId = $util.newBuffer($util.base64.length(object.parentSpanId)), 0) : object.parentSpanId.length >= 0 && (message.parentSpanId = object.parentSpanId)), object.name != null && (message.name = String(object.name)), object.kind) {
                  default:
                    if (typeof object.kind == "number") {
                      message.kind = object.kind;
                      break;
                    }
                    break;
                  case "SPAN_KIND_UNSPECIFIED":
                  case 0:
                    message.kind = 0;
                    break;
                  case "SPAN_KIND_INTERNAL":
                  case 1:
                    message.kind = 1;
                    break;
                  case "SPAN_KIND_SERVER":
                  case 2:
                    message.kind = 2;
                    break;
                  case "SPAN_KIND_CLIENT":
                  case 3:
                    message.kind = 3;
                    break;
                  case "SPAN_KIND_PRODUCER":
                  case 4:
                    message.kind = 4;
                    break;
                  case "SPAN_KIND_CONSUMER":
                  case 5:
                    message.kind = 5;
                    break;
                }
                if (object.startTimeUnixNano != null && ($util.Long ? (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = !1 : typeof object.startTimeUnixNano == "string" ? message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10) : typeof object.startTimeUnixNano == "number" ? message.startTimeUnixNano = object.startTimeUnixNano : typeof object.startTimeUnixNano == "object" && (message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber())), object.endTimeUnixNano != null && ($util.Long ? (message.endTimeUnixNano = $util.Long.fromValue(object.endTimeUnixNano)).unsigned = !1 : typeof object.endTimeUnixNano == "string" ? message.endTimeUnixNano = parseInt(object.endTimeUnixNano, 10) : typeof object.endTimeUnixNano == "number" ? message.endTimeUnixNano = object.endTimeUnixNano : typeof object.endTimeUnixNano == "object" && (message.endTimeUnixNano = new $util.LongBits(object.endTimeUnixNano.low >>> 0, object.endTimeUnixNano.high >>> 0).toNumber())), object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.droppedAttributesCount != null && (message.droppedAttributesCount = object.droppedAttributesCount >>> 0), object.events) {
                  if (!Array.isArray(object.events))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.events: array expected");
                  message.events = [];
                  for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] != "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.events: object expected");
                    message.events[i] = $root.opentelemetry.proto.trace.v1.Span.Event.fromObject(object.events[i]);
                  }
                }
                if (object.droppedEventsCount != null && (message.droppedEventsCount = object.droppedEventsCount >>> 0), object.links) {
                  if (!Array.isArray(object.links))
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.links: array expected");
                  message.links = [];
                  for (var i = 0; i < object.links.length; ++i) {
                    if (typeof object.links[i] != "object")
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.links: object expected");
                    message.links[i] = $root.opentelemetry.proto.trace.v1.Span.Link.fromObject(object.links[i]);
                  }
                }
                if (object.droppedLinksCount != null && (message.droppedLinksCount = object.droppedLinksCount >>> 0), object.status != null) {
                  if (typeof object.status != "object")
                    throw TypeError(".opentelemetry.proto.trace.v1.Span.status: object expected");
                  message.status = $root.opentelemetry.proto.trace.v1.Status.fromObject(object.status);
                }
                return message;
              }, Span.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.attributes = [], object.events = [], object.links = []), options.defaults) {
                  if (options.bytes === String ? object.traceId = "" : (object.traceId = [], options.bytes !== Array && (object.traceId = $util.newBuffer(object.traceId))), options.bytes === String ? object.spanId = "" : (object.spanId = [], options.bytes !== Array && (object.spanId = $util.newBuffer(object.spanId))), object.traceState = "", options.bytes === String ? object.parentSpanId = "" : (object.parentSpanId = [], options.bytes !== Array && (object.parentSpanId = $util.newBuffer(object.parentSpanId))), object.name = "", object.kind = options.enums === String ? "SPAN_KIND_UNSPECIFIED" : 0, $util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.endTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.endTimeUnixNano = options.longs === String ? "0" : 0;
                  object.droppedAttributesCount = 0, object.droppedEventsCount = 0, object.droppedLinksCount = 0, object.status = null;
                }
                if (message.traceId != null && message.hasOwnProperty("traceId") && (object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId), message.spanId != null && message.hasOwnProperty("spanId") && (object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId), message.traceState != null && message.hasOwnProperty("traceState") && (object.traceState = message.traceState), message.parentSpanId != null && message.hasOwnProperty("parentSpanId") && (object.parentSpanId = options.bytes === String ? $util.base64.encode(message.parentSpanId, 0, message.parentSpanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentSpanId) : message.parentSpanId), message.name != null && message.hasOwnProperty("name") && (object.name = message.name), message.kind != null && message.hasOwnProperty("kind") && (object.kind = options.enums === String ? $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] === void 0 ? message.kind : $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] : message.kind), message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && (typeof message.startTimeUnixNano == "number" ? object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano : object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano), message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano") && (typeof message.endTimeUnixNano == "number" ? object.endTimeUnixNano = options.longs === String ? String(message.endTimeUnixNano) : message.endTimeUnixNano : object.endTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.endTimeUnixNano.low >>> 0, message.endTimeUnixNano.high >>> 0).toNumber() : message.endTimeUnixNano), message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && (object.droppedAttributesCount = message.droppedAttributesCount), message.events && message.events.length) {
                  object.events = [];
                  for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.opentelemetry.proto.trace.v1.Span.Event.toObject(message.events[j], options);
                }
                if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount") && (object.droppedEventsCount = message.droppedEventsCount), message.links && message.links.length) {
                  object.links = [];
                  for (var j = 0; j < message.links.length; ++j)
                    object.links[j] = $root.opentelemetry.proto.trace.v1.Span.Link.toObject(message.links[j], options);
                }
                return message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount") && (object.droppedLinksCount = message.droppedLinksCount), message.status != null && message.hasOwnProperty("status") && (object.status = $root.opentelemetry.proto.trace.v1.Status.toObject(message.status, options)), object;
              }, Span.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Span.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span";
              }, Span.SpanKind = function() {
                var valuesById = {}, values = Object.create(valuesById);
                return values[valuesById[0] = "SPAN_KIND_UNSPECIFIED"] = 0, values[valuesById[1] = "SPAN_KIND_INTERNAL"] = 1, values[valuesById[2] = "SPAN_KIND_SERVER"] = 2, values[valuesById[3] = "SPAN_KIND_CLIENT"] = 3, values[valuesById[4] = "SPAN_KIND_PRODUCER"] = 4, values[valuesById[5] = "SPAN_KIND_CONSUMER"] = 5, values;
              }(), Span.Event = function() {
                function Event(properties) {
                  if (this.attributes = [], properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return Event.prototype.timeUnixNano = null, Event.prototype.name = null, Event.prototype.attributes = $util.emptyArray, Event.prototype.droppedAttributesCount = null, Event.create = function(properties) {
                  return new Event(properties);
                }, Event.encode = function(message, writer) {
                  if (writer || (writer = $Writer.create()), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                    /* id 1, wireType 1 =*/
                    9
                  ).fixed64(message.timeUnixNano), message.name != null && Object.hasOwnProperty.call(message, "name") && writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.name), message.attributes != null && message.attributes.length)
                    for (var i = 0; i < message.attributes.length; ++i)
                      $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                        /* id 3, wireType 2 =*/
                        26
                      ).fork()).ldelim();
                  return message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount") && writer.uint32(
                    /* id 4, wireType 0 =*/
                    32
                  ).uint32(message.droppedAttributesCount), writer;
                }, Event.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, Event.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Event(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.timeUnixNano = reader.fixed64();
                        break;
                      }
                      case 2: {
                        message.name = reader.string();
                        break;
                      }
                      case 3: {
                        message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                        break;
                      }
                      case 4: {
                        message.droppedAttributesCount = reader.uint32();
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, Event.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, Event.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                    return "timeUnixNano: integer|Long expected";
                  if (message.name != null && message.hasOwnProperty("name") && !$util.isString(message.name))
                    return "name: string expected";
                  if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!Array.isArray(message.attributes))
                      return "attributes: array expected";
                    for (var i = 0; i < message.attributes.length; ++i) {
                      var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                      if (error)
                        return "attributes." + error;
                    }
                  }
                  return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && !$util.isInteger(message.droppedAttributesCount) ? "droppedAttributesCount: integer expected" : null;
                }, Event.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Event)
                    return object;
                  var message = new $root.opentelemetry.proto.trace.v1.Span.Event();
                  if (object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.name != null && (message.name = String(object.name)), object.attributes) {
                    if (!Array.isArray(object.attributes))
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: array expected");
                    message.attributes = [];
                    for (var i = 0; i < object.attributes.length; ++i) {
                      if (typeof object.attributes[i] != "object")
                        throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: object expected");
                      message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                    }
                  }
                  return object.droppedAttributesCount != null && (message.droppedAttributesCount = object.droppedAttributesCount >>> 0), message;
                }, Event.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if ((options.arrays || options.defaults) && (object.attributes = []), options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, !1);
                      object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object.timeUnixNano = options.longs === String ? "0" : 0;
                    object.name = "", object.droppedAttributesCount = 0;
                  }
                  if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.name != null && message.hasOwnProperty("name") && (object.name = message.name), message.attributes && message.attributes.length) {
                    object.attributes = [];
                    for (var j = 0; j < message.attributes.length; ++j)
                      object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                  }
                  return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && (object.droppedAttributesCount = message.droppedAttributesCount), object;
                }, Event.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, Event.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Event";
                }, Event;
              }(), Span.Link = function() {
                function Link(properties) {
                  if (this.attributes = [], properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return Link.prototype.traceId = null, Link.prototype.spanId = null, Link.prototype.traceState = null, Link.prototype.attributes = $util.emptyArray, Link.prototype.droppedAttributesCount = null, Link.create = function(properties) {
                  return new Link(properties);
                }, Link.encode = function(message, writer) {
                  if (writer || (writer = $Writer.create()), message.traceId != null && Object.hasOwnProperty.call(message, "traceId") && writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).bytes(message.traceId), message.spanId != null && Object.hasOwnProperty.call(message, "spanId") && writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).bytes(message.spanId), message.traceState != null && Object.hasOwnProperty.call(message, "traceState") && writer.uint32(
                    /* id 3, wireType 2 =*/
                    26
                  ).string(message.traceState), message.attributes != null && message.attributes.length)
                    for (var i = 0; i < message.attributes.length; ++i)
                      $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                        /* id 4, wireType 2 =*/
                        34
                      ).fork()).ldelim();
                  return message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount") && writer.uint32(
                    /* id 5, wireType 0 =*/
                    40
                  ).uint32(message.droppedAttributesCount), writer;
                }, Link.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, Link.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Link(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.traceId = reader.bytes();
                        break;
                      }
                      case 2: {
                        message.spanId = reader.bytes();
                        break;
                      }
                      case 3: {
                        message.traceState = reader.string();
                        break;
                      }
                      case 4: {
                        message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                        break;
                      }
                      case 5: {
                        message.droppedAttributesCount = reader.uint32();
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, Link.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, Link.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.traceId != null && message.hasOwnProperty("traceId") && !(message.traceId && typeof message.traceId.length == "number" || $util.isString(message.traceId)))
                    return "traceId: buffer expected";
                  if (message.spanId != null && message.hasOwnProperty("spanId") && !(message.spanId && typeof message.spanId.length == "number" || $util.isString(message.spanId)))
                    return "spanId: buffer expected";
                  if (message.traceState != null && message.hasOwnProperty("traceState") && !$util.isString(message.traceState))
                    return "traceState: string expected";
                  if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!Array.isArray(message.attributes))
                      return "attributes: array expected";
                    for (var i = 0; i < message.attributes.length; ++i) {
                      var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                      if (error)
                        return "attributes." + error;
                    }
                  }
                  return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && !$util.isInteger(message.droppedAttributesCount) ? "droppedAttributesCount: integer expected" : null;
                }, Link.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Link)
                    return object;
                  var message = new $root.opentelemetry.proto.trace.v1.Span.Link();
                  if (object.traceId != null && (typeof object.traceId == "string" ? $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0) : object.traceId.length >= 0 && (message.traceId = object.traceId)), object.spanId != null && (typeof object.spanId == "string" ? $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0) : object.spanId.length >= 0 && (message.spanId = object.spanId)), object.traceState != null && (message.traceState = String(object.traceState)), object.attributes) {
                    if (!Array.isArray(object.attributes))
                      throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: array expected");
                    message.attributes = [];
                    for (var i = 0; i < object.attributes.length; ++i) {
                      if (typeof object.attributes[i] != "object")
                        throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: object expected");
                      message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                    }
                  }
                  return object.droppedAttributesCount != null && (message.droppedAttributesCount = object.droppedAttributesCount >>> 0), message;
                }, Link.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if ((options.arrays || options.defaults) && (object.attributes = []), options.defaults && (options.bytes === String ? object.traceId = "" : (object.traceId = [], options.bytes !== Array && (object.traceId = $util.newBuffer(object.traceId))), options.bytes === String ? object.spanId = "" : (object.spanId = [], options.bytes !== Array && (object.spanId = $util.newBuffer(object.spanId))), object.traceState = "", object.droppedAttributesCount = 0), message.traceId != null && message.hasOwnProperty("traceId") && (object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId), message.spanId != null && message.hasOwnProperty("spanId") && (object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId), message.traceState != null && message.hasOwnProperty("traceState") && (object.traceState = message.traceState), message.attributes && message.attributes.length) {
                    object.attributes = [];
                    for (var j = 0; j < message.attributes.length; ++j)
                      object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                  }
                  return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && (object.droppedAttributesCount = message.droppedAttributesCount), object;
                }, Link.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, Link.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Link";
                }, Link;
              }(), Span;
            }(), v1.Status = function() {
              function Status(properties) {
                if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Status.prototype.message = null, Status.prototype.code = null, Status.create = function(properties) {
                return new Status(properties);
              }, Status.encode = function(message, writer) {
                return writer || (writer = $Writer.create()), message.message != null && Object.hasOwnProperty.call(message, "message") && writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.message), message.code != null && Object.hasOwnProperty.call(message, "code") && writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).int32(message.code), writer;
              }, Status.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Status.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Status(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 2: {
                      message.message = reader.string();
                      break;
                    }
                    case 3: {
                      message.code = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Status.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Status.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.message != null && message.hasOwnProperty("message") && !$util.isString(message.message))
                  return "message: string expected";
                if (message.code != null && message.hasOwnProperty("code"))
                  switch (message.code) {
                    default:
                      return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              }, Status.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.trace.v1.Status)
                  return object;
                var message = new $root.opentelemetry.proto.trace.v1.Status();
                switch (object.message != null && (message.message = String(object.message)), object.code) {
                  default:
                    if (typeof object.code == "number") {
                      message.code = object.code;
                      break;
                    }
                    break;
                  case "STATUS_CODE_UNSET":
                  case 0:
                    message.code = 0;
                    break;
                  case "STATUS_CODE_OK":
                  case 1:
                    message.code = 1;
                    break;
                  case "STATUS_CODE_ERROR":
                  case 2:
                    message.code = 2;
                    break;
                }
                return message;
              }, Status.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                return options.defaults && (object.message = "", object.code = options.enums === String ? "STATUS_CODE_UNSET" : 0), message.message != null && message.hasOwnProperty("message") && (object.message = message.message), message.code != null && message.hasOwnProperty("code") && (object.code = options.enums === String ? $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] === void 0 ? message.code : $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] : message.code), object;
              }, Status.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Status.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.trace.v1.Status";
              }, Status.StatusCode = function() {
                var valuesById = {}, values = Object.create(valuesById);
                return values[valuesById[0] = "STATUS_CODE_UNSET"] = 0, values[valuesById[1] = "STATUS_CODE_OK"] = 1, values[valuesById[2] = "STATUS_CODE_ERROR"] = 2, values;
              }(), Status;
            }(), v1;
          }(), trace2;
        }(), proto.collector = function() {
          var collector = {};
          return collector.trace = function() {
            var trace2 = {};
            return trace2.v1 = function() {
              var v1 = {};
              return v1.TraceService = function() {
                function TraceService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                return (TraceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TraceService, TraceService.create = function(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                }, Object.defineProperty(TraceService.prototype.export = function export_(request3, callback) {
                  return this.rpcCall(export_, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, request3, callback);
                }, "name", { value: "Export" }), TraceService;
              }(), v1.ExportTraceServiceRequest = function() {
                function ExportTraceServiceRequest(properties) {
                  if (this.resourceSpans = [], properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportTraceServiceRequest.prototype.resourceSpans = $util.emptyArray, ExportTraceServiceRequest.create = function(properties) {
                  return new ExportTraceServiceRequest(properties);
                }, ExportTraceServiceRequest.encode = function(message, writer) {
                  if (writer || (writer = $Writer.create()), message.resourceSpans != null && message.resourceSpans.length)
                    for (var i = 0; i < message.resourceSpans.length; ++i)
                      $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(
                        /* id 1, wireType 2 =*/
                        10
                      ).fork()).ldelim();
                  return writer;
                }, ExportTraceServiceRequest.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportTraceServiceRequest.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.resourceSpans && message.resourceSpans.length || (message.resourceSpans = []), message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportTraceServiceRequest.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportTraceServiceRequest.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
                    if (!Array.isArray(message.resourceSpans))
                      return "resourceSpans: array expected";
                    for (var i = 0; i < message.resourceSpans.length; ++i) {
                      var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);
                      if (error)
                        return "resourceSpans." + error;
                    }
                  }
                  return null;
                }, ExportTraceServiceRequest.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();
                  if (object.resourceSpans) {
                    if (!Array.isArray(object.resourceSpans))
                      throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: array expected");
                    message.resourceSpans = [];
                    for (var i = 0; i < object.resourceSpans.length; ++i) {
                      if (typeof object.resourceSpans[i] != "object")
                        throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: object expected");
                      message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);
                    }
                  }
                  return message;
                }, ExportTraceServiceRequest.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if ((options.arrays || options.defaults) && (object.resourceSpans = []), message.resourceSpans && message.resourceSpans.length) {
                    object.resourceSpans = [];
                    for (var j = 0; j < message.resourceSpans.length; ++j)
                      object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);
                  }
                  return object;
                }, ExportTraceServiceRequest.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportTraceServiceRequest.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest";
                }, ExportTraceServiceRequest;
              }(), v1.ExportTraceServiceResponse = function() {
                function ExportTraceServiceResponse(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportTraceServiceResponse.prototype.partialSuccess = null, ExportTraceServiceResponse.create = function(properties) {
                  return new ExportTraceServiceResponse(properties);
                }, ExportTraceServiceResponse.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess") && $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.encode(message.partialSuccess, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim(), writer;
                }, ExportTraceServiceResponse.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportTraceServiceResponse.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.decode(reader, reader.uint32());
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportTraceServiceResponse.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportTraceServiceResponse.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                    var error = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify(message.partialSuccess);
                    if (error)
                      return "partialSuccess." + error;
                  }
                  return null;
                }, ExportTraceServiceResponse.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();
                  if (object.partialSuccess != null) {
                    if (typeof object.partialSuccess != "object")
                      throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.partialSuccess: object expected");
                    message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.fromObject(object.partialSuccess);
                  }
                  return message;
                }, ExportTraceServiceResponse.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  return options.defaults && (object.partialSuccess = null), message.partialSuccess != null && message.hasOwnProperty("partialSuccess") && (object.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.toObject(message.partialSuccess, options)), object;
                }, ExportTraceServiceResponse.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportTraceServiceResponse.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse";
                }, ExportTraceServiceResponse;
              }(), v1.ExportTracePartialSuccess = function() {
                function ExportTracePartialSuccess(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportTracePartialSuccess.prototype.rejectedSpans = null, ExportTracePartialSuccess.prototype.errorMessage = null, ExportTracePartialSuccess.create = function(properties) {
                  return new ExportTracePartialSuccess(properties);
                }, ExportTracePartialSuccess.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.rejectedSpans != null && Object.hasOwnProperty.call(message, "rejectedSpans") && writer.uint32(
                    /* id 1, wireType 0 =*/
                    8
                  ).int64(message.rejectedSpans), message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage") && writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.errorMessage), writer;
                }, ExportTracePartialSuccess.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportTracePartialSuccess.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.rejectedSpans = reader.int64();
                        break;
                      }
                      case 2: {
                        message.errorMessage = reader.string();
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportTracePartialSuccess.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportTracePartialSuccess.verify = function(message) {
                  return typeof message != "object" || message === null ? "object expected" : message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans") && !$util.isInteger(message.rejectedSpans) && !(message.rejectedSpans && $util.isInteger(message.rejectedSpans.low) && $util.isInteger(message.rejectedSpans.high)) ? "rejectedSpans: integer|Long expected" : message.errorMessage != null && message.hasOwnProperty("errorMessage") && !$util.isString(message.errorMessage) ? "errorMessage: string expected" : null;
                }, ExportTracePartialSuccess.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();
                  return object.rejectedSpans != null && ($util.Long ? (message.rejectedSpans = $util.Long.fromValue(object.rejectedSpans)).unsigned = !1 : typeof object.rejectedSpans == "string" ? message.rejectedSpans = parseInt(object.rejectedSpans, 10) : typeof object.rejectedSpans == "number" ? message.rejectedSpans = object.rejectedSpans : typeof object.rejectedSpans == "object" && (message.rejectedSpans = new $util.LongBits(object.rejectedSpans.low >>> 0, object.rejectedSpans.high >>> 0).toNumber())), object.errorMessage != null && (message.errorMessage = String(object.errorMessage)), message;
                }, ExportTracePartialSuccess.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, !1);
                      object.rejectedSpans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object.rejectedSpans = options.longs === String ? "0" : 0;
                    object.errorMessage = "";
                  }
                  return message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans") && (typeof message.rejectedSpans == "number" ? object.rejectedSpans = options.longs === String ? String(message.rejectedSpans) : message.rejectedSpans : object.rejectedSpans = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedSpans) : options.longs === Number ? new $util.LongBits(message.rejectedSpans.low >>> 0, message.rejectedSpans.high >>> 0).toNumber() : message.rejectedSpans), message.errorMessage != null && message.hasOwnProperty("errorMessage") && (object.errorMessage = message.errorMessage), object;
                }, ExportTracePartialSuccess.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportTracePartialSuccess.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess";
                }, ExportTracePartialSuccess;
              }(), v1;
            }(), trace2;
          }(), collector.metrics = function() {
            var metrics2 = {};
            return metrics2.v1 = function() {
              var v1 = {};
              return v1.MetricsService = function() {
                function MetricsService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                return (MetricsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsService, MetricsService.create = function(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                }, Object.defineProperty(MetricsService.prototype.export = function export_(request3, callback) {
                  return this.rpcCall(export_, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, request3, callback);
                }, "name", { value: "Export" }), MetricsService;
              }(), v1.ExportMetricsServiceRequest = function() {
                function ExportMetricsServiceRequest(properties) {
                  if (this.resourceMetrics = [], properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportMetricsServiceRequest.prototype.resourceMetrics = $util.emptyArray, ExportMetricsServiceRequest.create = function(properties) {
                  return new ExportMetricsServiceRequest(properties);
                }, ExportMetricsServiceRequest.encode = function(message, writer) {
                  if (writer || (writer = $Writer.create()), message.resourceMetrics != null && message.resourceMetrics.length)
                    for (var i = 0; i < message.resourceMetrics.length; ++i)
                      $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(
                        /* id 1, wireType 2 =*/
                        10
                      ).fork()).ldelim();
                  return writer;
                }, ExportMetricsServiceRequest.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportMetricsServiceRequest.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.resourceMetrics && message.resourceMetrics.length || (message.resourceMetrics = []), message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportMetricsServiceRequest.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportMetricsServiceRequest.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
                    if (!Array.isArray(message.resourceMetrics))
                      return "resourceMetrics: array expected";
                    for (var i = 0; i < message.resourceMetrics.length; ++i) {
                      var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);
                      if (error)
                        return "resourceMetrics." + error;
                    }
                  }
                  return null;
                }, ExportMetricsServiceRequest.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();
                  if (object.resourceMetrics) {
                    if (!Array.isArray(object.resourceMetrics))
                      throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: array expected");
                    message.resourceMetrics = [];
                    for (var i = 0; i < object.resourceMetrics.length; ++i) {
                      if (typeof object.resourceMetrics[i] != "object")
                        throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: object expected");
                      message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);
                    }
                  }
                  return message;
                }, ExportMetricsServiceRequest.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if ((options.arrays || options.defaults) && (object.resourceMetrics = []), message.resourceMetrics && message.resourceMetrics.length) {
                    object.resourceMetrics = [];
                    for (var j = 0; j < message.resourceMetrics.length; ++j)
                      object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);
                  }
                  return object;
                }, ExportMetricsServiceRequest.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportMetricsServiceRequest.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest";
                }, ExportMetricsServiceRequest;
              }(), v1.ExportMetricsServiceResponse = function() {
                function ExportMetricsServiceResponse(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportMetricsServiceResponse.prototype.partialSuccess = null, ExportMetricsServiceResponse.create = function(properties) {
                  return new ExportMetricsServiceResponse(properties);
                }, ExportMetricsServiceResponse.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess") && $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.encode(message.partialSuccess, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim(), writer;
                }, ExportMetricsServiceResponse.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportMetricsServiceResponse.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.decode(reader, reader.uint32());
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportMetricsServiceResponse.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportMetricsServiceResponse.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                    var error = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify(message.partialSuccess);
                    if (error)
                      return "partialSuccess." + error;
                  }
                  return null;
                }, ExportMetricsServiceResponse.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();
                  if (object.partialSuccess != null) {
                    if (typeof object.partialSuccess != "object")
                      throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.partialSuccess: object expected");
                    message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.fromObject(object.partialSuccess);
                  }
                  return message;
                }, ExportMetricsServiceResponse.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  return options.defaults && (object.partialSuccess = null), message.partialSuccess != null && message.hasOwnProperty("partialSuccess") && (object.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.toObject(message.partialSuccess, options)), object;
                }, ExportMetricsServiceResponse.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportMetricsServiceResponse.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse";
                }, ExportMetricsServiceResponse;
              }(), v1.ExportMetricsPartialSuccess = function() {
                function ExportMetricsPartialSuccess(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportMetricsPartialSuccess.prototype.rejectedDataPoints = null, ExportMetricsPartialSuccess.prototype.errorMessage = null, ExportMetricsPartialSuccess.create = function(properties) {
                  return new ExportMetricsPartialSuccess(properties);
                }, ExportMetricsPartialSuccess.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.rejectedDataPoints != null && Object.hasOwnProperty.call(message, "rejectedDataPoints") && writer.uint32(
                    /* id 1, wireType 0 =*/
                    8
                  ).int64(message.rejectedDataPoints), message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage") && writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.errorMessage), writer;
                }, ExportMetricsPartialSuccess.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportMetricsPartialSuccess.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.rejectedDataPoints = reader.int64();
                        break;
                      }
                      case 2: {
                        message.errorMessage = reader.string();
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportMetricsPartialSuccess.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportMetricsPartialSuccess.verify = function(message) {
                  return typeof message != "object" || message === null ? "object expected" : message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints") && !$util.isInteger(message.rejectedDataPoints) && !(message.rejectedDataPoints && $util.isInteger(message.rejectedDataPoints.low) && $util.isInteger(message.rejectedDataPoints.high)) ? "rejectedDataPoints: integer|Long expected" : message.errorMessage != null && message.hasOwnProperty("errorMessage") && !$util.isString(message.errorMessage) ? "errorMessage: string expected" : null;
                }, ExportMetricsPartialSuccess.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();
                  return object.rejectedDataPoints != null && ($util.Long ? (message.rejectedDataPoints = $util.Long.fromValue(object.rejectedDataPoints)).unsigned = !1 : typeof object.rejectedDataPoints == "string" ? message.rejectedDataPoints = parseInt(object.rejectedDataPoints, 10) : typeof object.rejectedDataPoints == "number" ? message.rejectedDataPoints = object.rejectedDataPoints : typeof object.rejectedDataPoints == "object" && (message.rejectedDataPoints = new $util.LongBits(object.rejectedDataPoints.low >>> 0, object.rejectedDataPoints.high >>> 0).toNumber())), object.errorMessage != null && (message.errorMessage = String(object.errorMessage)), message;
                }, ExportMetricsPartialSuccess.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, !1);
                      object.rejectedDataPoints = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object.rejectedDataPoints = options.longs === String ? "0" : 0;
                    object.errorMessage = "";
                  }
                  return message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints") && (typeof message.rejectedDataPoints == "number" ? object.rejectedDataPoints = options.longs === String ? String(message.rejectedDataPoints) : message.rejectedDataPoints : object.rejectedDataPoints = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedDataPoints) : options.longs === Number ? new $util.LongBits(message.rejectedDataPoints.low >>> 0, message.rejectedDataPoints.high >>> 0).toNumber() : message.rejectedDataPoints), message.errorMessage != null && message.hasOwnProperty("errorMessage") && (object.errorMessage = message.errorMessage), object;
                }, ExportMetricsPartialSuccess.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportMetricsPartialSuccess.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess";
                }, ExportMetricsPartialSuccess;
              }(), v1;
            }(), metrics2;
          }(), collector.logs = function() {
            var logs = {};
            return logs.v1 = function() {
              var v1 = {};
              return v1.LogsService = function() {
                function LogsService(rpcImpl, requestDelimited, responseDelimited) {
                  $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }
                return (LogsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogsService, LogsService.create = function(rpcImpl, requestDelimited, responseDelimited) {
                  return new this(rpcImpl, requestDelimited, responseDelimited);
                }, Object.defineProperty(LogsService.prototype.export = function export_(request3, callback) {
                  return this.rpcCall(export_, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, request3, callback);
                }, "name", { value: "Export" }), LogsService;
              }(), v1.ExportLogsServiceRequest = function() {
                function ExportLogsServiceRequest(properties) {
                  if (this.resourceLogs = [], properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportLogsServiceRequest.prototype.resourceLogs = $util.emptyArray, ExportLogsServiceRequest.create = function(properties) {
                  return new ExportLogsServiceRequest(properties);
                }, ExportLogsServiceRequest.encode = function(message, writer) {
                  if (writer || (writer = $Writer.create()), message.resourceLogs != null && message.resourceLogs.length)
                    for (var i = 0; i < message.resourceLogs.length; ++i)
                      $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(
                        /* id 1, wireType 2 =*/
                        10
                      ).fork()).ldelim();
                  return writer;
                }, ExportLogsServiceRequest.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportLogsServiceRequest.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.resourceLogs && message.resourceLogs.length || (message.resourceLogs = []), message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportLogsServiceRequest.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportLogsServiceRequest.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
                    if (!Array.isArray(message.resourceLogs))
                      return "resourceLogs: array expected";
                    for (var i = 0; i < message.resourceLogs.length; ++i) {
                      var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);
                      if (error)
                        return "resourceLogs." + error;
                    }
                  }
                  return null;
                }, ExportLogsServiceRequest.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();
                  if (object.resourceLogs) {
                    if (!Array.isArray(object.resourceLogs))
                      throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: array expected");
                    message.resourceLogs = [];
                    for (var i = 0; i < object.resourceLogs.length; ++i) {
                      if (typeof object.resourceLogs[i] != "object")
                        throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: object expected");
                      message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);
                    }
                  }
                  return message;
                }, ExportLogsServiceRequest.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if ((options.arrays || options.defaults) && (object.resourceLogs = []), message.resourceLogs && message.resourceLogs.length) {
                    object.resourceLogs = [];
                    for (var j = 0; j < message.resourceLogs.length; ++j)
                      object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);
                  }
                  return object;
                }, ExportLogsServiceRequest.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportLogsServiceRequest.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest";
                }, ExportLogsServiceRequest;
              }(), v1.ExportLogsServiceResponse = function() {
                function ExportLogsServiceResponse(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportLogsServiceResponse.prototype.partialSuccess = null, ExportLogsServiceResponse.create = function(properties) {
                  return new ExportLogsServiceResponse(properties);
                }, ExportLogsServiceResponse.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess") && $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.encode(message.partialSuccess, writer.uint32(
                    /* id 1, wireType 2 =*/
                    10
                  ).fork()).ldelim(), writer;
                }, ExportLogsServiceResponse.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportLogsServiceResponse.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.decode(reader, reader.uint32());
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportLogsServiceResponse.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportLogsServiceResponse.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
                    var error = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify(message.partialSuccess);
                    if (error)
                      return "partialSuccess." + error;
                  }
                  return null;
                }, ExportLogsServiceResponse.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();
                  if (object.partialSuccess != null) {
                    if (typeof object.partialSuccess != "object")
                      throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.partialSuccess: object expected");
                    message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.fromObject(object.partialSuccess);
                  }
                  return message;
                }, ExportLogsServiceResponse.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  return options.defaults && (object.partialSuccess = null), message.partialSuccess != null && message.hasOwnProperty("partialSuccess") && (object.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.toObject(message.partialSuccess, options)), object;
                }, ExportLogsServiceResponse.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportLogsServiceResponse.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse";
                }, ExportLogsServiceResponse;
              }(), v1.ExportLogsPartialSuccess = function() {
                function ExportLogsPartialSuccess(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ExportLogsPartialSuccess.prototype.rejectedLogRecords = null, ExportLogsPartialSuccess.prototype.errorMessage = null, ExportLogsPartialSuccess.create = function(properties) {
                  return new ExportLogsPartialSuccess(properties);
                }, ExportLogsPartialSuccess.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.rejectedLogRecords != null && Object.hasOwnProperty.call(message, "rejectedLogRecords") && writer.uint32(
                    /* id 1, wireType 0 =*/
                    8
                  ).int64(message.rejectedLogRecords), message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage") && writer.uint32(
                    /* id 2, wireType 2 =*/
                    18
                  ).string(message.errorMessage), writer;
                }, ExportLogsPartialSuccess.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ExportLogsPartialSuccess.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.rejectedLogRecords = reader.int64();
                        break;
                      }
                      case 2: {
                        message.errorMessage = reader.string();
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ExportLogsPartialSuccess.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ExportLogsPartialSuccess.verify = function(message) {
                  return typeof message != "object" || message === null ? "object expected" : message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords") && !$util.isInteger(message.rejectedLogRecords) && !(message.rejectedLogRecords && $util.isInteger(message.rejectedLogRecords.low) && $util.isInteger(message.rejectedLogRecords.high)) ? "rejectedLogRecords: integer|Long expected" : message.errorMessage != null && message.hasOwnProperty("errorMessage") && !$util.isString(message.errorMessage) ? "errorMessage: string expected" : null;
                }, ExportLogsPartialSuccess.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess)
                    return object;
                  var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();
                  return object.rejectedLogRecords != null && ($util.Long ? (message.rejectedLogRecords = $util.Long.fromValue(object.rejectedLogRecords)).unsigned = !1 : typeof object.rejectedLogRecords == "string" ? message.rejectedLogRecords = parseInt(object.rejectedLogRecords, 10) : typeof object.rejectedLogRecords == "number" ? message.rejectedLogRecords = object.rejectedLogRecords : typeof object.rejectedLogRecords == "object" && (message.rejectedLogRecords = new $util.LongBits(object.rejectedLogRecords.low >>> 0, object.rejectedLogRecords.high >>> 0).toNumber())), object.errorMessage != null && (message.errorMessage = String(object.errorMessage)), message;
                }, ExportLogsPartialSuccess.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if (options.defaults) {
                    if ($util.Long) {
                      var long = new $util.Long(0, 0, !1);
                      object.rejectedLogRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                      object.rejectedLogRecords = options.longs === String ? "0" : 0;
                    object.errorMessage = "";
                  }
                  return message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords") && (typeof message.rejectedLogRecords == "number" ? object.rejectedLogRecords = options.longs === String ? String(message.rejectedLogRecords) : message.rejectedLogRecords : object.rejectedLogRecords = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedLogRecords) : options.longs === Number ? new $util.LongBits(message.rejectedLogRecords.low >>> 0, message.rejectedLogRecords.high >>> 0).toNumber() : message.rejectedLogRecords), message.errorMessage != null && message.hasOwnProperty("errorMessage") && (object.errorMessage = message.errorMessage), object;
                }, ExportLogsPartialSuccess.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ExportLogsPartialSuccess.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess";
                }, ExportLogsPartialSuccess;
              }(), v1;
            }(), logs;
          }(), collector;
        }(), proto.metrics = function() {
          var metrics2 = {};
          return metrics2.v1 = function() {
            var v1 = {};
            return v1.MetricsData = function() {
              function MetricsData(properties) {
                if (this.resourceMetrics = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return MetricsData.prototype.resourceMetrics = $util.emptyArray, MetricsData.create = function(properties) {
                return new MetricsData(properties);
              }, MetricsData.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.resourceMetrics != null && message.resourceMetrics.length)
                  for (var i = 0; i < message.resourceMetrics.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, MetricsData.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, MetricsData.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.MetricsData(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.resourceMetrics && message.resourceMetrics.length || (message.resourceMetrics = []), message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, MetricsData.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, MetricsData.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
                  if (!Array.isArray(message.resourceMetrics))
                    return "resourceMetrics: array expected";
                  for (var i = 0; i < message.resourceMetrics.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);
                    if (error)
                      return "resourceMetrics." + error;
                  }
                }
                return null;
              }, MetricsData.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.MetricsData)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.MetricsData();
                if (object.resourceMetrics) {
                  if (!Array.isArray(object.resourceMetrics))
                    throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: array expected");
                  message.resourceMetrics = [];
                  for (var i = 0; i < object.resourceMetrics.length; ++i) {
                    if (typeof object.resourceMetrics[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: object expected");
                    message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);
                  }
                }
                return message;
              }, MetricsData.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.resourceMetrics = []), message.resourceMetrics && message.resourceMetrics.length) {
                  object.resourceMetrics = [];
                  for (var j = 0; j < message.resourceMetrics.length; ++j)
                    object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);
                }
                return object;
              }, MetricsData.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, MetricsData.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.MetricsData";
              }, MetricsData;
            }(), v1.ResourceMetrics = function() {
              function ResourceMetrics(properties) {
                if (this.scopeMetrics = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ResourceMetrics.prototype.resource = null, ResourceMetrics.prototype.scopeMetrics = $util.emptyArray, ResourceMetrics.prototype.schemaUrl = null, ResourceMetrics.create = function(properties) {
                return new ResourceMetrics(properties);
              }, ResourceMetrics.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.resource != null && Object.hasOwnProperty.call(message, "resource") && $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim(), message.scopeMetrics != null && message.scopeMetrics.length)
                  for (var i = 0; i < message.scopeMetrics.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.ScopeMetrics.encode(message.scopeMetrics[i], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                return message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.schemaUrl), writer;
              }, ResourceMetrics.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ResourceMetrics.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      message.scopeMetrics && message.scopeMetrics.length || (message.scopeMetrics = []), message.scopeMetrics.push($root.opentelemetry.proto.metrics.v1.ScopeMetrics.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ResourceMetrics.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ResourceMetrics.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                  var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                  if (error)
                    return "resource." + error;
                }
                if (message.scopeMetrics != null && message.hasOwnProperty("scopeMetrics")) {
                  if (!Array.isArray(message.scopeMetrics))
                    return "scopeMetrics: array expected";
                  for (var i = 0; i < message.scopeMetrics.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.verify(message.scopeMetrics[i]);
                    if (error)
                      return "scopeMetrics." + error;
                  }
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && !$util.isString(message.schemaUrl) ? "schemaUrl: string expected" : null;
              }, ResourceMetrics.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.ResourceMetrics)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();
                if (object.resource != null) {
                  if (typeof object.resource != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.resource: object expected");
                  message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
                }
                if (object.scopeMetrics) {
                  if (!Array.isArray(object.scopeMetrics))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: array expected");
                  message.scopeMetrics = [];
                  for (var i = 0; i < object.scopeMetrics.length; ++i) {
                    if (typeof object.scopeMetrics[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: object expected");
                    message.scopeMetrics[i] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.fromObject(object.scopeMetrics[i]);
                  }
                }
                return object.schemaUrl != null && (message.schemaUrl = String(object.schemaUrl)), message;
              }, ResourceMetrics.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.scopeMetrics = []), options.defaults && (object.resource = null, object.schemaUrl = ""), message.resource != null && message.hasOwnProperty("resource") && (object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options)), message.scopeMetrics && message.scopeMetrics.length) {
                  object.scopeMetrics = [];
                  for (var j = 0; j < message.scopeMetrics.length; ++j)
                    object.scopeMetrics[j] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.toObject(message.scopeMetrics[j], options);
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && (object.schemaUrl = message.schemaUrl), object;
              }, ResourceMetrics.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ResourceMetrics.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ResourceMetrics";
              }, ResourceMetrics;
            }(), v1.ScopeMetrics = function() {
              function ScopeMetrics(properties) {
                if (this.metrics = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ScopeMetrics.prototype.scope = null, ScopeMetrics.prototype.metrics = $util.emptyArray, ScopeMetrics.prototype.schemaUrl = null, ScopeMetrics.create = function(properties) {
                return new ScopeMetrics(properties);
              }, ScopeMetrics.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.scope != null && Object.hasOwnProperty.call(message, "scope") && $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim(), message.metrics != null && message.metrics.length)
                  for (var i = 0; i < message.metrics.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.Metric.encode(message.metrics[i], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                return message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.schemaUrl), writer;
              }, ScopeMetrics.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ScopeMetrics.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      message.metrics && message.metrics.length || (message.metrics = []), message.metrics.push($root.opentelemetry.proto.metrics.v1.Metric.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ScopeMetrics.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ScopeMetrics.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                  var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                  if (error)
                    return "scope." + error;
                }
                if (message.metrics != null && message.hasOwnProperty("metrics")) {
                  if (!Array.isArray(message.metrics))
                    return "metrics: array expected";
                  for (var i = 0; i < message.metrics.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.Metric.verify(message.metrics[i]);
                    if (error)
                      return "metrics." + error;
                  }
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && !$util.isString(message.schemaUrl) ? "schemaUrl: string expected" : null;
              }, ScopeMetrics.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.ScopeMetrics)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();
                if (object.scope != null) {
                  if (typeof object.scope != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.scope: object expected");
                  message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
                }
                if (object.metrics) {
                  if (!Array.isArray(object.metrics))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: array expected");
                  message.metrics = [];
                  for (var i = 0; i < object.metrics.length; ++i) {
                    if (typeof object.metrics[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: object expected");
                    message.metrics[i] = $root.opentelemetry.proto.metrics.v1.Metric.fromObject(object.metrics[i]);
                  }
                }
                return object.schemaUrl != null && (message.schemaUrl = String(object.schemaUrl)), message;
              }, ScopeMetrics.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.metrics = []), options.defaults && (object.scope = null, object.schemaUrl = ""), message.scope != null && message.hasOwnProperty("scope") && (object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options)), message.metrics && message.metrics.length) {
                  object.metrics = [];
                  for (var j = 0; j < message.metrics.length; ++j)
                    object.metrics[j] = $root.opentelemetry.proto.metrics.v1.Metric.toObject(message.metrics[j], options);
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && (object.schemaUrl = message.schemaUrl), object;
              }, ScopeMetrics.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ScopeMetrics.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ScopeMetrics";
              }, ScopeMetrics;
            }(), v1.Metric = function() {
              function Metric(properties) {
                if (properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              Metric.prototype.name = null, Metric.prototype.description = null, Metric.prototype.unit = null, Metric.prototype.gauge = null, Metric.prototype.sum = null, Metric.prototype.histogram = null, Metric.prototype.exponentialHistogram = null, Metric.prototype.summary = null;
              var $oneOfFields;
              return Object.defineProperty(Metric.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["gauge", "sum", "histogram", "exponentialHistogram", "summary"]),
                set: $util.oneOfSetter($oneOfFields)
              }), Metric.create = function(properties) {
                return new Metric(properties);
              }, Metric.encode = function(message, writer) {
                return writer || (writer = $Writer.create()), message.name != null && Object.hasOwnProperty.call(message, "name") && writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).string(message.name), message.description != null && Object.hasOwnProperty.call(message, "description") && writer.uint32(
                  /* id 2, wireType 2 =*/
                  18
                ).string(message.description), message.unit != null && Object.hasOwnProperty.call(message, "unit") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.unit), message.gauge != null && Object.hasOwnProperty.call(message, "gauge") && $root.opentelemetry.proto.metrics.v1.Gauge.encode(message.gauge, writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).fork()).ldelim(), message.sum != null && Object.hasOwnProperty.call(message, "sum") && $root.opentelemetry.proto.metrics.v1.Sum.encode(message.sum, writer.uint32(
                  /* id 7, wireType 2 =*/
                  58
                ).fork()).ldelim(), message.histogram != null && Object.hasOwnProperty.call(message, "histogram") && $root.opentelemetry.proto.metrics.v1.Histogram.encode(message.histogram, writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).fork()).ldelim(), message.exponentialHistogram != null && Object.hasOwnProperty.call(message, "exponentialHistogram") && $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.encode(message.exponentialHistogram, writer.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).fork()).ldelim(), message.summary != null && Object.hasOwnProperty.call(message, "summary") && $root.opentelemetry.proto.metrics.v1.Summary.encode(message.summary, writer.uint32(
                  /* id 11, wireType 2 =*/
                  90
                ).fork()).ldelim(), writer;
              }, Metric.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Metric.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Metric(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.name = reader.string();
                      break;
                    }
                    case 2: {
                      message.description = reader.string();
                      break;
                    }
                    case 3: {
                      message.unit = reader.string();
                      break;
                    }
                    case 5: {
                      message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.decode(reader, reader.uint32());
                      break;
                    }
                    case 7: {
                      message.sum = $root.opentelemetry.proto.metrics.v1.Sum.decode(reader, reader.uint32());
                      break;
                    }
                    case 9: {
                      message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.decode(reader, reader.uint32());
                      break;
                    }
                    case 10: {
                      message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.decode(reader, reader.uint32());
                      break;
                    }
                    case 11: {
                      message.summary = $root.opentelemetry.proto.metrics.v1.Summary.decode(reader, reader.uint32());
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Metric.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Metric.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name") && !$util.isString(message.name))
                  return "name: string expected";
                if (message.description != null && message.hasOwnProperty("description") && !$util.isString(message.description))
                  return "description: string expected";
                if (message.unit != null && message.hasOwnProperty("unit") && !$util.isString(message.unit))
                  return "unit: string expected";
                if (message.gauge != null && message.hasOwnProperty("gauge")) {
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Gauge.verify(message.gauge);
                    if (error)
                      return "gauge." + error;
                  }
                }
                if (message.sum != null && message.hasOwnProperty("sum")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Sum.verify(message.sum);
                    if (error)
                      return "sum." + error;
                  }
                }
                if (message.histogram != null && message.hasOwnProperty("histogram")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Histogram.verify(message.histogram);
                    if (error)
                      return "histogram." + error;
                  }
                }
                if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.verify(message.exponentialHistogram);
                    if (error)
                      return "exponentialHistogram." + error;
                  }
                }
                if (message.summary != null && message.hasOwnProperty("summary")) {
                  if (properties.data === 1)
                    return "data: multiple values";
                  properties.data = 1;
                  {
                    var error = $root.opentelemetry.proto.metrics.v1.Summary.verify(message.summary);
                    if (error)
                      return "summary." + error;
                  }
                }
                return null;
              }, Metric.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.Metric)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.Metric();
                if (object.name != null && (message.name = String(object.name)), object.description != null && (message.description = String(object.description)), object.unit != null && (message.unit = String(object.unit)), object.gauge != null) {
                  if (typeof object.gauge != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.gauge: object expected");
                  message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.fromObject(object.gauge);
                }
                if (object.sum != null) {
                  if (typeof object.sum != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.sum: object expected");
                  message.sum = $root.opentelemetry.proto.metrics.v1.Sum.fromObject(object.sum);
                }
                if (object.histogram != null) {
                  if (typeof object.histogram != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.histogram: object expected");
                  message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.fromObject(object.histogram);
                }
                if (object.exponentialHistogram != null) {
                  if (typeof object.exponentialHistogram != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.exponentialHistogram: object expected");
                  message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.fromObject(object.exponentialHistogram);
                }
                if (object.summary != null) {
                  if (typeof object.summary != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.Metric.summary: object expected");
                  message.summary = $root.opentelemetry.proto.metrics.v1.Summary.fromObject(object.summary);
                }
                return message;
              }, Metric.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                return options.defaults && (object.name = "", object.description = "", object.unit = ""), message.name != null && message.hasOwnProperty("name") && (object.name = message.name), message.description != null && message.hasOwnProperty("description") && (object.description = message.description), message.unit != null && message.hasOwnProperty("unit") && (object.unit = message.unit), message.gauge != null && message.hasOwnProperty("gauge") && (object.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.toObject(message.gauge, options), options.oneofs && (object.data = "gauge")), message.sum != null && message.hasOwnProperty("sum") && (object.sum = $root.opentelemetry.proto.metrics.v1.Sum.toObject(message.sum, options), options.oneofs && (object.data = "sum")), message.histogram != null && message.hasOwnProperty("histogram") && (object.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.toObject(message.histogram, options), options.oneofs && (object.data = "histogram")), message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram") && (object.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.toObject(message.exponentialHistogram, options), options.oneofs && (object.data = "exponentialHistogram")), message.summary != null && message.hasOwnProperty("summary") && (object.summary = $root.opentelemetry.proto.metrics.v1.Summary.toObject(message.summary, options), options.oneofs && (object.data = "summary")), object;
              }, Metric.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Metric.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Metric";
              }, Metric;
            }(), v1.Gauge = function() {
              function Gauge(properties) {
                if (this.dataPoints = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Gauge.prototype.dataPoints = $util.emptyArray, Gauge.create = function(properties) {
                return new Gauge(properties);
              }, Gauge.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.dataPoints != null && message.dataPoints.length)
                  for (var i = 0; i < message.dataPoints.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, Gauge.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Gauge.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Gauge(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.dataPoints && message.dataPoints.length || (message.dataPoints = []), message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Gauge.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Gauge.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i = 0; i < message.dataPoints.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                return null;
              }, Gauge.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.Gauge)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.Gauge();
                if (object.dataPoints) {
                  if (!Array.isArray(object.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i = 0; i < object.dataPoints.length; ++i) {
                    if (typeof object.dataPoints[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: object expected");
                    message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);
                  }
                }
                return message;
              }, Gauge.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.dataPoints = []), message.dataPoints && message.dataPoints.length) {
                  object.dataPoints = [];
                  for (var j = 0; j < message.dataPoints.length; ++j)
                    object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);
                }
                return object;
              }, Gauge.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Gauge.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Gauge";
              }, Gauge;
            }(), v1.Sum = function() {
              function Sum(properties) {
                if (this.dataPoints = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Sum.prototype.dataPoints = $util.emptyArray, Sum.prototype.aggregationTemporality = null, Sum.prototype.isMonotonic = null, Sum.create = function(properties) {
                return new Sum(properties);
              }, Sum.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.dataPoints != null && message.dataPoints.length)
                  for (var i = 0; i < message.dataPoints.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality") && writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.aggregationTemporality), message.isMonotonic != null && Object.hasOwnProperty.call(message, "isMonotonic") && writer.uint32(
                  /* id 3, wireType 0 =*/
                  24
                ).bool(message.isMonotonic), writer;
              }, Sum.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Sum.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Sum(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.dataPoints && message.dataPoints.length || (message.dataPoints = []), message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.aggregationTemporality = reader.int32();
                      break;
                    }
                    case 3: {
                      message.isMonotonic = reader.bool();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Sum.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Sum.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i = 0; i < message.dataPoints.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  switch (message.aggregationTemporality) {
                    default:
                      return "aggregationTemporality: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return message.isMonotonic != null && message.hasOwnProperty("isMonotonic") && typeof message.isMonotonic != "boolean" ? "isMonotonic: boolean expected" : null;
              }, Sum.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.Sum)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.Sum();
                if (object.dataPoints) {
                  if (!Array.isArray(object.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i = 0; i < object.dataPoints.length; ++i) {
                    if (typeof object.dataPoints[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: object expected");
                    message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);
                  }
                }
                switch (object.aggregationTemporality) {
                  default:
                    if (typeof object.aggregationTemporality == "number") {
                      message.aggregationTemporality = object.aggregationTemporality;
                      break;
                    }
                    break;
                  case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                  case 0:
                    message.aggregationTemporality = 0;
                    break;
                  case "AGGREGATION_TEMPORALITY_DELTA":
                  case 1:
                    message.aggregationTemporality = 1;
                    break;
                  case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                  case 2:
                    message.aggregationTemporality = 2;
                    break;
                }
                return object.isMonotonic != null && (message.isMonotonic = !!object.isMonotonic), message;
              }, Sum.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.dataPoints = []), options.defaults && (object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0, object.isMonotonic = !1), message.dataPoints && message.dataPoints.length) {
                  object.dataPoints = [];
                  for (var j = 0; j < message.dataPoints.length; ++j)
                    object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);
                }
                return message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality") && (object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === void 0 ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality), message.isMonotonic != null && message.hasOwnProperty("isMonotonic") && (object.isMonotonic = message.isMonotonic), object;
              }, Sum.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Sum.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Sum";
              }, Sum;
            }(), v1.Histogram = function() {
              function Histogram(properties) {
                if (this.dataPoints = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Histogram.prototype.dataPoints = $util.emptyArray, Histogram.prototype.aggregationTemporality = null, Histogram.create = function(properties) {
                return new Histogram(properties);
              }, Histogram.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.dataPoints != null && message.dataPoints.length)
                  for (var i = 0; i < message.dataPoints.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.encode(message.dataPoints[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality") && writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.aggregationTemporality), writer;
              }, Histogram.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Histogram.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Histogram(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.dataPoints && message.dataPoints.length || (message.dataPoints = []), message.dataPoints.push($root.opentelemetry.proto.metrics.v1.HistogramDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.aggregationTemporality = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Histogram.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Histogram.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i = 0; i < message.dataPoints.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.verify(message.dataPoints[i]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  switch (message.aggregationTemporality) {
                    default:
                      return "aggregationTemporality: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              }, Histogram.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.Histogram)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.Histogram();
                if (object.dataPoints) {
                  if (!Array.isArray(object.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i = 0; i < object.dataPoints.length; ++i) {
                    if (typeof object.dataPoints[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: object expected");
                    message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.fromObject(object.dataPoints[i]);
                  }
                }
                switch (object.aggregationTemporality) {
                  default:
                    if (typeof object.aggregationTemporality == "number") {
                      message.aggregationTemporality = object.aggregationTemporality;
                      break;
                    }
                    break;
                  case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                  case 0:
                    message.aggregationTemporality = 0;
                    break;
                  case "AGGREGATION_TEMPORALITY_DELTA":
                  case 1:
                    message.aggregationTemporality = 1;
                    break;
                  case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                  case 2:
                    message.aggregationTemporality = 2;
                    break;
                }
                return message;
              }, Histogram.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.dataPoints = []), options.defaults && (object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0), message.dataPoints && message.dataPoints.length) {
                  object.dataPoints = [];
                  for (var j = 0; j < message.dataPoints.length; ++j)
                    object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.toObject(message.dataPoints[j], options);
                }
                return message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality") && (object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === void 0 ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality), object;
              }, Histogram.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Histogram.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Histogram";
              }, Histogram;
            }(), v1.ExponentialHistogram = function() {
              function ExponentialHistogram(properties) {
                if (this.dataPoints = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ExponentialHistogram.prototype.dataPoints = $util.emptyArray, ExponentialHistogram.prototype.aggregationTemporality = null, ExponentialHistogram.create = function(properties) {
                return new ExponentialHistogram(properties);
              }, ExponentialHistogram.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.dataPoints != null && message.dataPoints.length)
                  for (var i = 0; i < message.dataPoints.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.encode(message.dataPoints[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality") && writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.aggregationTemporality), writer;
              }, ExponentialHistogram.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ExponentialHistogram.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.dataPoints && message.dataPoints.length || (message.dataPoints = []), message.dataPoints.push($root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.aggregationTemporality = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ExponentialHistogram.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ExponentialHistogram.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i = 0; i < message.dataPoints.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify(message.dataPoints[i]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
                  switch (message.aggregationTemporality) {
                    default:
                      return "aggregationTemporality: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              }, ExponentialHistogram.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogram)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();
                if (object.dataPoints) {
                  if (!Array.isArray(object.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i = 0; i < object.dataPoints.length; ++i) {
                    if (typeof object.dataPoints[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: object expected");
                    message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.fromObject(object.dataPoints[i]);
                  }
                }
                switch (object.aggregationTemporality) {
                  default:
                    if (typeof object.aggregationTemporality == "number") {
                      message.aggregationTemporality = object.aggregationTemporality;
                      break;
                    }
                    break;
                  case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
                  case 0:
                    message.aggregationTemporality = 0;
                    break;
                  case "AGGREGATION_TEMPORALITY_DELTA":
                  case 1:
                    message.aggregationTemporality = 1;
                    break;
                  case "AGGREGATION_TEMPORALITY_CUMULATIVE":
                  case 2:
                    message.aggregationTemporality = 2;
                    break;
                }
                return message;
              }, ExponentialHistogram.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.dataPoints = []), options.defaults && (object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0), message.dataPoints && message.dataPoints.length) {
                  object.dataPoints = [];
                  for (var j = 0; j < message.dataPoints.length; ++j)
                    object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.toObject(message.dataPoints[j], options);
                }
                return message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality") && (object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === void 0 ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality), object;
              }, ExponentialHistogram.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ExponentialHistogram.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogram";
              }, ExponentialHistogram;
            }(), v1.Summary = function() {
              function Summary(properties) {
                if (this.dataPoints = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return Summary.prototype.dataPoints = $util.emptyArray, Summary.create = function(properties) {
                return new Summary(properties);
              }, Summary.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.dataPoints != null && message.dataPoints.length)
                  for (var i = 0; i < message.dataPoints.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.encode(message.dataPoints[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, Summary.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Summary.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Summary(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.dataPoints && message.dataPoints.length || (message.dataPoints = []), message.dataPoints.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Summary.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Summary.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
                  if (!Array.isArray(message.dataPoints))
                    return "dataPoints: array expected";
                  for (var i = 0; i < message.dataPoints.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.verify(message.dataPoints[i]);
                    if (error)
                      return "dataPoints." + error;
                  }
                }
                return null;
              }, Summary.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.Summary)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.Summary();
                if (object.dataPoints) {
                  if (!Array.isArray(object.dataPoints))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: array expected");
                  message.dataPoints = [];
                  for (var i = 0; i < object.dataPoints.length; ++i) {
                    if (typeof object.dataPoints[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: object expected");
                    message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.fromObject(object.dataPoints[i]);
                  }
                }
                return message;
              }, Summary.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.dataPoints = []), message.dataPoints && message.dataPoints.length) {
                  object.dataPoints = [];
                  for (var j = 0; j < message.dataPoints.length; ++j)
                    object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.toObject(message.dataPoints[j], options);
                }
                return object;
              }, Summary.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Summary.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Summary";
              }, Summary;
            }(), v1.AggregationTemporality = function() {
              var valuesById = {}, values = Object.create(valuesById);
              return values[valuesById[0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0, values[valuesById[1] = "AGGREGATION_TEMPORALITY_DELTA"] = 1, values[valuesById[2] = "AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2, values;
            }(), v1.DataPointFlags = function() {
              var valuesById = {}, values = Object.create(valuesById);
              return values[valuesById[0] = "DATA_POINT_FLAGS_DO_NOT_USE"] = 0, values[valuesById[1] = "DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK"] = 1, values;
            }(), v1.NumberDataPoint = function() {
              function NumberDataPoint(properties) {
                if (this.attributes = [], this.exemplars = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              NumberDataPoint.prototype.attributes = $util.emptyArray, NumberDataPoint.prototype.startTimeUnixNano = null, NumberDataPoint.prototype.timeUnixNano = null, NumberDataPoint.prototype.asDouble = null, NumberDataPoint.prototype.asInt = null, NumberDataPoint.prototype.exemplars = $util.emptyArray, NumberDataPoint.prototype.flags = null;
              var $oneOfFields;
              return Object.defineProperty(NumberDataPoint.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
                set: $util.oneOfSetter($oneOfFields)
              }), NumberDataPoint.create = function(properties) {
                return new NumberDataPoint(properties);
              }, NumberDataPoint.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano") && writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).fixed64(message.startTimeUnixNano), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                  /* id 3, wireType 1 =*/
                  25
                ).fixed64(message.timeUnixNano), message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble") && writer.uint32(
                  /* id 4, wireType 1 =*/
                  33
                ).double(message.asDouble), message.exemplars != null && message.exemplars.length)
                  for (var i = 0; i < message.exemplars.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(
                      /* id 5, wireType 2 =*/
                      42
                    ).fork()).ldelim();
                if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt") && writer.uint32(
                  /* id 6, wireType 1 =*/
                  49
                ).sfixed64(message.asInt), message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 7, wireType 2 =*/
                      58
                    ).fork()).ldelim();
                return message.flags != null && Object.hasOwnProperty.call(message, "flags") && writer.uint32(
                  /* id 8, wireType 0 =*/
                  64
                ).uint32(message.flags), writer;
              }, NumberDataPoint.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, NumberDataPoint.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 7: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.asDouble = reader.double();
                      break;
                    }
                    case 6: {
                      message.asInt = reader.sfixed64();
                      break;
                    }
                    case 5: {
                      message.exemplars && message.exemplars.length || (message.exemplars = []), message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                      break;
                    }
                    case 8: {
                      message.flags = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, NumberDataPoint.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, NumberDataPoint.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && !$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
                if (message.asDouble != null && message.hasOwnProperty("asDouble") && (properties.value = 1, typeof message.asDouble != "number"))
                  return "asDouble: number expected";
                if (message.asInt != null && message.hasOwnProperty("asInt")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  if (properties.value = 1, !$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
                    return "asInt: integer|Long expected";
                }
                if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                  if (!Array.isArray(message.exemplars))
                    return "exemplars: array expected";
                  for (var i = 0; i < message.exemplars.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
                    if (error)
                      return "exemplars." + error;
                  }
                }
                return message.flags != null && message.hasOwnProperty("flags") && !$util.isInteger(message.flags) ? "flags: integer expected" : null;
              }, NumberDataPoint.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.NumberDataPoint)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.startTimeUnixNano != null && ($util.Long ? (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = !1 : typeof object.startTimeUnixNano == "string" ? message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10) : typeof object.startTimeUnixNano == "number" ? message.startTimeUnixNano = object.startTimeUnixNano : typeof object.startTimeUnixNano == "object" && (message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber())), object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.asDouble != null && (message.asDouble = Number(object.asDouble)), object.asInt != null && ($util.Long ? (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = !1 : typeof object.asInt == "string" ? message.asInt = parseInt(object.asInt, 10) : typeof object.asInt == "number" ? message.asInt = object.asInt : typeof object.asInt == "object" && (message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber())), object.exemplars) {
                  if (!Array.isArray(object.exemplars))
                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: array expected");
                  message.exemplars = [];
                  for (var i = 0; i < object.exemplars.length; ++i) {
                    if (typeof object.exemplars[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: object expected");
                    message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
                  }
                }
                return object.flags != null && (message.flags = object.flags >>> 0), message;
              }, NumberDataPoint.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.exemplars = [], object.attributes = []), options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  object.flags = 0;
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && (typeof message.startTimeUnixNano == "number" ? object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano : object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano), message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.asDouble != null && message.hasOwnProperty("asDouble") && (object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble, options.oneofs && (object.value = "asDouble")), message.exemplars && message.exemplars.length) {
                  object.exemplars = [];
                  for (var j = 0; j < message.exemplars.length; ++j)
                    object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
                }
                if (message.asInt != null && message.hasOwnProperty("asInt") && (typeof message.asInt == "number" ? object.asInt = options.longs === String ? String(message.asInt) : message.asInt : object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt, options.oneofs && (object.value = "asInt")), message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                return message.flags != null && message.hasOwnProperty("flags") && (object.flags = message.flags), object;
              }, NumberDataPoint.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, NumberDataPoint.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.NumberDataPoint";
              }, NumberDataPoint;
            }(), v1.HistogramDataPoint = function() {
              function HistogramDataPoint(properties) {
                if (this.attributes = [], this.bucketCounts = [], this.explicitBounds = [], this.exemplars = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              HistogramDataPoint.prototype.attributes = $util.emptyArray, HistogramDataPoint.prototype.startTimeUnixNano = null, HistogramDataPoint.prototype.timeUnixNano = null, HistogramDataPoint.prototype.count = null, HistogramDataPoint.prototype.sum = null, HistogramDataPoint.prototype.bucketCounts = $util.emptyArray, HistogramDataPoint.prototype.explicitBounds = $util.emptyArray, HistogramDataPoint.prototype.exemplars = $util.emptyArray, HistogramDataPoint.prototype.flags = null, HistogramDataPoint.prototype.min = null, HistogramDataPoint.prototype.max = null;
              var $oneOfFields;
              return Object.defineProperty(HistogramDataPoint.prototype, "_sum", {
                get: $util.oneOfGetter($oneOfFields = ["sum"]),
                set: $util.oneOfSetter($oneOfFields)
              }), Object.defineProperty(HistogramDataPoint.prototype, "_min", {
                get: $util.oneOfGetter($oneOfFields = ["min"]),
                set: $util.oneOfSetter($oneOfFields)
              }), Object.defineProperty(HistogramDataPoint.prototype, "_max", {
                get: $util.oneOfGetter($oneOfFields = ["max"]),
                set: $util.oneOfSetter($oneOfFields)
              }), HistogramDataPoint.create = function(properties) {
                return new HistogramDataPoint(properties);
              }, HistogramDataPoint.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano") && writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).fixed64(message.startTimeUnixNano), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                  /* id 3, wireType 1 =*/
                  25
                ).fixed64(message.timeUnixNano), message.count != null && Object.hasOwnProperty.call(message, "count") && writer.uint32(
                  /* id 4, wireType 1 =*/
                  33
                ).fixed64(message.count), message.sum != null && Object.hasOwnProperty.call(message, "sum") && writer.uint32(
                  /* id 5, wireType 1 =*/
                  41
                ).double(message.sum), message.bucketCounts != null && message.bucketCounts.length) {
                  writer.uint32(
                    /* id 6, wireType 2 =*/
                    50
                  ).fork();
                  for (var i = 0; i < message.bucketCounts.length; ++i)
                    writer.fixed64(message.bucketCounts[i]);
                  writer.ldelim();
                }
                if (message.explicitBounds != null && message.explicitBounds.length) {
                  writer.uint32(
                    /* id 7, wireType 2 =*/
                    58
                  ).fork();
                  for (var i = 0; i < message.explicitBounds.length; ++i)
                    writer.double(message.explicitBounds[i]);
                  writer.ldelim();
                }
                if (message.exemplars != null && message.exemplars.length)
                  for (var i = 0; i < message.exemplars.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(
                      /* id 8, wireType 2 =*/
                      66
                    ).fork()).ldelim();
                if (message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 9, wireType 2 =*/
                      74
                    ).fork()).ldelim();
                return message.flags != null && Object.hasOwnProperty.call(message, "flags") && writer.uint32(
                  /* id 10, wireType 0 =*/
                  80
                ).uint32(message.flags), message.min != null && Object.hasOwnProperty.call(message, "min") && writer.uint32(
                  /* id 11, wireType 1 =*/
                  89
                ).double(message.min), message.max != null && Object.hasOwnProperty.call(message, "max") && writer.uint32(
                  /* id 12, wireType 1 =*/
                  97
                ).double(message.max), writer;
              }, HistogramDataPoint.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, HistogramDataPoint.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 9: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.count = reader.fixed64();
                      break;
                    }
                    case 5: {
                      message.sum = reader.double();
                      break;
                    }
                    case 6: {
                      if (message.bucketCounts && message.bucketCounts.length || (message.bucketCounts = []), (tag & 7) === 2)
                        for (var end2 = reader.uint32() + reader.pos; reader.pos < end2; )
                          message.bucketCounts.push(reader.fixed64());
                      else
                        message.bucketCounts.push(reader.fixed64());
                      break;
                    }
                    case 7: {
                      if (message.explicitBounds && message.explicitBounds.length || (message.explicitBounds = []), (tag & 7) === 2)
                        for (var end2 = reader.uint32() + reader.pos; reader.pos < end2; )
                          message.explicitBounds.push(reader.double());
                      else
                        message.explicitBounds.push(reader.double());
                      break;
                    }
                    case 8: {
                      message.exemplars && message.exemplars.length || (message.exemplars = []), message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                      break;
                    }
                    case 10: {
                      message.flags = reader.uint32();
                      break;
                    }
                    case 11: {
                      message.min = reader.double();
                      break;
                    }
                    case 12: {
                      message.max = reader.double();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, HistogramDataPoint.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, HistogramDataPoint.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && !$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
                if (message.count != null && message.hasOwnProperty("count") && !$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                  return "count: integer|Long expected";
                if (message.sum != null && message.hasOwnProperty("sum") && (properties._sum = 1, typeof message.sum != "number"))
                  return "sum: number expected";
                if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
                  if (!Array.isArray(message.bucketCounts))
                    return "bucketCounts: array expected";
                  for (var i = 0; i < message.bucketCounts.length; ++i)
                    if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))
                      return "bucketCounts: integer|Long[] expected";
                }
                if (message.explicitBounds != null && message.hasOwnProperty("explicitBounds")) {
                  if (!Array.isArray(message.explicitBounds))
                    return "explicitBounds: array expected";
                  for (var i = 0; i < message.explicitBounds.length; ++i)
                    if (typeof message.explicitBounds[i] != "number")
                      return "explicitBounds: number[] expected";
                }
                if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                  if (!Array.isArray(message.exemplars))
                    return "exemplars: array expected";
                  for (var i = 0; i < message.exemplars.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
                    if (error)
                      return "exemplars." + error;
                  }
                }
                return message.flags != null && message.hasOwnProperty("flags") && !$util.isInteger(message.flags) ? "flags: integer expected" : message.min != null && message.hasOwnProperty("min") && (properties._min = 1, typeof message.min != "number") ? "min: number expected" : message.max != null && message.hasOwnProperty("max") && (properties._max = 1, typeof message.max != "number") ? "max: number expected" : null;
              }, HistogramDataPoint.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.HistogramDataPoint)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.startTimeUnixNano != null && ($util.Long ? (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = !1 : typeof object.startTimeUnixNano == "string" ? message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10) : typeof object.startTimeUnixNano == "number" ? message.startTimeUnixNano = object.startTimeUnixNano : typeof object.startTimeUnixNano == "object" && (message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber())), object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.count != null && ($util.Long ? (message.count = $util.Long.fromValue(object.count)).unsigned = !1 : typeof object.count == "string" ? message.count = parseInt(object.count, 10) : typeof object.count == "number" ? message.count = object.count : typeof object.count == "object" && (message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber())), object.sum != null && (message.sum = Number(object.sum)), object.bucketCounts) {
                  if (!Array.isArray(object.bucketCounts))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.bucketCounts: array expected");
                  message.bucketCounts = [];
                  for (var i = 0; i < object.bucketCounts.length; ++i)
                    $util.Long ? (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = !1 : typeof object.bucketCounts[i] == "string" ? message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10) : typeof object.bucketCounts[i] == "number" ? message.bucketCounts[i] = object.bucketCounts[i] : typeof object.bucketCounts[i] == "object" && (message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber());
                }
                if (object.explicitBounds) {
                  if (!Array.isArray(object.explicitBounds))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.explicitBounds: array expected");
                  message.explicitBounds = [];
                  for (var i = 0; i < object.explicitBounds.length; ++i)
                    message.explicitBounds[i] = Number(object.explicitBounds[i]);
                }
                if (object.exemplars) {
                  if (!Array.isArray(object.exemplars))
                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: array expected");
                  message.exemplars = [];
                  for (var i = 0; i < object.exemplars.length; ++i) {
                    if (typeof object.exemplars[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: object expected");
                    message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
                  }
                }
                return object.flags != null && (message.flags = object.flags >>> 0), object.min != null && (message.min = Number(object.min)), object.max != null && (message.max = Number(object.max)), message;
              }, HistogramDataPoint.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.bucketCounts = [], object.explicitBounds = [], object.exemplars = [], object.attributes = []), options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.count = options.longs === String ? "0" : 0;
                  object.flags = 0;
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && (typeof message.startTimeUnixNano == "number" ? object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano : object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano), message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.count != null && message.hasOwnProperty("count") && (typeof message.count == "number" ? object.count = options.longs === String ? String(message.count) : message.count : object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count), message.sum != null && message.hasOwnProperty("sum") && (object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum, options.oneofs && (object._sum = "sum")), message.bucketCounts && message.bucketCounts.length) {
                  object.bucketCounts = [];
                  for (var j = 0; j < message.bucketCounts.length; ++j)
                    typeof message.bucketCounts[j] == "number" ? object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j] : object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber() : message.bucketCounts[j];
                }
                if (message.explicitBounds && message.explicitBounds.length) {
                  object.explicitBounds = [];
                  for (var j = 0; j < message.explicitBounds.length; ++j)
                    object.explicitBounds[j] = options.json && !isFinite(message.explicitBounds[j]) ? String(message.explicitBounds[j]) : message.explicitBounds[j];
                }
                if (message.exemplars && message.exemplars.length) {
                  object.exemplars = [];
                  for (var j = 0; j < message.exemplars.length; ++j)
                    object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
                }
                if (message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                return message.flags != null && message.hasOwnProperty("flags") && (object.flags = message.flags), message.min != null && message.hasOwnProperty("min") && (object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min, options.oneofs && (object._min = "min")), message.max != null && message.hasOwnProperty("max") && (object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max, options.oneofs && (object._max = "max")), object;
              }, HistogramDataPoint.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, HistogramDataPoint.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.HistogramDataPoint";
              }, HistogramDataPoint;
            }(), v1.ExponentialHistogramDataPoint = function() {
              function ExponentialHistogramDataPoint(properties) {
                if (this.attributes = [], this.exemplars = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              ExponentialHistogramDataPoint.prototype.attributes = $util.emptyArray, ExponentialHistogramDataPoint.prototype.startTimeUnixNano = null, ExponentialHistogramDataPoint.prototype.timeUnixNano = null, ExponentialHistogramDataPoint.prototype.count = null, ExponentialHistogramDataPoint.prototype.sum = null, ExponentialHistogramDataPoint.prototype.scale = null, ExponentialHistogramDataPoint.prototype.zeroCount = null, ExponentialHistogramDataPoint.prototype.positive = null, ExponentialHistogramDataPoint.prototype.negative = null, ExponentialHistogramDataPoint.prototype.flags = null, ExponentialHistogramDataPoint.prototype.exemplars = $util.emptyArray, ExponentialHistogramDataPoint.prototype.min = null, ExponentialHistogramDataPoint.prototype.max = null, ExponentialHistogramDataPoint.prototype.zeroThreshold = null;
              var $oneOfFields;
              return Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_sum", {
                get: $util.oneOfGetter($oneOfFields = ["sum"]),
                set: $util.oneOfSetter($oneOfFields)
              }), Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_min", {
                get: $util.oneOfGetter($oneOfFields = ["min"]),
                set: $util.oneOfSetter($oneOfFields)
              }), Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_max", {
                get: $util.oneOfGetter($oneOfFields = ["max"]),
                set: $util.oneOfSetter($oneOfFields)
              }), ExponentialHistogramDataPoint.create = function(properties) {
                return new ExponentialHistogramDataPoint(properties);
              }, ExponentialHistogramDataPoint.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano") && writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).fixed64(message.startTimeUnixNano), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                  /* id 3, wireType 1 =*/
                  25
                ).fixed64(message.timeUnixNano), message.count != null && Object.hasOwnProperty.call(message, "count") && writer.uint32(
                  /* id 4, wireType 1 =*/
                  33
                ).fixed64(message.count), message.sum != null && Object.hasOwnProperty.call(message, "sum") && writer.uint32(
                  /* id 5, wireType 1 =*/
                  41
                ).double(message.sum), message.scale != null && Object.hasOwnProperty.call(message, "scale") && writer.uint32(
                  /* id 6, wireType 0 =*/
                  48
                ).sint32(message.scale), message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount") && writer.uint32(
                  /* id 7, wireType 1 =*/
                  57
                ).fixed64(message.zeroCount), message.positive != null && Object.hasOwnProperty.call(message, "positive") && $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.positive, writer.uint32(
                  /* id 8, wireType 2 =*/
                  66
                ).fork()).ldelim(), message.negative != null && Object.hasOwnProperty.call(message, "negative") && $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.negative, writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).fork()).ldelim(), message.flags != null && Object.hasOwnProperty.call(message, "flags") && writer.uint32(
                  /* id 10, wireType 0 =*/
                  80
                ).uint32(message.flags), message.exemplars != null && message.exemplars.length)
                  for (var i = 0; i < message.exemplars.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(
                      /* id 11, wireType 2 =*/
                      90
                    ).fork()).ldelim();
                return message.min != null && Object.hasOwnProperty.call(message, "min") && writer.uint32(
                  /* id 12, wireType 1 =*/
                  97
                ).double(message.min), message.max != null && Object.hasOwnProperty.call(message, "max") && writer.uint32(
                  /* id 13, wireType 1 =*/
                  105
                ).double(message.max), message.zeroThreshold != null && Object.hasOwnProperty.call(message, "zeroThreshold") && writer.uint32(
                  /* id 14, wireType 1 =*/
                  113
                ).double(message.zeroThreshold), writer;
              }, ExponentialHistogramDataPoint.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ExponentialHistogramDataPoint.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.count = reader.fixed64();
                      break;
                    }
                    case 5: {
                      message.sum = reader.double();
                      break;
                    }
                    case 6: {
                      message.scale = reader.sint32();
                      break;
                    }
                    case 7: {
                      message.zeroCount = reader.fixed64();
                      break;
                    }
                    case 8: {
                      message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
                      break;
                    }
                    case 9: {
                      message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
                      break;
                    }
                    case 10: {
                      message.flags = reader.uint32();
                      break;
                    }
                    case 11: {
                      message.exemplars && message.exemplars.length || (message.exemplars = []), message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
                      break;
                    }
                    case 12: {
                      message.min = reader.double();
                      break;
                    }
                    case 13: {
                      message.max = reader.double();
                      break;
                    }
                    case 14: {
                      message.zeroThreshold = reader.double();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ExponentialHistogramDataPoint.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ExponentialHistogramDataPoint.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && !$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
                if (message.count != null && message.hasOwnProperty("count") && !$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                  return "count: integer|Long expected";
                if (message.sum != null && message.hasOwnProperty("sum") && (properties._sum = 1, typeof message.sum != "number"))
                  return "sum: number expected";
                if (message.scale != null && message.hasOwnProperty("scale") && !$util.isInteger(message.scale))
                  return "scale: integer expected";
                if (message.zeroCount != null && message.hasOwnProperty("zeroCount") && !$util.isInteger(message.zeroCount) && !(message.zeroCount && $util.isInteger(message.zeroCount.low) && $util.isInteger(message.zeroCount.high)))
                  return "zeroCount: integer|Long expected";
                if (message.positive != null && message.hasOwnProperty("positive")) {
                  var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.positive);
                  if (error)
                    return "positive." + error;
                }
                if (message.negative != null && message.hasOwnProperty("negative")) {
                  var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.negative);
                  if (error)
                    return "negative." + error;
                }
                if (message.flags != null && message.hasOwnProperty("flags") && !$util.isInteger(message.flags))
                  return "flags: integer expected";
                if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
                  if (!Array.isArray(message.exemplars))
                    return "exemplars: array expected";
                  for (var i = 0; i < message.exemplars.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
                    if (error)
                      return "exemplars." + error;
                  }
                }
                return message.min != null && message.hasOwnProperty("min") && (properties._min = 1, typeof message.min != "number") ? "min: number expected" : message.max != null && message.hasOwnProperty("max") && (properties._max = 1, typeof message.max != "number") ? "max: number expected" : message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold") && typeof message.zeroThreshold != "number" ? "zeroThreshold: number expected" : null;
              }, ExponentialHistogramDataPoint.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.startTimeUnixNano != null && ($util.Long ? (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = !1 : typeof object.startTimeUnixNano == "string" ? message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10) : typeof object.startTimeUnixNano == "number" ? message.startTimeUnixNano = object.startTimeUnixNano : typeof object.startTimeUnixNano == "object" && (message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber())), object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.count != null && ($util.Long ? (message.count = $util.Long.fromValue(object.count)).unsigned = !1 : typeof object.count == "string" ? message.count = parseInt(object.count, 10) : typeof object.count == "number" ? message.count = object.count : typeof object.count == "object" && (message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber())), object.sum != null && (message.sum = Number(object.sum)), object.scale != null && (message.scale = object.scale | 0), object.zeroCount != null && ($util.Long ? (message.zeroCount = $util.Long.fromValue(object.zeroCount)).unsigned = !1 : typeof object.zeroCount == "string" ? message.zeroCount = parseInt(object.zeroCount, 10) : typeof object.zeroCount == "number" ? message.zeroCount = object.zeroCount : typeof object.zeroCount == "object" && (message.zeroCount = new $util.LongBits(object.zeroCount.low >>> 0, object.zeroCount.high >>> 0).toNumber())), object.positive != null) {
                  if (typeof object.positive != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.positive: object expected");
                  message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.positive);
                }
                if (object.negative != null) {
                  if (typeof object.negative != "object")
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.negative: object expected");
                  message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.negative);
                }
                if (object.flags != null && (message.flags = object.flags >>> 0), object.exemplars) {
                  if (!Array.isArray(object.exemplars))
                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: array expected");
                  message.exemplars = [];
                  for (var i = 0; i < object.exemplars.length; ++i) {
                    if (typeof object.exemplars[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: object expected");
                    message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
                  }
                }
                return object.min != null && (message.min = Number(object.min)), object.max != null && (message.max = Number(object.max)), object.zeroThreshold != null && (message.zeroThreshold = Number(object.zeroThreshold)), message;
              }, ExponentialHistogramDataPoint.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.attributes = [], object.exemplars = []), options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.count = options.longs === String ? "0" : 0;
                  if (object.scale = 0, $util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.zeroCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.zeroCount = options.longs === String ? "0" : 0;
                  object.positive = null, object.negative = null, object.flags = 0, object.zeroThreshold = 0;
                }
                if (message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && (typeof message.startTimeUnixNano == "number" ? object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano : object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano), message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.count != null && message.hasOwnProperty("count") && (typeof message.count == "number" ? object.count = options.longs === String ? String(message.count) : message.count : object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count), message.sum != null && message.hasOwnProperty("sum") && (object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum, options.oneofs && (object._sum = "sum")), message.scale != null && message.hasOwnProperty("scale") && (object.scale = message.scale), message.zeroCount != null && message.hasOwnProperty("zeroCount") && (typeof message.zeroCount == "number" ? object.zeroCount = options.longs === String ? String(message.zeroCount) : message.zeroCount : object.zeroCount = options.longs === String ? $util.Long.prototype.toString.call(message.zeroCount) : options.longs === Number ? new $util.LongBits(message.zeroCount.low >>> 0, message.zeroCount.high >>> 0).toNumber() : message.zeroCount), message.positive != null && message.hasOwnProperty("positive") && (object.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.positive, options)), message.negative != null && message.hasOwnProperty("negative") && (object.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.negative, options)), message.flags != null && message.hasOwnProperty("flags") && (object.flags = message.flags), message.exemplars && message.exemplars.length) {
                  object.exemplars = [];
                  for (var j = 0; j < message.exemplars.length; ++j)
                    object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
                }
                return message.min != null && message.hasOwnProperty("min") && (object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min, options.oneofs && (object._min = "min")), message.max != null && message.hasOwnProperty("max") && (object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max, options.oneofs && (object._max = "max")), message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold") && (object.zeroThreshold = options.json && !isFinite(message.zeroThreshold) ? String(message.zeroThreshold) : message.zeroThreshold), object;
              }, ExponentialHistogramDataPoint.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ExponentialHistogramDataPoint.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint";
              }, ExponentialHistogramDataPoint.Buckets = function() {
                function Buckets(properties) {
                  if (this.bucketCounts = [], properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return Buckets.prototype.offset = null, Buckets.prototype.bucketCounts = $util.emptyArray, Buckets.create = function(properties) {
                  return new Buckets(properties);
                }, Buckets.encode = function(message, writer) {
                  if (writer || (writer = $Writer.create()), message.offset != null && Object.hasOwnProperty.call(message, "offset") && writer.uint32(
                    /* id 1, wireType 0 =*/
                    8
                  ).sint32(message.offset), message.bucketCounts != null && message.bucketCounts.length) {
                    writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork();
                    for (var i = 0; i < message.bucketCounts.length; ++i)
                      writer.uint64(message.bucketCounts[i]);
                    writer.ldelim();
                  }
                  return writer;
                }, Buckets.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, Buckets.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.offset = reader.sint32();
                        break;
                      }
                      case 2: {
                        if (message.bucketCounts && message.bucketCounts.length || (message.bucketCounts = []), (tag & 7) === 2)
                          for (var end2 = reader.uint32() + reader.pos; reader.pos < end2; )
                            message.bucketCounts.push(reader.uint64());
                        else
                          message.bucketCounts.push(reader.uint64());
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, Buckets.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, Buckets.verify = function(message) {
                  if (typeof message != "object" || message === null)
                    return "object expected";
                  if (message.offset != null && message.hasOwnProperty("offset") && !$util.isInteger(message.offset))
                    return "offset: integer expected";
                  if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
                    if (!Array.isArray(message.bucketCounts))
                      return "bucketCounts: array expected";
                    for (var i = 0; i < message.bucketCounts.length; ++i)
                      if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))
                        return "bucketCounts: integer|Long[] expected";
                  }
                  return null;
                }, Buckets.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets)
                    return object;
                  var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();
                  if (object.offset != null && (message.offset = object.offset | 0), object.bucketCounts) {
                    if (!Array.isArray(object.bucketCounts))
                      throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucketCounts: array expected");
                    message.bucketCounts = [];
                    for (var i = 0; i < object.bucketCounts.length; ++i)
                      $util.Long ? (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = !0 : typeof object.bucketCounts[i] == "string" ? message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10) : typeof object.bucketCounts[i] == "number" ? message.bucketCounts[i] = object.bucketCounts[i] : typeof object.bucketCounts[i] == "object" && (message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber(!0));
                  }
                  return message;
                }, Buckets.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  if ((options.arrays || options.defaults) && (object.bucketCounts = []), options.defaults && (object.offset = 0), message.offset != null && message.hasOwnProperty("offset") && (object.offset = message.offset), message.bucketCounts && message.bucketCounts.length) {
                    object.bucketCounts = [];
                    for (var j = 0; j < message.bucketCounts.length; ++j)
                      typeof message.bucketCounts[j] == "number" ? object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j] : object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber(!0) : message.bucketCounts[j];
                  }
                  return object;
                }, Buckets.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, Buckets.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets";
                }, Buckets;
              }(), ExponentialHistogramDataPoint;
            }(), v1.SummaryDataPoint = function() {
              function SummaryDataPoint(properties) {
                if (this.attributes = [], this.quantileValues = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return SummaryDataPoint.prototype.attributes = $util.emptyArray, SummaryDataPoint.prototype.startTimeUnixNano = null, SummaryDataPoint.prototype.timeUnixNano = null, SummaryDataPoint.prototype.count = null, SummaryDataPoint.prototype.sum = null, SummaryDataPoint.prototype.quantileValues = $util.emptyArray, SummaryDataPoint.prototype.flags = null, SummaryDataPoint.create = function(properties) {
                return new SummaryDataPoint(properties);
              }, SummaryDataPoint.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano") && writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).fixed64(message.startTimeUnixNano), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                  /* id 3, wireType 1 =*/
                  25
                ).fixed64(message.timeUnixNano), message.count != null && Object.hasOwnProperty.call(message, "count") && writer.uint32(
                  /* id 4, wireType 1 =*/
                  33
                ).fixed64(message.count), message.sum != null && Object.hasOwnProperty.call(message, "sum") && writer.uint32(
                  /* id 5, wireType 1 =*/
                  41
                ).double(message.sum), message.quantileValues != null && message.quantileValues.length)
                  for (var i = 0; i < message.quantileValues.length; ++i)
                    $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.encode(message.quantileValues[i], writer.uint32(
                      /* id 6, wireType 2 =*/
                      50
                    ).fork()).ldelim();
                if (message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 7, wireType 2 =*/
                      58
                    ).fork()).ldelim();
                return message.flags != null && Object.hasOwnProperty.call(message, "flags") && writer.uint32(
                  /* id 8, wireType 0 =*/
                  64
                ).uint32(message.flags), writer;
              }, SummaryDataPoint.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, SummaryDataPoint.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 7: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.startTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 4: {
                      message.count = reader.fixed64();
                      break;
                    }
                    case 5: {
                      message.sum = reader.double();
                      break;
                    }
                    case 6: {
                      message.quantileValues && message.quantileValues.length || (message.quantileValues = []), message.quantileValues.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.decode(reader, reader.uint32()));
                      break;
                    }
                    case 8: {
                      message.flags = reader.uint32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, SummaryDataPoint.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, SummaryDataPoint.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && !$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
                  return "startTimeUnixNano: integer|Long expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
                if (message.count != null && message.hasOwnProperty("count") && !$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                  return "count: integer|Long expected";
                if (message.sum != null && message.hasOwnProperty("sum") && typeof message.sum != "number")
                  return "sum: number expected";
                if (message.quantileValues != null && message.hasOwnProperty("quantileValues")) {
                  if (!Array.isArray(message.quantileValues))
                    return "quantileValues: array expected";
                  for (var i = 0; i < message.quantileValues.length; ++i) {
                    var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify(message.quantileValues[i]);
                    if (error)
                      return "quantileValues." + error;
                  }
                }
                return message.flags != null && message.hasOwnProperty("flags") && !$util.isInteger(message.flags) ? "flags: integer expected" : null;
              }, SummaryDataPoint.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                if (object.startTimeUnixNano != null && ($util.Long ? (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = !1 : typeof object.startTimeUnixNano == "string" ? message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10) : typeof object.startTimeUnixNano == "number" ? message.startTimeUnixNano = object.startTimeUnixNano : typeof object.startTimeUnixNano == "object" && (message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber())), object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.count != null && ($util.Long ? (message.count = $util.Long.fromValue(object.count)).unsigned = !1 : typeof object.count == "string" ? message.count = parseInt(object.count, 10) : typeof object.count == "number" ? message.count = object.count : typeof object.count == "object" && (message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber())), object.sum != null && (message.sum = Number(object.sum)), object.quantileValues) {
                  if (!Array.isArray(object.quantileValues))
                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: array expected");
                  message.quantileValues = [];
                  for (var i = 0; i < object.quantileValues.length; ++i) {
                    if (typeof object.quantileValues[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: object expected");
                    message.quantileValues[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.fromObject(object.quantileValues[i]);
                  }
                }
                return object.flags != null && (message.flags = object.flags >>> 0), message;
              }, SummaryDataPoint.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.quantileValues = [], object.attributes = []), options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.startTimeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.count = options.longs === String ? "0" : 0;
                  object.sum = 0, object.flags = 0;
                }
                if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano") && (typeof message.startTimeUnixNano == "number" ? object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano : object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano), message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.count != null && message.hasOwnProperty("count") && (typeof message.count == "number" ? object.count = options.longs === String ? String(message.count) : message.count : object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count), message.sum != null && message.hasOwnProperty("sum") && (object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum), message.quantileValues && message.quantileValues.length) {
                  object.quantileValues = [];
                  for (var j = 0; j < message.quantileValues.length; ++j)
                    object.quantileValues[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.toObject(message.quantileValues[j], options);
                }
                if (message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                return message.flags != null && message.hasOwnProperty("flags") && (object.flags = message.flags), object;
              }, SummaryDataPoint.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, SummaryDataPoint.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint";
              }, SummaryDataPoint.ValueAtQuantile = function() {
                function ValueAtQuantile(properties) {
                  if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                      properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
                }
                return ValueAtQuantile.prototype.quantile = null, ValueAtQuantile.prototype.value = null, ValueAtQuantile.create = function(properties) {
                  return new ValueAtQuantile(properties);
                }, ValueAtQuantile.encode = function(message, writer) {
                  return writer || (writer = $Writer.create()), message.quantile != null && Object.hasOwnProperty.call(message, "quantile") && writer.uint32(
                    /* id 1, wireType 1 =*/
                    9
                  ).double(message.quantile), message.value != null && Object.hasOwnProperty.call(message, "value") && writer.uint32(
                    /* id 2, wireType 1 =*/
                    17
                  ).double(message.value), writer;
                }, ValueAtQuantile.encodeDelimited = function(message, writer) {
                  return this.encode(message, writer).ldelim();
                }, ValueAtQuantile.decode = function(reader, length) {
                  reader instanceof $Reader || (reader = $Reader.create(reader));
                  for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile(); reader.pos < end; ) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                      case 1: {
                        message.quantile = reader.double();
                        break;
                      }
                      case 2: {
                        message.value = reader.double();
                        break;
                      }
                      default:
                        reader.skipType(tag & 7);
                        break;
                    }
                  }
                  return message;
                }, ValueAtQuantile.decodeDelimited = function(reader) {
                  return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
                }, ValueAtQuantile.verify = function(message) {
                  return typeof message != "object" || message === null ? "object expected" : message.quantile != null && message.hasOwnProperty("quantile") && typeof message.quantile != "number" ? "quantile: number expected" : message.value != null && message.hasOwnProperty("value") && typeof message.value != "number" ? "value: number expected" : null;
                }, ValueAtQuantile.fromObject = function(object) {
                  if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile)
                    return object;
                  var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();
                  return object.quantile != null && (message.quantile = Number(object.quantile)), object.value != null && (message.value = Number(object.value)), message;
                }, ValueAtQuantile.toObject = function(message, options) {
                  options || (options = {});
                  var object = {};
                  return options.defaults && (object.quantile = 0, object.value = 0), message.quantile != null && message.hasOwnProperty("quantile") && (object.quantile = options.json && !isFinite(message.quantile) ? String(message.quantile) : message.quantile), message.value != null && message.hasOwnProperty("value") && (object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value), object;
                }, ValueAtQuantile.prototype.toJSON = function() {
                  return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                }, ValueAtQuantile.getTypeUrl = function(typeUrlPrefix) {
                  return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile";
                }, ValueAtQuantile;
              }(), SummaryDataPoint;
            }(), v1.Exemplar = function() {
              function Exemplar(properties) {
                if (this.filteredAttributes = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              Exemplar.prototype.filteredAttributes = $util.emptyArray, Exemplar.prototype.timeUnixNano = null, Exemplar.prototype.asDouble = null, Exemplar.prototype.asInt = null, Exemplar.prototype.spanId = null, Exemplar.prototype.traceId = null;
              var $oneOfFields;
              return Object.defineProperty(Exemplar.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
                set: $util.oneOfSetter($oneOfFields)
              }), Exemplar.create = function(properties) {
                return new Exemplar(properties);
              }, Exemplar.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                  /* id 2, wireType 1 =*/
                  17
                ).fixed64(message.timeUnixNano), message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble") && writer.uint32(
                  /* id 3, wireType 1 =*/
                  25
                ).double(message.asDouble), message.spanId != null && Object.hasOwnProperty.call(message, "spanId") && writer.uint32(
                  /* id 4, wireType 2 =*/
                  34
                ).bytes(message.spanId), message.traceId != null && Object.hasOwnProperty.call(message, "traceId") && writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).bytes(message.traceId), message.asInt != null && Object.hasOwnProperty.call(message, "asInt") && writer.uint32(
                  /* id 6, wireType 1 =*/
                  49
                ).sfixed64(message.asInt), message.filteredAttributes != null && message.filteredAttributes.length)
                  for (var i = 0; i < message.filteredAttributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.filteredAttributes[i], writer.uint32(
                      /* id 7, wireType 2 =*/
                      58
                    ).fork()).ldelim();
                return writer;
              }, Exemplar.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, Exemplar.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Exemplar(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 7: {
                      message.filteredAttributes && message.filteredAttributes.length || (message.filteredAttributes = []), message.filteredAttributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 2: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 3: {
                      message.asDouble = reader.double();
                      break;
                    }
                    case 6: {
                      message.asInt = reader.sfixed64();
                      break;
                    }
                    case 4: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    case 5: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, Exemplar.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, Exemplar.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                var properties = {};
                if (message.filteredAttributes != null && message.hasOwnProperty("filteredAttributes")) {
                  if (!Array.isArray(message.filteredAttributes))
                    return "filteredAttributes: array expected";
                  for (var i = 0; i < message.filteredAttributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.filteredAttributes[i]);
                    if (error)
                      return "filteredAttributes." + error;
                  }
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
                if (message.asDouble != null && message.hasOwnProperty("asDouble") && (properties.value = 1, typeof message.asDouble != "number"))
                  return "asDouble: number expected";
                if (message.asInt != null && message.hasOwnProperty("asInt")) {
                  if (properties.value === 1)
                    return "value: multiple values";
                  if (properties.value = 1, !$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
                    return "asInt: integer|Long expected";
                }
                return message.spanId != null && message.hasOwnProperty("spanId") && !(message.spanId && typeof message.spanId.length == "number" || $util.isString(message.spanId)) ? "spanId: buffer expected" : message.traceId != null && message.hasOwnProperty("traceId") && !(message.traceId && typeof message.traceId.length == "number" || $util.isString(message.traceId)) ? "traceId: buffer expected" : null;
              }, Exemplar.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.metrics.v1.Exemplar)
                  return object;
                var message = new $root.opentelemetry.proto.metrics.v1.Exemplar();
                if (object.filteredAttributes) {
                  if (!Array.isArray(object.filteredAttributes))
                    throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: array expected");
                  message.filteredAttributes = [];
                  for (var i = 0; i < object.filteredAttributes.length; ++i) {
                    if (typeof object.filteredAttributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: object expected");
                    message.filteredAttributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.filteredAttributes[i]);
                  }
                }
                return object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.asDouble != null && (message.asDouble = Number(object.asDouble)), object.asInt != null && ($util.Long ? (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = !1 : typeof object.asInt == "string" ? message.asInt = parseInt(object.asInt, 10) : typeof object.asInt == "number" ? message.asInt = object.asInt : typeof object.asInt == "object" && (message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber())), object.spanId != null && (typeof object.spanId == "string" ? $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0) : object.spanId.length >= 0 && (message.spanId = object.spanId)), object.traceId != null && (typeof object.traceId == "string" ? $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0) : object.traceId.length >= 0 && (message.traceId = object.traceId)), message;
              }, Exemplar.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.filteredAttributes = []), options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  options.bytes === String ? object.spanId = "" : (object.spanId = [], options.bytes !== Array && (object.spanId = $util.newBuffer(object.spanId))), options.bytes === String ? object.traceId = "" : (object.traceId = [], options.bytes !== Array && (object.traceId = $util.newBuffer(object.traceId)));
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.asDouble != null && message.hasOwnProperty("asDouble") && (object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble, options.oneofs && (object.value = "asDouble")), message.spanId != null && message.hasOwnProperty("spanId") && (object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId), message.traceId != null && message.hasOwnProperty("traceId") && (object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId), message.asInt != null && message.hasOwnProperty("asInt") && (typeof message.asInt == "number" ? object.asInt = options.longs === String ? String(message.asInt) : message.asInt : object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt, options.oneofs && (object.value = "asInt")), message.filteredAttributes && message.filteredAttributes.length) {
                  object.filteredAttributes = [];
                  for (var j = 0; j < message.filteredAttributes.length; ++j)
                    object.filteredAttributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.filteredAttributes[j], options);
                }
                return object;
              }, Exemplar.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, Exemplar.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Exemplar";
              }, Exemplar;
            }(), v1;
          }(), metrics2;
        }(), proto.logs = function() {
          var logs = {};
          return logs.v1 = function() {
            var v1 = {};
            return v1.LogsData = function() {
              function LogsData(properties) {
                if (this.resourceLogs = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return LogsData.prototype.resourceLogs = $util.emptyArray, LogsData.create = function(properties) {
                return new LogsData(properties);
              }, LogsData.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.resourceLogs != null && message.resourceLogs.length)
                  for (var i = 0; i < message.resourceLogs.length; ++i)
                    $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(
                      /* id 1, wireType 2 =*/
                      10
                    ).fork()).ldelim();
                return writer;
              }, LogsData.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, LogsData.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogsData(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.resourceLogs && message.resourceLogs.length || (message.resourceLogs = []), message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, LogsData.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, LogsData.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
                  if (!Array.isArray(message.resourceLogs))
                    return "resourceLogs: array expected";
                  for (var i = 0; i < message.resourceLogs.length; ++i) {
                    var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);
                    if (error)
                      return "resourceLogs." + error;
                  }
                }
                return null;
              }, LogsData.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.logs.v1.LogsData)
                  return object;
                var message = new $root.opentelemetry.proto.logs.v1.LogsData();
                if (object.resourceLogs) {
                  if (!Array.isArray(object.resourceLogs))
                    throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: array expected");
                  message.resourceLogs = [];
                  for (var i = 0; i < object.resourceLogs.length; ++i) {
                    if (typeof object.resourceLogs[i] != "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: object expected");
                    message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);
                  }
                }
                return message;
              }, LogsData.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.resourceLogs = []), message.resourceLogs && message.resourceLogs.length) {
                  object.resourceLogs = [];
                  for (var j = 0; j < message.resourceLogs.length; ++j)
                    object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);
                }
                return object;
              }, LogsData.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, LogsData.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogsData";
              }, LogsData;
            }(), v1.ResourceLogs = function() {
              function ResourceLogs(properties) {
                if (this.scopeLogs = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ResourceLogs.prototype.resource = null, ResourceLogs.prototype.scopeLogs = $util.emptyArray, ResourceLogs.prototype.schemaUrl = null, ResourceLogs.create = function(properties) {
                return new ResourceLogs(properties);
              }, ResourceLogs.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.resource != null && Object.hasOwnProperty.call(message, "resource") && $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim(), message.scopeLogs != null && message.scopeLogs.length)
                  for (var i = 0; i < message.scopeLogs.length; ++i)
                    $root.opentelemetry.proto.logs.v1.ScopeLogs.encode(message.scopeLogs[i], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                return message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.schemaUrl), writer;
              }, ResourceLogs.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ResourceLogs.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ResourceLogs(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      message.scopeLogs && message.scopeLogs.length || (message.scopeLogs = []), message.scopeLogs.push($root.opentelemetry.proto.logs.v1.ScopeLogs.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ResourceLogs.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ResourceLogs.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.resource != null && message.hasOwnProperty("resource")) {
                  var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
                  if (error)
                    return "resource." + error;
                }
                if (message.scopeLogs != null && message.hasOwnProperty("scopeLogs")) {
                  if (!Array.isArray(message.scopeLogs))
                    return "scopeLogs: array expected";
                  for (var i = 0; i < message.scopeLogs.length; ++i) {
                    var error = $root.opentelemetry.proto.logs.v1.ScopeLogs.verify(message.scopeLogs[i]);
                    if (error)
                      return "scopeLogs." + error;
                  }
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && !$util.isString(message.schemaUrl) ? "schemaUrl: string expected" : null;
              }, ResourceLogs.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.logs.v1.ResourceLogs)
                  return object;
                var message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();
                if (object.resource != null) {
                  if (typeof object.resource != "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.resource: object expected");
                  message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
                }
                if (object.scopeLogs) {
                  if (!Array.isArray(object.scopeLogs))
                    throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: array expected");
                  message.scopeLogs = [];
                  for (var i = 0; i < object.scopeLogs.length; ++i) {
                    if (typeof object.scopeLogs[i] != "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: object expected");
                    message.scopeLogs[i] = $root.opentelemetry.proto.logs.v1.ScopeLogs.fromObject(object.scopeLogs[i]);
                  }
                }
                return object.schemaUrl != null && (message.schemaUrl = String(object.schemaUrl)), message;
              }, ResourceLogs.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.scopeLogs = []), options.defaults && (object.resource = null, object.schemaUrl = ""), message.resource != null && message.hasOwnProperty("resource") && (object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options)), message.scopeLogs && message.scopeLogs.length) {
                  object.scopeLogs = [];
                  for (var j = 0; j < message.scopeLogs.length; ++j)
                    object.scopeLogs[j] = $root.opentelemetry.proto.logs.v1.ScopeLogs.toObject(message.scopeLogs[j], options);
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && (object.schemaUrl = message.schemaUrl), object;
              }, ResourceLogs.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ResourceLogs.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.logs.v1.ResourceLogs";
              }, ResourceLogs;
            }(), v1.ScopeLogs = function() {
              function ScopeLogs(properties) {
                if (this.logRecords = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return ScopeLogs.prototype.scope = null, ScopeLogs.prototype.logRecords = $util.emptyArray, ScopeLogs.prototype.schemaUrl = null, ScopeLogs.create = function(properties) {
                return new ScopeLogs(properties);
              }, ScopeLogs.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.scope != null && Object.hasOwnProperty.call(message, "scope") && $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(
                  /* id 1, wireType 2 =*/
                  10
                ).fork()).ldelim(), message.logRecords != null && message.logRecords.length)
                  for (var i = 0; i < message.logRecords.length; ++i)
                    $root.opentelemetry.proto.logs.v1.LogRecord.encode(message.logRecords[i], writer.uint32(
                      /* id 2, wireType 2 =*/
                      18
                    ).fork()).ldelim();
                return message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.schemaUrl), writer;
              }, ScopeLogs.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, ScopeLogs.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ScopeLogs(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
                      break;
                    }
                    case 2: {
                      message.logRecords && message.logRecords.length || (message.logRecords = []), message.logRecords.push($root.opentelemetry.proto.logs.v1.LogRecord.decode(reader, reader.uint32()));
                      break;
                    }
                    case 3: {
                      message.schemaUrl = reader.string();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, ScopeLogs.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, ScopeLogs.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.scope != null && message.hasOwnProperty("scope")) {
                  var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
                  if (error)
                    return "scope." + error;
                }
                if (message.logRecords != null && message.hasOwnProperty("logRecords")) {
                  if (!Array.isArray(message.logRecords))
                    return "logRecords: array expected";
                  for (var i = 0; i < message.logRecords.length; ++i) {
                    var error = $root.opentelemetry.proto.logs.v1.LogRecord.verify(message.logRecords[i]);
                    if (error)
                      return "logRecords." + error;
                  }
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && !$util.isString(message.schemaUrl) ? "schemaUrl: string expected" : null;
              }, ScopeLogs.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.logs.v1.ScopeLogs)
                  return object;
                var message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();
                if (object.scope != null) {
                  if (typeof object.scope != "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.scope: object expected");
                  message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
                }
                if (object.logRecords) {
                  if (!Array.isArray(object.logRecords))
                    throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: array expected");
                  message.logRecords = [];
                  for (var i = 0; i < object.logRecords.length; ++i) {
                    if (typeof object.logRecords[i] != "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: object expected");
                    message.logRecords[i] = $root.opentelemetry.proto.logs.v1.LogRecord.fromObject(object.logRecords[i]);
                  }
                }
                return object.schemaUrl != null && (message.schemaUrl = String(object.schemaUrl)), message;
              }, ScopeLogs.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.logRecords = []), options.defaults && (object.scope = null, object.schemaUrl = ""), message.scope != null && message.hasOwnProperty("scope") && (object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options)), message.logRecords && message.logRecords.length) {
                  object.logRecords = [];
                  for (var j = 0; j < message.logRecords.length; ++j)
                    object.logRecords[j] = $root.opentelemetry.proto.logs.v1.LogRecord.toObject(message.logRecords[j], options);
                }
                return message.schemaUrl != null && message.hasOwnProperty("schemaUrl") && (object.schemaUrl = message.schemaUrl), object;
              }, ScopeLogs.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, ScopeLogs.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.logs.v1.ScopeLogs";
              }, ScopeLogs;
            }(), v1.SeverityNumber = function() {
              var valuesById = {}, values = Object.create(valuesById);
              return values[valuesById[0] = "SEVERITY_NUMBER_UNSPECIFIED"] = 0, values[valuesById[1] = "SEVERITY_NUMBER_TRACE"] = 1, values[valuesById[2] = "SEVERITY_NUMBER_TRACE2"] = 2, values[valuesById[3] = "SEVERITY_NUMBER_TRACE3"] = 3, values[valuesById[4] = "SEVERITY_NUMBER_TRACE4"] = 4, values[valuesById[5] = "SEVERITY_NUMBER_DEBUG"] = 5, values[valuesById[6] = "SEVERITY_NUMBER_DEBUG2"] = 6, values[valuesById[7] = "SEVERITY_NUMBER_DEBUG3"] = 7, values[valuesById[8] = "SEVERITY_NUMBER_DEBUG4"] = 8, values[valuesById[9] = "SEVERITY_NUMBER_INFO"] = 9, values[valuesById[10] = "SEVERITY_NUMBER_INFO2"] = 10, values[valuesById[11] = "SEVERITY_NUMBER_INFO3"] = 11, values[valuesById[12] = "SEVERITY_NUMBER_INFO4"] = 12, values[valuesById[13] = "SEVERITY_NUMBER_WARN"] = 13, values[valuesById[14] = "SEVERITY_NUMBER_WARN2"] = 14, values[valuesById[15] = "SEVERITY_NUMBER_WARN3"] = 15, values[valuesById[16] = "SEVERITY_NUMBER_WARN4"] = 16, values[valuesById[17] = "SEVERITY_NUMBER_ERROR"] = 17, values[valuesById[18] = "SEVERITY_NUMBER_ERROR2"] = 18, values[valuesById[19] = "SEVERITY_NUMBER_ERROR3"] = 19, values[valuesById[20] = "SEVERITY_NUMBER_ERROR4"] = 20, values[valuesById[21] = "SEVERITY_NUMBER_FATAL"] = 21, values[valuesById[22] = "SEVERITY_NUMBER_FATAL2"] = 22, values[valuesById[23] = "SEVERITY_NUMBER_FATAL3"] = 23, values[valuesById[24] = "SEVERITY_NUMBER_FATAL4"] = 24, values;
            }(), v1.LogRecordFlags = function() {
              var valuesById = {}, values = Object.create(valuesById);
              return values[valuesById[0] = "LOG_RECORD_FLAGS_DO_NOT_USE"] = 0, values[valuesById[255] = "LOG_RECORD_FLAGS_TRACE_FLAGS_MASK"] = 255, values;
            }(), v1.LogRecord = function() {
              function LogRecord(properties) {
                if (this.attributes = [], properties)
                  for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    properties[keys[i]] != null && (this[keys[i]] = properties[keys[i]]);
              }
              return LogRecord.prototype.timeUnixNano = null, LogRecord.prototype.observedTimeUnixNano = null, LogRecord.prototype.severityNumber = null, LogRecord.prototype.severityText = null, LogRecord.prototype.body = null, LogRecord.prototype.attributes = $util.emptyArray, LogRecord.prototype.droppedAttributesCount = null, LogRecord.prototype.flags = null, LogRecord.prototype.traceId = null, LogRecord.prototype.spanId = null, LogRecord.create = function(properties) {
                return new LogRecord(properties);
              }, LogRecord.encode = function(message, writer) {
                if (writer || (writer = $Writer.create()), message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano") && writer.uint32(
                  /* id 1, wireType 1 =*/
                  9
                ).fixed64(message.timeUnixNano), message.severityNumber != null && Object.hasOwnProperty.call(message, "severityNumber") && writer.uint32(
                  /* id 2, wireType 0 =*/
                  16
                ).int32(message.severityNumber), message.severityText != null && Object.hasOwnProperty.call(message, "severityText") && writer.uint32(
                  /* id 3, wireType 2 =*/
                  26
                ).string(message.severityText), message.body != null && Object.hasOwnProperty.call(message, "body") && $root.opentelemetry.proto.common.v1.AnyValue.encode(message.body, writer.uint32(
                  /* id 5, wireType 2 =*/
                  42
                ).fork()).ldelim(), message.attributes != null && message.attributes.length)
                  for (var i = 0; i < message.attributes.length; ++i)
                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(
                      /* id 6, wireType 2 =*/
                      50
                    ).fork()).ldelim();
                return message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount") && writer.uint32(
                  /* id 7, wireType 0 =*/
                  56
                ).uint32(message.droppedAttributesCount), message.flags != null && Object.hasOwnProperty.call(message, "flags") && writer.uint32(
                  /* id 8, wireType 5 =*/
                  69
                ).fixed32(message.flags), message.traceId != null && Object.hasOwnProperty.call(message, "traceId") && writer.uint32(
                  /* id 9, wireType 2 =*/
                  74
                ).bytes(message.traceId), message.spanId != null && Object.hasOwnProperty.call(message, "spanId") && writer.uint32(
                  /* id 10, wireType 2 =*/
                  82
                ).bytes(message.spanId), message.observedTimeUnixNano != null && Object.hasOwnProperty.call(message, "observedTimeUnixNano") && writer.uint32(
                  /* id 11, wireType 1 =*/
                  89
                ).fixed64(message.observedTimeUnixNano), writer;
              }, LogRecord.encodeDelimited = function(message, writer) {
                return this.encode(message, writer).ldelim();
              }, LogRecord.decode = function(reader, length) {
                reader instanceof $Reader || (reader = $Reader.create(reader));
                for (var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogRecord(); reader.pos < end; ) {
                  var tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.timeUnixNano = reader.fixed64();
                      break;
                    }
                    case 11: {
                      message.observedTimeUnixNano = reader.fixed64();
                      break;
                    }
                    case 2: {
                      message.severityNumber = reader.int32();
                      break;
                    }
                    case 3: {
                      message.severityText = reader.string();
                      break;
                    }
                    case 5: {
                      message.body = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
                      break;
                    }
                    case 6: {
                      message.attributes && message.attributes.length || (message.attributes = []), message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
                      break;
                    }
                    case 7: {
                      message.droppedAttributesCount = reader.uint32();
                      break;
                    }
                    case 8: {
                      message.flags = reader.fixed32();
                      break;
                    }
                    case 9: {
                      message.traceId = reader.bytes();
                      break;
                    }
                    case 10: {
                      message.spanId = reader.bytes();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              }, LogRecord.decodeDelimited = function(reader) {
                return reader instanceof $Reader || (reader = new $Reader(reader)), this.decode(reader, reader.uint32());
              }, LogRecord.verify = function(message) {
                if (typeof message != "object" || message === null)
                  return "object expected";
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && !$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
                  return "timeUnixNano: integer|Long expected";
                if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano") && !$util.isInteger(message.observedTimeUnixNano) && !(message.observedTimeUnixNano && $util.isInteger(message.observedTimeUnixNano.low) && $util.isInteger(message.observedTimeUnixNano.high)))
                  return "observedTimeUnixNano: integer|Long expected";
                if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
                  switch (message.severityNumber) {
                    default:
                      return "severityNumber: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                      break;
                  }
                if (message.severityText != null && message.hasOwnProperty("severityText") && !$util.isString(message.severityText))
                  return "severityText: string expected";
                if (message.body != null && message.hasOwnProperty("body")) {
                  var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.body);
                  if (error)
                    return "body." + error;
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                  if (!Array.isArray(message.attributes))
                    return "attributes: array expected";
                  for (var i = 0; i < message.attributes.length; ++i) {
                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
                    if (error)
                      return "attributes." + error;
                  }
                }
                return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && !$util.isInteger(message.droppedAttributesCount) ? "droppedAttributesCount: integer expected" : message.flags != null && message.hasOwnProperty("flags") && !$util.isInteger(message.flags) ? "flags: integer expected" : message.traceId != null && message.hasOwnProperty("traceId") && !(message.traceId && typeof message.traceId.length == "number" || $util.isString(message.traceId)) ? "traceId: buffer expected" : message.spanId != null && message.hasOwnProperty("spanId") && !(message.spanId && typeof message.spanId.length == "number" || $util.isString(message.spanId)) ? "spanId: buffer expected" : null;
              }, LogRecord.fromObject = function(object) {
                if (object instanceof $root.opentelemetry.proto.logs.v1.LogRecord)
                  return object;
                var message = new $root.opentelemetry.proto.logs.v1.LogRecord();
                switch (object.timeUnixNano != null && ($util.Long ? (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = !1 : typeof object.timeUnixNano == "string" ? message.timeUnixNano = parseInt(object.timeUnixNano, 10) : typeof object.timeUnixNano == "number" ? message.timeUnixNano = object.timeUnixNano : typeof object.timeUnixNano == "object" && (message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber())), object.observedTimeUnixNano != null && ($util.Long ? (message.observedTimeUnixNano = $util.Long.fromValue(object.observedTimeUnixNano)).unsigned = !1 : typeof object.observedTimeUnixNano == "string" ? message.observedTimeUnixNano = parseInt(object.observedTimeUnixNano, 10) : typeof object.observedTimeUnixNano == "number" ? message.observedTimeUnixNano = object.observedTimeUnixNano : typeof object.observedTimeUnixNano == "object" && (message.observedTimeUnixNano = new $util.LongBits(object.observedTimeUnixNano.low >>> 0, object.observedTimeUnixNano.high >>> 0).toNumber())), object.severityNumber) {
                  default:
                    if (typeof object.severityNumber == "number") {
                      message.severityNumber = object.severityNumber;
                      break;
                    }
                    break;
                  case "SEVERITY_NUMBER_UNSPECIFIED":
                  case 0:
                    message.severityNumber = 0;
                    break;
                  case "SEVERITY_NUMBER_TRACE":
                  case 1:
                    message.severityNumber = 1;
                    break;
                  case "SEVERITY_NUMBER_TRACE2":
                  case 2:
                    message.severityNumber = 2;
                    break;
                  case "SEVERITY_NUMBER_TRACE3":
                  case 3:
                    message.severityNumber = 3;
                    break;
                  case "SEVERITY_NUMBER_TRACE4":
                  case 4:
                    message.severityNumber = 4;
                    break;
                  case "SEVERITY_NUMBER_DEBUG":
                  case 5:
                    message.severityNumber = 5;
                    break;
                  case "SEVERITY_NUMBER_DEBUG2":
                  case 6:
                    message.severityNumber = 6;
                    break;
                  case "SEVERITY_NUMBER_DEBUG3":
                  case 7:
                    message.severityNumber = 7;
                    break;
                  case "SEVERITY_NUMBER_DEBUG4":
                  case 8:
                    message.severityNumber = 8;
                    break;
                  case "SEVERITY_NUMBER_INFO":
                  case 9:
                    message.severityNumber = 9;
                    break;
                  case "SEVERITY_NUMBER_INFO2":
                  case 10:
                    message.severityNumber = 10;
                    break;
                  case "SEVERITY_NUMBER_INFO3":
                  case 11:
                    message.severityNumber = 11;
                    break;
                  case "SEVERITY_NUMBER_INFO4":
                  case 12:
                    message.severityNumber = 12;
                    break;
                  case "SEVERITY_NUMBER_WARN":
                  case 13:
                    message.severityNumber = 13;
                    break;
                  case "SEVERITY_NUMBER_WARN2":
                  case 14:
                    message.severityNumber = 14;
                    break;
                  case "SEVERITY_NUMBER_WARN3":
                  case 15:
                    message.severityNumber = 15;
                    break;
                  case "SEVERITY_NUMBER_WARN4":
                  case 16:
                    message.severityNumber = 16;
                    break;
                  case "SEVERITY_NUMBER_ERROR":
                  case 17:
                    message.severityNumber = 17;
                    break;
                  case "SEVERITY_NUMBER_ERROR2":
                  case 18:
                    message.severityNumber = 18;
                    break;
                  case "SEVERITY_NUMBER_ERROR3":
                  case 19:
                    message.severityNumber = 19;
                    break;
                  case "SEVERITY_NUMBER_ERROR4":
                  case 20:
                    message.severityNumber = 20;
                    break;
                  case "SEVERITY_NUMBER_FATAL":
                  case 21:
                    message.severityNumber = 21;
                    break;
                  case "SEVERITY_NUMBER_FATAL2":
                  case 22:
                    message.severityNumber = 22;
                    break;
                  case "SEVERITY_NUMBER_FATAL3":
                  case 23:
                    message.severityNumber = 23;
                    break;
                  case "SEVERITY_NUMBER_FATAL4":
                  case 24:
                    message.severityNumber = 24;
                    break;
                }
                if (object.severityText != null && (message.severityText = String(object.severityText)), object.body != null) {
                  if (typeof object.body != "object")
                    throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.body: object expected");
                  message.body = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.body);
                }
                if (object.attributes) {
                  if (!Array.isArray(object.attributes))
                    throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: array expected");
                  message.attributes = [];
                  for (var i = 0; i < object.attributes.length; ++i) {
                    if (typeof object.attributes[i] != "object")
                      throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: object expected");
                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
                  }
                }
                return object.droppedAttributesCount != null && (message.droppedAttributesCount = object.droppedAttributesCount >>> 0), object.flags != null && (message.flags = object.flags >>> 0), object.traceId != null && (typeof object.traceId == "string" ? $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0) : object.traceId.length >= 0 && (message.traceId = object.traceId)), object.spanId != null && (typeof object.spanId == "string" ? $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0) : object.spanId.length >= 0 && (message.spanId = object.spanId)), message;
              }, LogRecord.toObject = function(message, options) {
                options || (options = {});
                var object = {};
                if ((options.arrays || options.defaults) && (object.attributes = []), options.defaults) {
                  if ($util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.timeUnixNano = options.longs === String ? "0" : 0;
                  if (object.severityNumber = options.enums === String ? "SEVERITY_NUMBER_UNSPECIFIED" : 0, object.severityText = "", object.body = null, object.droppedAttributesCount = 0, object.flags = 0, options.bytes === String ? object.traceId = "" : (object.traceId = [], options.bytes !== Array && (object.traceId = $util.newBuffer(object.traceId))), options.bytes === String ? object.spanId = "" : (object.spanId = [], options.bytes !== Array && (object.spanId = $util.newBuffer(object.spanId))), $util.Long) {
                    var long = new $util.Long(0, 0, !1);
                    object.observedTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                  } else
                    object.observedTimeUnixNano = options.longs === String ? "0" : 0;
                }
                if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano") && (typeof message.timeUnixNano == "number" ? object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano : object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano), message.severityNumber != null && message.hasOwnProperty("severityNumber") && (object.severityNumber = options.enums === String ? $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] === void 0 ? message.severityNumber : $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] : message.severityNumber), message.severityText != null && message.hasOwnProperty("severityText") && (object.severityText = message.severityText), message.body != null && message.hasOwnProperty("body") && (object.body = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.body, options)), message.attributes && message.attributes.length) {
                  object.attributes = [];
                  for (var j = 0; j < message.attributes.length; ++j)
                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
                }
                return message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount") && (object.droppedAttributesCount = message.droppedAttributesCount), message.flags != null && message.hasOwnProperty("flags") && (object.flags = message.flags), message.traceId != null && message.hasOwnProperty("traceId") && (object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId), message.spanId != null && message.hasOwnProperty("spanId") && (object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId), message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano") && (typeof message.observedTimeUnixNano == "number" ? object.observedTimeUnixNano = options.longs === String ? String(message.observedTimeUnixNano) : message.observedTimeUnixNano : object.observedTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.observedTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.observedTimeUnixNano.low >>> 0, message.observedTimeUnixNano.high >>> 0).toNumber() : message.observedTimeUnixNano), object;
              }, LogRecord.prototype.toJSON = function() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
              }, LogRecord.getTypeUrl = function(typeUrlPrefix) {
                return typeUrlPrefix === void 0 && (typeUrlPrefix = "type.googleapis.com"), typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogRecord";
              }, LogRecord;
            }(), v1;
          }(), logs;
        }(), proto;
      }(), opentelemetry;
    }();
    module2.exports = $root;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/utils.js
var require_utils5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/utils.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getOtlpEncoder = exports2.encodeAsString = exports2.encodeAsLongBits = exports2.toLongBits = exports2.hrTimeToNanos = void 0;
    var core_1 = require_src();
    function hrTimeToNanos(hrTime) {
      let NANOSECONDS = BigInt(1e9);
      return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
    }
    exports2.hrTimeToNanos = hrTimeToNanos;
    function toLongBits(value) {
      let low = Number(BigInt.asUintN(32, value)), high = Number(BigInt.asUintN(32, value >> BigInt(32)));
      return { low, high };
    }
    exports2.toLongBits = toLongBits;
    function encodeAsLongBits(hrTime) {
      let nanos = hrTimeToNanos(hrTime);
      return toLongBits(nanos);
    }
    exports2.encodeAsLongBits = encodeAsLongBits;
    function encodeAsString(hrTime) {
      return hrTimeToNanos(hrTime).toString();
    }
    exports2.encodeAsString = encodeAsString;
    var encodeTimestamp = typeof BigInt < "u" ? encodeAsString : core_1.hrTimeToNanoseconds;
    function identity(value) {
      return value;
    }
    function optionalHexToBinary(str) {
      if (str !== void 0)
        return (0, core_1.hexToBinary)(str);
    }
    var DEFAULT_ENCODER = {
      encodeHrTime: encodeAsLongBits,
      encodeSpanContext: core_1.hexToBinary,
      encodeOptionalSpanContext: optionalHexToBinary
    };
    function getOtlpEncoder(options) {
      var _a, _b;
      if (options === void 0)
        return DEFAULT_ENCODER;
      let useLongBits = (_a = options.useLongBits) !== null && _a !== void 0 ? _a : !0, useHex = (_b = options.useHex) !== null && _b !== void 0 ? _b : !1;
      return {
        encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
        encodeSpanContext: useHex ? identity : core_1.hexToBinary,
        encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary
      };
    }
    exports2.getOtlpEncoder = getOtlpEncoder;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js
var require_internal = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/common/internal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.toAnyValue = exports2.toKeyValue = exports2.toAttributes = exports2.createInstrumentationScope = exports2.createResource = void 0;
    function createResource(resource) {
      return {
        attributes: toAttributes(resource.attributes),
        droppedAttributesCount: 0
      };
    }
    exports2.createResource = createResource;
    function createInstrumentationScope(scope) {
      return {
        name: scope.name,
        version: scope.version
      };
    }
    exports2.createInstrumentationScope = createInstrumentationScope;
    function toAttributes(attributes) {
      return Object.keys(attributes).map((key) => toKeyValue(key, attributes[key]));
    }
    exports2.toAttributes = toAttributes;
    function toKeyValue(key, value) {
      return {
        key,
        value: toAnyValue(value)
      };
    }
    exports2.toKeyValue = toKeyValue;
    function toAnyValue(value) {
      let t = typeof value;
      return t === "string" ? { stringValue: value } : t === "number" ? Number.isInteger(value) ? { intValue: value } : { doubleValue: value } : t === "boolean" ? { boolValue: value } : value instanceof Uint8Array ? { bytesValue: value } : Array.isArray(value) ? { arrayValue: { values: value.map(toAnyValue) } } : t === "object" && value != null ? {
        kvlistValue: {
          values: Object.entries(value).map(([k, v]) => toKeyValue(k, v))
        }
      } : {};
    }
    exports2.toAnyValue = toAnyValue;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/internal.js
var require_internal2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/internal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.toLogAttributes = exports2.createExportLogsServiceRequest = void 0;
    var utils_1 = require_utils5(), internal_1 = require_internal();
    function createExportLogsServiceRequest(logRecords, options) {
      let encoder = (0, utils_1.getOtlpEncoder)(options);
      return {
        resourceLogs: logRecordsToResourceLogs(logRecords, encoder)
      };
    }
    exports2.createExportLogsServiceRequest = createExportLogsServiceRequest;
    function createResourceMap(logRecords) {
      let resourceMap = /* @__PURE__ */ new Map();
      for (let record of logRecords) {
        let { resource, instrumentationScope: { name, version = "", schemaUrl = "" } } = record, ismMap = resourceMap.get(resource);
        ismMap || (ismMap = /* @__PURE__ */ new Map(), resourceMap.set(resource, ismMap));
        let ismKey = `${name}@${version}:${schemaUrl}`, records = ismMap.get(ismKey);
        records || (records = [], ismMap.set(ismKey, records)), records.push(record);
      }
      return resourceMap;
    }
    function logRecordsToResourceLogs(logRecords, encoder) {
      let resourceMap = createResourceMap(logRecords);
      return Array.from(resourceMap, ([resource, ismMap]) => ({
        resource: (0, internal_1.createResource)(resource),
        scopeLogs: Array.from(ismMap, ([, scopeLogs]) => ({
          scope: (0, internal_1.createInstrumentationScope)(scopeLogs[0].instrumentationScope),
          logRecords: scopeLogs.map((log) => toLogRecord(log, encoder)),
          schemaUrl: scopeLogs[0].instrumentationScope.schemaUrl
        })),
        schemaUrl: void 0
      }));
    }
    function toLogRecord(log, encoder) {
      var _a, _b, _c;
      return {
        timeUnixNano: encoder.encodeHrTime(log.hrTime),
        observedTimeUnixNano: encoder.encodeHrTime(log.hrTimeObserved),
        severityNumber: log.severityNumber,
        severityText: log.severityText,
        body: (0, internal_1.toAnyValue)(log.body),
        attributes: toLogAttributes(log.attributes),
        droppedAttributesCount: log.droppedAttributesCount,
        flags: (_a = log.spanContext) === null || _a === void 0 ? void 0 : _a.traceFlags,
        traceId: encoder.encodeOptionalSpanContext((_b = log.spanContext) === null || _b === void 0 ? void 0 : _b.traceId),
        spanId: encoder.encodeOptionalSpanContext((_c = log.spanContext) === null || _c === void 0 ? void 0 : _c.spanId)
      };
    }
    function toLogAttributes(attributes) {
      return Object.keys(attributes).map((key) => (0, internal_1.toKeyValue)(key, attributes[key]));
    }
    exports2.toLogAttributes = toLogAttributes;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/protobuf/logs.js
var require_logs = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/protobuf/logs.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ProtobufLogsSerializer = void 0;
    var root = require_root(), internal_1 = require_internal2(), logsResponseType = root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, logsRequestType = root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest;
    exports2.ProtobufLogsSerializer = {
      serializeRequest: (arg) => {
        let request3 = (0, internal_1.createExportLogsServiceRequest)(arg);
        return logsRequestType.encode(request3).finish();
      },
      deserializeResponse: (arg) => logsResponseType.decode(arg)
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/protobuf/index.js
var require_protobuf = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/protobuf/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ProtobufLogsSerializer = void 0;
    var logs_1 = require_logs();
    Object.defineProperty(exports2, "ProtobufLogsSerializer", { enumerable: !0, get: function() {
      return logs_1.ProtobufLogsSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js
var require_internal3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/internal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createExportMetricsServiceRequest = exports2.toMetric = exports2.toScopeMetrics = exports2.toResourceMetrics = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports)), sdk_metrics_1 = require_src3(), utils_1 = require_utils5(), internal_1 = require_internal();
    function toResourceMetrics(resourceMetrics, options) {
      let encoder = (0, utils_1.getOtlpEncoder)(options);
      return {
        resource: (0, internal_1.createResource)(resourceMetrics.resource),
        schemaUrl: void 0,
        scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder)
      };
    }
    exports2.toResourceMetrics = toResourceMetrics;
    function toScopeMetrics(scopeMetrics, encoder) {
      return Array.from(scopeMetrics.map((metrics2) => ({
        scope: (0, internal_1.createInstrumentationScope)(metrics2.scope),
        metrics: metrics2.metrics.map((metricData) => toMetric(metricData, encoder)),
        schemaUrl: metrics2.scope.schemaUrl
      })));
    }
    exports2.toScopeMetrics = toScopeMetrics;
    function toMetric(metricData, encoder) {
      let out = {
        name: metricData.descriptor.name,
        description: metricData.descriptor.description,
        unit: metricData.descriptor.unit
      }, aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);
      switch (metricData.dataPointType) {
        case sdk_metrics_1.DataPointType.SUM:
          out.sum = {
            aggregationTemporality,
            isMonotonic: metricData.isMonotonic,
            dataPoints: toSingularDataPoints(metricData, encoder)
          };
          break;
        case sdk_metrics_1.DataPointType.GAUGE:
          out.gauge = {
            dataPoints: toSingularDataPoints(metricData, encoder)
          };
          break;
        case sdk_metrics_1.DataPointType.HISTOGRAM:
          out.histogram = {
            aggregationTemporality,
            dataPoints: toHistogramDataPoints(metricData, encoder)
          };
          break;
        case sdk_metrics_1.DataPointType.EXPONENTIAL_HISTOGRAM:
          out.exponentialHistogram = {
            aggregationTemporality,
            dataPoints: toExponentialHistogramDataPoints(metricData, encoder)
          };
          break;
      }
      return out;
    }
    exports2.toMetric = toMetric;
    function toSingularDataPoint(dataPoint, valueType, encoder) {
      let out = {
        attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
        startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
        timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
      };
      switch (valueType) {
        case api_1.ValueType.INT:
          out.asInt = dataPoint.value;
          break;
        case api_1.ValueType.DOUBLE:
          out.asDouble = dataPoint.value;
          break;
      }
      return out;
    }
    function toSingularDataPoints(metricData, encoder) {
      return metricData.dataPoints.map((dataPoint) => toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder));
    }
    function toHistogramDataPoints(metricData, encoder) {
      return metricData.dataPoints.map((dataPoint) => {
        let histogram = dataPoint.value;
        return {
          attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
          bucketCounts: histogram.buckets.counts,
          explicitBounds: histogram.buckets.boundaries,
          count: histogram.count,
          sum: histogram.sum,
          min: histogram.min,
          max: histogram.max,
          startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
          timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
        };
      });
    }
    function toExponentialHistogramDataPoints(metricData, encoder) {
      return metricData.dataPoints.map((dataPoint) => {
        let histogram = dataPoint.value;
        return {
          attributes: (0, internal_1.toAttributes)(dataPoint.attributes),
          count: histogram.count,
          min: histogram.min,
          max: histogram.max,
          sum: histogram.sum,
          positive: {
            offset: histogram.positive.offset,
            bucketCounts: histogram.positive.bucketCounts
          },
          negative: {
            offset: histogram.negative.offset,
            bucketCounts: histogram.negative.bucketCounts
          },
          scale: histogram.scale,
          zeroCount: histogram.zeroCount,
          startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
          timeUnixNano: encoder.encodeHrTime(dataPoint.endTime)
        };
      });
    }
    function toAggregationTemporality(temporality) {
      switch (temporality) {
        case sdk_metrics_1.AggregationTemporality.DELTA:
          return 1;
        case sdk_metrics_1.AggregationTemporality.CUMULATIVE:
          return 2;
      }
    }
    function createExportMetricsServiceRequest(resourceMetrics, options) {
      return {
        resourceMetrics: resourceMetrics.map((metrics2) => toResourceMetrics(metrics2, options))
      };
    }
    exports2.createExportMetricsServiceRequest = createExportMetricsServiceRequest;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/protobuf/metrics.js
var require_metrics = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/protobuf/metrics.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ProtobufMetricsSerializer = void 0;
    var root = require_root(), internal_1 = require_internal3(), metricsResponseType = root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, metricsRequestType = root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest;
    exports2.ProtobufMetricsSerializer = {
      serializeRequest: (arg) => {
        let request3 = (0, internal_1.createExportMetricsServiceRequest)([arg]);
        return metricsRequestType.encode(request3).finish();
      },
      deserializeResponse: (arg) => metricsResponseType.decode(arg)
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/protobuf/index.js
var require_protobuf2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/protobuf/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ProtobufMetricsSerializer = void 0;
    var metrics_1 = require_metrics();
    Object.defineProperty(exports2, "ProtobufMetricsSerializer", { enumerable: !0, get: function() {
      return metrics_1.ProtobufMetricsSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js
var require_internal4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/internal.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.createExportTraceServiceRequest = exports2.toOtlpSpanEvent = exports2.toOtlpLink = exports2.sdkSpanToOtlpSpan = void 0;
    var internal_1 = require_internal(), utils_1 = require_utils5();
    function sdkSpanToOtlpSpan(span, encoder) {
      var _a;
      let ctx = span.spanContext(), status = span.status;
      return {
        traceId: encoder.encodeSpanContext(ctx.traceId),
        spanId: encoder.encodeSpanContext(ctx.spanId),
        parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
        traceState: (_a = ctx.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: encoder.encodeHrTime(span.startTime),
        endTimeUnixNano: encoder.encodeHrTime(span.endTime),
        attributes: (0, internal_1.toAttributes)(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map((event) => toOtlpSpanEvent(event, encoder)),
        droppedEventsCount: span.droppedEventsCount,
        status: {
          // API and proto enums share the same values
          code: status.code,
          message: status.message
        },
        links: span.links.map((link) => toOtlpLink(link, encoder)),
        droppedLinksCount: span.droppedLinksCount
      };
    }
    exports2.sdkSpanToOtlpSpan = sdkSpanToOtlpSpan;
    function toOtlpLink(link, encoder) {
      var _a;
      return {
        attributes: link.attributes ? (0, internal_1.toAttributes)(link.attributes) : [],
        spanId: encoder.encodeSpanContext(link.context.spanId),
        traceId: encoder.encodeSpanContext(link.context.traceId),
        traceState: (_a = link.context.traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0
      };
    }
    exports2.toOtlpLink = toOtlpLink;
    function toOtlpSpanEvent(timedEvent, encoder) {
      return {
        attributes: timedEvent.attributes ? (0, internal_1.toAttributes)(timedEvent.attributes) : [],
        name: timedEvent.name,
        timeUnixNano: encoder.encodeHrTime(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0
      };
    }
    exports2.toOtlpSpanEvent = toOtlpSpanEvent;
    function createExportTraceServiceRequest(spans, options) {
      let encoder = (0, utils_1.getOtlpEncoder)(options);
      return {
        resourceSpans: spanRecordsToResourceSpans(spans, encoder)
      };
    }
    exports2.createExportTraceServiceRequest = createExportTraceServiceRequest;
    function createResourceMap(readableSpans) {
      let resourceMap = /* @__PURE__ */ new Map();
      for (let record of readableSpans) {
        let ilmMap = resourceMap.get(record.resource);
        ilmMap || (ilmMap = /* @__PURE__ */ new Map(), resourceMap.set(record.resource, ilmMap));
        let instrumentationLibraryKey = `${record.instrumentationLibrary.name}@${record.instrumentationLibrary.version || ""}:${record.instrumentationLibrary.schemaUrl || ""}`, records = ilmMap.get(instrumentationLibraryKey);
        records || (records = [], ilmMap.set(instrumentationLibraryKey, records)), records.push(record);
      }
      return resourceMap;
    }
    function spanRecordsToResourceSpans(readableSpans, encoder) {
      let resourceMap = createResourceMap(readableSpans), out = [], entryIterator = resourceMap.entries(), entry = entryIterator.next();
      for (; !entry.done; ) {
        let [resource, ilmMap] = entry.value, scopeResourceSpans = [], ilmIterator = ilmMap.values(), ilmEntry = ilmIterator.next();
        for (; !ilmEntry.done; ) {
          let scopeSpans = ilmEntry.value;
          if (scopeSpans.length > 0) {
            let spans = scopeSpans.map((readableSpan) => sdkSpanToOtlpSpan(readableSpan, encoder));
            scopeResourceSpans.push({
              scope: (0, internal_1.createInstrumentationScope)(scopeSpans[0].instrumentationLibrary),
              spans,
              schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl
            });
          }
          ilmEntry = ilmIterator.next();
        }
        let transformedSpans = {
          resource: (0, internal_1.createResource)(resource),
          scopeSpans: scopeResourceSpans,
          schemaUrl: void 0
        };
        out.push(transformedSpans), entry = entryIterator.next();
      }
      return out;
    }
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/protobuf/trace.js
var require_trace = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/protobuf/trace.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ProtobufTraceSerializer = void 0;
    var root = require_root(), internal_1 = require_internal4(), traceResponseType = root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, traceRequestType = root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;
    exports2.ProtobufTraceSerializer = {
      serializeRequest: (arg) => {
        let request3 = (0, internal_1.createExportTraceServiceRequest)(arg);
        return traceRequestType.encode(request3).finish();
      },
      deserializeResponse: (arg) => traceResponseType.decode(arg)
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/protobuf/index.js
var require_protobuf3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/protobuf/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ProtobufTraceSerializer = void 0;
    var trace_1 = require_trace();
    Object.defineProperty(exports2, "ProtobufTraceSerializer", { enumerable: !0, get: function() {
      return trace_1.ProtobufTraceSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/json/logs.js
var require_logs2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/json/logs.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonLogsSerializer = void 0;
    var internal_1 = require_internal2();
    exports2.JsonLogsSerializer = {
      serializeRequest: (arg) => {
        let request3 = (0, internal_1.createExportLogsServiceRequest)(arg, {
          useHex: !0,
          useLongBits: !1
        });
        return new TextEncoder().encode(JSON.stringify(request3));
      },
      deserializeResponse: (arg) => {
        let decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/logs/json/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonLogsSerializer = void 0;
    var logs_1 = require_logs2();
    Object.defineProperty(exports2, "JsonLogsSerializer", { enumerable: !0, get: function() {
      return logs_1.JsonLogsSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/json/metrics.js
var require_metrics2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/json/metrics.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonMetricsSerializer = void 0;
    var internal_1 = require_internal3();
    exports2.JsonMetricsSerializer = {
      serializeRequest: (arg) => {
        let request3 = (0, internal_1.createExportMetricsServiceRequest)([arg], {
          useLongBits: !1
        });
        return new TextEncoder().encode(JSON.stringify(request3));
      },
      deserializeResponse: (arg) => {
        let decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/json/index.js
var require_json2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/metrics/json/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonMetricsSerializer = void 0;
    var metrics_1 = require_metrics2();
    Object.defineProperty(exports2, "JsonMetricsSerializer", { enumerable: !0, get: function() {
      return metrics_1.JsonMetricsSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/json/trace.js
var require_trace2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/json/trace.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonTraceSerializer = void 0;
    var internal_1 = require_internal4();
    exports2.JsonTraceSerializer = {
      serializeRequest: (arg) => {
        let request3 = (0, internal_1.createExportTraceServiceRequest)(arg, {
          useHex: !0,
          useLongBits: !1
        });
        return new TextEncoder().encode(JSON.stringify(request3));
      },
      deserializeResponse: (arg) => {
        let decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/json/index.js
var require_json3 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/trace/json/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonTraceSerializer = void 0;
    var trace_1 = require_trace2();
    Object.defineProperty(exports2, "JsonTraceSerializer", { enumerable: !0, get: function() {
      return trace_1.JsonTraceSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/src/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.JsonTraceSerializer = exports2.JsonMetricsSerializer = exports2.JsonLogsSerializer = exports2.ProtobufTraceSerializer = exports2.ProtobufMetricsSerializer = exports2.ProtobufLogsSerializer = void 0;
    var protobuf_1 = require_protobuf();
    Object.defineProperty(exports2, "ProtobufLogsSerializer", { enumerable: !0, get: function() {
      return protobuf_1.ProtobufLogsSerializer;
    } });
    var protobuf_2 = require_protobuf2();
    Object.defineProperty(exports2, "ProtobufMetricsSerializer", { enumerable: !0, get: function() {
      return protobuf_2.ProtobufMetricsSerializer;
    } });
    var protobuf_3 = require_protobuf3();
    Object.defineProperty(exports2, "ProtobufTraceSerializer", { enumerable: !0, get: function() {
      return protobuf_3.ProtobufTraceSerializer;
    } });
    var json_1 = require_json();
    Object.defineProperty(exports2, "JsonLogsSerializer", { enumerable: !0, get: function() {
      return json_1.JsonLogsSerializer;
    } });
    var json_2 = require_json2();
    Object.defineProperty(exports2, "JsonMetricsSerializer", { enumerable: !0, get: function() {
      return json_2.JsonMetricsSerializer;
    } });
    var json_3 = require_json3();
    Object.defineProperty(exports2, "JsonTraceSerializer", { enumerable: !0, get: function() {
      return json_3.JsonTraceSerializer;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/version.js
var require_version2 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/version.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.VERSION = void 0;
    exports2.VERSION = "0.57.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/is-export-retryable.js
function isExportRetryable(statusCode) {
  var retryCodes = [429, 502, 503, 504];
  return retryCodes.includes(statusCode);
}
function parseRetryAfterToMills(retryAfter) {
  if (retryAfter != null) {
    var seconds = Number.parseInt(retryAfter, 10);
    if (Number.isInteger(seconds))
      return seconds > 0 ? seconds * 1e3 : -1;
    var delay = new Date(retryAfter).getTime() - Date.now();
    return delay >= 0 ? delay : 0;
  }
}
var init_is_export_retryable = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/is-export-retryable.js"() {
    init_cjs_shims();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-transport-utils.js
var http_transport_utils_exports = {};
__export(http_transport_utils_exports, {
  compressAndSend: () => compressAndSend,
  createHttpAgent: () => createHttpAgent,
  sendWithHttp: () => sendWithHttp
});
import * as http from "http";
import * as https from "https";
import * as zlib from "zlib";
import { Readable } from "stream";
function sendWithHttp(params, agent, data, onDone, timeoutMillis) {
  var parsedUrl = new URL(params.url), nodeVersion = Number(process.versions.node.split(".")[0]), options = {
    hostname: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.pathname,
    method: "POST",
    headers: __assign({}, params.headers()),
    agent
  }, request3 = parsedUrl.protocol === "http:" ? http.request : https.request, req = request3(options, function(res) {
    var responseData = [];
    res.on("data", function(chunk) {
      return responseData.push(chunk);
    }), res.on("end", function() {
      if (res.statusCode && res.statusCode < 299)
        onDone({
          status: "success",
          data: Buffer.concat(responseData)
        });
      else if (res.statusCode && isExportRetryable(res.statusCode))
        onDone({
          status: "retryable",
          retryInMillis: parseRetryAfterToMills(res.headers["retry-after"])
        });
      else {
        var error = new OTLPExporterError(res.statusMessage, res.statusCode, Buffer.concat(responseData).toString());
        onDone({
          status: "failure",
          error
        });
      }
    });
  });
  req.setTimeout(timeoutMillis, function() {
    req.destroy(), onDone({
      status: "failure",
      error: new Error("Request Timeout")
    });
  }), req.on("error", function(error) {
    onDone({
      status: "failure",
      error
    });
  });
  var reportTimeoutErrorEvent = nodeVersion >= 14 ? "close" : "abort";
  req.on(reportTimeoutErrorEvent, function() {
    onDone({
      status: "failure",
      error: new Error("Request timed out")
    });
  }), compressAndSend(req, params.compression, data, function(error) {
    onDone({
      status: "failure",
      error
    });
  });
}
function compressAndSend(req, compression, data, onError) {
  var dataStream = readableFromUint8Array(data);
  compression === "gzip" && (req.setHeader("Content-Encoding", "gzip"), dataStream = dataStream.on("error", onError).pipe(zlib.createGzip()).on("error", onError)), dataStream.pipe(req).on("error", onError);
}
function readableFromUint8Array(buff) {
  var readable = new Readable();
  return readable.push(buff), readable.push(null), readable;
}
function createHttpAgent(rawUrl, agentOptions) {
  var parsedUrl = new URL(rawUrl), Agent3 = parsedUrl.protocol === "http:" ? http.Agent : https.Agent;
  return new Agent3(agentOptions);
}
var __assign, init_http_transport_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-transport-utils.js"() {
    init_cjs_shims();
    init_is_export_retryable();
    init_types2();
    __assign = function() {
      return __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, __assign.apply(this, arguments);
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-exporter-transport.js
function createHttpExporterTransport(parameters) {
  return new HttpExporterTransport(parameters);
}
var __awaiter3, __generator3, HttpExporterTransport, init_http_exporter_transport = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-exporter-transport.js"() {
    init_cjs_shims();
    __awaiter3 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator3 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        for (; _; ) try {
          if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              return _.label++, { value: op[1], done: !1 };
            case 5:
              _.label++, y = op[1], op = [0];
              continue;
            case 7:
              op = _.ops.pop(), _.trys.pop();
              continue;
            default:
              if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1], t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2], _.ops.push(op);
                break;
              }
              t[2] && _.ops.pop(), _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e], y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, HttpExporterTransport = /** @class */
    function() {
      function HttpExporterTransport2(_parameters) {
        this._parameters = _parameters, this._send = null, this._agent = null;
      }
      return HttpExporterTransport2.prototype.send = function(data, timeoutMillis) {
        return __awaiter3(this, void 0, void 0, function() {
          var _a, sendWithHttp2, createHttpAgent2, _this = this;
          return __generator3(this, function(_b) {
            return this._send == null && (_a = (init_http_transport_utils(), __toCommonJS(http_transport_utils_exports)), sendWithHttp2 = _a.sendWithHttp, createHttpAgent2 = _a.createHttpAgent, this._agent = createHttpAgent2(this._parameters.url, this._parameters.agentOptions), this._send = sendWithHttp2), [2, new Promise(function(resolve) {
              var _a2;
              (_a2 = _this._send) === null || _a2 === void 0 || _a2.call(_this, _this._parameters, _this._agent, data, function(result) {
                resolve(result);
              }, timeoutMillis);
            })];
          });
        });
      }, HttpExporterTransport2.prototype.shutdown = function() {
      }, HttpExporterTransport2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/retrying-transport.js
function getJitter() {
  return Math.random() * (2 * JITTER) - JITTER;
}
function createRetryingTransport(options) {
  return new RetryingTransport(options.transport);
}
var __awaiter4, __generator4, MAX_ATTEMPTS, INITIAL_BACKOFF, MAX_BACKOFF, BACKOFF_MULTIPLIER, JITTER, RetryingTransport, init_retrying_transport = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/retrying-transport.js"() {
    init_cjs_shims();
    __awaiter4 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator4 = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        for (; _; ) try {
          if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          switch (y = 0, t && (op = [op[0] & 2, t.value]), op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              return _.label++, { value: op[1], done: !1 };
            case 5:
              _.label++, y = op[1], op = [0];
              continue;
            case 7:
              op = _.ops.pop(), _.trys.pop();
              continue;
            default:
              if (t = _.trys, !(t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1], t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2], _.ops.push(op);
                break;
              }
              t[2] && _.ops.pop(), _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e], y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, MAX_ATTEMPTS = 5, INITIAL_BACKOFF = 1e3, MAX_BACKOFF = 5e3, BACKOFF_MULTIPLIER = 1.5, JITTER = 0.2;
    RetryingTransport = /** @class */
    function() {
      function RetryingTransport2(_transport) {
        this._transport = _transport;
      }
      return RetryingTransport2.prototype.retry = function(data, timeoutMillis, inMillis) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            _this._transport.send(data, timeoutMillis).then(resolve, reject);
          }, inMillis);
        });
      }, RetryingTransport2.prototype.send = function(data, timeoutMillis) {
        var _a;
        return __awaiter4(this, void 0, void 0, function() {
          var deadline, result, attempts, nextBackoff, backoff, retryInMillis, remainingTimeoutMillis;
          return __generator4(this, function(_b) {
            switch (_b.label) {
              case 0:
                return deadline = Date.now() + timeoutMillis, [4, this._transport.send(data, timeoutMillis)];
              case 1:
                result = _b.sent(), attempts = MAX_ATTEMPTS, nextBackoff = INITIAL_BACKOFF, _b.label = 2;
              case 2:
                return result.status === "retryable" && attempts > 0 ? (attempts--, backoff = Math.max(Math.min(nextBackoff, MAX_BACKOFF) + getJitter(), 0), nextBackoff = nextBackoff * BACKOFF_MULTIPLIER, retryInMillis = (_a = result.retryInMillis) !== null && _a !== void 0 ? _a : backoff, remainingTimeoutMillis = deadline - Date.now(), retryInMillis > remainingTimeoutMillis ? [2, result] : [4, this.retry(data, remainingTimeoutMillis, retryInMillis)]) : [3, 4];
              case 3:
                return result = _b.sent(), [3, 2];
              case 4:
                return [2, result];
            }
          });
        });
      }, RetryingTransport2.prototype.shutdown = function() {
        return this._transport.shutdown();
      }, RetryingTransport2;
    }();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-http-export-delegate.js
function createOtlpHttpExportDelegate(options, serializer) {
  return createOtlpExportDelegate({
    transport: createRetryingTransport({
      transport: createHttpExporterTransport(options)
    }),
    serializer,
    promiseHandler: createBoundedQueueExportPromiseHandler(options)
  }, { timeout: options.timeoutMillis });
}
var init_otlp_http_export_delegate = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-http-export-delegate.js"() {
    init_cjs_shims();
    init_otlp_export_delegate();
    init_http_exporter_transport();
    init_bounded_queue_export_promise_handler();
    init_retrying_transport();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-env-configuration.js
function parseAndValidateTimeoutFromEnv(timeoutEnvVar) {
  var _a, envTimeout = (_a = process.env[timeoutEnvVar]) === null || _a === void 0 ? void 0 : _a.trim();
  if (envTimeout != null && envTimeout !== "") {
    var definedTimeout = Number(envTimeout);
    if (!Number.isNaN(definedTimeout) && Number.isFinite(definedTimeout) && definedTimeout > 0)
      return definedTimeout;
    diag2.warn("Configuration: " + timeoutEnvVar + " is invalid, expected number greater than 0 (actual: " + envTimeout + ")");
  }
}
function getTimeoutFromEnv(signalIdentifier) {
  var specificTimeout = parseAndValidateTimeoutFromEnv("OTEL_EXPORTER_OTLP_" + signalIdentifier + "_TIMEOUT"), nonSpecificTimeout = parseAndValidateTimeoutFromEnv("OTEL_EXPORTER_OTLP_TIMEOUT");
  return specificTimeout ?? nonSpecificTimeout;
}
function parseAndValidateCompressionFromEnv(compressionEnvVar) {
  var _a, compression = (_a = process.env[compressionEnvVar]) === null || _a === void 0 ? void 0 : _a.trim();
  if (compression !== "") {
    if (compression == null || compression === "none" || compression === "gzip")
      return compression;
    diag2.warn("Configuration: " + compressionEnvVar + " is invalid, expected 'none' or 'gzip' (actual: '" + compression + "')");
  }
}
function getCompressionFromEnv(signalIdentifier) {
  var specificCompression = parseAndValidateCompressionFromEnv("OTEL_EXPORTER_OTLP_" + signalIdentifier + "_COMPRESSION"), nonSpecificCompression = parseAndValidateCompressionFromEnv("OTEL_EXPORTER_OTLP_COMPRESSION");
  return specificCompression ?? nonSpecificCompression;
}
function getSharedConfigurationFromEnvironment(signalIdentifier) {
  return {
    timeoutMillis: getTimeoutFromEnv(signalIdentifier),
    compression: getCompressionFromEnv(signalIdentifier)
  };
}
var init_shared_env_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-env-configuration.js"() {
    init_cjs_shims();
    init_esm();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js
function validateAndNormalizeHeaders(partialHeaders) {
  return function() {
    var _a, headers = {};
    return Object.entries((_a = partialHeaders?.()) !== null && _a !== void 0 ? _a : {}).forEach(function(_a2) {
      var _b = __read6(_a2, 2), key = _b[0], value = _b[1];
      typeof value < "u" ? headers[key] = String(value) : diag2.warn('Header "' + key + '" has invalid value (' + value + ") and will be ignored");
    }), headers;
  };
}
var __read6, init_util = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js"() {
    init_cjs_shims();
    init_esm();
    __read6 = function(o, n) {
      var m = typeof Symbol == "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        for (; (n === void 0 || n-- > 0) && !(r = i.next()).done; ) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          r && !r.done && (m = i.return) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-http-configuration.js
function mergeHeaders(userProvidedHeaders, fallbackHeaders, defaultHeaders) {
  var requiredHeaders = __assign2({}, defaultHeaders()), headers = {};
  return function() {
    return fallbackHeaders != null && Object.assign(headers, fallbackHeaders()), userProvidedHeaders != null && Object.assign(headers, userProvidedHeaders()), Object.assign(headers, requiredHeaders);
  };
}
function validateUserProvidedUrl(url2) {
  if (url2 != null)
    try {
      return new URL(url2), url2;
    } catch {
      throw new Error("Configuration: Could not parse user-provided export URL: '" + url2 + "'");
    }
}
function mergeOtlpHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
  var _a, _b, _c, _d;
  return __assign2(__assign2({}, mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration)), { headers: mergeHeaders(validateAndNormalizeHeaders(userProvidedConfiguration.headers), fallbackConfiguration.headers, defaultConfiguration.headers), url: (_b = (_a = validateUserProvidedUrl(userProvidedConfiguration.url)) !== null && _a !== void 0 ? _a : fallbackConfiguration.url) !== null && _b !== void 0 ? _b : defaultConfiguration.url, agentOptions: (_d = (_c = userProvidedConfiguration.agentOptions) !== null && _c !== void 0 ? _c : fallbackConfiguration.agentOptions) !== null && _d !== void 0 ? _d : defaultConfiguration.agentOptions });
}
function getHttpConfigurationDefaults(requiredHeaders, signalResourcePath) {
  return __assign2(__assign2({}, getSharedConfigurationDefaults()), { headers: function() {
    return requiredHeaders;
  }, url: "http://localhost:4318/" + signalResourcePath, agentOptions: { keepAlive: !0 } });
}
var __assign2, init_otlp_http_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-http-configuration.js"() {
    init_cjs_shims();
    init_shared_configuration();
    init_util();
    __assign2 = function() {
      return __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, __assign2.apply(this, arguments);
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-http-env-configuration.js
function getStaticHeadersFromEnv(signalIdentifier) {
  var _a, _b, signalSpecificRawHeaders = (_a = process.env["OTEL_EXPORTER_OTLP_" + signalIdentifier + "_HEADERS"]) === null || _a === void 0 ? void 0 : _a.trim(), nonSignalSpecificRawHeaders = (_b = process.env.OTEL_EXPORTER_OTLP_HEADERS) === null || _b === void 0 ? void 0 : _b.trim(), signalSpecificHeaders = import_core3.baggageUtils.parseKeyPairsIntoRecord(signalSpecificRawHeaders), nonSignalSpecificHeaders = import_core3.baggageUtils.parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders);
  if (!(Object.keys(signalSpecificHeaders).length === 0 && Object.keys(nonSignalSpecificHeaders).length === 0))
    return Object.assign({}, import_core3.baggageUtils.parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders), import_core3.baggageUtils.parseKeyPairsIntoRecord(signalSpecificRawHeaders));
}
function appendRootPathToUrlIfNeeded(url2) {
  try {
    var parsedUrl = new URL(url2);
    return parsedUrl.toString();
  } catch {
    diag2.warn("Configuration: Could not parse environment-provided export URL: '" + url2 + "', falling back to undefined");
    return;
  }
}
function appendResourcePathToUrl(url2, path) {
  try {
    new URL(url2);
  } catch {
    diag2.warn("Configuration: Could not parse environment-provided export URL: '" + url2 + "', falling back to undefined");
    return;
  }
  url2.endsWith("/") || (url2 = url2 + "/"), url2 += path;
  try {
    new URL(url2);
  } catch {
    diag2.warn("Configuration: Provided URL appended with '" + path + "' is not a valid URL, using 'undefined' instead of '" + url2 + "'");
    return;
  }
  return url2;
}
function getNonSpecificUrlFromEnv(signalResourcePath) {
  var _a, envUrl = (_a = process.env.OTEL_EXPORTER_OTLP_ENDPOINT) === null || _a === void 0 ? void 0 : _a.trim();
  if (!(envUrl == null || envUrl === ""))
    return appendResourcePathToUrl(envUrl, signalResourcePath);
}
function getSpecificUrlFromEnv(signalIdentifier) {
  var _a, envUrl = (_a = process.env["OTEL_EXPORTER_OTLP_" + signalIdentifier + "_ENDPOINT"]) === null || _a === void 0 ? void 0 : _a.trim();
  if (!(envUrl == null || envUrl === ""))
    return appendRootPathToUrlIfNeeded(envUrl);
}
function getHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath) {
  var _a;
  return __assign3(__assign3({}, getSharedConfigurationFromEnvironment(signalIdentifier)), { url: (_a = getSpecificUrlFromEnv(signalIdentifier)) !== null && _a !== void 0 ? _a : getNonSpecificUrlFromEnv(signalResourcePath), headers: wrapStaticHeadersInFunction(getStaticHeadersFromEnv(signalIdentifier)) });
}
var import_core3, __assign3, init_otlp_http_env_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-http-env-configuration.js"() {
    init_cjs_shims();
    import_core3 = __toESM(require_src());
    init_esm();
    init_shared_env_configuration();
    init_shared_configuration();
    __assign3 = function() {
      return __assign3 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
        }
        return t;
      }, __assign3.apply(this, arguments);
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/convert-legacy-node-http-options.js
function convertLegacyAgentOptions(config) {
  return config?.keepAlive != null && (config.httpAgentOptions != null ? config.httpAgentOptions.keepAlive == null && (config.httpAgentOptions.keepAlive = config.keepAlive) : config.httpAgentOptions = {
    keepAlive: config.keepAlive
  }), config.httpAgentOptions;
}
function convertLegacyHttpOptions(config, signalIdentifier, signalResourcePath, requiredHeaders) {
  return config.metadata && diag2.warn("Metadata cannot be set when using http"), mergeOtlpHttpConfigurationWithDefaults({
    url: config.url,
    headers: wrapStaticHeadersInFunction(config.headers),
    concurrencyLimit: config.concurrencyLimit,
    timeoutMillis: config.timeoutMillis,
    compression: config.compression,
    agentOptions: convertLegacyAgentOptions(config)
  }, getHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath), getHttpConfigurationDefaults(requiredHeaders, signalResourcePath));
}
var init_convert_legacy_node_http_options = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/convert-legacy-node-http-options.js"() {
    init_cjs_shims();
    init_otlp_http_configuration();
    init_otlp_http_env_configuration();
    init_esm();
    init_shared_configuration();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index-node-http.js
var index_node_http_exports = {};
__export(index_node_http_exports, {
  convertLegacyHttpOptions: () => convertLegacyHttpOptions,
  createOtlpHttpExportDelegate: () => createOtlpHttpExportDelegate,
  getSharedConfigurationFromEnvironment: () => getSharedConfigurationFromEnvironment
});
var init_index_node_http = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index-node-http.js"() {
    init_cjs_shims();
    init_otlp_http_export_delegate();
    init_shared_env_configuration();
    init_convert_legacy_node_http_options();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/OTLPMetricExporter.js
var require_OTLPMetricExporter = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/OTLPMetricExporter.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OTLPMetricExporter = void 0;
    var OTLPMetricExporterBase_1 = require_OTLPMetricExporterBase(), otlp_transformer_1 = require_src4(), version_1 = require_version2(), node_http_1 = (init_index_node_http(), __toCommonJS(index_node_http_exports)), USER_AGENT = {
      "User-Agent": `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`
    }, OTLPMetricExporter2 = class extends OTLPMetricExporterBase_1.OTLPMetricExporterBase {
      constructor(config) {
        super((0, node_http_1.createOtlpHttpExportDelegate)((0, node_http_1.convertLegacyHttpOptions)(config ?? {}, "METRICS", "v1/metrics", Object.assign(Object.assign({}, USER_AGENT), { "Content-Type": "application/json" })), otlp_transformer_1.JsonMetricsSerializer), config);
      }
    };
    exports2.OTLPMetricExporter = OTLPMetricExporter2;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/index.js
var require_node4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/node/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OTLPMetricExporter = void 0;
    var OTLPMetricExporter_1 = require_OTLPMetricExporter();
    Object.defineProperty(exports2, "OTLPMetricExporter", { enumerable: !0, get: function() {
      return OTLPMetricExporter_1.OTLPMetricExporter;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/index.js
var require_platform4 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/platform/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OTLPMetricExporter = void 0;
    var node_1 = require_node4();
    Object.defineProperty(exports2, "OTLPMetricExporter", { enumerable: !0, get: function() {
      return node_1.OTLPMetricExporter;
    } });
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/index.js
var require_src5 = __commonJS({
  "../../node_modules/.pnpm/@opentelemetry+exporter-metrics-otlp-http@0.57.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-metrics-otlp-http/build/src/index.js"(exports2) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.OTLPMetricExporterBase = exports2.LowMemoryTemporalitySelector = exports2.DeltaTemporalitySelector = exports2.CumulativeTemporalitySelector = exports2.AggregationTemporalityPreference = exports2.OTLPMetricExporter = void 0;
    var platform_1 = require_platform4();
    Object.defineProperty(exports2, "OTLPMetricExporter", { enumerable: !0, get: function() {
      return platform_1.OTLPMetricExporter;
    } });
    var OTLPMetricExporterOptions_1 = require_OTLPMetricExporterOptions();
    Object.defineProperty(exports2, "AggregationTemporalityPreference", { enumerable: !0, get: function() {
      return OTLPMetricExporterOptions_1.AggregationTemporalityPreference;
    } });
    var OTLPMetricExporterBase_1 = require_OTLPMetricExporterBase();
    Object.defineProperty(exports2, "CumulativeTemporalitySelector", { enumerable: !0, get: function() {
      return OTLPMetricExporterBase_1.CumulativeTemporalitySelector;
    } });
    Object.defineProperty(exports2, "DeltaTemporalitySelector", { enumerable: !0, get: function() {
      return OTLPMetricExporterBase_1.DeltaTemporalitySelector;
    } });
    Object.defineProperty(exports2, "LowMemoryTemporalitySelector", { enumerable: !0, get: function() {
      return OTLPMetricExporterBase_1.LowMemoryTemporalitySelector;
    } });
    Object.defineProperty(exports2, "OTLPMetricExporterBase", { enumerable: !0, get: function() {
      return OTLPMetricExporterBase_1.OTLPMetricExporterBase;
    } });
  }
});

// ../cli-kit/dist/public/node/plugins.js
init_cjs_shims();
async function fanoutHooks(config, event, options, timeout) {
  let res = await config.runHook(event, options, timeout);
  return Object.fromEntries(res.successes.map(({ result, plugin }) => [plugin.name, result]));
}
async function getListOfTunnelPlugins(config) {
  let hooks = await fanoutHooks(config, "tunnel_provider", {}), names = getArrayRejectingUndefined(Object.values(hooks).map((key) => key?.name));
  return getArrayContainsDuplicates(names) ? { plugins: names, error: "multiple-plugins-for-provider" } : { plugins: names };
}

// ../cli-kit/dist/public/node/analytics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/monorail.js
init_cjs_shims();
var url = "https://monorail-edge.shopifysvc.com/v1/produce", MONORAIL_COMMAND_TOPIC = "app_cli3_command/1.19", publishedCommandNames = /* @__PURE__ */ new Set();
async function publishMonorailEvent(schemaId, publicData, sensitiveData) {
  let commandName = publicData.command;
  if (commandName && typeof commandName == "string") {
    if (publishedCommandNames.has(commandName))
      return { type: "ok" };
    publishedCommandNames.add(commandName);
  }
  try {
    let currentTime = (/* @__PURE__ */ new Date()).getTime(), payload = { ...publicData, ...sensitiveData }, body = JSON.stringify({ schema_id: schemaId, payload }), headers = buildHeaders(currentTime), response = await fetch(url, { method: "POST", body, headers }, "non-blocking");
    return response.status === 200 ? (outputDebug(outputContent`Analytics event sent: ${outputToken.json(sanitizePayload(payload))}`), { type: "ok" }) : (outputDebug(`Failed to report usage analytics: ${response.statusText}`), { type: "error", message: response.statusText });
  } catch (error) {
    let message = "Failed to report usage analytics";
    return error instanceof Error && (message = message.concat(`: ${error.message}`)), outputDebug(message), { type: "error", message };
  }
}
function sanitizePayload(payload) {
  let result = { ...payload };
  return "api_key" in result && (result.api_key = "****"), result;
}
var buildHeaders = (currentTime) => ({
  "Content-Type": "application/json; charset=utf-8",
  "X-Monorail-Edge-Event-Created-At-Ms": currentTime.toString(),
  "X-Monorail-Edge-Event-Sent-At-Ms": currentTime.toString()
});

// ../cli-kit/dist/private/node/analytics/storage.js
init_cjs_shims();

// ../cli-kit/dist/private/node/analytics/error-categorizer.js
init_cjs_shims();
var ErrorCategory;
(function(ErrorCategory2) {
  ErrorCategory2.Liquid = "LIQUID", ErrorCategory2.ThemeCheck = "THEME_CHECK", ErrorCategory2.Network = "NETWORK", ErrorCategory2.FileSystem = "FILE_SYSTEM", ErrorCategory2.Authentication = "AUTHENTICATION", ErrorCategory2.Validation = "VALIDATION", ErrorCategory2.Permission = "PERMISSION", ErrorCategory2.RateLimit = "RATE_LIMIT", ErrorCategory2.Json = "JSON", ErrorCategory2.Unknown = "UNKNOWN";
})(ErrorCategory || (ErrorCategory = {}));
var ERROR_CATEGORY_TERMS = {
  [ErrorCategory.Liquid]: ["liquid"],
  [ErrorCategory.Json]: ["json", "parse response"],
  [ErrorCategory.ThemeCheck]: ["theme check"],
  [ErrorCategory.Authentication]: ["unauthorized", "forbidden", "auth", "token", "credential"],
  [ErrorCategory.Network]: [
    "eai_again",
    "econn",
    "enetunreach",
    "enotfound",
    "epipe",
    "etimedout",
    "fetch",
    "network",
    "request",
    "socket",
    "the operation was aborted",
    "timed out",
    "timeout"
  ],
  [ErrorCategory.FileSystem]: ["enoent", "eacces", "file", "directory", "path"],
  [ErrorCategory.Permission]: ["permission", "denied", "access", "insufficient"],
  [ErrorCategory.RateLimit]: ["rate limit", "too many requests", "throttle"],
  [ErrorCategory.Validation]: ["validation", "invalid", "required"]
};
function categorizeError(error) {
  if (!(error instanceof Error))
    return ErrorCategory.Unknown;
  let message = error.message.toLowerCase();
  for (let [category, terms] of Object.entries(ERROR_CATEGORY_TERMS))
    if (terms.some((term) => message.includes(term)))
      return category;
  return ErrorCategory.Unknown;
}
function formatErrorMessage(error, category) {
  let message = error instanceof Error ? error.message : String(error);
  return (ERROR_FORMATTERS[category] || formatGenericError)(message);
}
var ERROR_FORMATTERS = {
  [ErrorCategory.Network]: formatNetworkError,
  [ErrorCategory.Authentication]: formatGenericError,
  [ErrorCategory.FileSystem]: formatGenericError,
  [ErrorCategory.RateLimit]: formatGenericError,
  [ErrorCategory.Json]: formatGenericError,
  [ErrorCategory.Validation]: formatGenericError,
  [ErrorCategory.Permission]: formatGenericError,
  [ErrorCategory.Liquid]: formatGenericError,
  [ErrorCategory.ThemeCheck]: formatGenericError,
  [ErrorCategory.Unknown]: formatGenericError
};
function formatNetworkError(message) {
  let httpStatusMatch = message.match(/\b([1-5]\d{2})\b/), connectionErrorMatch = message.match(/\b(E[A-Z]+)\b/), graphqlCodeMatch = message.match(/(?:code|error)[:\s]*(\d{3})/i), normalized = message.toLowerCase().substring(0, 50);
  return httpStatusMatch?.[1] ? normalized = `http-${httpStatusMatch[1]}-${normalized.replace(/\b\d{3}\b/g, "").trim()}` : graphqlCodeMatch?.[1] ? normalized = `http-${graphqlCodeMatch[1]}-${normalized.replace(/(?:code|error)[:\s]*\d{3}/gi, "").trim()}` : connectionErrorMatch?.[1] ? normalized = `http-000-${connectionErrorMatch[1].toLowerCase()}-${normalized.replace(/\b[eE][A-Z]+\b/g, "").trim()}` : normalized = `http-000-${normalized}`, normalized.replace(/[^a-zA-Z0-9-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").substring(0, 50);
}
function formatGenericError(message) {
  return message.toLowerCase().substring(0, 50).replace(/[^a-zA-Z0-9]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}

// ../cli-kit/dist/private/node/analytics/bounded-collections.js
init_cjs_shims();
var BArray = class extends Array {
  push(...items) {
    let result = super.push(...items);
    return this.enforceLimit(), result;
  }
  clear() {
    this.length = 0;
  }
  toArray() {
    return [...this];
  }
  enforceLimit() {
    for (; this.length > 1e3; )
      this.shift();
  }
}, BMap = class extends Map {
  constructor() {
    super(...arguments), this.insertionOrder = [];
  }
  set(key, value) {
    return this.has(key) || this.insertionOrder.push(key), super.set(key, value), this.enforceLimit(), this;
  }
  delete(key) {
    let index = this.insertionOrder.indexOf(key);
    return index > -1 && this.insertionOrder.splice(index, 1), super.delete(key);
  }
  clear() {
    this.insertionOrder = [], super.clear();
  }
  toObject() {
    return Object.fromEntries(this);
  }
  enforceLimit() {
    for (; this.size > 1e3 && this.insertionOrder.length > 0; ) {
      let oldestKey = this.insertionOrder.shift();
      oldestKey !== void 0 && super.delete(oldestKey);
    }
  }
};

// ../cli-kit/dist/private/node/analytics/storage.js
var _runtimeAnalyticsStore = {
  timings: new BArray(),
  activeTimings: new BMap(),
  errors: new BArray(),
  retries: new BArray(),
  events: new BArray()
};
function recordTiming(eventName) {
  let now = Date.now();
  if (!_runtimeAnalyticsStore.activeTimings.has(eventName)) {
    _runtimeAnalyticsStore.activeTimings.set(eventName, now), recordEvent(`timing:start:${eventName}`);
    return;
  }
  let startTime = _runtimeAnalyticsStore.activeTimings.get(eventName);
  if (startTime === void 0)
    return;
  let duration = now - startTime;
  _runtimeAnalyticsStore.timings.push({
    event: eventName,
    duration
  }), _runtimeAnalyticsStore.activeTimings.delete(eventName), recordEvent(`timing:end:${eventName}`);
}
function recordError(error) {
  let category = categorizeError(error), errorEntry = {
    category,
    message: (error instanceof Error ? error.message : String(error)).substring(0, 200),
    timestamp: Date.now()
  };
  if (errorEntry.category === ErrorCategory.Unknown && !errorEntry.message)
    return;
  _runtimeAnalyticsStore.errors.push(errorEntry);
  let normalizedErrorCategory = category.toLowerCase(), normalizedErrorMessage = formatErrorMessage(error, category);
  recordEvent(`error:${normalizedErrorCategory}:${normalizedErrorMessage}`);
}
function recordEvent(eventName) {
  _runtimeAnalyticsStore.events.push({
    name: eventName,
    timestamp: Date.now()
  });
}
function compileData() {
  return {
    timings: _runtimeAnalyticsStore.timings.toArray(),
    errors: _runtimeAnalyticsStore.errors.toArray(),
    retries: _runtimeAnalyticsStore.retries.toArray(),
    events: _runtimeAnalyticsStore.events.toArray()
  };
}

// ../cli-kit/dist/private/node/otel-metrics.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/service/types.js
init_cjs_shims();
var MetricInstrumentType;
(function(MetricInstrumentType2) {
  MetricInstrumentType2.Histogram = "Histogram", MetricInstrumentType2.Counter = "Counter", MetricInstrumentType2.UpDownCounter = "UpDownCounter";
})(MetricInstrumentType || (MetricInstrumentType = {}));

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.js
init_cjs_shims();

// ../cli-kit/dist/public/node/vendor/otel-js/export/InstantaneousMetricReader.js
init_cjs_shims();
var import_sdk_metrics = __toESM(require_src3(), 1), import_core = __toESM(require_src(), 1);
init_esm();

// ../cli-kit/dist/public/node/vendor/otel-js/utils/throttle.js
init_cjs_shims();
function throttle(func, wait, { leading = !0, trailing = !0 } = {}) {
  let lastArgs, result, context2, timeout = null, previous = 0;
  function later() {
    previous = leading === !1 ? 0 : Date.now(), timeout = null, lastArgs && (result = func.apply(context2, lastArgs)), context2 = null, lastArgs = null;
  }
  return function(...args) {
    let now = Date.now();
    !previous && leading === !1 && (previous = now);
    let remaining = wait - (now - previous);
    return context2 = this, lastArgs = args, remaining <= 0 || remaining > wait ? (timeout && (clearTimeout(timeout), timeout = null), previous = now, lastArgs && (result = func.apply(context2, lastArgs)), context2 = null, lastArgs = null) : !timeout && trailing !== !1 && (timeout = setTimeout(later, remaining)), result;
  };
}

// ../cli-kit/dist/public/node/vendor/otel-js/export/InstantaneousMetricReader.js
var InstantaneousMetricReader = class extends import_sdk_metrics.MetricReader {
  constructor({ exporter, throttleLimit }) {
    super({
      aggregationSelector: exporter.selectAggregation?.bind(exporter),
      aggregationTemporalitySelector: exporter.selectAggregationTemporality?.bind(exporter)
    }), this._exporter = exporter, this.onForceFlush = throttle(
      // eslint-disable-next-line @typescript-eslint/unbound-method
      this.onForceFlush,
      throttleLimit
    );
  }
  async onForceFlush() {
    let { resourceMetrics, errors } = await this.collect({});
    return errors.length > 0 && diag2.error("PeriodicExportingMetricReader: metrics collection errors", ...errors), new Promise((resolve, reject) => {
      this._exporter.export(resourceMetrics, (result) => {
        result.code === import_core.ExportResultCode.SUCCESS ? resolve() : reject(result.error ?? new Error(`InstantaneousMetricReader: metrics export failed (error ${result.error})`));
      });
    });
  }
  async onShutdown() {
    await this._exporter.shutdown();
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultMeterProvider.js
var import_exporter_metrics_otlp_http = __toESM(require_src5(), 1), import_resources = __toESM(require_src2(), 1), import_sdk_metrics2 = __toESM(require_src3(), 1);
init_esm2();
var DefaultMeterProvider = class extends import_sdk_metrics2.MeterProvider {
  constructor({ serviceName, env, throttleLimit, useXhr, otelEndpoint }) {
    super({
      resource: new import_resources.Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: serviceName
      })
    });
    let opts = {
      // url: OTEL_ENDPOINTS[env as Environment] || OTEL_ENDPOINTS.local,
      // CLI addition
      url: otelEndpoint,
      temporalityPreference: import_sdk_metrics2.AggregationTemporality.DELTA
    };
    useXhr && (opts.headers = {});
    let exporter = new import_exporter_metrics_otlp_http.OTLPMetricExporter(opts);
    this.addMetricReader(new InstantaneousMetricReader({
      exporter,
      throttleLimit
    })), env === "dev" && this.addMetricReader(new InstantaneousMetricReader({
      exporter: new import_sdk_metrics2.ConsoleMetricExporter(),
      throttleLimit
    }));
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.js
init_cjs_shims();
var import_sdk_metrics3 = __toESM(require_src3(), 1);

// ../cli-kit/dist/public/node/vendor/otel-js/utils/validators.js
init_cjs_shims();
init_esm();
var validMetricRegex = new RegExp("[^a-zA-Z_][^a-zA-Z0-9_]*");
function isValidMetricName(value) {
  return validMetricRegex.test(value) ? (diag2.warn(`Metric name ${value} contains invalid characters and will be dropped.
    Service Names and metric names must conform to the following regex %c[a-zA-Z_][a-zA-Z0-9_]*`, "color:red"), !1) : !0;
}

// ../cli-kit/dist/public/node/vendor/otel-js/service/BaseOtelService/BaseOtelService.js
var instrumentationScope = "opentelemetry-js-shopify-web", BaseOtelService = class {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({ serviceName, prefixMetric = !1, metrics: metrics2 = {}, onRecord, meterProvider }) {
    if (this.metrics = /* @__PURE__ */ new Map(), this.recordListeners = /* @__PURE__ */ new Set(), !serviceName)
      throw new Error("Service name is required.");
    if (this.serviceName = serviceName, this.prefixMetric = prefixMetric, onRecord && this.addOnRecord(onRecord), !meterProvider)
      throw new Error("MeterProvider is required.");
    this.meterProvider = meterProvider, this.register(metrics2);
  }
  getMeterProvider() {
    return this.meterProvider;
  }
  addView(viewOptions) {
    this.meterProvider._sharedState?.viewRegistry?.addView?.(new import_sdk_metrics3.View(viewOptions));
  }
  record(metricName, value, labels) {
    let recordMetric = this.metrics.get(metricName);
    if (!recordMetric)
      throw new Error(`Service ${this.serviceName} has no metrics registered for name: ${metricName}. Can't record value for unknown metric.`);
    recordMetric(value, labels);
  }
  registerMetric(metricName, { type, ...options }) {
    if (this.metrics.has(metricName))
      return;
    let meter = this.meterProvider.getMeter(instrumentationScope), name = this.prefixMetric ? `${this.serviceName}_${metricName}` : metricName;
    if (!isValidMetricName(name))
      return;
    let createInstrument = () => {
      switch (type) {
        case MetricInstrumentType.Counter:
          return meter.createCounter(name, options);
        case MetricInstrumentType.UpDownCounter:
          return meter.createUpDownCounter(name, options);
        case MetricInstrumentType.Histogram:
          return "boundaries" in options && this.addView({
            instrumentName: name,
            aggregation: new import_sdk_metrics3.ExplicitBucketHistogramAggregation(options.boundaries, !0)
          }), meter.createHistogram(name, options);
      }
    };
    this.metrics.set(metricName, (firstValue, firstLabels) => {
      let instrument = createInstrument(), record = (value, labels) => {
        let [finalValue, finalLabels] = this.notifyRecordListeners(
          metricName,
          value,
          // ensures an new object is created so we don't mutate the original
          { ...labels }
        );
        "record" in instrument ? instrument.record(finalValue, finalLabels) : instrument.add(finalValue, finalLabels), this.meterProvider.forceFlush({}).catch(() => {
        });
      };
      record(firstValue, firstLabels), this.metrics.set(metricName, record);
    });
  }
  register(metrics2) {
    Object.entries(metrics2).forEach(([metricName, options]) => {
      this.registerMetric(metricName, options);
    });
  }
  addOnRecord(onRecord) {
    return this.recordListeners.add(onRecord), () => {
      this.recordListeners.delete(onRecord);
    };
  }
  removeOnRecord(onRecord) {
    this.recordListeners.delete(onRecord);
  }
  shutdown() {
    return this.metrics.clear(), this.recordListeners.clear(), this.meterProvider.shutdown();
  }
  notifyRecordListeners(metricName, initialValue, initialLabels) {
    return Array.from(this.recordListeners).reduce((recordArgs, listener) => listener(metricName, ...recordArgs) || recordArgs, [initialValue, initialLabels]);
  }
};

// ../cli-kit/dist/public/node/vendor/otel-js/service/DefaultOtelService/DefaultOtelService.js
init_esm();
var DefaultOtelService = class extends BaseOtelService {
  /**
   * Bootstraps an Otel exporter which can send Otel metrics to a dedicated Shopify supported collector endpoint.
   */
  constructor({
    throttleLimit = 5e3,
    env = "local",
    serviceName,
    prefixMetric = !1,
    metrics: metrics2 = {},
    onRecord,
    meterProvider,
    useXhr = !1,
    // CLI addition
    otelEndpoint
  }) {
    diag2.setLogger(new DiagConsoleLogger(), ["production", "staging"].includes(env) ? DiagLogLevel.ERROR : DiagLogLevel.INFO), super({
      serviceName,
      meterProvider: meterProvider ?? new DefaultMeterProvider({
        serviceName,
        env,
        throttleLimit,
        useXhr,
        // CLI addition
        otelEndpoint
      }),
      prefixMetric,
      metrics: metrics2,
      onRecord
    });
  }
  shutdown() {
    return diag2.disable(), super.shutdown();
  }
};

// ../cli-kit/dist/private/node/otel-metrics.js
init_esm();
var Name;
(function(Name2) {
  Name2.Counter = "cli_commands_total", Name2.Duration = "cli_commands_duration_ms", Name2.Elapsed = "cli_commands_wall_clock_elapsed_ms";
})(Name || (Name = {}));
async function recordMetrics(options, timing, recorderFactory = createMetricRecorder) {
  let recorder = recorderFactory({
    skipMetricAnalytics: options.skipMetricAnalytics,
    otelOptions: defaultOtelOptions()
  }), regularisedCliVersion = options.cliVersion;
  options.cliVersion.includes("nightly") ? regularisedCliVersion = "nightly" : options.cliVersion.includes("pre") && (regularisedCliVersion = "pre");
  let labels = {
    exit: options.exitMode,
    job: `${options.owningPlugin}::${options.command}`,
    cli_version: regularisedCliVersion
  };
  recordCommandCounter(recorder, labels), recordCommandTiming(recorder, labels, timing);
}
function defaultOtelOptions() {
  return {
    serviceName: "shopify-cli",
    throttleLimit: 1e3,
    prefixMetric: !1,
    metrics: {
      [Name.Counter]: {
        type: MetricInstrumentType.Counter,
        description: "Total number of CLI commands executed",
        valueType: ValueType.INT
      },
      [Name.Duration]: {
        type: MetricInstrumentType.Histogram,
        description: "Total time spent in execution of CLI commands. Does not include time spent waiting for network, prompts, etc.",
        valueType: ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      },
      [Name.Elapsed]: {
        type: MetricInstrumentType.Histogram,
        description: "Total time elapsed from start to finish of CLI commands. Includes time spent waiting for network, prompts, etc.",
        valueType: ValueType.INT,
        boundaries: [0, 100, 250, 500, 1e3, 2e3, 5e3, 1e4, 2e4, 5e4]
      }
    }
  };
}
function createMetricRecorder(options) {
  let recorder = "console";
  return options.skipMetricAnalytics || isUnitTest() || (recorder = {
    type: "otel",
    otel: globalOtelService(options)
  }), recorder;
}
var _otelService;
function globalOtelService(options) {
  return _otelService || (_otelService = new DefaultOtelService({
    ...options.otelOptions,
    env: void 0,
    otelEndpoint: `${opentelemetryDomain()}/v1/metrics`
  })), _otelService;
}
function recordCommandCounter(recorder, labels) {
  if (recorder === "console") {
    outputDebug(outputContent`[OTEL] record ${Name.Counter} counter ${outputToken.json({ labels })}`);
    return;
  }
  recorder.otel.record(Name.Counter, 1, labels);
}
function recordCommandTiming(recorder, labels, timing) {
  if (recorder === "console") {
    outputDebug(outputContent`[OTEL] record ${Name.Duration} histogram ${timing.active.toString()}ms ${outputToken.json({
      labels
    })}`), outputDebug(outputContent`[OTEL] record ${Name.Elapsed} histogram stage="active" ${timing.active.toString()}ms`), outputDebug(outputContent`[OTEL] record ${Name.Elapsed} histogram stage="network" ${timing.network.toString()}ms`), outputDebug(outputContent`[OTEL] record ${Name.Elapsed} histogram stage="prompt" ${timing.prompt.toString()}ms`);
    return;
  }
  timing.active > 0 && (recorder.otel.record(Name.Duration, timing.active, labels), recorder.otel.record(Name.Elapsed, timing.active, { ...labels, stage: "active" })), timing.network > 0 && recorder.otel.record(Name.Elapsed, timing.network, { ...labels, stage: "network" }), timing.prompt > 0 && recorder.otel.record(Name.Elapsed, timing.prompt, { ...labels, stage: "prompt" });
}

// ../cli-kit/dist/public/node/analytics.js
async function reportAnalyticsEvent(options) {
  try {
    let payload = await buildPayload(options);
    if (payload === void 0)
      return;
    let withinRateLimit = !1;
    if (await runWithRateLimit({
      key: "report-analytics-event",
      ...reportingRateLimit,
      task: async () => {
        withinRateLimit = !0;
      }
    }), !withinRateLimit) {
      outputDebug(outputContent`Skipping command analytics due to rate limiting, payload: ${outputToken.json(payload)}`);
      return;
    }
    let skipMonorailAnalytics = !alwaysLogAnalytics() && analyticsDisabled(), skipMetricAnalytics = !alwaysLogMetrics() && analyticsDisabled();
    (skipMonorailAnalytics || skipMetricAnalytics) && outputDebug(outputContent`Skipping command analytics, payload: ${outputToken.json(payload)}`);
    let doMonorail = async () => {
      if (skipMonorailAnalytics)
        return;
      let response = await publishMonorailEvent(MONORAIL_COMMAND_TOPIC, payload.public, payload.sensitive);
      response.type === "error" && outputDebug(response.message);
    }, doOpenTelemetry = async () => {
      let active = payload.public.cmd_all_timing_active_ms || 0, network = payload.public.cmd_all_timing_network_ms || 0, prompt = payload.public.cmd_all_timing_prompts_ms || 0;
      return recordMetrics({
        skipMetricAnalytics,
        cliVersion: payload.public.cli_version,
        owningPlugin: payload.public.cmd_all_plugin || "@shopify/cli",
        command: payload.public.command,
        exitMode: options.exitMode
      }, {
        active,
        network,
        prompt
      });
    };
    await Promise.all([doMonorail(), doOpenTelemetry()]);
  } catch (error) {
    let message = "Failed to report usage analytics";
    error instanceof Error && (message = message.concat(`: ${error.message}`)), outputDebug(message);
  }
}
async function buildPayload({ config, errorMessage, exitMode }) {
  let { commandStartOptions, environmentFlags, ...sensitiveMetadata } = getAllSensitiveMetadata();
  if (commandStartOptions === void 0) {
    outputDebug("Unable to log analytics event - no information on executed command");
    return;
  }
  let { startCommand, startArgs, startTime } = commandStartOptions, currentTime = (/* @__PURE__ */ new Date()).getTime(), { "@shopify/cli": internalPluginsPublic, ...externalPluginsPublic } = await fanoutHooks(config, "public_command_metadata", {}), { "@shopify/cli": internalPluginsSensitive, ...externalPluginsSensitive } = await fanoutHooks(config, "sensitive_command_metadata", {}), environmentData = await getEnvironmentData(config), sensitiveEnvironmentData = await getSensitiveEnvironmentData(config), publicMetadata = getAllPublicMetadata(), totalTimeFromSubtimers = ["cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"].reduce((total, timer) => {
    let value = publicMetadata[timer];
    return value !== void 0 ? total + value : total;
  }, 0), wallClockElapsed = currentTime - startTime, totalTimeWithoutSubtimers = wallClockElapsed - totalTimeFromSubtimers, payload = {
    public: {
      command: startCommand,
      time_start: startTime,
      time_end: currentTime,
      total_time: wallClockElapsed,
      success: exitMode === "ok" && errorMessage === void 0,
      cli_version: CLI_KIT_VERSION,
      ruby_version: "",
      node_version: process.version.replace("v", ""),
      is_employee: await isShopify(),
      ...environmentData,
      ...internalPluginsPublic,
      ...publicMetadata,
      cmd_all_timing_active_ms: totalTimeWithoutSubtimers,
      cmd_all_exit: exitMode,
      user_id: await getLastSeenUserIdAfterAuth(),
      request_ids: requestIdsCollection.getRequestIds()
    },
    sensitive: {
      args: startArgs.join(" "),
      cmd_all_environment_flags: environmentFlags,
      error_message: errorMessage,
      ...internalPluginsSensitive,
      ...sensitiveEnvironmentData,
      metadata: JSON.stringify({
        ...sensitiveMetadata,
        extraPublic: {
          ...externalPluginsPublic
        },
        extraSensitive: { ...externalPluginsSensitive }
      })
    }
  };
  return ["cmd_all_timing_active_ms", "cmd_all_timing_network_ms", "cmd_all_timing_prompts_ms"].forEach((metric) => {
    let current = payload.public[metric];
    current !== void 0 && (payload.public[metric] = Math.floor(current));
  }), payload = JSON.parse(JSON.stringify(payload)), sanitizePayload2(payload);
}
function sanitizePayload2(payload) {
  let sanitizedPayloadString = JSON.stringify(payload).replace(/shptka_\w*/g, "*****");
  return JSON.parse(sanitizedPayloadString);
}
function recordTiming2(eventName) {
  recordTiming(eventName);
}
function recordError2(error) {
  return recordError(error), error;
}
function recordEvent2(eventName) {
  recordEvent(eventName);
}
function compileData2() {
  return compileData();
}

export {
  fanoutHooks,
  getListOfTunnelPlugins,
  reportAnalyticsEvent,
  recordTiming2 as recordTiming,
  recordError2 as recordError,
  recordEvent2 as recordEvent,
  compileData2 as compileData
};
//# sourceMappingURL=chunk-EPNYJUKL.js.map
