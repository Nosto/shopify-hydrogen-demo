{"version":3,"sources":["../../src/pluck.ts"],"names":[],"mappings":"AAIO,MAAM,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAKzB,sBAAsB,CAAC,MAAW,YAAiB;AAEjD,UAAM,wBACJ,KAAK,SAAS,qBACd,oBAAoB,KAAK,KAAK,OAAO,CAAC,GAAG,OAAO,OAAO,EAAE;AAE3D,QAAI;AAAuB,aAAO;AAGlC,UAAM,EAAC,gBAAe,IAAI;AAC1B,UAAM,iBAAiB,kBAAkB,iBAAiB,SAAS,CAAC;AACpE,UAAM,sBAAsB,gBAAgB,OAAO,KAAK,EAAE,YAAY;AAEtE,WAAO,wBAAwB,SAAS;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,qBAAqB,CAAC,MAAc,EAAC,OAAO,KAAK,gBAAe,MAAW;AACzE,QAAI,cAAc,KAEf,MAAM,QAAQ,GAAG,MAAM,CAAC,EAGxB,QAAQ,kBAAkB,CAAC,GAAG,OAAO,mBAAmB,EAAE,EAC1D,MAAM,KAAK,EACX,KAAK,GAAG;AAEX,UAAM,aAAa,kBAAkB,CAAC,GAAG,SAAS;AAClD,UAAM,iBAAiB,KAAK,MAAM,GAAG,UAAU;AAC/C,UAAM,CAAC,EAAE,OAAO,IAAI,eAAe,MAAM,iBAAiB,KAAK,CAAC;AAEhE,QAAI,SAAS;AAGX,qBAAe,eAAe;AAAA,IAChC;AAEA,WAAO;AAAA,EACT;AACF","sourcesContent":["/**\n * This is a modified version of graphql-tag-pluck's default config.\n * https://github.com/ardatan/graphql-tools/issues/5127\n */\nexport const pluckConfig = {\n  /**\n   * Hook to determine if a node is a gql template literal.\n   * By default, graphql-tag-pluck only looks for leading comments or `gql` tag.\n   */\n  isGqlTemplateLiteral: (node: any, options: any) => {\n    // Check for internal gql comment: const QUERY = `#graphql ...`\n    const hasInternalGqlComment =\n      node.type === 'TemplateLiteral' &&\n      /\\s*#graphql\\s*\\n/i.test(node.quasis[0]?.value?.raw || '');\n\n    if (hasInternalGqlComment) return true;\n\n    // Check for leading gql comment: const QUERY = /* GraphQL */ `...`\n    const {leadingComments} = node;\n    const leadingComment = leadingComments?.[leadingComments?.length - 1];\n    const leadingCommentValue = leadingComment?.value?.trim().toLowerCase();\n\n    return leadingCommentValue === options?.gqlMagicComment;\n  },\n\n  /**\n   * Instruct how to extract the gql template literal from the code.\n   * By default, embedded expressions in template literals (e.g. ${foo})\n   * are removed from the template string. This hook allows us to annotate\n   * the template string with the required embedded expressions instead of\n   * removing them. Later, we can use this information to reconstruct the\n   * embedded expressions.\n   */\n  pluckStringFromFile: (code: string, {start, end, leadingComments}: any) => {\n    let gqlTemplate = code\n      // Slice quotes\n      .slice(start + 1, end - 1)\n      // Annotate embedded expressions\n      // e.g. ${foo} -> #REQUIRED_VAR=foo\n      .replace(/\\$\\{([^}]*)\\}/g, (_, m1) => '#REQUIRED_VAR=' + m1)\n      .split('\\\\`')\n      .join('`');\n\n    const chunkStart = leadingComments?.[0]?.start ?? start;\n    const codeBeforeNode = code.slice(0, chunkStart);\n    const [, varName] = codeBeforeNode.match(/\\s(\\w+)\\s*=\\s*$/) || [];\n\n    if (varName) {\n      // Annotate with the name of the variable that stores this gql template.\n      // This is used to reconstruct the embedded expressions later.\n      gqlTemplate += '#VAR_NAME=' + varName;\n    }\n\n    return gqlTemplate;\n  },\n};\n"]}