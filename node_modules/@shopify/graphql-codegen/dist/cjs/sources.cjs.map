{"version":3,"sources":["../../src/sources.ts"],"names":[],"mappings":"AAIA,MAAM,aAAa,CAAC,QAAgB,IAAI,OAAO,CAAC,EAAE,YAAY,IAAI,IAAI,MAAM,CAAC;AAE7E,MAAM,oBAAoB,CACxB,SACG;AACH,MAAI,KAAK,SAAS,sBAAsB;AACtC,WAAO;AAAA,EACT;AAKA,SAAO,WAAW,KAAK,KAAM,KAAK,IAAI,WAAW,KAAK,SAAS;AACjE;AAEO,SAAS,eACd,SACA,YAAY,mBACZ;AACA,QAAM,wBAAqD,CAAC;AAE5D,aAAW,kBAAkB,SAAS;AACpC,UAAM,SAAS,cAAc,cAAc;AAC3C,UAAM,EAAC,SAAQ,IAAI;AACnB,UAAM,aAAyC,CAAC;AAEhD,eAAW,cAAc,UAAU,eAAe,CAAC,GAAG;AACpD,UACE,YAAY,SAAS,yBACrB,YAAY,SAAS;AAErB;AAEF,UAAI,WAAW,MAAM,SAAS;AAAQ;AAEtC,iBAAW,KAAK;AAAA,QACd,aAAa,UAAU,UAAU;AAAA,QACjC;AAAA,MACF,CAAC;AAAA,IACH;AAEA,QAAI,WAAW,WAAW;AAAG;AAE7B,0BAAsB,KAAK;AAAA,MACzB;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AA6CA,SAAS,cAAc,QAAgB;AACrC,QAAM,cAAc,EAAC,GAAG,OAAM;AAE9B,cAAY,SAAS,OAAO,QAAQ,QAAQ,SAAS,IAAI;AAEzD,SAAO;AACT","sourcesContent":["import type {Source} from '@graphql-tools/utils';\nimport type {FragmentDefinitionNode, OperationDefinitionNode} from 'graphql';\nimport type {OperationOrFragment, SourceWithOperations} from './plugin.js';\n\nconst capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n\nconst capitalizeQueries = (\n  node: OperationDefinitionNode | FragmentDefinitionNode,\n) => {\n  if (node.kind === 'FragmentDefinition') {\n    return 'not used';\n  }\n\n  // Match the names generated by typescript-operations plugin:\n  // e.g. 'query Hello {...}' => HelloQuery\n  // -- Anonymous queries are not supported.\n  return capitalize(node.name!.value) + capitalize(node.operation);\n};\n\nexport function processSources(\n  sources: Array<Source>,\n  buildName = capitalizeQueries,\n) {\n  const sourcesWithOperations: Array<SourceWithOperations> = [];\n\n  for (const originalSource of sources) {\n    const source = fixLinebreaks(originalSource);\n    const {document} = source;\n    const operations: Array<OperationOrFragment> = [];\n\n    for (const definition of document?.definitions ?? []) {\n      if (\n        definition?.kind !== 'OperationDefinition' &&\n        definition?.kind !== 'FragmentDefinition'\n      )\n        continue;\n\n      if (definition.name?.kind !== `Name`) continue;\n\n      operations.push({\n        initialName: buildName(definition),\n        definition,\n      });\n    }\n\n    if (operations.length === 0) continue;\n\n    sourcesWithOperations.push({\n      source,\n      operations,\n    });\n  }\n\n  return sourcesWithOperations;\n}\n\n/**\n * https://github.com/dotansimha/graphql-code-generator/issues/7362\n *\n * Source file is read by @graphql/tools using fs.promises.readFile,\n * which means that the linebreaks are read as-is and the result will be different\n * depending on the OS: it will contain LF (\\n) on Linux/MacOS and CRLF (\\r\\n) on Windows.\n *\n * In most scenarios that would be OK. However, gql-tag-operation is using the resulting string\n * as a TypeScript type. Which means that the string will be compared against a template literal,\n * for example:\n *\n * <pre><code>\n * `\n * query a {\n *    a\n *  }\n * ` === '\\n query a {\\n    a\\n  }\\n '\n * </code></pre>\n *\n * According to clause 12.8.6.2 of ECMAScript Language Specification\n * (https://tc39.es/ecma262/#sec-static-semantics-trv),\n * when comparing strings, JavaScript doesn't care which linebreaks does the source file contain,\n * any linebreak (CR, LF or CRLF) is LF from JavaScript standpoint\n * (otherwise the result of the above comparison would be OS-dependent, which doesn't make sense).\n *\n * Therefore gql-tag-operation would break on Windows as it would generate\n *\n * '\\r\\n query a {\\r\\n    a\\r\\n  }\\r\\n '\n *\n * which is NOT equal to\n *\n * <pre><code>\n * `\n * query a {\n *    a\n *  }\n * `\n * </code></pre>\n *\n * Therefore we need to replace \\r\\n with \\n in the string.\n *\n * @param source\n */\nfunction fixLinebreaks(source: Source) {\n  const fixedSource = {...source};\n\n  fixedSource.rawSDL = source.rawSDL?.replace(/\\r\\n/g, '\\n');\n\n  return fixedSource;\n}\n"]}