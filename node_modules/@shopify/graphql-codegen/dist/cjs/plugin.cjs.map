{"version":3,"sources":["../../src/plugin.ts"],"names":[],"mappings":"AAiBO,MAAM,SAGR,CAAC,GAAG,IAAI,EAAC,uBAAuB,uBAAsB,GAAG,UAAU;AACtE,QAAM,OAAO,yBAAyB,qBAAqB;AAE3D,OAAK,KAAK,sBAAsB;AAEhC,SAAO,KAAK,KAAK,EAAE,IAAI;AACzB;AAEO,MAAM,iCAAiC;AACvC,MAAM,oCAAoC;AAEjD,MAAM,eAAe;AAIrB,MAAM,qBAAqB,CACzB,QACA,iBACG;AACH,MAAI,mBAAmB;AAEvB,SAAO,iBAAiB,KAAK,MAAM,KAAK,CAAC,kBAAkB;AACzD,QAAI,oBAAoB,OAAO,SAAS,sBAAsB;AAC9D,eAAW,CAAC,OAAO,YAAY,KAAK,mBAAmB;AACrD,UAAI,aAAa,IAAI,YAAY,GAAG;AAClC,iBAAS,OAAO,QAAQ,OAAO,aAAa,IAAI,YAAY,CAAE;AAAA,MAChE,OAAO;AAIL,2BAAmB;AACnB,gBAAQ;AAAA,UACN,IAAI;AAAA,YACF,aAAa,YAAY;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAEA,MAAM,iBAAiB,CAAC,MAAc,eAAsC;AAC1E,QAAM,QAAQ,CAAC,aAAa,IAAI;AAAA,CAAM;AAEtC,aAAW,CAAC,gBAAgB,SAAS,KAAK,YAAY;AACpD,UAAM;AAAA,MACJ,KAAK,KAAK,UAAU,cAAc,CAAC,cACjC,UAAU,WAAW,IAAI,UAAU,CAAC,IAAI,OAC1C,gBAAgB,UAAU,IAAI,CAAC,MAAM,IAAI,WAAW,EAAE,KAAK,KAAK,CAAC;AAAA;AAAA,IACnE;AAAA,EACF;AAEA,QAAM,KAAK;AAAA,CAAK;AAEhB,SAAO;AACT;AAEA,SAAS,yBACP,wBAAqD,CAAC,GACtD;AACA,QAAM,UAAU,oBAAI,IAAsB;AAC1C,QAAM,YAAY,oBAAI,IAAsB;AAE5C,QAAM,eAAe,oBAAI,IAAoB;AAC7C,aAAW,EAAC,OAAM,KAAK,uBAAuB;AAC5C,UAAM,eAAe,OAAO,QAAQ,MAAM,iBAAiB,IAAI,CAAC;AAChE,QAAI,cAAc;AAChB,aAAO,SAAS,OAAO,OAAQ,QAAQ,kBAAkB,EAAE;AAC3D,mBAAa,IAAI,cAAc,OAAO,MAAO;AAAA,IAC/C;AAAA,EACF;AAEA,aAAW,EAAC,YAAY,OAAM,KAAK,uBAAuB;AACxD,UAAM,mBAAmB,WAAW;AAAA,MAClC,CAAC,OAAO,GAAG,WAAW,SAAS;AAAA,IACjC;AAEA,QAAI,iBAAiB,WAAW;AAAG;AAEnC,UAAM,YAAY,OAAO;AACzB,UAAM,SAAS,aAAa,KAAK,SAAS,IAAI,YAAY;AAC1D,WAAO;AAAA,MACL,mBAAmB,WAAW,YAAY;AAAA,MAC1C,iBAAiB,IAAI,CAAC,MAAM,EAAE,WAAW;AAAA,IAC3C;AAAA,EACF;AAEA,SAAO;AAAA,IACL,GAAG,eAAe,gCAAgC,OAAO;AAAA,IACzD;AAAA,IACA,GAAG,eAAe,mCAAmC,SAAS;AAAA,EAChE;AACF","sourcesContent":["// This plugin is based on `gql-tag-operations-preset`\n// https://www.npmjs.com/package/@graphql-codegen/gql-tag-operations-preset\n\nimport type {PluginFunction} from '@graphql-codegen/plugin-helpers';\nimport type {Source} from '@graphql-tools/utils';\nimport type {FragmentDefinitionNode, OperationDefinitionNode} from 'graphql';\n\nexport type OperationOrFragment = {\n  initialName: string;\n  definition: OperationDefinitionNode | FragmentDefinitionNode;\n};\n\nexport type SourceWithOperations = {\n  source: Source;\n  operations: Array<OperationOrFragment>;\n};\n\nexport const plugin: PluginFunction<{\n  sourcesWithOperations: Array<SourceWithOperations>;\n  interfaceExtensionCode: string;\n}> = (_, __, {sourcesWithOperations, interfaceExtensionCode}, _info) => {\n  const code = getDocumentRegistryChunk(sourcesWithOperations);\n\n  code.push(interfaceExtensionCode);\n\n  return code.join('') + '\\n';\n};\n\nexport const GENERATED_QUERY_INTERFACE_NAME = 'GeneratedQueryTypes';\nexport const GENERATED_MUTATION_INTERFACE_NAME = 'GeneratedMutationTypes';\n\nconst isMutationRE = /(^|}\\s|\\n\\s*)mutation[\\s({]/im;\n\n// Iteratively replace fragment annotations with the actual fragment content\n// until there are no more annotations in the operation.\nconst normalizeOperation = (\n  rawSDL: string,\n  variablesMap: Map<string, string>,\n) => {\n  let variableNotFound = false;\n\n  while (/#REQUIRED_VAR=/.test(rawSDL) && !variableNotFound) {\n    let requiredVariables = rawSDL.matchAll(/#REQUIRED_VAR=(\\w+)/g);\n    for (const [match, variableName] of requiredVariables) {\n      if (variablesMap.has(variableName)) {\n        rawSDL = rawSDL.replace(match, variablesMap.get(variableName)!);\n      } else {\n        // An annotation cannot be replaced, so the operation is invalid.\n        // This should not happen, but we'll handle it just in case\n        // to prevent infinite loops. This should be logged as an error and fixed.\n        variableNotFound = true; // break;\n        console.error(\n          new Error(\n            `Variable \"${variableName}\" not found. This might be a bug in @shopify/graphql-codegen, please report it.`,\n          ),\n        );\n      }\n    }\n  }\n\n  return rawSDL;\n};\n\nconst buildTypeLines = (name: string, operations: Map<string, string[]>) => {\n  const lines = [`interface ${name} {\\n`];\n\n  for (const [originalString, typeNames] of operations) {\n    lines.push(\n      `  ${JSON.stringify(originalString)}: {return: ${\n        typeNames.length === 1 ? typeNames[0] : 'never'\n      }, variables: ${typeNames.map((n) => n + 'Variables').join(' & ')}},\\n`,\n    );\n  }\n\n  lines.push(`}\\n`);\n\n  return lines;\n};\n\nfunction getDocumentRegistryChunk(\n  sourcesWithOperations: Array<SourceWithOperations> = [],\n) {\n  const queries = new Map<string, string[]>();\n  const mutations = new Map<string, string[]>();\n\n  const variablesMap = new Map<string, string>();\n  for (const {source} of sourcesWithOperations) {\n    const variableName = source.rawSDL?.match(/#VAR_NAME=(\\w+)/)?.[1];\n    if (variableName) {\n      source.rawSDL = source.rawSDL!.replace(/#VAR_NAME=\\w+$/, '');\n      variablesMap.set(variableName, source.rawSDL!);\n    }\n  }\n\n  for (const {operations, source} of sourcesWithOperations) {\n    const actualOperations = operations.filter(\n      (op) => op.definition.kind === 'OperationDefinition',\n    );\n\n    if (actualOperations.length === 0) continue;\n\n    const sdlString = source.rawSDL!;\n    const target = isMutationRE.test(sdlString) ? mutations : queries;\n    target.set(\n      normalizeOperation(sdlString, variablesMap),\n      actualOperations.map((o) => o.initialName),\n    );\n  }\n\n  return [\n    ...buildTypeLines(GENERATED_QUERY_INTERFACE_NAME, queries),\n    '\\n',\n    ...buildTypeLines(GENERATED_MUTATION_INTERFACE_NAME, mutations),\n  ];\n}\n"]}