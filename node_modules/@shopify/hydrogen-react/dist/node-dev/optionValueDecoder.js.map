{"version":3,"file":"optionValueDecoder.js","sources":["../../src/optionValueDecoder.ts"],"sourcesContent":["/**\n * This file provides utility functions for determining whether or not an option value combination is present in an encoded option value string.\n *\n * In V1 of the encoding strategy, option value arrays are encoded as a trie with the following rules:\n *  - `:` `,` ` ` and `-` are control characters.\n *  - `:` indicates a new option. ex: 0:1 indicates value 0 for the option in position 1, value 1 for the option in position 2.\n *  - `,` indicates the end of a repeated prefix, mulitple consecutive commas indicate the end of multiple repeated prefixes.\n *  - ` ` indicates a gap in the sequence of option values. ex: `0 4` indicates option values in position 0 and 4 are present.\n *  - `-` indicates a continuous range of option values. ex: `0 1-3 4`. Ranges are only present encoded in the final option value position, so for example the trie for the set [[0,0,0],[0,0,1], ..., [0,2,2]] will be structured as `0:0:0-2,1:0-2,2:0-2`, not `0:0-2:0-2`.\n */\n\nimport {Product} from './storefront-api-types.js';\n\nconst OPTION_VALUE_SEPARATOR = ',';\n\nconst V1_CONTROL_CHARS = {\n  OPTION: ':',\n  END_OF_PREFIX: ',',\n  SEQUENCE_GAP: ' ',\n  RANGE: '-',\n};\n\nexport type IsOptionValueCombinationInEncodedVariant = (\n  targetOptionValueCombination: number[],\n  encodedVariantField: string,\n) => boolean;\n\n/**\n * Determine whether an option value combination is present in an encoded option value string. Function is memoized by encodedVariantField.\n *\n * @param targetOptionValueCombination - Indices of option values to look up in the encoded option value string. A partial set of indices may be passed to determine whether a node or any children is present. For example, if a product has 3 options, passing [0] will return true if any option value combination for the first option's option value is present in the encoded string.\n * @param encodedVariantField - Encoded option value string from the Storefront API, e.g. [product.encodedVariantExistence](/docs/api/storefront/2025-07/objects/Product#field-encodedvariantexistence) or [product.encodedVariantAvailability](/docs/api/storefront/2025-07/objects/Product#field-encodedvariantavailability)\n * @returns - True if a full or partial targetOptionValueIndices is present in the encoded option value string, false otherwise.\n */\nexport const isOptionValueCombinationInEncodedVariant: IsOptionValueCombinationInEncodedVariant =\n  ((): IsOptionValueCombinationInEncodedVariant => {\n    const decodedOptionValues = new Map<string, Set<string>>();\n\n    return function (\n      targetOptionValueCombination: number[],\n      encodedVariantField: string,\n    ): boolean {\n      if (targetOptionValueCombination.length === 0) {\n        return false;\n      }\n\n      if (!decodedOptionValues.has(encodedVariantField)) {\n        const decodedOptionValuesSet = new Set<string>();\n\n        for (const optionValue of decodeEncodedVariant(encodedVariantField)) {\n          // add the complete option value to the decoded option values set\n          decodedOptionValuesSet.add(optionValue.join(OPTION_VALUE_SEPARATOR));\n\n          // add all composite parts of the option value to the decoded option values set. e.g. if the option value is [0,1,2], add \"0\", \"0,1\", \"0,1,2\"\n          for (let i = 0; i < optionValue.length; i++) {\n            decodedOptionValuesSet.add(\n              optionValue.slice(0, i + 1).join(OPTION_VALUE_SEPARATOR),\n            );\n          }\n        }\n\n        decodedOptionValues.set(encodedVariantField, decodedOptionValuesSet);\n      }\n\n      return Boolean(\n        decodedOptionValues\n          .get(encodedVariantField)\n          ?.has(targetOptionValueCombination.join(OPTION_VALUE_SEPARATOR)),\n      );\n    };\n  })();\n\ntype EncodedVariantField =\n  | Product['encodedVariantAvailability']\n  // eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents\n  | Product['encodedVariantExistence'];\ntype DecodedOptionValues = number[][];\n\n/**\n * For an encoded option value string, decode into option value combinations. Entries represent a valid combination formatted as an array of option value positions.\n * @param encodedVariantField - Encoded option value string from the Storefront API, e.g. [product.encodedVariantExistence](/docs/api/storefront/2025-07/objects/Product#field-encodedvariantexistence) or [product.encodedVariantAvailability](/docs/api/storefront/2025-07/objects/Product#field-encodedvariantavailability)\n * @returns Decoded option value combinations\n */\nexport function decodeEncodedVariant(\n  encodedVariantField: EncodedVariantField,\n): DecodedOptionValues {\n  if (!encodedVariantField) return [];\n\n  if (encodedVariantField.startsWith('v1_')) {\n    return v1Decoder(stripVersion(encodedVariantField));\n  }\n\n  throw new Error('Unsupported option value encoding');\n}\n\nconst stripVersion: (encodedVariantField: string) => string = (\n  encodedVariantField: string,\n) => encodedVariantField.replace(/^v1_/, '');\n\n/**\n * We encode an array of arrays representing variants, expressed in terms of options and option values, as a trie.\n *\n * This encoding strategy allows extremely large numbers of variants to be expressed in an extremely compact data structure.\n *\n * Integers represent option and values, so [0,0,0] represents option_value at array index 0 for the options at array indexes 0, 1 and 2\n *\n * `:`, `,`, ` ` and `-` are control characters.\n * `:` indicates a new option\n * `,` indicates the end of a repeated prefix, mulitple consecutive commas indicate the end of multiple repeated prefixes.\n * ` ` indicates a gap in the sequence of option values\n * `-` indicates a continuous range of option values\n *\n * Encoding process:\n *\n * example input array: [[0,0,0], [0,1,0], [0,1,1], [1,0,0], [1,0,1], [1,1,1], [2,0,1], [2,1,0]]\n *\n * step 1: encode as string: \"0:0:0,0:1:0,0:1:1,1:0:0,1:0:1,1:1:1,2:0:1,2:1:0,\"\n * step 2: combine nodes that share a prefix: \"0:0:0,0:1:0 1,1:0:0 1,1:1:1,2:0:1,2:1:0,\"\n * step 3: encode data as a trie so no prefixes need to be repeated: \"0:0:0,1:0 1,,1:0:0 1,1:1,,2:0:1,1:0,,\"\n * step 4: since the options are sorted, use a dash to express ranges: \"0:0:0,1:0-1,,1:0:0-1,1:1,,2:0:1,1:0,,\"\n */\nfunction v1Decoder(encodedVariantField: string): number[][] {\n  const tokenizer = /[ :,-]/g;\n  let index = 0;\n  let token: RegExpExecArray | null;\n  const options: number[][] = [];\n  const currentOptionValue: number[] = [];\n  let depth = 0;\n  let rangeStart: number | null = null;\n\n  // iterate over control characters\n  while ((token = tokenizer.exec(encodedVariantField))) {\n    const operation = token[0];\n    const optionValueIndex =\n      Number.parseInt(encodedVariantField.slice(index, token.index)) || 0;\n\n    if (rangeStart !== null) {\n      // If a range has been started, iterate over the range and add each option value to the list of options\n      // - `rangeStart` is set if the last control char was a dash, e.g. `0` for 0-2. It represents the numeric option value position for the start of the range.\n      // - `optionValueIndex` is the numeric option value position for the end of the range\n      for (; rangeStart < optionValueIndex; rangeStart++) {\n        currentOptionValue[depth] = rangeStart;\n        options.push([...currentOptionValue]);\n      }\n      // indicates the range has been processed\n      rangeStart = null;\n    }\n\n    currentOptionValue[depth] = optionValueIndex;\n\n    if (operation === V1_CONTROL_CHARS.RANGE) {\n      // dash operation indicates we are in a range. e.g. 0-2 means option values 0, 1, 2\n      rangeStart = optionValueIndex;\n    } else if (operation === V1_CONTROL_CHARS.OPTION) {\n      // colon operation indicates that we are moving down to the next layer of option values. e.g. 0:0:0-2 means we traverse down from option1 to option3 and represents [[0,0,0], [0,0,1], [0,0,2]]\n      depth++;\n    } else {\n      if (\n        operation === V1_CONTROL_CHARS.SEQUENCE_GAP ||\n        (operation === V1_CONTROL_CHARS.END_OF_PREFIX &&\n          encodedVariantField[token.index - 1] !==\n            V1_CONTROL_CHARS.END_OF_PREFIX)\n      ) {\n        // add the current option value to the list of options if we hit a gap in our sequence or we are at the end of our depth and need to move back up\n        options.push([...currentOptionValue]);\n      }\n      if (operation === V1_CONTROL_CHARS.END_OF_PREFIX) {\n        // go up an option level, trash the last item in currentOptionValue\n        currentOptionValue.pop();\n        depth--;\n      }\n    }\n    index = tokenizer.lastIndex;\n  }\n\n  // The while loop only iterates control characters, meaning if an encoded string ends with an index it will not be processed.\n  const encodingEndsWithIndex = encodedVariantField.match(/\\d+$/g);\n  if (encodingEndsWithIndex) {\n    const finalValueIndex = parseInt(encodingEndsWithIndex[0]);\n    if (rangeStart != null) {\n      // process final range\n      for (; rangeStart <= finalValueIndex; rangeStart++) {\n        currentOptionValue[depth] = rangeStart;\n        options.push([...currentOptionValue]);\n      }\n    } else {\n      // process final index\n      options.push([finalValueIndex]);\n    }\n  }\n\n  return options;\n}\n"],"names":[],"mappings":";;AAaA,MAAM,yBAAyB;AAE/B,MAAM,mBAAmB;AAAA,EACvB,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,cAAc;AAAA,EACd,OAAO;AACT;AAcO,MAAM,2CACV,uBAAgD;AAC/C,QAAM,0CAA0B,IAAA;AAEhC,SAAO,SACL,8BACA,qBACS;;AACT,QAAI,6BAA6B,WAAW,GAAG;AAC7C,aAAO;AAAA,IACT;AAEA,QAAI,CAAC,oBAAoB,IAAI,mBAAmB,GAAG;AACjD,YAAM,6CAA6B,IAAA;AAEnC,iBAAW,eAAe,qBAAqB,mBAAmB,GAAG;AAEnE,+BAAuB,IAAI,YAAY,KAAK,sBAAsB,CAAC;AAGnE,iBAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,iCAAuB;AAAA,YACrB,YAAY,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,sBAAsB;AAAA,UAAA;AAAA,QAE3D;AAAA,MACF;AAEA,0BAAoB,IAAI,qBAAqB,sBAAsB;AAAA,IACrE;AAEA,WAAO;AAAA,OACL,yBACG,IAAI,mBAAmB,MAD1B,mBAEI,IAAI,6BAA6B,KAAK,sBAAsB;AAAA,IAAC;AAAA,EAErE;AACF,GAAA;AAaK,SAAS,qBACd,qBACqB;AACrB,MAAI,CAAC,oBAAqB,QAAO,CAAA;AAEjC,MAAI,oBAAoB,WAAW,KAAK,GAAG;AACzC,WAAO,UAAU,aAAa,mBAAmB,CAAC;AAAA,EACpD;AAEA,QAAM,IAAI,MAAM,mCAAmC;AACrD;AAEA,MAAM,eAAwD,CAC5D,wBACG,oBAAoB,QAAQ,QAAQ,EAAE;AAwB3C,SAAS,UAAU,qBAAyC;AAC1D,QAAM,YAAY;AAClB,MAAI,QAAQ;AACZ,MAAI;AACJ,QAAM,UAAsB,CAAA;AAC5B,QAAM,qBAA+B,CAAA;AACrC,MAAI,QAAQ;AACZ,MAAI,aAA4B;AAGhC,SAAQ,QAAQ,UAAU,KAAK,mBAAmB,GAAI;AACpD,UAAM,YAAY,MAAM,CAAC;AACzB,UAAM,mBACJ,OAAO,SAAS,oBAAoB,MAAM,OAAO,MAAM,KAAK,CAAC,KAAK;AAEpE,QAAI,eAAe,MAAM;AAIvB,aAAO,aAAa,kBAAkB,cAAc;AAClD,2BAAmB,KAAK,IAAI;AAC5B,gBAAQ,KAAK,CAAC,GAAG,kBAAkB,CAAC;AAAA,MACtC;AAEA,mBAAa;AAAA,IACf;AAEA,uBAAmB,KAAK,IAAI;AAE5B,QAAI,cAAc,iBAAiB,OAAO;AAExC,mBAAa;AAAA,IACf,WAAW,cAAc,iBAAiB,QAAQ;AAEhD;AAAA,IACF,OAAO;AACL,UACE,cAAc,iBAAiB,gBAC9B,cAAc,iBAAiB,iBAC9B,oBAAoB,MAAM,QAAQ,CAAC,MACjC,iBAAiB,eACrB;AAEA,gBAAQ,KAAK,CAAC,GAAG,kBAAkB,CAAC;AAAA,MACtC;AACA,UAAI,cAAc,iBAAiB,eAAe;AAEhD,2BAAmB,IAAA;AACnB;AAAA,MACF;AAAA,IACF;AACA,YAAQ,UAAU;AAAA,EACpB;AAGA,QAAM,wBAAwB,oBAAoB,MAAM,OAAO;AAC/D,MAAI,uBAAuB;AACzB,UAAM,kBAAkB,SAAS,sBAAsB,CAAC,CAAC;AACzD,QAAI,cAAc,MAAM;AAEtB,aAAO,cAAc,iBAAiB,cAAc;AAClD,2BAAmB,KAAK,IAAI;AAC5B,gBAAQ,KAAK,CAAC,GAAG,kBAAkB,CAAC;AAAA,MACtC;AAAA,IACF,OAAO;AAEL,cAAQ,KAAK,CAAC,eAAe,CAAC;AAAA,IAChC;AAAA,EACF;AAEA,SAAO;AACT;;;"}