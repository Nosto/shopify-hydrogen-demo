"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const flattenConnection = require("./flatten-connection.js");
function parseMetafield(metafield) {
  if (!metafield.type) {
    const noTypeError = `parseMetafield(): The 'type' field is required in order to parse the Metafield.`;
    {
      throw new Error(noTypeError);
    }
  }
  switch (metafield.type) {
    case "boolean":
      return {
        ...metafield,
        parsedValue: metafield.value === "true"
      };
    case "collection_reference":
    case "file_reference":
    case "page_reference":
    case "product_reference":
    case "variant_reference":
      return {
        ...metafield,
        parsedValue: metafield.reference
      };
    case "color":
    case "multi_line_text_field":
    case "single_line_text_field":
    case "url":
      return {
        ...metafield,
        parsedValue: metafield.value
      };
    // TODO: 'money' should probably be parsed even further to like `useMoney()`, but that logic needs to be extracted first so it's not a hook
    case "money": {
      let parsedValue = null;
      try {
        const parsed = parseJSON(metafield.value ?? "");
        if (parsed && typeof parsed === "object" && "currency_code" in parsed) {
          const moneyData = parsed;
          parsedValue = {
            amount: moneyData.amount,
            currencyCode: moneyData.currency_code
          };
        } else if (parsed && typeof parsed === "object" && "currencyCode" in parsed) {
          parsedValue = parsed;
        } else {
          parsedValue = parsed;
        }
      } catch (err) {
        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
        {
          throw new Error(parseError);
        }
      }
      return {
        ...metafield,
        parsedValue
      };
    }
    case "dimension":
    case "json":
    case "rating":
    case "volume":
    case "weight":
    case "rich_text_field":
    case "list.color":
    case "list.dimension":
    case "list.number_integer":
    case "list.number_decimal":
    case "list.rating":
    case "list.single_line_text_field":
    case "list.url":
    case "list.volume":
    case "list.weight": {
      let parsedValue = null;
      try {
        parsedValue = parseJSON(metafield.value ?? "");
      } catch (err) {
        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
        {
          throw new Error(parseError);
        }
      }
      return {
        ...metafield,
        parsedValue
      };
    }
    case "date":
    case "date_time":
      return {
        ...metafield,
        parsedValue: new Date(metafield.value ?? "")
      };
    case "list.date":
    case "list.date_time": {
      const jsonParseValue = parseJSON((metafield == null ? void 0 : metafield.value) ?? "");
      return {
        ...metafield,
        parsedValue: jsonParseValue.map((dateString) => new Date(dateString))
      };
    }
    case "number_decimal":
    case "number_integer":
      return {
        ...metafield,
        parsedValue: Number(metafield.value)
      };
    case "list.collection_reference":
    case "list.file_reference":
    case "list.page_reference":
    case "list.product_reference":
    case "list.variant_reference":
      return {
        ...metafield,
        parsedValue: flattenConnection.flattenConnection(metafield.references ?? void 0)
      };
    default: {
      const typeNotFoundError = `parseMetafield(): the 'metafield.type' you passed in is not supported. Your type: "${metafield.type}". If you believe this is an error, please open an issue on GitHub.`;
      {
        throw new Error(typeNotFoundError);
      }
    }
  }
}
function parseJSON(json) {
  if (String(json).includes("__proto__")) {
    return JSON.parse(json, (k, v) => {
      if (k !== "__proto__") return v;
    });
  }
  return JSON.parse(json);
}
exports.parseJSON = parseJSON;
exports.parseMetafield = parseMetafield;
//# sourceMappingURL=parse-metafield.js.map
