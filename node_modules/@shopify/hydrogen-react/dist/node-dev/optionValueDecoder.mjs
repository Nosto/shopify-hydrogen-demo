const OPTION_VALUE_SEPARATOR = ",";
const V1_CONTROL_CHARS = {
  OPTION: ":",
  END_OF_PREFIX: ",",
  SEQUENCE_GAP: " ",
  RANGE: "-"
};
const isOptionValueCombinationInEncodedVariant = /* @__PURE__ */ (() => {
  const decodedOptionValues = /* @__PURE__ */ new Map();
  return function(targetOptionValueCombination, encodedVariantField) {
    var _a;
    if (targetOptionValueCombination.length === 0) {
      return false;
    }
    if (!decodedOptionValues.has(encodedVariantField)) {
      const decodedOptionValuesSet = /* @__PURE__ */ new Set();
      for (const optionValue of decodeEncodedVariant(encodedVariantField)) {
        decodedOptionValuesSet.add(optionValue.join(OPTION_VALUE_SEPARATOR));
        for (let i = 0; i < optionValue.length; i++) {
          decodedOptionValuesSet.add(
            optionValue.slice(0, i + 1).join(OPTION_VALUE_SEPARATOR)
          );
        }
      }
      decodedOptionValues.set(encodedVariantField, decodedOptionValuesSet);
    }
    return Boolean(
      (_a = decodedOptionValues.get(encodedVariantField)) == null ? void 0 : _a.has(targetOptionValueCombination.join(OPTION_VALUE_SEPARATOR))
    );
  };
})();
function decodeEncodedVariant(encodedVariantField) {
  if (!encodedVariantField) return [];
  if (encodedVariantField.startsWith("v1_")) {
    return v1Decoder(stripVersion(encodedVariantField));
  }
  throw new Error("Unsupported option value encoding");
}
const stripVersion = (encodedVariantField) => encodedVariantField.replace(/^v1_/, "");
function v1Decoder(encodedVariantField) {
  const tokenizer = /[ :,-]/g;
  let index = 0;
  let token;
  const options = [];
  const currentOptionValue = [];
  let depth = 0;
  let rangeStart = null;
  while (token = tokenizer.exec(encodedVariantField)) {
    const operation = token[0];
    const optionValueIndex = Number.parseInt(encodedVariantField.slice(index, token.index)) || 0;
    if (rangeStart !== null) {
      for (; rangeStart < optionValueIndex; rangeStart++) {
        currentOptionValue[depth] = rangeStart;
        options.push([...currentOptionValue]);
      }
      rangeStart = null;
    }
    currentOptionValue[depth] = optionValueIndex;
    if (operation === V1_CONTROL_CHARS.RANGE) {
      rangeStart = optionValueIndex;
    } else if (operation === V1_CONTROL_CHARS.OPTION) {
      depth++;
    } else {
      if (operation === V1_CONTROL_CHARS.SEQUENCE_GAP || operation === V1_CONTROL_CHARS.END_OF_PREFIX && encodedVariantField[token.index - 1] !== V1_CONTROL_CHARS.END_OF_PREFIX) {
        options.push([...currentOptionValue]);
      }
      if (operation === V1_CONTROL_CHARS.END_OF_PREFIX) {
        currentOptionValue.pop();
        depth--;
      }
    }
    index = tokenizer.lastIndex;
  }
  const encodingEndsWithIndex = encodedVariantField.match(/\d+$/g);
  if (encodingEndsWithIndex) {
    const finalValueIndex = parseInt(encodingEndsWithIndex[0]);
    if (rangeStart != null) {
      for (; rangeStart <= finalValueIndex; rangeStart++) {
        currentOptionValue[depth] = rangeStart;
        options.push([...currentOptionValue]);
      }
    } else {
      options.push([finalValueIndex]);
    }
  }
  return options;
}
export {
  decodeEncodedVariant,
  isOptionValueCombinationInEncodedVariant
};
//# sourceMappingURL=optionValueDecoder.mjs.map
