"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const index = require("../../fsm/es/index.js");
const React = require("react");
const useIsomorphicLayoutEffect = require("use-isomorphic-layout-effect");
const withSelector = require("../../../../_virtual/with-selector.js");
const useConstant = require("./useConstant.js");
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function identity(a) {
  return a;
}
var getServiceState = function(service) {
  var currentValue;
  service.subscribe(function(state) {
    currentValue = state;
  }).unsubscribe();
  return currentValue;
};
function useMachine(stateMachine, options) {
  var persistedStateRef = React.useRef();
  if (process.env.NODE_ENV !== "production") {
    var _a = __read(React.useState(stateMachine), 1), initialMachine = _a[0];
    if (stateMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var _b = __read(useConstant(function() {
    var queue2 = [];
    var service2 = index.interpret(index.createMachine(stateMachine.config, options ? options : stateMachine._options));
    var send = service2.send;
    service2.send = function(event) {
      if (service2.status === index.InterpreterStatus.NotStarted) {
        queue2.push(event);
        return;
      }
      send(event);
      persistedStateRef.current = service2.state;
    };
    return [service2, queue2];
  }), 2), service = _b[0], queue = _b[1];
  useIsomorphicLayoutEffect(function() {
    if (options) {
      service._machine._options = options;
    }
  });
  var useServiceResult = useService(service);
  React.useEffect(function() {
    service.start(persistedStateRef.current);
    queue.forEach(service.send);
    persistedStateRef.current = service.state;
    return function() {
      service.stop();
    };
  }, []);
  return useServiceResult;
}
var isEqual = function(_prevState, nextState) {
  return nextState.changed === false;
};
function useService(service) {
  var getSnapshot = React.useCallback(function() {
    return getServiceState(service);
  }, [service]);
  var subscribe = React.useCallback(function(handleStoreChange) {
    var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [service]);
  var storeSnapshot = withSelector.withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getSnapshot, identity, isEqual);
  return [storeSnapshot, service.send, service];
}
exports.useMachine = useMachine;
exports.useService = useService;
//# sourceMappingURL=fsm.js.map
