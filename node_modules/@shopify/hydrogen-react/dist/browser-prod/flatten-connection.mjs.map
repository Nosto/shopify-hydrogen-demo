{"version":3,"file":"flatten-connection.mjs","sources":["../../src/flatten-connection.ts"],"sourcesContent":["import type {PartialDeep} from 'type-fest';\n\n/**\n * The `flattenConnection` utility transforms a connection object from the Storefront API (for example, [Product-related connections](https://shopify.dev/api/storefront/reference/products/product)) into a flat array of nodes.\n * The utility works with either `nodes` or `edges.node`.\n *\n * If `connection` is null or undefined, will return an empty array instead in production. In development, an error will be thrown.\n */\nexport function flattenConnection<\n  ConnectionGeneric extends\n    | PartialDeep<ConnectionEdges, {recurseIntoArrays: true}>\n    | PartialDeep<ConnectionNodes, {recurseIntoArrays: true}>\n    | ConnectionEdges\n    | ConnectionNodes,\n>(\n  connection?: ConnectionGeneric,\n): ConnectionGeneric extends\n  | {\n      edges: Array<{node: infer ConnectionBaseType}>;\n    }\n  | {\n      nodes: Array<infer ConnectionBaseType>;\n    }\n  ? // if it's not a PartialDeep, then return the infered type\n    ConnectionBaseType[]\n  : ConnectionGeneric extends\n        | PartialDeep<\n            {edges: {node: Array<infer ConnectionBaseType>}},\n            {recurseIntoArrays: true}\n          >\n        | PartialDeep<\n            {\n              nodes: Array<infer ConnectionBaseType>;\n            },\n            {recurseIntoArrays: true}\n          >\n    ? // if it is a PartialDeep, return a PartialDeep inferred type\n      PartialDeep<ConnectionBaseType[], {recurseIntoArrays: true}>\n    : never {\n  if (!connection) {\n    const noConnectionErr = `flattenConnection(): needs a 'connection' to flatten, but received '${\n      connection ?? ''\n    }' instead.`;\n    if (__HYDROGEN_DEV__) {\n      throw new Error(noConnectionErr);\n    } else {\n      console.error(noConnectionErr + ` Returning an empty array`);\n      // @ts-expect-error We don't want to crash prod, so return an empty array\n      return [];\n    }\n  }\n\n  if ('nodes' in connection) {\n    // @ts-expect-error return type is failing\n    return connection.nodes;\n  }\n\n  if ('edges' in connection && Array.isArray(connection.edges)) {\n    // @ts-expect-error return type is failing\n    return connection.edges.map((edge) => {\n      if (!edge?.node) {\n        throw new Error(\n          'flattenConnection(): Connection edges must contain nodes',\n        );\n      }\n      return edge.node;\n    }) as Array<unknown>;\n  }\n\n  if (__HYDROGEN_DEV__) {\n    console.warn(\n      `flattenConnection(): The connection did not contain either \"nodes\" or \"edges.node\". Returning an empty array.`,\n    );\n  }\n\n  // @ts-expect-error We don't want to crash prod, so return an empty array\n  return [];\n}\n\ntype ConnectionEdges = {\n  edges: Array<{node: unknown}>;\n};\n\ntype ConnectionNodes = {\n  nodes: Array<unknown>;\n};\n\n// This is only for documentation purposes, and it is not used in the code.\nexport interface ConnectionGenericForDoc {\n  connection?: ConnectionEdges | ConnectionNodes;\n}\nexport type FlattenConnectionReturnForDoc = unknown[];\n"],"names":[],"mappings":"AAQO,SAAS,kBAOd,YAuBU;AACV,MAAI,CAAC,YAAY;AACf,UAAM,kBAAkB,uEACtB,cAAc,EAChB;AAGO;AACL,cAAQ,MAAM,kBAAkB,2BAA2B;AAE3D,aAAO,CAAA;AAAA,IACT;AAAA,EACF;AAEA,MAAI,WAAW,YAAY;AAEzB,WAAO,WAAW;AAAA,EACpB;AAEA,MAAI,WAAW,cAAc,MAAM,QAAQ,WAAW,KAAK,GAAG;AAE5D,WAAO,WAAW,MAAM,IAAI,CAAC,SAAS;AACpC,UAAI,EAAC,6BAAM,OAAM;AACf,cAAM,IAAI;AAAA,UACR;AAAA,QAAA;AAAA,MAEJ;AACA,aAAO,KAAK;AAAA,IACd,CAAC;AAAA,EACH;AASA,SAAO,CAAA;AACT;"}