(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react")) : typeof define === "function" && define.amd ? define(["exports", "react"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.hydrogenreact = {}, global.React));
})(this, (function(exports2, React$1) {
  "use strict";
  function _interopNamespaceDefault(e2) {
    const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e2) {
      for (const k in e2) {
        if (k !== "default") {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n2, k, d.get ? d : {
            enumerable: true,
            get: () => e2[k]
          });
        }
      }
    }
    n2.default = e2;
    return Object.freeze(n2);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React$1);
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  function t(t2, n2) {
    var e2 = "function" == typeof Symbol && t2[Symbol.iterator];
    if (!e2) return t2;
    var r2, i2, o2 = e2.call(t2), a2 = [];
    try {
      for (; (void 0 === n2 || n2-- > 0) && !(r2 = o2.next()).done; ) a2.push(r2.value);
    } catch (t3) {
      i2 = { error: t3 };
    } finally {
      try {
        r2 && !r2.done && (e2 = o2.return) && e2.call(o2);
      } finally {
        if (i2) throw i2.error;
      }
    }
    return a2;
  }
  var n;
  !(function(t2) {
    t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
  })(n || (n = {}));
  var e = { type: "xstate.init" };
  function r(t2) {
    return void 0 === t2 ? [] : [].concat(t2);
  }
  function i(t2) {
    return { type: "xstate.assign", assignment: t2 };
  }
  function o(t2, n2) {
    return "string" == typeof (t2 = "string" == typeof t2 && n2 && n2[t2] ? n2[t2] : t2) ? { type: t2 } : "function" == typeof t2 ? { type: t2.name, exec: t2 } : t2;
  }
  function a(t2) {
    return function(n2) {
      return t2 === n2;
    };
  }
  function u$1(t2) {
    return "string" == typeof t2 ? { type: t2 } : t2;
  }
  function c(t2, n2) {
    return { value: t2, context: n2, actions: [], changed: false, matches: a(t2) };
  }
  function f(t2, n2, e2) {
    var r2 = n2, i2 = false;
    return [t2.filter((function(t3) {
      if ("xstate.assign" === t3.type) {
        i2 = true;
        var n3 = Object.assign({}, r2);
        return "function" == typeof t3.assignment ? n3 = t3.assignment(r2, e2) : Object.keys(t3.assignment).forEach((function(i3) {
          n3[i3] = "function" == typeof t3.assignment[i3] ? t3.assignment[i3](r2, e2) : t3.assignment[i3];
        })), r2 = n3, false;
      }
      return true;
    })), r2, i2];
  }
  function s(n2, i2) {
    void 0 === i2 && (i2 = {});
    var s2 = t(f(r(n2.states[n2.initial].entry).map((function(t2) {
      return o(t2, i2.actions);
    })), n2.context, e), 2), l2 = s2[0], v2 = s2[1], y = { config: n2, _options: i2, initialState: { value: n2.initial, actions: l2, context: v2, matches: a(n2.initial) }, transition: function(e2, i3) {
      var s3, l3, v3 = "string" == typeof e2 ? { value: e2, context: n2.context } : e2, p = v3.value, g2 = v3.context, d = u$1(i3), x = n2.states[p];
      if (x.on) {
        var m = r(x.on[d.type]);
        try {
          for (var h = (function(t2) {
            var n3 = "function" == typeof Symbol && Symbol.iterator, e3 = n3 && t2[n3], r2 = 0;
            if (e3) return e3.call(t2);
            if (t2 && "number" == typeof t2.length) return { next: function() {
              return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };
            } };
            throw new TypeError(n3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
          })(m), b = h.next(); !b.done; b = h.next()) {
            var S = b.value;
            if (void 0 === S) return c(p, g2);
            var w = "string" == typeof S ? { target: S } : S, j = w.target, E = w.actions, R = void 0 === E ? [] : E, N = w.cond, O = void 0 === N ? function() {
              return true;
            } : N, _ = void 0 === j, k = null != j ? j : p, T = n2.states[k];
            if (O(g2, d)) {
              var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter((function(t2) {
                return t2;
              }))).map((function(t2) {
                return o(t2, y._options.actions);
              })), g2, d), 3), z = q[0], A = q[1], B = q[2], C = null != j ? j : p;
              return { value: C, context: A, actions: z, changed: j !== p || z.length > 0 || B, matches: a(C) };
            }
          }
        } catch (t2) {
          s3 = { error: t2 };
        } finally {
          try {
            b && !b.done && (l3 = h.return) && l3.call(h);
          } finally {
            if (s3) throw s3.error;
          }
        }
      }
      return c(p, g2);
    } };
    return y;
  }
  var l$1 = function(t2, n2) {
    return t2.actions.forEach((function(e2) {
      var r2 = e2.exec;
      return r2 && r2(t2.context, n2);
    }));
  };
  function v(t2) {
    var r2 = t2.initialState, i2 = n.NotStarted, o2 = /* @__PURE__ */ new Set(), c2 = { _machine: t2, send: function(e2) {
      i2 === n.Running && (r2 = t2.transition(r2, e2), l$1(r2, u$1(e2)), o2.forEach((function(t3) {
        return t3(r2);
      })));
    }, subscribe: function(t3) {
      return o2.add(t3), t3(r2), { unsubscribe: function() {
        return o2.delete(t3);
      } };
    }, start: function(o3) {
      if (o3) {
        var u2 = "object" == typeof o3 ? o3 : { context: t2.config.context, value: o3 };
        r2 = { value: u2.value, actions: [], context: u2.context, matches: a(u2.value) };
      } else r2 = t2.initialState;
      return i2 = n.Running, l$1(r2, e), c2;
    }, stop: function() {
      return i2 = n.Stopped, o2.clear(), c2;
    }, get state() {
      return r2;
    }, get status() {
      return i2;
    } };
    return c2;
  }
  var index = React$1.useLayoutEffect;
  var withSelector = { exports: {} };
  var withSelector_development = {};
  var shim = { exports: {} };
  var useSyncExternalStoreShim_development = {};
  var hasRequiredUseSyncExternalStoreShim_development;
  function requireUseSyncExternalStoreShim_development() {
    if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
    hasRequiredUseSyncExternalStoreShim_development = 1;
    /**
     * @license React
     * use-sync-external-store-shim.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React2 = React$1;
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React2.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim2;
        useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
    return useSyncExternalStoreShim_development;
  }
  var hasRequiredShim;
  function requireShim() {
    if (hasRequiredShim) return shim.exports;
    hasRequiredShim = 1;
    {
      shim.exports = requireUseSyncExternalStoreShim_development();
    }
    return shim.exports;
  }
  var hasRequiredWithSelector_development;
  function requireWithSelector_development() {
    if (hasRequiredWithSelector_development) return withSelector_development;
    hasRequiredWithSelector_development = 1;
    /**
     * @license React
     * use-sync-external-store-shim/with-selector.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    {
      (function() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React2 = React$1;
        var shim2 = requireShim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim2.useSyncExternalStore;
        var useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
        function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
          var instRef = useRef(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual2 !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual2(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
    return withSelector_development;
  }
  var hasRequiredWithSelector;
  function requireWithSelector() {
    if (hasRequiredWithSelector) return withSelector.exports;
    hasRequiredWithSelector = 1;
    {
      withSelector.exports = requireWithSelector_development();
    }
    return withSelector.exports;
  }
  var withSelectorExports = requireWithSelector();
  function useConstant(fn) {
    var ref = React__namespace.useRef();
    if (!ref.current) {
      ref.current = { v: fn() };
    }
    return ref.current.v;
  }
  var __read = function(o2, n2) {
    var m = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m) return o2;
    var i2 = m.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m = i2["return"])) m.call(i2);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  };
  function identity(a2) {
    return a2;
  }
  var getServiceState = function(service) {
    var currentValue;
    service.subscribe(function(state) {
      currentValue = state;
    }).unsubscribe();
    return currentValue;
  };
  function useMachine(stateMachine, options) {
    var persistedStateRef = React$1.useRef();
    {
      var _a = __read(React$1.useState(stateMachine), 1), initialMachine = _a[0];
      if (stateMachine !== initialMachine) {
        console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
      }
    }
    var _b = __read(useConstant(function() {
      var queue2 = [];
      var service2 = v(s(stateMachine.config, options ? options : stateMachine._options));
      var send = service2.send;
      service2.send = function(event) {
        if (service2.status === n.NotStarted) {
          queue2.push(event);
          return;
        }
        send(event);
        persistedStateRef.current = service2.state;
      };
      return [service2, queue2];
    }), 2), service = _b[0], queue = _b[1];
    index(function() {
      if (options) {
        service._machine._options = options;
      }
    });
    var useServiceResult = useService(service);
    React$1.useEffect(function() {
      service.start(persistedStateRef.current);
      queue.forEach(service.send);
      persistedStateRef.current = service.state;
      return function() {
        service.stop();
      };
    }, []);
    return useServiceResult;
  }
  var isEqual = function(_prevState, nextState) {
    return nextState.changed === false;
  };
  function useService(service) {
    var getSnapshot = React$1.useCallback(function() {
      return getServiceState(service);
    }, [service]);
    var subscribe = React$1.useCallback(function(handleStoreChange) {
      var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
      return unsubscribe;
    }, [service]);
    var storeSnapshot = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getSnapshot, identity, isEqual);
    return [storeSnapshot, service.send, service];
  }
  function flattenConnection(connection) {
    if (!connection) {
      const noConnectionErr = `flattenConnection(): needs a 'connection' to flatten, but received '${connection ?? ""}' instead.`;
      {
        throw new Error(noConnectionErr);
      }
    }
    if ("nodes" in connection) {
      return connection.nodes;
    }
    if ("edges" in connection && Array.isArray(connection.edges)) {
      return connection.edges.map((edge) => {
        if (!(edge == null ? void 0 : edge.node)) {
          throw new Error(
            "flattenConnection(): Connection edges must contain nodes"
          );
        }
        return edge.node;
      });
    }
    {
      console.warn(
        `flattenConnection(): The connection did not contain either "nodes" or "edges.node". Returning an empty array.`
      );
    }
    return [];
  }
  const CartLineAdd = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartLineAdd(
    $cartId: ID!
    $lines: [CartLineInput!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartCreate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartCreate(
    $input: CartInput!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartCreate(input: $input) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartLineRemove = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartLineRemove(
    $cartId: ID!
    $lines: [ID!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesRemove(cartId: $cartId, lineIds: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartLineUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartLineUpdate(
    $cartId: ID!
    $lines: [CartLineUpdateInput!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesUpdate(cartId: $cartId, lines: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartNoteUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartNoteUpdate(
    $cartId: ID!
    $note: String!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartNoteUpdate(cartId: $cartId, note: $note) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartBuyerIdentityUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartBuyerIdentityUpdate(
    $cartId: ID!
    $buyerIdentity: CartBuyerIdentityInput!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartBuyerIdentityUpdate(cartId: $cartId, buyerIdentity: $buyerIdentity) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartAttributesUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartAttributesUpdate(
    $attributes: [AttributeInput!]!
    $cartId: ID!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartAttributesUpdate(attributes: $attributes, cartId: $cartId) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartDiscountCodesUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartDiscountCodesUpdate(
    $cartId: ID!
    $discountCodes: [String!]
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartDiscountCodesUpdate(cartId: $cartId, discountCodes: $discountCodes) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartQuery = (cartFragment) => (
    /* GraphQL */
    `
  query CartQuery(
    $id: ID!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cart(id: $id) {
      ...CartFragment
    }
  }

  ${cartFragment}
`
  );
  const defaultCartFragment = (
    /* GraphQL */
    `
  fragment CartFragment on Cart {
    id
    checkoutUrl
    totalQuantity
    buyerIdentity {
      countryCode
      customer {
        id
        email
        firstName
        lastName
        displayName
      }
      email
      phone
    }
    lines(first: $numCartLines) {
      edges {
        node {
          id
          quantity
          attributes {
            key
            value
          }
          cost {
            totalAmount {
              amount
              currencyCode
            }
            compareAtAmountPerQuantity {
              amount
              currencyCode
            }
          }
          merchandise {
            ... on ProductVariant {
              id
              availableForSale
              compareAtPrice {
                ...MoneyFragment
              }
              price {
                ...MoneyFragment
              }
              requiresShipping
              title
              image {
                ...ImageFragment
              }
              product {
                handle
                title
                id
              }
              selectedOptions {
                name
                value
              }
            }
          }
        }
      }
    }
    cost {
      subtotalAmount {
        ...MoneyFragment
      }
      totalAmount {
        ...MoneyFragment
      }
      totalDutyAmount {
        ...MoneyFragment
      }
      totalTaxAmount {
        ...MoneyFragment
      }
    }
    note
    attributes {
      key
      value
    }
    discountCodes {
      code
      applicable
    }
  }

  fragment MoneyFragment on MoneyV2 {
    currencyCode
    amount
  }
  fragment ImageFragment on Image {
    id
    url
    altText
    width
    height
  }
`
  );
  const SFAPI_VERSION = "2025-07";
  const MOCK_SHOP_DOMAIN = "mock.shop";
  const isMockShop = (domain) => domain.includes(MOCK_SHOP_DOMAIN);
  function createStorefrontClient({
    storeDomain,
    privateStorefrontToken,
    publicStorefrontToken,
    storefrontApiVersion = SFAPI_VERSION,
    contentType
  }) {
    if (!storeDomain) {
      {
        storeDomain = MOCK_SHOP_DOMAIN;
        warnOnce(
          `storeDomain missing, defaulting to ${MOCK_SHOP_DOMAIN}`,
          "info"
        );
      }
    }
    if (storefrontApiVersion !== SFAPI_VERSION) {
      warnOnce(
        `The Storefront API version that you're using is different than the version this build of Hydrogen React is targeting.
You may run into unexpected errors if these versions don't match. Received version: "${storefrontApiVersion}"; expected version "${SFAPI_VERSION}"`
      );
    }
    if (!privateStorefrontToken && !globalThis.document && !isMockShop(storeDomain)) {
      warnOnce(
        `Using a private storefront token is recommended for server environments.
Refer to the authentication https://shopify.dev/api/storefront#authentication documentation for more details.`
      );
    }
    if (privateStorefrontToken && globalThis.document) {
      warnOnce(
        "You are attempting to use a private token in an environment where it can be easily accessed by anyone.\nThis is a security risk; please use the public token and the `publicStorefrontToken` prop"
      );
    }
    const getShopifyDomain = (overrideProps) => {
      const domain = (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? storeDomain;
      return domain.includes("://") ? domain : `https://${domain}`;
    };
    return {
      getShopifyDomain,
      getStorefrontApiUrl(overrideProps) {
        const domain = getShopifyDomain(overrideProps);
        const apiUrl = domain + (domain.endsWith("/") ? "api" : "/api");
        if (isMockShop(domain)) return apiUrl;
        return `${apiUrl}/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? storefrontApiVersion}/graphql.json`;
      },
      getPrivateTokenHeaders(overrideProps) {
        if (!privateStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) && !isMockShop(storeDomain)) {
          throw new Error(
            H2_PREFIX_ERROR + "You did not pass in a `privateStorefrontToken` while using `createStorefrontClient()` or `getPrivateTokenHeaders()`"
          );
        }
        if (!(overrideProps == null ? void 0 : overrideProps.buyerIp)) {
          warnOnce(
            "It is recommended to pass in the `buyerIp` property which improves analytics and data in the admin."
          );
        }
        const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType;
        return {
          // default to json
          "content-type": finalContentType === "graphql" ? "application/graphql" : "application/json",
          "X-SDK-Variant": "hydrogen-react",
          "X-SDK-Variant-Source": "react",
          "X-SDK-Version": storefrontApiVersion,
          "Shopify-Storefront-Private-Token": (overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) ?? privateStorefrontToken ?? "",
          ...(overrideProps == null ? void 0 : overrideProps.buyerIp) ? { "Shopify-Storefront-Buyer-IP": overrideProps.buyerIp } : {}
        };
      },
      getPublicTokenHeaders(overrideProps) {
        if (!publicStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) && !isMockShop(storeDomain)) {
          throw new Error(
            H2_PREFIX_ERROR + "You did not pass in a `publicStorefrontToken` while using `createStorefrontClient()` or `getPublicTokenHeaders()`"
          );
        }
        const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType ?? "json";
        return getPublicTokenHeadersRaw(
          finalContentType,
          storefrontApiVersion,
          (overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) ?? publicStorefrontToken ?? ""
        );
      }
    };
  }
  function getPublicTokenHeadersRaw(contentType, storefrontApiVersion, accessToken) {
    return {
      // default to json
      "content-type": contentType === "graphql" ? "application/graphql" : "application/json",
      "X-SDK-Variant": "hydrogen-react",
      "X-SDK-Variant-Source": "react",
      "X-SDK-Version": storefrontApiVersion,
      "X-Shopify-Storefront-Access-Token": accessToken
    };
  }
  const warnings = /* @__PURE__ */ new Set();
  const H2_PREFIX_ERROR = "[h2:error:createStorefrontClient] ";
  const warnOnce = (string, type = "warn") => {
    if (!warnings.has(string)) {
      console[type](`[h2:${type}:createStorefrontClient] ` + string);
      warnings.add(string);
    }
  };
  const defaultShopifyContext = {
    storeDomain: "test",
    storefrontToken: "abc123",
    storefrontApiVersion: SFAPI_VERSION,
    countryIsoCode: "US",
    languageIsoCode: "EN",
    getStorefrontApiUrl() {
      return "";
    },
    getPublicTokenHeaders() {
      return {};
    },
    getShopifyDomain() {
      return "";
    }
  };
  const ShopifyContext = React$1.createContext(
    defaultShopifyContext
  );
  function ShopifyProvider({
    children,
    ...shopifyConfig
  }) {
    if (!shopifyConfig.countryIsoCode || !shopifyConfig.languageIsoCode || !shopifyConfig.storeDomain || !shopifyConfig.storefrontToken || !shopifyConfig.storefrontApiVersion) {
      throw new Error(
        `Please provide the necessary props to '<ShopifyProvider/>'`
      );
    }
    if (shopifyConfig.storefrontApiVersion !== SFAPI_VERSION) {
      console.warn(
        `<ShopifyProvider/>: This version of Hydrogen React is built for Shopify's Storefront API version ${SFAPI_VERSION}, but it looks like you're using version ${shopifyConfig.storefrontApiVersion}. There may be issues or bugs if you use a mismatched version of Hydrogen React and the Storefront API.`
      );
    }
    const finalConfig = React$1.useMemo(() => {
      function getShopifyDomain(overrideProps) {
        const domain = (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? shopifyConfig.storeDomain;
        return domain.includes("://") ? domain : `https://${domain}`;
      }
      return {
        ...shopifyConfig,
        getPublicTokenHeaders(overrideProps) {
          return getPublicTokenHeadersRaw(
            overrideProps.contentType,
            shopifyConfig.storefrontApiVersion,
            overrideProps.storefrontToken ?? shopifyConfig.storefrontToken
          );
        },
        getShopifyDomain,
        getStorefrontApiUrl(overrideProps) {
          const finalDomainUrl = getShopifyDomain({
            storeDomain: (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? shopifyConfig.storeDomain
          });
          return `${finalDomainUrl}${finalDomainUrl.endsWith("/") ? "" : "/"}api/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? shopifyConfig.storefrontApiVersion}/graphql.json`;
        }
      };
    }, [shopifyConfig]);
    return /* @__PURE__ */ React.createElement(ShopifyContext.Provider, { value: finalConfig }, children);
  }
  function useShop() {
    const shopContext = React$1.useContext(ShopifyContext);
    if (!shopContext) {
      throw new Error(`'useShop()' must be a descendent of <ShopifyProvider/>`);
    }
    return shopContext;
  }
  const CART_ID_STORAGE_KEY = "shopifyCartId";
  const SHOPIFY_STOREFRONT_ID_HEADER = "Shopify-Storefront-Id";
  const SHOPIFY_STOREFRONT_Y_HEADER = "Shopify-Storefront-Y";
  const SHOPIFY_STOREFRONT_S_HEADER = "Shopify-Storefront-S";
  const SHOPIFY_Y = "_shopify_y";
  const SHOPIFY_S = "_shopify_s";
  var g = /* @__PURE__ */ new Set([
    "domain",
    "path",
    "max-age",
    "expires",
    "samesite",
    "secure",
    "httponly"
  ]);
  function u(a2) {
    let r2 = {}, e2, t2, n2 = 0, m = a2.split(/;\s*/g), s2, i2;
    for (; n2 < m.length; n2++)
      if (t2 = m[n2], e2 = t2.indexOf("="), ~e2) {
        if (s2 = t2.substring(0, e2++).trim(), i2 = t2.substring(e2).trim(), i2[0] === '"' && (i2 = i2.substring(1, i2.length - 1)), ~i2.indexOf("%"))
          try {
            i2 = decodeURIComponent(i2);
          } catch (f2) {
          }
        g.has(t2 = s2.toLowerCase()) ? t2 === "expires" ? r2.expires = new Date(i2) : t2 === "max-age" ? r2.maxage = +i2 : r2[t2] = i2 : r2[s2] = i2;
      } else
        (s2 = t2.trim().toLowerCase()) && (s2 === "httponly" || s2 === "secure") && (r2[s2] = true);
    return r2;
  }
  function l(a2, r2, e2 = {}) {
    let t2 = a2 + "=" + encodeURIComponent(r2);
    return e2.expires && (t2 += "; Expires=" + new Date(e2.expires).toUTCString()), e2.maxage != null && e2.maxage >= 0 && (t2 += "; Max-Age=" + (e2.maxage | 0)), e2.domain && (t2 += "; Domain=" + e2.domain), e2.path && (t2 += "; Path=" + e2.path), e2.samesite && (t2 += "; SameSite=" + e2.samesite), (e2.secure || e2.samesite === "None") && (t2 += "; Secure"), e2.httponly && (t2 += "; HttpOnly"), t2;
  }
  const tokenHash = "xxxx-4xxx-xxxx-xxxxxxxxxxxx";
  function buildUUID() {
    let hash = "";
    try {
      const crypto = window.crypto;
      const randomValuesArray = new Uint16Array(31);
      crypto.getRandomValues(randomValuesArray);
      let i2 = 0;
      hash = tokenHash.replace(/[x]/g, (c2) => {
        const r2 = randomValuesArray[i2] % 16;
        const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
        i2++;
        return v2.toString(16);
      }).toUpperCase();
    } catch (err) {
      hash = tokenHash.replace(/[x]/g, (c2) => {
        const r2 = Math.random() * 16 | 0;
        const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
        return v2.toString(16);
      }).toUpperCase();
    }
    return `${hexTime()}-${hash}`;
  }
  function hexTime() {
    let dateNumber = 0;
    let perfNumber = 0;
    dateNumber = (/* @__PURE__ */ new Date()).getTime() >>> 0;
    try {
      perfNumber = performance.now() >>> 0;
    } catch (err) {
      perfNumber = 0;
    }
    const output = Math.abs(dateNumber + perfNumber).toString(16).toLowerCase();
    return output.padStart(8, "0");
  }
  function getShopifyCookies(cookies) {
    const cookieData = u(cookies);
    return {
      [SHOPIFY_Y]: cookieData[SHOPIFY_Y] || "",
      [SHOPIFY_S]: cookieData[SHOPIFY_S] || ""
    };
  }
  function useCartFetch() {
    const { storefrontId, getPublicTokenHeaders, getStorefrontApiUrl } = useShop();
    return React$1.useCallback(
      ({
        query,
        variables
      }) => {
        const headers = getPublicTokenHeaders({ contentType: "json" });
        if (storefrontId) {
          headers[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
        }
        const cookieData = getShopifyCookies(document.cookie);
        headers[SHOPIFY_STOREFRONT_Y_HEADER] = cookieData[SHOPIFY_Y];
        headers[SHOPIFY_STOREFRONT_S_HEADER] = cookieData[SHOPIFY_S];
        return fetch(getStorefrontApiUrl(), {
          method: "POST",
          headers,
          body: JSON.stringify({
            query: query.toString(),
            variables
          })
        }).then(
          (res) => res.json()
        ).catch((error) => {
          return {
            data: void 0,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            errors: error == null ? void 0 : error.toString()
          };
        });
      },
      [getPublicTokenHeaders, storefrontId, getStorefrontApiUrl]
    );
  }
  function useCartActions({
    numCartLines,
    cartFragment,
    countryCode = "US",
    languageCode = "EN"
  }) {
    const fetchCart = useCartFetch();
    const cartFetch = React$1.useCallback(
      (cartId) => {
        return fetchCart({
          query: CartQuery(cartFragment),
          variables: {
            id: cartId,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [fetchCart, cartFragment, numCartLines, countryCode, languageCode]
    );
    const cartCreate = React$1.useCallback(
      (cart) => {
        return fetchCart({
          query: CartCreate(cartFragment),
          variables: {
            input: cart,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    const cartLineAdd = React$1.useCallback(
      (cartId, lines) => {
        return fetchCart({
          query: CartLineAdd(cartFragment),
          variables: {
            cartId,
            lines,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    const cartLineUpdate = React$1.useCallback(
      (cartId, lines) => {
        return fetchCart({
          query: CartLineUpdate(cartFragment),
          variables: {
            cartId,
            lines,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    const cartLineRemove = React$1.useCallback(
      (cartId, lines) => {
        return fetchCart({
          query: CartLineRemove(cartFragment),
          variables: {
            cartId,
            lines,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    const noteUpdate = React$1.useCallback(
      (cartId, note) => {
        return fetchCart({
          query: CartNoteUpdate(cartFragment),
          variables: {
            cartId,
            note,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [fetchCart, cartFragment, numCartLines, countryCode, languageCode]
    );
    const buyerIdentityUpdate = React$1.useCallback(
      (cartId, buyerIdentity) => {
        return fetchCart({
          query: CartBuyerIdentityUpdate(cartFragment),
          variables: {
            cartId,
            buyerIdentity,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    const cartAttributesUpdate = React$1.useCallback(
      (cartId, attributes) => {
        return fetchCart({
          query: CartAttributesUpdate(cartFragment),
          variables: {
            cartId,
            attributes,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    const discountCodesUpdate = React$1.useCallback(
      (cartId, discountCodes) => {
        return fetchCart({
          query: CartDiscountCodesUpdate(cartFragment),
          variables: {
            cartId,
            discountCodes,
            numCartLines,
            country: countryCode,
            language: languageCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
    );
    return React$1.useMemo(
      () => ({
        cartFetch,
        cartCreate,
        cartLineAdd,
        cartLineUpdate,
        cartLineRemove,
        noteUpdate,
        buyerIdentityUpdate,
        cartAttributesUpdate,
        discountCodesUpdate,
        cartFragment
      }),
      [
        cartFetch,
        cartCreate,
        cartLineAdd,
        cartLineUpdate,
        cartLineRemove,
        noteUpdate,
        buyerIdentityUpdate,
        cartAttributesUpdate,
        discountCodesUpdate,
        cartFragment
      ]
    );
  }
  function invokeCart(action, options) {
    return {
      entry: [
        ...(options == null ? void 0 : options.entryActions) || [],
        i({
          lastValidCart: (context) => context == null ? void 0 : context.cart
        }),
        "onCartActionEntry",
        "onCartActionOptimisticUI",
        action
      ],
      on: {
        RESOLVE: {
          target: (options == null ? void 0 : options.resolveTarget) || "idle",
          actions: [
            i({
              prevCart: (context) => context == null ? void 0 : context.lastValidCart,
              cart: (_, event) => {
                var _a;
                return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.cart;
              },
              rawCartResult: (_, event) => {
                var _a;
                return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.rawCartResult;
              },
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              errors: (_) => void 0
            })
          ]
        },
        ERROR: {
          target: (options == null ? void 0 : options.errorTarget) || "error",
          actions: [
            i({
              prevCart: (context) => context == null ? void 0 : context.lastValidCart,
              cart: (context) => context == null ? void 0 : context.lastValidCart,
              errors: (_, event) => {
                var _a;
                return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.errors;
              }
            })
          ]
        },
        CART_COMPLETED: {
          target: "cartCompleted",
          actions: i({
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            prevCart: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            cart: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            lastValidCart: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            rawCartResult: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            errors: (_) => void 0
          })
        }
      },
      exit: ["onCartActionComplete", ...(options == null ? void 0 : options.exitActions) || []]
    };
  }
  const INITIALIZING_CART_EVENTS = {
    CART_FETCH: {
      target: "cartFetching"
    },
    CART_CREATE: {
      target: "cartCreating"
    },
    CART_SET: {
      target: "idle",
      actions: [
        i({
          rawCartResult: (_, event) => event.payload.cart,
          cart: (_, event) => cartFromGraphQL(event.payload.cart)
        })
      ]
    }
  };
  const UPDATING_CART_EVENTS = {
    CARTLINE_ADD: {
      target: "cartLineAdding"
    },
    CARTLINE_UPDATE: {
      target: "cartLineUpdating"
    },
    CARTLINE_REMOVE: {
      target: "cartLineRemoving"
    },
    NOTE_UPDATE: {
      target: "noteUpdating"
    },
    BUYER_IDENTITY_UPDATE: {
      target: "buyerIdentityUpdating"
    },
    CART_ATTRIBUTES_UPDATE: {
      target: "cartAttributesUpdating"
    },
    DISCOUNT_CODES_UPDATE: {
      target: "discountCodesUpdating"
    }
  };
  function createCartMachine(initialCart) {
    return s({
      id: "Cart",
      initial: initialCart ? "idle" : "uninitialized",
      context: {
        cart: initialCart && cartFromGraphQL(initialCart)
      },
      states: {
        uninitialized: {
          on: INITIALIZING_CART_EVENTS
        },
        cartCompleted: {
          on: INITIALIZING_CART_EVENTS
        },
        initializationError: {
          on: INITIALIZING_CART_EVENTS
        },
        idle: {
          on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS }
        },
        error: {
          on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS }
        },
        cartFetching: invokeCart("cartFetchAction", {
          errorTarget: "initializationError"
        }),
        cartCreating: invokeCart("cartCreateAction", {
          errorTarget: "initializationError"
        }),
        cartLineRemoving: invokeCart("cartLineRemoveAction"),
        cartLineUpdating: invokeCart("cartLineUpdateAction"),
        cartLineAdding: invokeCart("cartLineAddAction"),
        noteUpdating: invokeCart("noteUpdateAction"),
        buyerIdentityUpdating: invokeCart("buyerIdentityUpdateAction"),
        cartAttributesUpdating: invokeCart("cartAttributesUpdateAction"),
        discountCodesUpdating: invokeCart("discountCodesUpdateAction")
      }
    });
  }
  function useCartAPIStateMachine({
    numCartLines,
    onCartActionEntry,
    onCartActionOptimisticUI,
    onCartActionComplete,
    data: cart,
    cartFragment,
    countryCode,
    languageCode
  }) {
    const {
      cartFetch,
      cartCreate,
      cartLineAdd,
      cartLineUpdate,
      cartLineRemove,
      noteUpdate,
      buyerIdentityUpdate,
      cartAttributesUpdate,
      discountCodesUpdate
    } = useCartActions({
      numCartLines,
      cartFragment,
      countryCode,
      languageCode
    });
    const cartMachine = React$1.useMemo(() => createCartMachine(cart), [cart]);
    const [state, send, service] = useMachine(cartMachine, {
      actions: {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartFetchAction: async (_, event) => {
          var _a;
          if (event.type !== "CART_FETCH") return;
          const { data, errors } = await cartFetch((_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.cartId);
          const resultEvent = eventFromFetchResult(event, data == null ? void 0 : data.cart, errors);
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartCreateAction: async (_, event) => {
          var _a;
          if (event.type !== "CART_CREATE") return;
          const { data, errors } = await cartCreate(event == null ? void 0 : event.payload);
          const resultEvent = eventFromFetchResult(
            event,
            (_a = data == null ? void 0 : data.cartCreate) == null ? void 0 : _a.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartLineAddAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CARTLINE_ADD" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
          const { data, errors } = await cartLineAdd(
            context.cart.id,
            event.payload.lines
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartLinesAdd) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartLineUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CARTLINE_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
          const { data, errors } = await cartLineUpdate(
            context.cart.id,
            event.payload.lines
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartLinesUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartLineRemoveAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CARTLINE_REMOVE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
          const { data, errors } = await cartLineRemove(
            context.cart.id,
            event.payload.lines
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartLinesRemove) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        noteUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "NOTE_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
          const { data, errors } = await noteUpdate(
            context.cart.id,
            event.payload.note
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartNoteUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        buyerIdentityUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "BUYER_IDENTITY_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await buyerIdentityUpdate(
            context.cart.id,
            event.payload.buyerIdentity
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartBuyerIdentityUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartAttributesUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CART_ATTRIBUTES_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await cartAttributesUpdate(
            context.cart.id,
            event.payload.attributes
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartAttributesUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        discountCodesUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "DISCOUNT_CODES_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await discountCodesUpdate(
            context.cart.id,
            event.payload.discountCodes
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartDiscountCodesUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        ...onCartActionEntry && {
          onCartActionEntry: (context, event) => {
            if (isCartActionEvent(event)) {
              onCartActionEntry(context, event);
            }
          }
        },
        ...onCartActionOptimisticUI && {
          onCartActionOptimisticUI: i((context, event) => {
            return onCartActionOptimisticUI(context, event);
          })
        },
        ...onCartActionComplete && {
          onCartActionComplete: (context, event) => {
            if (isCartFetchResultEvent(event)) {
              onCartActionComplete(context, event);
            }
          }
        }
      }
    });
    return React$1.useMemo(() => [state, send, service], [state, send, service]);
  }
  function cartFromGraphQL(cart) {
    return {
      ...cart,
      lines: flattenConnection(cart == null ? void 0 : cart.lines),
      note: cart.note ?? void 0
    };
  }
  function eventFromFetchResult(cartActionEvent, cart, errors) {
    if (errors) {
      return { type: "ERROR", payload: { errors, cartActionEvent } };
    }
    if (!cart) {
      return {
        type: "CART_COMPLETED",
        payload: {
          cartActionEvent
        }
      };
    }
    return {
      type: "RESOLVE",
      payload: {
        cart: cartFromGraphQL(cart),
        rawCartResult: cart,
        cartActionEvent
      }
    };
  }
  function isCartActionEvent(event) {
    return event.type === "CART_CREATE" || event.type === "CARTLINE_ADD" || event.type === "CARTLINE_UPDATE" || event.type === "CARTLINE_REMOVE" || event.type === "NOTE_UPDATE" || event.type === "BUYER_IDENTITY_UPDATE" || event.type === "CART_ATTRIBUTES_UPDATE" || event.type === "DISCOUNT_CODES_UPDATE";
  }
  function isCartFetchResultEvent(event) {
    return event.type === "RESOLVE" || event.type === "ERROR" || event.type === "CART_COMPLETED";
  }
  const CartContext = React$1.createContext(null);
  function useCart() {
    const context = React$1.useContext(CartContext);
    if (!context) {
      throw new Error("Expected a Cart Context, but no Cart Context was found");
    }
    return context;
  }
  function CartProvider({
    children,
    numCartLines,
    onCreate,
    onLineAdd,
    onLineRemove,
    onLineUpdate,
    onNoteUpdate,
    onBuyerIdentityUpdate,
    onAttributesUpdate,
    onDiscountCodesUpdate,
    onCreateComplete,
    onLineAddComplete,
    onLineRemoveComplete,
    onLineUpdateComplete,
    onNoteUpdateComplete,
    onBuyerIdentityUpdateComplete,
    onAttributesUpdateComplete,
    onDiscountCodesUpdateComplete,
    data: cart,
    cartFragment = defaultCartFragment,
    customerAccessToken,
    countryCode,
    languageCode
  }) {
    var _a, _b, _c, _d, _e, _f, _g;
    const shop = useShop();
    if (!shop)
      throw new Error(
        "<CartProvider> needs to be a descendant of <ShopifyProvider>"
      );
    countryCode = (countryCode ?? shop.countryIsoCode ?? "US").toUpperCase();
    languageCode = (languageCode ?? shop.languageIsoCode ?? "EN").toUpperCase();
    if (countryCode) countryCode = countryCode.toUpperCase();
    const [prevCountryCode, setPrevCountryCode] = React$1.useState(countryCode);
    const [prevCustomerAccessToken, setPrevCustomerAccessToken] = React$1.useState(customerAccessToken);
    const customerOverridesCountryCode = React$1.useRef(false);
    if (prevCountryCode !== countryCode || prevCustomerAccessToken !== customerAccessToken) {
      setPrevCountryCode(countryCode);
      setPrevCustomerAccessToken(customerAccessToken);
      customerOverridesCountryCode.current = false;
    }
    const [cartState, cartSend] = useCartAPIStateMachine({
      numCartLines,
      data: cart,
      cartFragment,
      countryCode,
      languageCode,
      onCartActionEntry(_, event) {
        try {
          switch (event.type) {
            case "CART_CREATE":
              return onCreate == null ? void 0 : onCreate();
            case "CARTLINE_ADD":
              return onLineAdd == null ? void 0 : onLineAdd();
            case "CARTLINE_REMOVE":
              return onLineRemove == null ? void 0 : onLineRemove();
            case "CARTLINE_UPDATE":
              return onLineUpdate == null ? void 0 : onLineUpdate();
            case "NOTE_UPDATE":
              return onNoteUpdate == null ? void 0 : onNoteUpdate();
            case "BUYER_IDENTITY_UPDATE":
              return onBuyerIdentityUpdate == null ? void 0 : onBuyerIdentityUpdate();
            case "CART_ATTRIBUTES_UPDATE":
              return onAttributesUpdate == null ? void 0 : onAttributesUpdate();
            case "DISCOUNT_CODES_UPDATE":
              return onDiscountCodesUpdate == null ? void 0 : onDiscountCodesUpdate();
          }
        } catch (error) {
          console.error("Cart entry action failed", error);
        }
      },
      onCartActionOptimisticUI(context, event) {
        var _a2, _b2, _c2, _d2;
        if (!context.cart) return { ...context };
        switch (event.type) {
          case "CARTLINE_REMOVE":
            return {
              ...context,
              cart: {
                ...context.cart,
                lines: (_b2 = (_a2 = context == null ? void 0 : context.cart) == null ? void 0 : _a2.lines) == null ? void 0 : _b2.filter(
                  (line) => (line == null ? void 0 : line.id) && !event.payload.lines.includes(line == null ? void 0 : line.id)
                )
              }
            };
          case "CARTLINE_UPDATE":
            return {
              ...context,
              cart: {
                ...context.cart,
                lines: (_d2 = (_c2 = context == null ? void 0 : context.cart) == null ? void 0 : _c2.lines) == null ? void 0 : _d2.map((line) => {
                  const updatedLine = event.payload.lines.find(
                    ({ id }) => id === (line == null ? void 0 : line.id)
                  );
                  if (updatedLine && updatedLine.quantity) {
                    return {
                      ...line,
                      quantity: updatedLine.quantity
                    };
                  }
                  return line;
                })
              }
            };
        }
        return { ...context };
      },
      onCartActionComplete(context, event) {
        const cartActionEvent = event.payload.cartActionEvent;
        try {
          switch (event.type) {
            case "RESOLVE":
              switch (cartActionEvent.type) {
                case "CART_CREATE":
                  return onCreateComplete == null ? void 0 : onCreateComplete();
                case "CARTLINE_ADD":
                  return onLineAddComplete == null ? void 0 : onLineAddComplete();
                case "CARTLINE_REMOVE":
                  return onLineRemoveComplete == null ? void 0 : onLineRemoveComplete();
                case "CARTLINE_UPDATE":
                  return onLineUpdateComplete == null ? void 0 : onLineUpdateComplete();
                case "NOTE_UPDATE":
                  return onNoteUpdateComplete == null ? void 0 : onNoteUpdateComplete();
                case "BUYER_IDENTITY_UPDATE":
                  if (countryCodeNotUpdated(context, cartActionEvent)) {
                    customerOverridesCountryCode.current = true;
                  }
                  return onBuyerIdentityUpdateComplete == null ? void 0 : onBuyerIdentityUpdateComplete();
                case "CART_ATTRIBUTES_UPDATE":
                  return onAttributesUpdateComplete == null ? void 0 : onAttributesUpdateComplete();
                case "DISCOUNT_CODES_UPDATE":
                  return onDiscountCodesUpdateComplete == null ? void 0 : onDiscountCodesUpdateComplete();
              }
          }
        } catch (error) {
          console.error("onCartActionComplete failed", error);
        }
      }
    });
    const cartReady = React$1.useRef(false);
    const [isCartReady, setIsCartReady] = React$1.useState(false);
    const cartCompleted = cartState.matches("cartCompleted");
    const countryChanged = (cartState.value === "idle" || cartState.value === "error" || cartState.value === "cartCompleted") && countryCode !== ((_c = (_b = (_a = cartState == null ? void 0 : cartState.context) == null ? void 0 : _a.cart) == null ? void 0 : _b.buyerIdentity) == null ? void 0 : _c.countryCode) && !cartState.context.errors;
    const fetchingFromStorage = React$1.useRef(false);
    React$1.useEffect(() => {
      if (!cartReady.current && !fetchingFromStorage.current) {
        if (!cart && storageAvailable("localStorage")) {
          fetchingFromStorage.current = true;
          try {
            const cartId = window.localStorage.getItem(CART_ID_STORAGE_KEY);
            if (cartId) {
              cartSend({ type: "CART_FETCH", payload: { cartId } });
            }
          } catch (error) {
            console.warn("error fetching cartId");
            console.warn(error);
          }
        }
        cartReady.current = true;
        setIsCartReady(true);
      }
    }, [cart, cartReady, cartSend]);
    React$1.useEffect(() => {
      if (!countryChanged || customerOverridesCountryCode.current) return;
      cartSend({
        type: "BUYER_IDENTITY_UPDATE",
        payload: { buyerIdentity: { countryCode, customerAccessToken } }
      });
    }, [
      countryCode,
      customerAccessToken,
      countryChanged,
      customerOverridesCountryCode,
      cartSend
    ]);
    const onCartReadySend = React$1.useCallback(
      (cartEvent) => {
        if (!cartReady.current) {
          return console.warn("Cart isn't ready yet");
        }
        cartSend(cartEvent);
      },
      [cartSend]
    );
    React$1.useEffect(() => {
      var _a2, _b2, _c2;
      if (((_b2 = (_a2 = cartState == null ? void 0 : cartState.context) == null ? void 0 : _a2.cart) == null ? void 0 : _b2.id) && storageAvailable("localStorage")) {
        try {
          window.localStorage.setItem(
            CART_ID_STORAGE_KEY,
            (_c2 = cartState.context.cart) == null ? void 0 : _c2.id
          );
        } catch (error) {
          console.warn("Failed to save cartId to localStorage", error);
        }
      }
    }, [(_e = (_d = cartState == null ? void 0 : cartState.context) == null ? void 0 : _d.cart) == null ? void 0 : _e.id]);
    React$1.useEffect(() => {
      if (cartCompleted && storageAvailable("localStorage")) {
        try {
          window.localStorage.removeItem(CART_ID_STORAGE_KEY);
        } catch (error) {
          console.warn("Failed to delete cartId from localStorage", error);
        }
      }
    }, [cartCompleted]);
    const cartCreate = React$1.useCallback(
      (cartInput) => {
        var _a2, _b2;
        if (countryCode && !((_a2 = cartInput.buyerIdentity) == null ? void 0 : _a2.countryCode)) {
          if (cartInput.buyerIdentity == null) {
            cartInput.buyerIdentity = {};
          }
          cartInput.buyerIdentity.countryCode = countryCode;
        }
        if (customerAccessToken && !((_b2 = cartInput.buyerIdentity) == null ? void 0 : _b2.customerAccessToken)) {
          if (cartInput.buyerIdentity == null) {
            cartInput.buyerIdentity = {};
          }
          cartInput.buyerIdentity.customerAccessToken = customerAccessToken;
        }
        onCartReadySend({
          type: "CART_CREATE",
          payload: cartInput
        });
      },
      [countryCode, customerAccessToken, onCartReadySend]
    );
    const cartDisplayState = useDelayedStateUntilHydration(cartState);
    const cartContextValue = React$1.useMemo(() => {
      var _a2, _b2, _c2, _d2;
      return {
        ...((_a2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _a2.cart) ?? { lines: [], attributes: [] },
        status: transposeStatus(cartDisplayState.value),
        error: (_b2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _b2.errors,
        totalQuantity: ((_d2 = (_c2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _c2.cart) == null ? void 0 : _d2.totalQuantity) ?? 0,
        cartCreate,
        cartReady: isCartReady,
        linesAdd(lines) {
          var _a3, _b3;
          if ((_b3 = (_a3 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _a3.cart) == null ? void 0 : _b3.id) {
            onCartReadySend({
              type: "CARTLINE_ADD",
              payload: { lines }
            });
          } else {
            cartCreate({ lines });
          }
        },
        linesRemove(lines) {
          onCartReadySend({
            type: "CARTLINE_REMOVE",
            payload: {
              lines
            }
          });
        },
        linesUpdate(lines) {
          onCartReadySend({
            type: "CARTLINE_UPDATE",
            payload: {
              lines
            }
          });
        },
        noteUpdate(note) {
          onCartReadySend({
            type: "NOTE_UPDATE",
            payload: {
              note
            }
          });
        },
        buyerIdentityUpdate(buyerIdentity) {
          onCartReadySend({
            type: "BUYER_IDENTITY_UPDATE",
            payload: {
              buyerIdentity
            }
          });
        },
        cartAttributesUpdate(attributes) {
          onCartReadySend({
            type: "CART_ATTRIBUTES_UPDATE",
            payload: {
              attributes
            }
          });
        },
        discountCodesUpdate(discountCodes) {
          onCartReadySend({
            type: "DISCOUNT_CODES_UPDATE",
            payload: {
              discountCodes
            }
          });
        },
        cartFragment
      };
    }, [
      cartCreate,
      isCartReady,
      (_f = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _f.cart,
      (_g = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _g.errors,
      cartDisplayState.value,
      cartFragment,
      onCartReadySend
    ]);
    return /* @__PURE__ */ React.createElement(CartContext.Provider, { value: cartContextValue }, children);
  }
  function transposeStatus(status) {
    switch (status) {
      case "uninitialized":
      case "initializationError":
        return "uninitialized";
      case "idle":
      case "cartCompleted":
      case "error":
        return "idle";
      case "cartFetching":
        return "fetching";
      case "cartCreating":
        return "creating";
      case "cartLineAdding":
      case "cartLineRemoving":
      case "cartLineUpdating":
      case "noteUpdating":
      case "buyerIdentityUpdating":
      case "cartAttributesUpdating":
      case "discountCodesUpdating":
        return "updating";
    }
  }
  function useDelayedStateUntilHydration(state) {
    const [isPending, startTransition] = React$1.useTransition();
    const [delayedState, setDelayedState] = React$1.useState(state);
    const firstTimePending = React$1.useRef(false);
    if (isPending) {
      firstTimePending.current = true;
    }
    const firstTimePendingFinished = React$1.useRef(false);
    if (!isPending && firstTimePending.current) {
      firstTimePendingFinished.current = true;
    }
    React$1.useEffect(() => {
      startTransition(() => {
        if (!firstTimePendingFinished.current) {
          setDelayedState(state);
        }
      });
    }, [state]);
    const displayState = firstTimePendingFinished.current ? state : delayedState;
    return displayState;
  }
  function storageAvailable(type) {
    let storage;
    try {
      storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e2) {
      return !!(e2 instanceof DOMException && // everything except Firefox
      (e2.code === 22 || // Firefox
      e2.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e2.name === "QuotaExceededError" || // Firefox
      e2.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage && storage.length !== 0);
    }
  }
  function countryCodeNotUpdated(context, event) {
    var _a, _b;
    return !!(event.payload.buyerIdentity.countryCode && ((_b = (_a = context.cart) == null ? void 0 : _a.buyerIdentity) == null ? void 0 : _b.countryCode) !== event.payload.buyerIdentity.countryCode);
  }
  const ProductOptionsContext = React$1.createContext(null);
  function ProductProvider({
    children,
    data: product,
    initialVariantId: explicitVariantId
  }) {
    const variants = React$1.useMemo(
      () => flattenConnection(product.variants ?? {}),
      [product.variants]
    );
    if (!isProductVariantArray(variants)) {
      throw new Error(
        `<ProductProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`
      );
    }
    const options = React$1.useMemo(() => getOptions(variants), [variants]);
    const [selectedVariant, setSelectedVariant] = React$1.useState(() => getVariantBasedOnIdProp(explicitVariantId, variants));
    const [selectedOptions, setSelectedOptions] = React$1.useState(
      () => getSelectedOptions(selectedVariant)
    );
    React$1.useEffect(() => {
      const newSelectedVariant = getVariantBasedOnIdProp(
        explicitVariantId,
        variants
      );
      setSelectedVariant(newSelectedVariant);
      setSelectedOptions(getSelectedOptions(newSelectedVariant));
    }, [explicitVariantId, variants]);
    const setSelectedOption = React$1.useCallback(
      (name, value2) => {
        setSelectedOptions((selectedOptions2) => {
          const opts = { ...selectedOptions2, [name]: value2 };
          setSelectedVariant(getSelectedVariant(variants, opts));
          return opts;
        });
      },
      [setSelectedOptions, variants]
    );
    const isOptionInStock = React$1.useCallback(
      (option, value2) => {
        const proposedVariant = getSelectedVariant(variants, {
          ...selectedOptions,
          ...{ [option]: value2 }
        });
        return (proposedVariant == null ? void 0 : proposedVariant.availableForSale) ?? true;
      },
      [selectedOptions, variants]
    );
    const sellingPlanGroups = React$1.useMemo(
      () => flattenConnection(product.sellingPlanGroups ?? {}).map(
        (sellingPlanGroup) => ({
          ...sellingPlanGroup,
          sellingPlans: flattenConnection((sellingPlanGroup == null ? void 0 : sellingPlanGroup.sellingPlans) ?? {})
        })
      ),
      [product.sellingPlanGroups]
    );
    const [selectedSellingPlan, setSelectedSellingPlan] = React$1.useState(void 0);
    const selectedSellingPlanAllocation = React$1.useMemo(() => {
      var _a, _b;
      if (!selectedVariant || !selectedSellingPlan) {
        return;
      }
      if (!((_a = selectedVariant.sellingPlanAllocations) == null ? void 0 : _a.nodes) && !((_b = selectedVariant.sellingPlanAllocations) == null ? void 0 : _b.edges)) {
        throw new Error(
          `<ProductProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`
        );
      }
      return flattenConnection(selectedVariant.sellingPlanAllocations).find(
        (allocation) => {
          var _a2;
          return ((_a2 = allocation == null ? void 0 : allocation.sellingPlan) == null ? void 0 : _a2.id) === selectedSellingPlan.id;
        }
      );
    }, [selectedVariant, selectedSellingPlan]);
    const value = React$1.useMemo(
      () => ({
        product,
        variants,
        variantsConnection: product.variants,
        options,
        selectedVariant,
        setSelectedVariant,
        selectedOptions,
        setSelectedOption,
        setSelectedOptions,
        isOptionInStock,
        selectedSellingPlan,
        setSelectedSellingPlan,
        selectedSellingPlanAllocation,
        sellingPlanGroups,
        sellingPlanGroupsConnection: product.sellingPlanGroups
      }),
      [
        product,
        isOptionInStock,
        options,
        selectedOptions,
        selectedSellingPlan,
        selectedSellingPlanAllocation,
        selectedVariant,
        sellingPlanGroups,
        setSelectedOption,
        variants
      ]
    );
    return /* @__PURE__ */ React.createElement(ProductOptionsContext.Provider, { value }, children);
  }
  function useProduct() {
    const context = React$1.useContext(ProductOptionsContext);
    if (!context) {
      throw new Error(`'useProduct' must be a child of <ProductProvider />`);
    }
    return context;
  }
  function getSelectedVariant(variants, choices) {
    var _a, _b;
    if (!variants.length || ((_b = (_a = variants == null ? void 0 : variants[0]) == null ? void 0 : _a.selectedOptions) == null ? void 0 : _b.length) !== Object.keys(choices).length) {
      return;
    }
    return variants == null ? void 0 : variants.find((variant) => {
      return Object.entries(choices).every(([name, value]) => {
        var _a2;
        return (_a2 = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a2.some(
          (option) => (option == null ? void 0 : option.name) === name && (option == null ? void 0 : option.value) === value
        );
      });
    });
  }
  function getOptions(variants) {
    const map = variants.reduce(
      (memo, variant) => {
        var _a;
        if (!variant.selectedOptions) {
          throw new Error(`'getOptions' requires 'variant.selectedOptions'`);
        }
        (_a = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a.forEach((opt) => {
          memo[(opt == null ? void 0 : opt.name) ?? ""] = memo[(opt == null ? void 0 : opt.name) ?? ""] || /* @__PURE__ */ new Set();
          memo[(opt == null ? void 0 : opt.name) ?? ""].add((opt == null ? void 0 : opt.value) ?? "");
        });
        return memo;
      },
      {}
    );
    return Object.keys(map).map((option) => {
      return {
        name: option,
        values: Array.from(map[option])
      };
    });
  }
  function getVariantBasedOnIdProp(explicitVariantId, variants) {
    if (explicitVariantId) {
      const foundVariant = variants.find(
        (variant) => (variant == null ? void 0 : variant.id) === explicitVariantId
      );
      if (!foundVariant) {
        console.warn(
          `<ProductProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`
        );
      }
      return foundVariant;
    }
    if (explicitVariantId === null) {
      return null;
    }
    if (explicitVariantId === void 0) {
      return variants.find((variant) => variant == null ? void 0 : variant.availableForSale) || variants[0];
    }
  }
  function getSelectedOptions(selectedVariant) {
    return (selectedVariant == null ? void 0 : selectedVariant.selectedOptions) ? selectedVariant.selectedOptions.reduce(
      (memo, optionSet) => {
        memo[(optionSet == null ? void 0 : optionSet.name) ?? ""] = (optionSet == null ? void 0 : optionSet.value) ?? "";
        return memo;
      },
      {}
    ) : {};
  }
  function isProductVariantArray(maybeVariantArray) {
    if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {
      return false;
    }
    return true;
  }
  function BaseButton(props) {
    const {
      as,
      onClick,
      defaultOnClick,
      children,
      buttonRef,
      ...passthroughProps
    } = props;
    const handleOnClick = React$1.useCallback(
      (event) => {
        if (onClick) {
          const clickShouldContinue = onClick(event);
          if (typeof clickShouldContinue === "boolean" && clickShouldContinue === false || (event == null ? void 0 : event.defaultPrevented))
            return;
        }
        defaultOnClick == null ? void 0 : defaultOnClick(event);
      },
      [defaultOnClick, onClick]
    );
    const Component = as || "button";
    return /* @__PURE__ */ React.createElement(Component, { ref: buttonRef, onClick: handleOnClick, ...passthroughProps }, children);
  }
  function AddToCartButton(props) {
    const [addingItem, setAddingItem] = React$1.useState(false);
    const {
      variantId: explicitVariantId,
      quantity = 1,
      attributes,
      sellingPlanId,
      onClick,
      children,
      accessibleAddingToCartLabel,
      ...passthroughProps
    } = props;
    const { status, linesAdd } = useCart();
    const { selectedVariant } = useProduct();
    const variantId = explicitVariantId ?? (selectedVariant == null ? void 0 : selectedVariant.id) ?? "";
    const disabled = explicitVariantId === null || variantId === "" || selectedVariant === null || addingItem || // Only certain 'as' types such as 'button' contain `disabled`
    passthroughProps.disabled;
    React$1.useEffect(() => {
      if (addingItem && status === "idle") {
        setAddingItem(false);
      }
    }, [status, addingItem]);
    const handleAddItem = React$1.useCallback(() => {
      setAddingItem(true);
      linesAdd([
        {
          quantity,
          merchandiseId: variantId || "",
          attributes,
          sellingPlanId
        }
      ]);
    }, [linesAdd, quantity, variantId, attributes, sellingPlanId]);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(
      BaseButton,
      {
        ...passthroughProps,
        disabled,
        onClick,
        defaultOnClick: handleAddItem
      },
      children
    ), accessibleAddingToCartLabel ? /* @__PURE__ */ React__namespace.createElement(
      "p",
      {
        style: {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        role: "alert",
        "aria-live": "assertive"
      },
      addingItem ? accessibleAddingToCartLabel : null
    ) : null);
  }
  const AnalyticsEventName = {
    PAGE_VIEW: "PAGE_VIEW",
    ADD_TO_CART: "ADD_TO_CART",
    PAGE_VIEW_2: "PAGE_VIEW_2",
    COLLECTION_VIEW: "COLLECTION_VIEW",
    PRODUCT_VIEW: "PRODUCT_VIEW",
    SEARCH_VIEW: "SEARCH_VIEW"
  };
  const AnalyticsPageType = {
    article: "article",
    blog: "blog",
    captcha: "captcha",
    cart: "cart",
    collection: "collection",
    customersAccount: "customers/account",
    customersActivateAccount: "customers/activate_account",
    customersAddresses: "customers/addresses",
    customersLogin: "customers/login",
    customersOrder: "customers/order",
    customersRegister: "customers/register",
    customersResetPassword: "customers/reset_password",
    giftCard: "gift_card",
    home: "index",
    listCollections: "list-collections",
    forbidden: "403",
    notFound: "404",
    page: "page",
    password: "password",
    product: "product",
    policy: "policy",
    search: "search"
  };
  const ShopifySalesChannel = {
    hydrogen: "hydrogen",
    headless: "headless"
  };
  const ShopifyAppId = {
    hydrogen: "6167201",
    headless: "12875497473"
  };
  function schemaWrapper(schemaId, payload) {
    return {
      schema_id: schemaId,
      payload,
      metadata: {
        event_created_at_ms: Date.now()
      }
    };
  }
  function parseGid(gid) {
    const defaultReturn = {
      id: "",
      resource: null,
      resourceId: null,
      search: "",
      searchParams: new URLSearchParams(),
      hash: ""
    };
    if (typeof gid !== "string") {
      return defaultReturn;
    }
    try {
      const { search, searchParams, pathname, hash } = new URL(gid);
      const pathnameParts = pathname.split("/");
      const lastPathnamePart = pathnameParts[pathnameParts.length - 1];
      const resourcePart = pathnameParts[pathnameParts.length - 2];
      if (!lastPathnamePart || !resourcePart) {
        return defaultReturn;
      }
      const id = `${lastPathnamePart}${search}${hash}` || "";
      const resourceId = lastPathnamePart || null;
      const resource = resourcePart ?? null;
      return { id, resource, resourceId, search, searchParams, hash };
    } catch {
      return defaultReturn;
    }
  }
  function addDataIf(keyValuePairs, formattedData) {
    if (typeof keyValuePairs !== "object") {
      return {};
    }
    Object.entries(keyValuePairs).forEach(([key, value]) => {
      if (value) {
        formattedData[key] = value;
      }
    });
    return formattedData;
  }
  function errorIfServer(fnName) {
    if (typeof document === "undefined") {
      console.error(
        `${fnName} should only be used within the useEffect callback or event handlers`
      );
      return true;
    }
    return false;
  }
  const SCHEMA_ID$1 = "trekkie_storefront_page_view/1.4";
  const OXYGEN_DOMAIN = "myshopify.dev";
  function pageView$1(payload) {
    const pageViewPayload = payload;
    const { id, resource } = parseGid(pageViewPayload.resourceId);
    const resourceType = resource ? resource.toLowerCase() : void 0;
    return [
      schemaWrapper(
        SCHEMA_ID$1,
        addDataIf(
          {
            pageType: pageViewPayload.pageType,
            customerId: parseInt(parseGid(pageViewPayload.customerId).id || "0"),
            resourceType,
            resourceId: parseInt(id)
          },
          formatPayload$1(pageViewPayload)
        )
      )
    ];
  }
  function formatPayload$1(payload) {
    return {
      appClientId: payload.shopifySalesChannel ? ShopifyAppId[payload.shopifySalesChannel] : ShopifyAppId.headless,
      isMerchantRequest: isMerchantRequest(payload.url),
      hydrogenSubchannelId: payload.storefrontId || payload.hydrogenSubchannelId || "0",
      isPersistentCookie: payload.hasUserConsent,
      uniqToken: payload.uniqueToken,
      visitToken: payload.visitToken,
      microSessionId: buildUUID(),
      microSessionCount: 1,
      url: payload.url,
      path: payload.path,
      search: payload.search,
      referrer: payload.referrer,
      title: payload.title,
      shopId: parseInt(parseGid(payload.shopId).id),
      currency: payload.currency,
      contentLanguage: payload.acceptedLanguage || "en"
    };
  }
  function isMerchantRequest(url) {
    if (typeof url !== "string") {
      return false;
    }
    const hostname = new URL(url).hostname;
    if (hostname.indexOf(OXYGEN_DOMAIN) !== -1 || hostname === "localhost") {
      return true;
    }
    return false;
  }
  const version = "2025.7.0";
  const SCHEMA_ID = "custom_storefront_customer_tracking/1.2";
  const PAGE_RENDERED_EVENT_NAME = "page_rendered";
  const COLLECTION_PAGE_RENDERED_EVENT_NAME = "collection_page_rendered";
  const PRODUCT_PAGE_RENDERED_EVENT_NAME = "product_page_rendered";
  const PRODUCT_ADDED_TO_CART_EVENT_NAME = "product_added_to_cart";
  const SEARCH_SUBMITTED_EVENT_NAME = "search_submitted";
  function prepareAdditionalPayload(payload) {
    return {
      canonical_url: payload.canonicalUrl || payload.url,
      customer_id: parseInt(parseGid(payload.customerId).id || "0")
    };
  }
  function pageView(payload) {
    const pageViewPayload = payload;
    const additionalPayload = prepareAdditionalPayload(pageViewPayload);
    const pageType = pageViewPayload.pageType;
    const pageViewEvents = [];
    pageViewEvents.push(
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: PAGE_RENDERED_EVENT_NAME,
            ...additionalPayload
          },
          formatPayload(pageViewPayload)
        )
      )
    );
    switch (pageType) {
      case AnalyticsPageType.collection:
        pageViewEvents.push(
          schemaWrapper(
            SCHEMA_ID,
            addDataIf(
              {
                event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
                ...additionalPayload,
                collection_name: pageViewPayload.collectionHandle,
                collection_id: parseInt(
                  parseGid(pageViewPayload.collectionId).id
                )
              },
              formatPayload(pageViewPayload)
            )
          )
        );
        break;
      case AnalyticsPageType.product:
        pageViewEvents.push(
          schemaWrapper(
            SCHEMA_ID,
            addDataIf(
              {
                event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
                ...additionalPayload,
                products: formatProductPayload(pageViewPayload.products),
                total_value: pageViewPayload.totalValue
              },
              formatPayload(pageViewPayload)
            )
          )
        );
        break;
      case AnalyticsPageType.search:
        pageViewEvents.push(
          schemaWrapper(
            SCHEMA_ID,
            addDataIf(
              {
                event_name: SEARCH_SUBMITTED_EVENT_NAME,
                ...additionalPayload,
                search_string: pageViewPayload.searchString
              },
              formatPayload(pageViewPayload)
            )
          )
        );
        break;
    }
    return pageViewEvents;
  }
  function pageView2(payload) {
    const pageViewPayload = payload;
    const additionalPayload = prepareAdditionalPayload(pageViewPayload);
    return [
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: PAGE_RENDERED_EVENT_NAME,
            ...additionalPayload
          },
          formatPayload(pageViewPayload)
        )
      )
    ];
  }
  function collectionView(payload) {
    const pageViewPayload = payload;
    const additionalPayload = prepareAdditionalPayload(pageViewPayload);
    return [
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
            ...additionalPayload,
            collection_name: pageViewPayload.collectionHandle,
            collection_id: parseInt(parseGid(pageViewPayload.collectionId).id)
          },
          formatPayload(pageViewPayload)
        )
      )
    ];
  }
  function productView(payload) {
    const pageViewPayload = payload;
    const additionalPayload = prepareAdditionalPayload(pageViewPayload);
    return [
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
            ...additionalPayload,
            products: formatProductPayload(pageViewPayload.products),
            total_value: pageViewPayload.totalValue
          },
          formatPayload(pageViewPayload)
        )
      )
    ];
  }
  function searchView(payload) {
    const pageViewPayload = payload;
    const additionalPayload = prepareAdditionalPayload(pageViewPayload);
    return [
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: SEARCH_SUBMITTED_EVENT_NAME,
            ...additionalPayload,
            search_string: pageViewPayload.searchString
          },
          formatPayload(pageViewPayload)
        )
      )
    ];
  }
  function addToCart(payload) {
    const addToCartPayload = payload;
    const cartToken = parseGid(addToCartPayload.cartId);
    return [
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: PRODUCT_ADDED_TO_CART_EVENT_NAME,
            customerId: addToCartPayload.customerId,
            cart_token: (cartToken == null ? void 0 : cartToken.id) ? `${cartToken.id}` : null,
            total_value: addToCartPayload.totalValue,
            products: formatProductPayload(addToCartPayload.products),
            customer_id: parseInt(
              parseGid(addToCartPayload.customerId).id || "0"
            )
          },
          formatPayload(addToCartPayload)
        )
      )
    ];
  }
  function formatPayload(payload) {
    return {
      source: payload.shopifySalesChannel || ShopifySalesChannel.headless,
      asset_version_id: payload.assetVersionId || version,
      hydrogenSubchannelId: payload.storefrontId || payload.hydrogenSubchannelId || "0",
      is_persistent_cookie: payload.hasUserConsent,
      deprecated_visit_token: payload.visitToken,
      unique_token: payload.uniqueToken,
      event_time: Date.now(),
      event_id: buildUUID(),
      event_source_url: payload.url,
      referrer: payload.referrer,
      user_agent: payload.userAgent,
      navigation_type: payload.navigationType,
      navigation_api: payload.navigationApi,
      shop_id: parseInt(parseGid(payload.shopId).id),
      currency: payload.currency,
      ccpa_enforced: payload.ccpaEnforced || false,
      gdpr_enforced: payload.gdprEnforced || false,
      gdpr_enforced_as_string: payload.gdprEnforced ? "true" : "false",
      analytics_allowed: payload.analyticsAllowed || false,
      marketing_allowed: payload.marketingAllowed || false,
      sale_of_data_allowed: payload.saleOfDataAllowed || false
    };
  }
  function formatProductPayload(products) {
    return products ? products.map((p) => {
      const product = addDataIf(
        {
          variant_gid: p.variantGid,
          category: p.category,
          sku: p.sku,
          product_id: parseInt(parseGid(p.productGid).id),
          variant_id: parseInt(parseGid(p.variantGid).id)
        },
        {
          product_gid: p.productGid,
          name: p.name,
          variant: p.variantName || "",
          brand: p.brand,
          price: parseFloat(p.price),
          quantity: Number(p.quantity || 0)
        }
      );
      return JSON.stringify(product);
    }) : [];
  }
  function sendShopifyAnalytics(event, shopDomain) {
    const { eventName, payload } = event;
    if (!payload.hasUserConsent) return Promise.resolve();
    let events = [];
    const pageViewPayload = payload;
    if (eventName === AnalyticsEventName.PAGE_VIEW) {
      events = events.concat(
        pageView$1(pageViewPayload),
        pageView(pageViewPayload)
      );
    } else if (eventName === AnalyticsEventName.ADD_TO_CART) {
      events = events.concat(
        addToCart(payload)
      );
    } else if (eventName === AnalyticsEventName.PAGE_VIEW_2) {
      events = events.concat(
        pageView$1(pageViewPayload),
        pageView2(pageViewPayload)
      );
    } else if (eventName === AnalyticsEventName.COLLECTION_VIEW) {
      events = events.concat(collectionView(pageViewPayload));
    } else if (eventName === AnalyticsEventName.PRODUCT_VIEW) {
      events = events.concat(productView(pageViewPayload));
    } else if (eventName === AnalyticsEventName.SEARCH_VIEW) {
      events = events.concat(searchView(pageViewPayload));
    }
    if (events.length) {
      return sendToShopify(events, shopDomain);
    } else {
      return Promise.resolve();
    }
  }
  function isLighthouseUserAgent() {
    if (typeof window === "undefined" || !window.navigator) return false;
    return /Chrome-Lighthouse/.test(window.navigator.userAgent);
  }
  const ERROR_MESSAGE = "sendShopifyAnalytics request is unsuccessful";
  function sendToShopify(events, shopDomain) {
    if (isLighthouseUserAgent()) {
      return Promise.resolve();
    }
    const eventsToBeSent = {
      events,
      metadata: {
        event_sent_at_ms: Date.now()
      }
    };
    try {
      return fetch(
        shopDomain ? `https://${shopDomain}/.well-known/shopify/monorail/unstable/produce_batch` : "https://monorail-edge.shopifysvc.com/unstable/produce_batch",
        {
          method: "post",
          headers: {
            "content-type": "text/plain"
          },
          body: JSON.stringify(eventsToBeSent)
        }
      ).then((response) => {
        if (!response.ok) {
          throw new Error("Response failed");
        }
        return response.text();
      }).then((data) => {
        if (data) {
          const jsonResponse = JSON.parse(data);
          jsonResponse.result.forEach((eventResponse) => {
            if (eventResponse.status !== 200) {
              console.error(ERROR_MESSAGE, "\n\n", eventResponse.message);
            }
          });
        }
      }).catch((err) => {
        console.error(ERROR_MESSAGE, err);
        if (true) {
          throw new Error(ERROR_MESSAGE);
        }
      });
    } catch (error) {
      return Promise.resolve();
    }
  }
  function getClientBrowserParameters() {
    if (errorIfServer("getClientBrowserParameters")) {
      return {
        uniqueToken: "",
        visitToken: "",
        url: "",
        path: "",
        search: "",
        referrer: "",
        title: "",
        userAgent: "",
        navigationType: "",
        navigationApi: ""
      };
    }
    const [navigationType, navigationApi] = getNavigationType();
    const cookies = getShopifyCookies(document.cookie);
    return {
      uniqueToken: cookies[SHOPIFY_Y],
      visitToken: cookies[SHOPIFY_S],
      url: location.href,
      path: location.pathname,
      search: location.search,
      referrer: document.referrer,
      title: document.title,
      userAgent: navigator.userAgent,
      navigationType,
      navigationApi
    };
  }
  function getNavigationTypeExperimental() {
    try {
      const navigationEntries = (performance == null ? void 0 : performance.getEntriesByType) && (performance == null ? void 0 : performance.getEntriesByType("navigation"));
      if (navigationEntries && navigationEntries[0]) {
        const rawType = window.performance.getEntriesByType(
          "navigation"
        )[0]["type"];
        const navType = rawType && rawType.toString();
        return navType;
      }
    } catch (err) {
    }
    return void 0;
  }
  function getNavigationTypeLegacy() {
    var _a, _b;
    try {
      if (PerformanceNavigation && ((_a = performance == null ? void 0 : performance.navigation) == null ? void 0 : _a.type) !== null && ((_b = performance == null ? void 0 : performance.navigation) == null ? void 0 : _b.type) !== void 0) {
        const rawType = performance.navigation.type;
        switch (rawType) {
          case PerformanceNavigation.TYPE_NAVIGATE:
            return "navigate";
          case PerformanceNavigation.TYPE_RELOAD:
            return "reload";
          case PerformanceNavigation.TYPE_BACK_FORWARD:
            return "back_forward";
          default:
            return `unknown: ${rawType}`;
        }
      }
    } catch (err) {
    }
    return void 0;
  }
  function getNavigationType() {
    try {
      let navApi = "PerformanceNavigationTiming";
      let navType = getNavigationTypeExperimental();
      if (!navType) {
        navType = getNavigationTypeLegacy();
        navApi = "performance.navigation";
      }
      if (navType) {
        return [navType, navApi];
      } else {
        return ["unknown", "unknown"];
      }
    } catch (err) {
    }
    return ["error", "error"];
  }
  function BuyNowButton(props) {
    const { cartCreate, checkoutUrl } = useCart();
    const [loading, setLoading] = React$1.useState(false);
    const {
      quantity,
      variantId,
      sellingPlanId,
      onClick,
      attributes,
      children,
      ...passthroughProps
    } = props;
    React$1.useEffect(() => {
      if (loading && checkoutUrl) {
        window.location.href = checkoutUrl;
      }
    }, [loading, checkoutUrl]);
    const handleBuyNow = React$1.useCallback(() => {
      setLoading(true);
      cartCreate({
        lines: [
          {
            quantity: quantity ?? 1,
            merchandiseId: variantId,
            attributes,
            sellingPlanId
          }
        ]
      });
    }, [cartCreate, quantity, variantId, attributes, sellingPlanId]);
    return /* @__PURE__ */ React.createElement(
      BaseButton,
      {
        disabled: loading ?? passthroughProps.disabled,
        ...passthroughProps,
        onClick,
        defaultOnClick: handleBuyNow
      },
      children
    );
  }
  function CartCheckoutButton(props) {
    const [requestedCheckout, setRequestedCheckout] = React$1.useState(false);
    const { status, checkoutUrl } = useCart();
    const { children, ...passthroughProps } = props;
    React$1.useEffect(() => {
      if (requestedCheckout && checkoutUrl && status === "idle") {
        window.location.href = checkoutUrl;
      }
    }, [requestedCheckout, status, checkoutUrl]);
    return /* @__PURE__ */ React.createElement(
      BaseButton,
      {
        ...passthroughProps,
        disabled: requestedCheckout || passthroughProps.disabled,
        onClick: () => setRequestedCheckout(true)
      },
      children
    );
  }
  function useMoney(money) {
    const { countryIsoCode, languageIsoCode } = useShop();
    const locale = languageIsoCode.includes("_") ? languageIsoCode.replace("_", "-") : `${languageIsoCode}-${countryIsoCode}`;
    if (!locale) {
      throw new Error(
        `useMoney(): Unable to get 'locale' from 'useShop()', which means that 'locale' was not passed to '<ShopifyProvider/>'. 'locale' is required for 'useMoney()' to work`
      );
    }
    const amount = parseFloat(money.amount);
    let isCurrencySupported = true;
    try {
      new Intl.NumberFormat(locale, {
        style: "currency",
        currency: money.currencyCode
      });
    } catch (e2) {
      if (e2 instanceof RangeError && e2.message.includes("currency")) {
        isCurrencySupported = false;
      }
    }
    const {
      defaultFormatter,
      nameFormatter,
      narrowSymbolFormatter,
      withoutTrailingZerosFormatter,
      withoutCurrencyFormatter,
      withoutTrailingZerosOrCurrencyFormatter
    } = React$1.useMemo(() => {
      const options = isCurrencySupported ? {
        style: "currency",
        currency: money.currencyCode
      } : {
        style: "decimal",
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      };
      return {
        defaultFormatter: getLazyFormatter(locale, options),
        nameFormatter: getLazyFormatter(locale, {
          ...options,
          currencyDisplay: "name"
        }),
        narrowSymbolFormatter: getLazyFormatter(locale, {
          ...options,
          currencyDisplay: "narrowSymbol"
        }),
        withoutTrailingZerosFormatter: getLazyFormatter(locale, {
          ...options,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        }),
        withoutCurrencyFormatter: getLazyFormatter(locale, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2
        }),
        withoutTrailingZerosOrCurrencyFormatter: getLazyFormatter(locale, {
          minimumFractionDigits: 0,
          maximumFractionDigits: 0
        })
      };
    }, [money.currencyCode, locale, isCurrencySupported]);
    const isPartCurrency = (part) => part.type === "currency";
    const lazyFormatters = React$1.useMemo(
      () => ({
        original: () => money,
        currencyCode: () => money.currencyCode,
        localizedString: () => {
          const formatted = defaultFormatter().format(amount);
          return isCurrencySupported ? formatted : `${formatted} ${money.currencyCode}`;
        },
        parts: () => {
          const parts = defaultFormatter().formatToParts(amount);
          if (!isCurrencySupported) {
            parts.push(
              { type: "literal", value: " " },
              { type: "currency", value: money.currencyCode }
            );
          }
          return parts;
        },
        withoutTrailingZeros: () => {
          const formatted = amount % 1 === 0 ? withoutTrailingZerosFormatter().format(amount) : defaultFormatter().format(amount);
          return isCurrencySupported ? formatted : `${formatted} ${money.currencyCode}`;
        },
        withoutTrailingZerosAndCurrency: () => amount % 1 === 0 ? withoutTrailingZerosOrCurrencyFormatter().format(amount) : withoutCurrencyFormatter().format(amount),
        currencyName: () => {
          var _a;
          return ((_a = nameFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? money.currencyCode;
        },
        // e.g. "US dollars"
        currencySymbol: () => {
          var _a;
          return ((_a = defaultFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? money.currencyCode;
        },
        // e.g. "USD"
        currencyNarrowSymbol: () => {
          var _a;
          return ((_a = narrowSymbolFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? "";
        },
        // e.g. "$"
        amount: () => defaultFormatter().formatToParts(amount).filter(
          (part) => ["decimal", "fraction", "group", "integer", "literal"].includes(
            part.type
          )
        ).map((part) => part.value).join("")
      }),
      [
        money,
        amount,
        isCurrencySupported,
        nameFormatter,
        defaultFormatter,
        narrowSymbolFormatter,
        withoutCurrencyFormatter,
        withoutTrailingZerosFormatter,
        withoutTrailingZerosOrCurrencyFormatter
      ]
    );
    return React$1.useMemo(
      () => new Proxy(lazyFormatters, {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
        get: (target, key) => {
          var _a;
          return (_a = Reflect.get(target, key)) == null ? void 0 : _a.call(null);
        }
      }),
      [lazyFormatters]
    );
  }
  const formatterCache = /* @__PURE__ */ new Map();
  function getLazyFormatter(locale, options) {
    const key = JSON.stringify([locale, options]);
    return function() {
      let formatter = formatterCache.get(key);
      if (!formatter) {
        try {
          formatter = new Intl.NumberFormat(locale, options);
        } catch (error) {
          if (error instanceof RangeError && error.message.includes("currency")) {
            const fallbackOptions = { ...options };
            delete fallbackOptions.currency;
            delete fallbackOptions.currencyDisplay;
            delete fallbackOptions.currencySign;
            formatter = new Intl.NumberFormat(locale, fallbackOptions);
          } else {
            throw error;
          }
        }
        formatterCache.set(key, formatter);
      }
      return formatter;
    };
  }
  function Money({
    data,
    as,
    withoutCurrency,
    withoutTrailingZeros,
    measurement,
    measurementSeparator = "/",
    ...passthroughProps
  }) {
    if (!isMoney(data)) {
      throw new Error(
        `<Money/> needs a valid 'data' prop that has 'amount' and 'currencyCode'`
      );
    }
    const moneyObject = useMoney(data);
    const Wrapper = as ?? "div";
    let output = moneyObject.localizedString;
    if (withoutCurrency || withoutTrailingZeros) {
      if (withoutCurrency && !withoutTrailingZeros) {
        output = moneyObject.amount;
      } else if (!withoutCurrency && withoutTrailingZeros) {
        output = moneyObject.withoutTrailingZeros;
      } else {
        output = moneyObject.withoutTrailingZerosAndCurrency;
      }
    }
    return /* @__PURE__ */ React.createElement(Wrapper, { ...passthroughProps }, output, measurement && measurement.referenceUnit && /* @__PURE__ */ React.createElement(React.Fragment, null, measurementSeparator, measurement.referenceUnit));
  }
  function isMoney(maybeMoney) {
    return typeof maybeMoney.amount === "string" && !!maybeMoney.amount && typeof maybeMoney.currencyCode === "string" && !!maybeMoney.currencyCode;
  }
  function CartCost(props) {
    const { cost } = useCart();
    const { amountType = "total", children, ...passthroughProps } = props;
    let amount;
    if (amountType == "total") {
      amount = cost == null ? void 0 : cost.totalAmount;
    } else if (amountType == "subtotal") {
      amount = cost == null ? void 0 : cost.subtotalAmount;
    } else if (amountType == "tax") {
      amount = cost == null ? void 0 : cost.totalTaxAmount;
    } else if (amountType == "duty") {
      amount = cost == null ? void 0 : cost.totalDutyAmount;
    }
    if (amount == null) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(Money, { ...passthroughProps, data: amount }, children);
  }
  const CartLineContext = React$1.createContext(null);
  function useCartLine() {
    const context = React$1.useContext(CartLineContext);
    if (context == null) {
      throw new Error("Expected a cart line context but none was found");
    }
    return context;
  }
  function CartLineProvider({
    children,
    line
  }) {
    return /* @__PURE__ */ React.createElement(CartLineContext.Provider, { value: line }, children);
  }
  function CartLineQuantity(props) {
    const cartLine = useCartLine();
    const { as, ...passthroughProps } = props;
    const Wrapper = as ? as : "span";
    return /* @__PURE__ */ React.createElement(Wrapper, { ...passthroughProps }, cartLine.quantity);
  }
  function CartLineQuantityAdjustButton(props) {
    const { status, linesRemove, linesUpdate } = useCart();
    const cartLine = useCartLine();
    const { children, adjust, onClick, ...passthroughProps } = props;
    const handleAdjust = React$1.useCallback(() => {
      if (adjust === "remove") {
        linesRemove([(cartLine == null ? void 0 : cartLine.id) ?? ""]);
        return;
      }
      const quantity = adjust === "decrease" ? ((cartLine == null ? void 0 : cartLine.quantity) ?? 0) - 1 : ((cartLine == null ? void 0 : cartLine.quantity) ?? 0) + 1;
      if (quantity <= 0) {
        linesRemove([(cartLine == null ? void 0 : cartLine.id) ?? ""]);
        return;
      }
      const lineUpdate = {
        id: (cartLine == null ? void 0 : cartLine.id) ?? "",
        quantity,
        attributes: (cartLine == null ? void 0 : cartLine.attributes) ?? []
      };
      linesUpdate([lineUpdate]);
    }, [
      adjust,
      cartLine == null ? void 0 : cartLine.attributes,
      cartLine == null ? void 0 : cartLine.id,
      cartLine == null ? void 0 : cartLine.quantity,
      linesRemove,
      linesUpdate
    ]);
    const disabledAttr = passthroughProps.disabled;
    return /* @__PURE__ */ React.createElement(
      BaseButton,
      {
        ...passthroughProps,
        onClick,
        defaultOnClick: handleAdjust,
        disabled: typeof disabledAttr !== "undefined" ? disabledAttr : status !== "idle"
      },
      children
    );
  }
  const storefrontApiCustomScalars = {
    // Keep in sync with the definitions in the app/nextjs/codegen.ts!
    DateTime: "string",
    Decimal: "string",
    HTML: "string",
    URL: "string",
    Color: "string",
    UnsignedInt64: "string"
  };
  const customerAccountApiCustomScalars = {
    DateTime: "string",
    Decimal: "string",
    HTML: "string",
    ISO8601DateTime: "string",
    URL: "string",
    UnsignedInt64: "string"
  };
  const ExternalVideo = React$1.forwardRef(
    (props, ref) => {
      const {
        data,
        options,
        id = data.id,
        frameBorder = "0",
        allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
        allowFullScreen = true,
        loading = "lazy",
        ...passthroughProps
      } = props;
      if (!data.embedUrl) {
        throw new Error(`<ExternalVideo/> requires the 'embedUrl' property`);
      }
      let finalUrl = data.embedUrl;
      if (options) {
        const urlObject = new URL(data.embedUrl);
        for (const [key, value] of Object.entries(options)) {
          if (typeof value === "undefined") {
            continue;
          }
          urlObject.searchParams.set(key, value.toString());
        }
        finalUrl = urlObject.toString();
      }
      return /* @__PURE__ */ React.createElement(
        "iframe",
        {
          ...passthroughProps,
          id: id ?? data.embedUrl,
          title: data.alt ?? data.id ?? "external video",
          frameBorder,
          allow,
          allowFullScreen,
          src: finalUrl,
          loading,
          ref
        }
      );
    }
  );
  const OPTION_VALUE_SEPARATOR = ",";
  const V1_CONTROL_CHARS = {
    OPTION: ":",
    END_OF_PREFIX: ",",
    SEQUENCE_GAP: " ",
    RANGE: "-"
  };
  const isOptionValueCombinationInEncodedVariant = /* @__PURE__ */ (() => {
    const decodedOptionValues = /* @__PURE__ */ new Map();
    return function(targetOptionValueCombination, encodedVariantField) {
      var _a;
      if (targetOptionValueCombination.length === 0) {
        return false;
      }
      if (!decodedOptionValues.has(encodedVariantField)) {
        const decodedOptionValuesSet = /* @__PURE__ */ new Set();
        for (const optionValue of decodeEncodedVariant(encodedVariantField)) {
          decodedOptionValuesSet.add(optionValue.join(OPTION_VALUE_SEPARATOR));
          for (let i2 = 0; i2 < optionValue.length; i2++) {
            decodedOptionValuesSet.add(
              optionValue.slice(0, i2 + 1).join(OPTION_VALUE_SEPARATOR)
            );
          }
        }
        decodedOptionValues.set(encodedVariantField, decodedOptionValuesSet);
      }
      return Boolean(
        (_a = decodedOptionValues.get(encodedVariantField)) == null ? void 0 : _a.has(targetOptionValueCombination.join(OPTION_VALUE_SEPARATOR))
      );
    };
  })();
  function decodeEncodedVariant(encodedVariantField) {
    if (!encodedVariantField) return [];
    if (encodedVariantField.startsWith("v1_")) {
      return v1Decoder(stripVersion(encodedVariantField));
    }
    throw new Error("Unsupported option value encoding");
  }
  const stripVersion = (encodedVariantField) => encodedVariantField.replace(/^v1_/, "");
  function v1Decoder(encodedVariantField) {
    const tokenizer = /[ :,-]/g;
    let index2 = 0;
    let token;
    const options = [];
    const currentOptionValue = [];
    let depth = 0;
    let rangeStart = null;
    while (token = tokenizer.exec(encodedVariantField)) {
      const operation = token[0];
      const optionValueIndex = Number.parseInt(encodedVariantField.slice(index2, token.index)) || 0;
      if (rangeStart !== null) {
        for (; rangeStart < optionValueIndex; rangeStart++) {
          currentOptionValue[depth] = rangeStart;
          options.push([...currentOptionValue]);
        }
        rangeStart = null;
      }
      currentOptionValue[depth] = optionValueIndex;
      if (operation === V1_CONTROL_CHARS.RANGE) {
        rangeStart = optionValueIndex;
      } else if (operation === V1_CONTROL_CHARS.OPTION) {
        depth++;
      } else {
        if (operation === V1_CONTROL_CHARS.SEQUENCE_GAP || operation === V1_CONTROL_CHARS.END_OF_PREFIX && encodedVariantField[token.index - 1] !== V1_CONTROL_CHARS.END_OF_PREFIX) {
          options.push([...currentOptionValue]);
        }
        if (operation === V1_CONTROL_CHARS.END_OF_PREFIX) {
          currentOptionValue.pop();
          depth--;
        }
      }
      index2 = tokenizer.lastIndex;
    }
    const encodingEndsWithIndex = encodedVariantField.match(/\d+$/g);
    if (encodingEndsWithIndex) {
      const finalValueIndex = parseInt(encodingEndsWithIndex[0]);
      if (rangeStart != null) {
        for (; rangeStart <= finalValueIndex; rangeStart++) {
          currentOptionValue[depth] = rangeStart;
          options.push([...currentOptionValue]);
        }
      } else {
        options.push([finalValueIndex]);
      }
    }
    return options;
  }
  function mapProductOptions(options) {
    return Object.assign(
      {},
      ...options.map((option) => {
        return {
          [option.name]: Object.assign(
            {},
            ...(option == null ? void 0 : option.optionValues) ? option.optionValues.map((value, index2) => {
              return { [value.name]: index2 };
            }) : []
          )
        };
      })
    );
  }
  function mapSelectedProductOptionToObject(options) {
    return Object.assign(
      {},
      ...options.map((key) => {
        return { [key.name]: key.value };
      })
    );
  }
  function mapSelectedProductOptionToObjectAsString(options) {
    return JSON.stringify(mapSelectedProductOptionToObject(options));
  }
  function encodeSelectedProductOptionAsKey(selectedOption) {
    if (Array.isArray(selectedOption)) {
      return JSON.stringify(
        Object.assign(
          {},
          ...selectedOption.map((option) => ({ [option.name]: option.value }))
        )
      );
    } else {
      return JSON.stringify(selectedOption);
    }
  }
  function buildEncodingArrayFromSelectedOptions(selectedOption, productOptionMappings) {
    const encoding = Object.keys(selectedOption).map((key) => {
      return productOptionMappings[key] ? productOptionMappings[key][selectedOption[key]] : null;
    });
    return encoding.filter((code) => code !== null);
  }
  function mapVariants(variants) {
    return Object.assign(
      {},
      ...variants.map((variant) => {
        const variantKey = encodeSelectedProductOptionAsKey(
          variant.selectedOptions || []
        );
        return { [variantKey]: variant };
      })
    );
  }
  const PRODUCT_INPUTS = [
    "options",
    "selectedOrFirstAvailableVariant",
    "adjacentVariants"
  ];
  const PRODUCT_INPUTS_EXTRA = [
    "handle",
    "encodedVariantExistence",
    "encodedVariantAvailability"
  ];
  function logErrorAndReturnFalse(key) {
    console.error(
      `[h2:error:getProductOptions] product.${key} is missing. Make sure you query for this field from the Storefront API.`
    );
    return false;
  }
  function checkProductParam(product, checkAll = false) {
    var _a;
    let validParam = true;
    const productKeys = Object.keys(product);
    (checkAll ? [...PRODUCT_INPUTS, ...PRODUCT_INPUTS_EXTRA] : PRODUCT_INPUTS).forEach((key) => {
      if (!productKeys.includes(key)) {
        validParam = logErrorAndReturnFalse(key);
      }
    });
    if (product.options) {
      const firstOption = product == null ? void 0 : product.options[0];
      if (checkAll && !(firstOption == null ? void 0 : firstOption.name)) {
        validParam = logErrorAndReturnFalse("options.name");
      }
      if ((_a = product == null ? void 0 : product.options[0]) == null ? void 0 : _a.optionValues) {
        let firstOptionValues = product.options[0].optionValues[0];
        if (checkAll && !(firstOptionValues == null ? void 0 : firstOptionValues.name)) {
          validParam = logErrorAndReturnFalse("options.optionValues.name");
        }
        firstOptionValues = product.options[0].optionValues.filter(
          (value) => !!(value == null ? void 0 : value.firstSelectableVariant)
        )[0];
        if (firstOptionValues == null ? void 0 : firstOptionValues.firstSelectableVariant) {
          validParam = checkProductVariantParam(
            firstOptionValues.firstSelectableVariant,
            "options.optionValues.firstSelectableVariant",
            validParam,
            checkAll
          );
        }
      } else {
        validParam = logErrorAndReturnFalse("options.optionValues");
      }
    }
    if (product.selectedOrFirstAvailableVariant) {
      validParam = checkProductVariantParam(
        product.selectedOrFirstAvailableVariant,
        "selectedOrFirstAvailableVariant",
        validParam,
        checkAll
      );
    }
    if (!!product.adjacentVariants && product.adjacentVariants[0]) {
      validParam = checkProductVariantParam(
        product.adjacentVariants[0],
        "adjacentVariants",
        validParam,
        checkAll
      );
    }
    return validParam ? product : {};
  }
  function checkProductVariantParam(variant, key, currentValidParamState, checkAll) {
    var _a;
    let validParam = currentValidParamState;
    if (checkAll && !((_a = variant.product) == null ? void 0 : _a.handle)) {
      validParam = logErrorAndReturnFalse(`${key}.product.handle`);
    }
    if (variant.selectedOptions) {
      const firstSelectedOption = variant.selectedOptions[0];
      if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.name)) {
        validParam = logErrorAndReturnFalse(`${key}.selectedOptions.name`);
      }
      if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.value)) {
        validParam = logErrorAndReturnFalse(`${key}.selectedOptions.value`);
      }
    } else {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions`);
    }
    return validParam;
  }
  function getAdjacentAndFirstAvailableVariants(product) {
    const checkedProduct = checkProductParam(product);
    if (!checkedProduct.options) return [];
    const availableVariants = {};
    checkedProduct.options.map((option) => {
      var _a;
      (_a = option.optionValues) == null ? void 0 : _a.map((value) => {
        if (value.firstSelectableVariant) {
          const variantKey = mapSelectedProductOptionToObjectAsString(
            value.firstSelectableVariant.selectedOptions
          );
          availableVariants[variantKey] = value.firstSelectableVariant;
        }
      });
    });
    checkedProduct.adjacentVariants.map((variant) => {
      const variantKey = mapSelectedProductOptionToObjectAsString(
        variant.selectedOptions
      );
      availableVariants[variantKey] = variant;
    });
    const selectedVariant = checkedProduct.selectedOrFirstAvailableVariant;
    if (selectedVariant) {
      const variantKey = mapSelectedProductOptionToObjectAsString(
        selectedVariant.selectedOptions
      );
      availableVariants[variantKey] = selectedVariant;
    }
    return Object.values(availableVariants);
  }
  function getProductOptions(product) {
    const checkedProduct = checkProductParam(product, true);
    if (!checkedProduct.options) return [];
    const {
      options,
      selectedOrFirstAvailableVariant: selectedVariant,
      adjacentVariants,
      encodedVariantExistence,
      encodedVariantAvailability,
      handle: productHandle
    } = checkedProduct;
    const selectedOptionKeys = selectedVariant == null ? void 0 : selectedVariant.selectedOptions.map(
      (option) => option.name
    );
    const filteredOptions = options.filter((option) => {
      return selectedOptionKeys && selectedOptionKeys.indexOf(option.name) >= 0;
    });
    const productOptionMappings = mapProductOptions(options);
    const variants = mapVariants(
      selectedVariant ? [selectedVariant, ...adjacentVariants] : adjacentVariants
    );
    const selectedOptions = mapSelectedProductOptionToObject(
      selectedVariant ? selectedVariant.selectedOptions : []
    );
    const productOptions = filteredOptions.map((option, optionIndex) => {
      return {
        ...option,
        optionValues: option.optionValues.map((value) => {
          var _a;
          const targetOptionParams = { ...selectedOptions };
          targetOptionParams[option.name] = value.name;
          const targetKey = encodeSelectedProductOptionAsKey(
            targetOptionParams || []
          );
          const encodingKey = buildEncodingArrayFromSelectedOptions(
            targetOptionParams || [],
            productOptionMappings
          );
          const topDownKey = encodingKey.slice(0, optionIndex + 1);
          const exists = isOptionValueCombinationInEncodedVariant(
            topDownKey,
            encodedVariantExistence || ""
          );
          const available = isOptionValueCombinationInEncodedVariant(
            topDownKey,
            encodedVariantAvailability || ""
          );
          const variant = variants[targetKey] || value.firstSelectableVariant;
          let variantOptionParam = {};
          if (variant) {
            variantOptionParam = mapSelectedProductOptionToObject(
              variant.selectedOptions || []
            );
          }
          const searchParams = new URLSearchParams(variantOptionParam);
          const handle = ((_a = variant == null ? void 0 : variant.product) == null ? void 0 : _a.handle) || productHandle;
          return {
            ...value,
            variant,
            handle,
            variantUriQuery: searchParams.toString(),
            selected: selectedOptions[option.name] === value.name,
            exists,
            available,
            isDifferentProduct: handle !== productHandle
          };
        })
      };
    });
    return productOptions;
  }
  const IMAGE_FRAGMENT = `#graphql
  fragment Image on Image {
    altText
    url
    width
    height
  }
`;
  const Image = React__namespace.forwardRef(
    ({
      alt,
      aspectRatio,
      crop = "center",
      data,
      decoding = "async",
      height = "auto",
      loader = shopifyLoader,
      loading = "lazy",
      sizes,
      src,
      srcSetOptions = {
        intervals: 15,
        startingWidth: 200,
        incrementSize: 200,
        placeholderWidth: 100
      },
      width = "100%",
      ...passthroughProps
    }, ref) => {
      const normalizedData = React__namespace.useMemo(() => {
        const dataWidth = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.width : void 0;
        const dataHeight = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.height : void 0;
        return {
          width: dataWidth,
          height: dataHeight,
          unitsMatch: Boolean(unitsMatch(dataWidth, dataHeight))
        };
      }, [data]);
      const normalizedProps = React__namespace.useMemo(() => {
        const nWidthProp = width || "100%";
        const widthParts = getUnitValueParts(nWidthProp.toString());
        const nWidth = `${widthParts.number}${widthParts.unit}`;
        const autoHeight = height === void 0 || height === null;
        const heightParts = autoHeight ? null : getUnitValueParts(height.toString());
        const fixedHeight = heightParts ? `${heightParts.number}${heightParts.unit}` : "";
        const nHeight = autoHeight ? "auto" : fixedHeight;
        const nSrc = src || (data == null ? void 0 : data.url);
        if (!nSrc) {
          console.warn(
            `No src or data.url provided to Image component.`,
            (passthroughProps == null ? void 0 : passthroughProps.key) || ""
          );
        }
        const nAlt = (data == null ? void 0 : data.altText) && !alt ? data == null ? void 0 : data.altText : alt || "";
        const nAspectRatio = aspectRatio ? aspectRatio : normalizedData.unitsMatch ? [
          getNormalizedFixedUnit(normalizedData.width),
          getNormalizedFixedUnit(normalizedData.height)
        ].join("/") : void 0;
        return {
          width: nWidth,
          height: nHeight,
          src: nSrc,
          alt: nAlt,
          aspectRatio: nAspectRatio
        };
      }, [
        width,
        height,
        src,
        data,
        alt,
        aspectRatio,
        normalizedData,
        passthroughProps == null ? void 0 : passthroughProps.key
      ]);
      const { intervals, startingWidth, incrementSize, placeholderWidth } = srcSetOptions;
      const imageWidths = React__namespace.useMemo(() => {
        return generateImageWidths(
          width,
          intervals,
          startingWidth,
          incrementSize
        );
      }, [width, intervals, startingWidth, incrementSize]);
      const fixedWidth = isFixedWidth(normalizedProps.width);
      if (!sizes && !fixedWidth) {
        console.warn(
          [
            "No sizes prop provided to Image component,",
            "you may be loading unnecessarily large images.",
            `Image used is ${src || (data == null ? void 0 : data.url) || (passthroughProps == null ? void 0 : passthroughProps.key) || "unknown"}`
          ].join(" ")
        );
      }
      if (fixedWidth) {
        return /* @__PURE__ */ React__namespace.createElement(
          FixedWidthImage,
          {
            aspectRatio,
            crop,
            decoding,
            height,
            imageWidths,
            loader,
            loading,
            normalizedProps,
            passthroughProps,
            ref,
            width,
            data
          }
        );
      } else {
        return /* @__PURE__ */ React__namespace.createElement(
          FluidImage,
          {
            aspectRatio,
            crop,
            decoding,
            imageWidths,
            loader,
            loading,
            normalizedProps,
            passthroughProps,
            placeholderWidth,
            ref,
            sizes,
            data
          }
        );
      }
    }
  );
  const FixedWidthImage = React__namespace.forwardRef(
    ({
      aspectRatio,
      crop,
      decoding,
      height,
      imageWidths,
      loader = shopifyLoader,
      loading,
      normalizedProps,
      passthroughProps,
      width,
      data
    }, ref) => {
      const fixed = React__namespace.useMemo(() => {
        const intWidth = getNormalizedFixedUnit(width);
        const intHeight = getNormalizedFixedUnit(height);
        const fixedAspectRatio = aspectRatio ? aspectRatio : unitsMatch(normalizedProps.width, normalizedProps.height) ? [intWidth, intHeight].join("/") : normalizedProps.aspectRatio ? normalizedProps.aspectRatio : void 0;
        const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, fixedAspectRatio, crop, {
          width: (data == null ? void 0 : data.width) ?? void 0,
          height: (data == null ? void 0 : data.height) ?? void 0
        });
        const fixedHeight = intHeight ? intHeight : fixedAspectRatio && intWidth ? intWidth * (parseAspectRatio(fixedAspectRatio) ?? 1) : void 0;
        const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
        const src = loader({
          src: normalizedProps.src,
          width: intWidth,
          height: fixedHeight,
          crop: normalizedProps.height === "auto" ? void 0 : crop
        });
        return {
          width: intWidth,
          aspectRatio: fixedAspectRatio,
          height: fixedHeight,
          srcSet,
          src
        };
      }, [
        aspectRatio,
        crop,
        data,
        height,
        imageWidths,
        loader,
        normalizedProps,
        width
      ]);
      return /* @__PURE__ */ React__namespace.createElement(
        "img",
        {
          ref,
          alt: normalizedProps.alt,
          decoding,
          height: fixed.height,
          loading,
          src: fixed.src,
          srcSet: fixed.srcSet,
          width: fixed.width,
          style: {
            aspectRatio: fixed.aspectRatio,
            ...passthroughProps.style
          },
          ...passthroughProps
        }
      );
    }
  );
  const FluidImage = React__namespace.forwardRef(
    ({
      crop,
      decoding,
      imageWidths,
      loader = shopifyLoader,
      loading,
      normalizedProps,
      passthroughProps,
      placeholderWidth,
      sizes,
      data
    }, ref) => {
      const fluid = React__namespace.useMemo(() => {
        const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, normalizedProps.aspectRatio, crop, {
          width: (data == null ? void 0 : data.width) ?? void 0,
          height: (data == null ? void 0 : data.height) ?? void 0
        });
        const placeholderHeight = normalizedProps.aspectRatio && placeholderWidth ? placeholderWidth * (parseAspectRatio(normalizedProps.aspectRatio) ?? 1) : void 0;
        const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
        const src = loader({
          src: normalizedProps.src,
          width: placeholderWidth,
          height: placeholderHeight,
          crop
        });
        return {
          placeholderHeight,
          srcSet,
          src
        };
      }, [crop, data, imageWidths, loader, normalizedProps, placeholderWidth]);
      return /* @__PURE__ */ React__namespace.createElement(
        "img",
        {
          ref,
          alt: normalizedProps.alt,
          decoding,
          height: fluid.placeholderHeight,
          loading,
          sizes,
          src: fluid.src,
          srcSet: fluid.srcSet,
          width: placeholderWidth,
          ...passthroughProps,
          style: {
            width: normalizedProps.width,
            aspectRatio: normalizedProps.aspectRatio,
            ...passthroughProps.style
          }
        }
      );
    }
  );
  const PLACEHOLDER_DOMAIN = "https://placeholder.shopify.com";
  function shopifyLoader({ src, width, height, crop }) {
    if (!src) {
      return "";
    }
    const url = new URL(src, PLACEHOLDER_DOMAIN);
    if (width) {
      url.searchParams.append("width", Math.round(width).toString());
    }
    if (height) {
      url.searchParams.append("height", Math.round(height).toString());
    }
    if (crop) {
      url.searchParams.append("crop", crop);
    }
    return url.href.replace(PLACEHOLDER_DOMAIN, "");
  }
  function unitsMatch(width = "100%", height = "auto") {
    return getUnitValueParts(width.toString()).unit === getUnitValueParts(height.toString()).unit;
  }
  function getUnitValueParts(value) {
    const unit = value.replace(/[0-9.]/g, "");
    const number = parseFloat(value.replace(unit, ""));
    return {
      unit: unit === "" ? number === void 0 ? "auto" : "px" : unit,
      number
    };
  }
  function getNormalizedFixedUnit(value) {
    if (value === void 0) {
      return;
    }
    const { unit, number } = getUnitValueParts(value.toString());
    switch (unit) {
      case "em":
        return number * 16;
      case "rem":
        return number * 16;
      case "px":
        return number;
      case "":
        return number;
      default:
        return;
    }
  }
  function isFixedWidth(width) {
    const fixedEndings = /\d(px|em|rem)$/;
    return typeof width === "number" || fixedEndings.test(width);
  }
  function generateSrcSet(src, sizesArray, loader = shopifyLoader) {
    if (!src) {
      return "";
    }
    if ((sizesArray == null ? void 0 : sizesArray.length) === 0 || !sizesArray) {
      return src;
    }
    return sizesArray.map(
      (size, i2) => `${loader({
        src,
        width: size.width,
        height: size.height,
        crop: size.crop
      })} ${sizesArray.length === 3 ? `${i2 + 1}x` : `${size.width ?? 0}w`}`
    ).join(`, `);
  }
  function generateImageWidths(width = "100%", intervals, startingWidth, incrementSize) {
    const responsive = Array.from(
      { length: intervals },
      (_, i2) => i2 * incrementSize + startingWidth
    );
    const fixed = Array.from(
      { length: 3 },
      (_, i2) => (i2 + 1) * (getNormalizedFixedUnit(width) ?? 0)
    );
    return isFixedWidth(width) ? fixed : responsive;
  }
  function parseAspectRatio(aspectRatio) {
    if (!aspectRatio) return;
    const [width, height] = aspectRatio.split("/");
    return 1 / (Number(width) / Number(height));
  }
  function generateSizes(imageWidths, aspectRatio, crop = "center", sourceDimensions) {
    if (!imageWidths) return;
    return imageWidths.map((width) => {
      return {
        width,
        height: aspectRatio ? width * (parseAspectRatio(aspectRatio) ?? 1) : void 0,
        crop
      };
    }).filter(({ width, height }) => {
      if ((sourceDimensions == null ? void 0 : sourceDimensions.width) && width > sourceDimensions.width) {
        return false;
      }
      if ((sourceDimensions == null ? void 0 : sourceDimensions.height) && height && height > sourceDimensions.height) {
        return false;
      }
      return true;
    });
  }
  const SCRIPTS_LOADED = {};
  function loadScript(src, options) {
    const isScriptLoaded = SCRIPTS_LOADED[src];
    if (isScriptLoaded) {
      return isScriptLoaded;
    }
    const promise = new Promise((resolve, reject) => {
      const script = document.createElement("script");
      if (options == null ? void 0 : options.module) {
        script.type = "module";
      } else {
        script.type = "text/javascript";
      }
      script.src = src;
      script.onload = () => {
        resolve(true);
      };
      script.onerror = () => {
        reject(false);
      };
      if ((options == null ? void 0 : options.in) === "head") {
        document.head.appendChild(script);
      } else {
        document.body.appendChild(script);
      }
      const attributes = options == null ? void 0 : options.attributes;
      if (attributes) {
        Object.keys(attributes).forEach((key) => {
          script.setAttribute(key, attributes[key]);
        });
      }
    });
    SCRIPTS_LOADED[src] = promise;
    return promise;
  }
  function useLoadScript(url, options) {
    const [status, setStatus] = React$1.useState("loading");
    React$1.useEffect(
      () => {
        loadScript(url, options).then(() => setStatus("done")).catch(() => setStatus("error"));
      },
      // Ignore options changes since it won't trigger a new load.
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [url]
    );
    return status;
  }
  const Video = React$1.forwardRef((props, ref) => {
    var _a;
    const {
      data,
      previewImageOptions,
      id = data.id,
      playsInline = true,
      controls = true,
      sourceProps = {},
      ...passthroughProps
    } = props;
    const posterUrl = shopifyLoader({
      src: ((_a = data.previewImage) == null ? void 0 : _a.url) ?? "",
      ...previewImageOptions
    });
    if (!data.sources) {
      throw new Error(`<Video/> requires a 'data.sources' array`);
    }
    return (
      // eslint-disable-next-line jsx-a11y/media-has-caption
      /* @__PURE__ */ React.createElement(
        "video",
        {
          ...passthroughProps,
          id,
          playsInline,
          controls,
          poster: posterUrl,
          ref
        },
        data.sources.map((source) => {
          if (!((source == null ? void 0 : source.url) && (source == null ? void 0 : source.mimeType))) {
            throw new Error(`<Video/> needs 'source.url' and 'source.mimeType'`);
          }
          return /* @__PURE__ */ React.createElement(
            "source",
            {
              ...sourceProps,
              key: source.url,
              src: source.url,
              type: source.mimeType
            }
          );
        })
      )
    );
  });
  function ModelViewer(props) {
    var _a, _b, _c;
    const [modelViewer, setModelViewer] = React$1.useState(
      void 0
    );
    const callbackRef = React$1.useCallback((node) => {
      setModelViewer(node);
    }, []);
    const { data, children, className, ...passthroughProps } = props;
    const modelViewerLoadedStatus = useLoadScript(
      "https://unpkg.com/@google/model-viewer@v1.12.1/dist/model-viewer.min.js",
      {
        module: true
      }
    );
    React$1.useEffect(() => {
      const hydrogenEventListener = {
        error: passthroughProps.onError,
        load: passthroughProps.onLoad,
        preload: passthroughProps.onPreload,
        "model-visibility": passthroughProps.onModelVisibility,
        progress: passthroughProps.onProgress,
        "ar-status": passthroughProps.onArStatus,
        "ar-tracking": passthroughProps.onArTracking,
        "quick-look-button-tapped": passthroughProps.onQuickLookButtonTapped,
        "camera-change": passthroughProps.onCameraChange,
        "environment-change": passthroughProps.onEnvironmentChange,
        play: passthroughProps.onPlay,
        pause: passthroughProps.onPause,
        "scene-graph-ready": passthroughProps.onSceneGraphReady
      };
      if (!modelViewer) {
        return;
      }
      Object.entries(hydrogenEventListener).forEach(
        ([eventName, callbackFunc]) => {
          if (callbackFunc) {
            modelViewer.addEventListener(eventName, callbackFunc);
          }
        }
      );
      return () => {
        if (modelViewer == null) {
          return;
        }
        Object.entries(hydrogenEventListener).forEach(
          ([eventName, callbackFunc]) => {
            if (callbackFunc) {
              modelViewer.removeEventListener(eventName, callbackFunc);
            }
          }
        );
      };
    }, [
      modelViewer,
      passthroughProps.onArStatus,
      passthroughProps.onArTracking,
      passthroughProps.onCameraChange,
      passthroughProps.onEnvironmentChange,
      passthroughProps.onError,
      passthroughProps.onLoad,
      passthroughProps.onModelVisibility,
      passthroughProps.onPause,
      passthroughProps.onPlay,
      passthroughProps.onPreload,
      passthroughProps.onProgress,
      passthroughProps.onQuickLookButtonTapped,
      passthroughProps.onSceneGraphReady
    ]);
    if (modelViewerLoadedStatus !== "done") {
      return null;
    }
    if (!((_b = (_a = data.sources) == null ? void 0 : _a[0]) == null ? void 0 : _b.url)) {
      const sourcesUrlError = `<ModelViewer/> requires 'data.sources' prop to be an array, with an object that has a property 'url' on it. Rendering 'null'`;
      {
        throw new Error(sourcesUrlError);
      }
    }
    if (!data.alt) {
      console.warn(
        `<ModelViewer/> requires the 'data.alt' prop for accessibility`
      );
    }
    return /* @__PURE__ */ React.createElement(
      "model-viewer",
      {
        ref: callbackRef,
        ...passthroughProps,
        class: className,
        id: passthroughProps.id ?? data.id,
        src: data.sources[0].url,
        alt: data.alt ?? null,
        "camera-controls": passthroughProps.cameraControls ?? true,
        poster: (passthroughProps.poster || ((_c = data.previewImage) == null ? void 0 : _c.url)) ?? null,
        autoplay: passthroughProps.autoplay ?? true,
        loading: passthroughProps.loading,
        reveal: passthroughProps.reveal,
        ar: passthroughProps.ar,
        "ar-modes": passthroughProps.arModes,
        "ar-scale": passthroughProps.arScale,
        "ar-placement": passthroughProps.arPlacement,
        "ios-src": passthroughProps.iosSrc,
        "touch-action": passthroughProps.touchAction,
        "disable-zoom": passthroughProps.disableZoom,
        "orbit-sensitivity": passthroughProps.orbitSensitivity,
        "auto-rotate": passthroughProps.autoRotate,
        "auto-rotate-delay": passthroughProps.autoRotateDelay,
        "rotation-per-second": passthroughProps.rotationPerSecond,
        "interaction-policy": passthroughProps.interactionPolicy,
        "interaction-prompt": passthroughProps.interactionPrompt,
        "interaction-prompt-style": passthroughProps.interactionPromptStyle,
        "interaction-prompt-threshold": passthroughProps.interactionPromptThreshold,
        "camera-orbit": passthroughProps.cameraOrbit,
        "camera-target": passthroughProps.cameraTarget,
        "field-of-view": passthroughProps.fieldOfView,
        "max-camera-orbit": passthroughProps.maxCameraOrbit,
        "min-camera-orbit": passthroughProps.minCameraOrbit,
        "max-field-of-view": passthroughProps.maxFieldOfView,
        "min-field-of-view": passthroughProps.minFieldOfView,
        bounds: passthroughProps.bounds,
        "interpolation-decay": passthroughProps.interpolationDecay ?? 100,
        "skybox-image": passthroughProps.skyboxImage,
        "environment-image": passthroughProps.environmentImage,
        exposure: passthroughProps.exposure,
        "shadow-intensity": passthroughProps.shadowIntensity ?? 0,
        "shadow-softness": passthroughProps.shadowSoftness ?? 0,
        "animation-name": passthroughProps.animationName,
        "animation-crossfade-duration": passthroughProps.animationCrossfadeDuration,
        "variant-name": passthroughProps.variantName,
        orientation: passthroughProps.orientation,
        scale: passthroughProps.scale
      },
      children
    );
  }
  function MediaFile({
    data,
    mediaOptions,
    ...passthroughProps
  }) {
    switch (data.__typename) {
      case "MediaImage": {
        if (!data.image) {
          const noDataImage = `<MediaFile/>: 'data.image' does not exist for __typename of 'MediaImage'; rendering 'null' by default.`;
          {
            throw new Error(noDataImage);
          }
        }
        return /* @__PURE__ */ React.createElement(
          Image,
          {
            ...passthroughProps,
            ...mediaOptions == null ? void 0 : mediaOptions.image,
            data: data.image
          }
        );
      }
      case "Video": {
        return /* @__PURE__ */ React.createElement(Video, { ...passthroughProps, ...mediaOptions == null ? void 0 : mediaOptions.video, data });
      }
      case "ExternalVideo": {
        return /* @__PURE__ */ React.createElement(
          ExternalVideo,
          {
            ...passthroughProps,
            ...mediaOptions == null ? void 0 : mediaOptions.externalVideo,
            data
          }
        );
      }
      case "Model3d": {
        return (
          // @ts-expect-error There are issues with the inferred HTML attribute types here for ModelViewer (and contentEditable), but I think that's a little bit beyond me at the moment
          /* @__PURE__ */ React.createElement(
            ModelViewer,
            {
              ...passthroughProps,
              ...mediaOptions == null ? void 0 : mediaOptions.modelViewer,
              data
            }
          )
        );
      }
      default: {
        const typenameMissingMessage = `<MediaFile /> requires the '__typename' property to exist on the 'data' prop in order to render the matching sub-component for this type of media.`;
        {
          throw new Error(typenameMissingMessage);
        }
      }
    }
  }
  function parseMetafield(metafield) {
    if (!metafield.type) {
      const noTypeError = `parseMetafield(): The 'type' field is required in order to parse the Metafield.`;
      {
        throw new Error(noTypeError);
      }
    }
    switch (metafield.type) {
      case "boolean":
        return {
          ...metafield,
          parsedValue: metafield.value === "true"
        };
      case "collection_reference":
      case "file_reference":
      case "page_reference":
      case "product_reference":
      case "variant_reference":
        return {
          ...metafield,
          parsedValue: metafield.reference
        };
      case "color":
      case "multi_line_text_field":
      case "single_line_text_field":
      case "url":
        return {
          ...metafield,
          parsedValue: metafield.value
        };
      // TODO: 'money' should probably be parsed even further to like `useMoney()`, but that logic needs to be extracted first so it's not a hook
      case "money": {
        let parsedValue = null;
        try {
          const parsed = parseJSON(metafield.value ?? "");
          if (parsed && typeof parsed === "object" && "currency_code" in parsed) {
            const moneyData = parsed;
            parsedValue = {
              amount: moneyData.amount,
              currencyCode: moneyData.currency_code
            };
          } else if (parsed && typeof parsed === "object" && "currencyCode" in parsed) {
            parsedValue = parsed;
          } else {
            parsedValue = parsed;
          }
        } catch (err) {
          const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
          {
            throw new Error(parseError);
          }
        }
        return {
          ...metafield,
          parsedValue
        };
      }
      case "dimension":
      case "json":
      case "rating":
      case "volume":
      case "weight":
      case "rich_text_field":
      case "list.color":
      case "list.dimension":
      case "list.number_integer":
      case "list.number_decimal":
      case "list.rating":
      case "list.single_line_text_field":
      case "list.url":
      case "list.volume":
      case "list.weight": {
        let parsedValue = null;
        try {
          parsedValue = parseJSON(metafield.value ?? "");
        } catch (err) {
          const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
          {
            throw new Error(parseError);
          }
        }
        return {
          ...metafield,
          parsedValue
        };
      }
      case "date":
      case "date_time":
        return {
          ...metafield,
          parsedValue: new Date(metafield.value ?? "")
        };
      case "list.date":
      case "list.date_time": {
        const jsonParseValue = parseJSON((metafield == null ? void 0 : metafield.value) ?? "");
        return {
          ...metafield,
          parsedValue: jsonParseValue.map((dateString) => new Date(dateString))
        };
      }
      case "number_decimal":
      case "number_integer":
        return {
          ...metafield,
          parsedValue: Number(metafield.value)
        };
      case "list.collection_reference":
      case "list.file_reference":
      case "list.page_reference":
      case "list.product_reference":
      case "list.variant_reference":
        return {
          ...metafield,
          parsedValue: flattenConnection(metafield.references ?? void 0)
        };
      default: {
        const typeNotFoundError = `parseMetafield(): the 'metafield.type' you passed in is not supported. Your type: "${metafield.type}". If you believe this is an error, please open an issue on GitHub.`;
        {
          throw new Error(typeNotFoundError);
        }
      }
    }
  }
  function parseJSON(json) {
    if (String(json).includes("__proto__")) {
      return JSON.parse(json, (k, v2) => {
        if (k !== "__proto__") return v2;
      });
    }
    return JSON.parse(json);
  }
  function ProductPrice(props) {
    var _a, _b, _c, _d, _e, _f;
    const {
      priceType = "regular",
      variantId,
      valueType = "min",
      data: product,
      ...passthroughProps
    } = props;
    if (product == null) {
      throw new Error(`<ProductPrice/> requires a product as the 'data' prop`);
    }
    let price;
    let measurement;
    const variant = variantId ? flattenConnection((product == null ? void 0 : product.variants) ?? {}).find(
      (variant2) => (variant2 == null ? void 0 : variant2.id) === variantId
    ) ?? null : null;
    const variantPriceProperty = valueType === "max" ? "maxVariantPrice" : "minVariantPrice";
    if (priceType === "compareAt") {
      if (variantId && variant) {
        price = variant.compareAtPrice;
      } else {
        price = (_a = product == null ? void 0 : product.compareAtPriceRange) == null ? void 0 : _a[variantPriceProperty];
      }
      let priceAsNumber;
      if (variantId && variant) {
        priceAsNumber = parseFloat(((_b = variant.price) == null ? void 0 : _b.amount) ?? "0");
      } else {
        priceAsNumber = parseFloat(
          ((_d = (_c = product == null ? void 0 : product.priceRange) == null ? void 0 : _c[variantPriceProperty]) == null ? void 0 : _d.amount) ?? "0"
        );
      }
      const compareAtPriceAsNumber = parseFloat((price == null ? void 0 : price.amount) ?? "0");
      if (priceAsNumber >= compareAtPriceAsNumber) {
        return null;
      }
    } else {
      if (variantId && variant) {
        price = variant.price;
        if (valueType === "unit") {
          price = variant.unitPrice;
          measurement = variant.unitPriceMeasurement;
        }
      } else if (valueType === "max") {
        price = (_e = product.priceRange) == null ? void 0 : _e.maxVariantPrice;
      } else {
        price = (_f = product.priceRange) == null ? void 0 : _f.minVariantPrice;
      }
    }
    if (!price) {
      return null;
    }
    if (measurement) {
      return /* @__PURE__ */ React.createElement(Money, { ...passthroughProps, data: price, measurement });
    }
    return /* @__PURE__ */ React.createElement(Money, { ...passthroughProps, data: price });
  }
  const RichTextComponents = {
    root: Root,
    heading: Heading,
    paragraph: Paragraph,
    text: Text,
    link: RichTextLink,
    list: List,
    "list-item": ListItem
  };
  function Root({
    node
  }) {
    return /* @__PURE__ */ React.createElement("div", null, node.children);
  }
  function Heading({
    node
  }) {
    return React$1.createElement(`h${node.level ?? "1"}`, null, node.children);
  }
  function Paragraph({
    node
  }) {
    return /* @__PURE__ */ React.createElement("p", null, node.children);
  }
  function Text({
    node
  }) {
    if (node.bold && node.italic)
      return /* @__PURE__ */ React.createElement("em", null, /* @__PURE__ */ React.createElement("strong", null, node.value));
    if (node.bold) return /* @__PURE__ */ React.createElement("strong", null, node.value);
    if (node.italic) return /* @__PURE__ */ React.createElement("em", null, node.value);
    return node.value;
  }
  function RichTextLink({
    node
  }) {
    return /* @__PURE__ */ React.createElement("a", { href: node.url, title: node.title, target: node.target }, node.children);
  }
  function List({
    node
  }) {
    const List2 = node.listType === "unordered" ? "ul" : "ol";
    return /* @__PURE__ */ React.createElement(List2, null, node.children);
  }
  function ListItem({
    node
  }) {
    return /* @__PURE__ */ React.createElement("li", null, node.children);
  }
  function RichText({
    as,
    data,
    plain,
    components,
    ...passthroughProps
  }) {
    try {
      const Wrapper = as ?? "div";
      const parsedData = React$1.useMemo(
        () => JSON.parse(data),
        [data]
      );
      return /* @__PURE__ */ React.createElement(Wrapper, { ...passthroughProps }, plain ? richTextToString(parsedData) : serializeRichTextASTNode(components, parsedData));
    } catch (e2) {
      throw new Error(
        "[h2:error:RichText] Parsing error. Make sure to pass a JSON string of rich text metafield",
        {
          cause: e2
        }
      );
    }
  }
  function serializeRichTextASTNode(components = {}, node, index2 = 0) {
    let children;
    if ("children" in node) {
      children = node.children.map(
        (child, childIndex) => serializeRichTextASTNode(components, child, childIndex)
      );
    }
    const Component = components[node.type === "list-item" ? "listItem" : node.type] ?? RichTextComponents[node.type];
    switch (node.type) {
      case "root":
        return React$1.createElement(
          Component,
          {
            key: index2,
            node: {
              type: "root",
              children
            }
          }
        );
      case "heading":
        return React$1.createElement(
          Component,
          {
            key: index2,
            node: {
              type: "heading",
              level: node.level,
              children
            }
          }
        );
      case "paragraph":
        return React$1.createElement(
          Component,
          {
            key: index2,
            node: {
              type: "paragraph",
              children
            }
          }
        );
      case "text": {
        const elements = (node.value ?? "").split("\n").flatMap((value, subindex) => {
          const key = `${index2}-${value}-${subindex}`;
          const textElement = React$1.createElement(
            Component,
            {
              key,
              node: {
                type: "text",
                italic: node.italic,
                bold: node.bold,
                value
              }
            }
          );
          return subindex === 0 ? textElement : [React$1.createElement("br", { key: `${key}-br` }), textElement];
        });
        return elements.length > 1 ? React$1.createElement(React$1.Fragment, { key: index2 }, elements) : elements[0];
      }
      case "link":
        return React$1.createElement(
          Component,
          {
            key: index2,
            node: {
              type: "link",
              url: node.url,
              title: node.title,
              target: node.target,
              children
            }
          }
        );
      case "list":
        return React$1.createElement(
          Component,
          {
            key: index2,
            node: {
              type: "list",
              listType: node.listType,
              children
            }
          }
        );
      case "list-item":
        return React$1.createElement(
          Component,
          {
            key: index2,
            node: {
              type: "list-item",
              children
            }
          }
        );
    }
  }
  function richTextToString(node, result = []) {
    switch (node.type) {
      case "root":
        node.children.forEach((child) => richTextToString(child, result));
        break;
      case "heading":
      case "paragraph":
        node.children.forEach((child) => richTextToString(child, result));
        result.push(" ");
        break;
      case "text":
        result.push(node.value || "");
        break;
      case "link":
        node.children.forEach((child) => richTextToString(child, result));
        break;
      case "list":
        node.children.forEach((item) => {
          if (item.children) {
            item.children.forEach((child) => richTextToString(child, result));
          }
          result.push(" ");
        });
        break;
      default:
        throw new Error(`Unknown node encountered ${node.type}`);
    }
    return result.join("").trim();
  }
  const SHOPJS_URL = "https://cdn.shopify.com/shopifycloud/shop-js/v1.0/client.js";
  function isChannel(channel) {
    return channel === "headless" || channel === "hydrogen";
  }
  function ShopPayButton({
    channel,
    variantIds,
    className,
    variantIdsAndQuantities,
    width,
    storeDomain: _storeDomain
  }) {
    const shop = useShop();
    const storeDomain = _storeDomain || (shop == null ? void 0 : shop.storeDomain);
    const shopPayLoadedStatus = useLoadScript(SHOPJS_URL);
    let ids = [];
    let channelAttribution;
    if (!storeDomain || storeDomain === defaultShopifyContext.storeDomain) {
      throw new Error(MissingStoreDomainErrorMessage);
    }
    if (variantIds && variantIdsAndQuantities) {
      throw new Error(DoublePropsErrorMessage);
    }
    if (!variantIds && !variantIdsAndQuantities) {
      throw new Error(MissingPropsErrorMessage);
    }
    if (channel) {
      if (isChannel(channel)) {
        channelAttribution = channel;
      } else {
        throw new Error(InvalidChannelErrorMessage);
      }
    }
    if (variantIds) {
      ids = variantIds.reduce((prev, curr) => {
        const bareId = parseGid(curr).id;
        if (bareId) {
          prev.push(bareId);
        }
        return prev;
      }, []);
    } else if (variantIdsAndQuantities) {
      ids = variantIdsAndQuantities.reduce((prev, curr) => {
        const bareId = parseGid(curr == null ? void 0 : curr.id).id;
        if (bareId) {
          prev.push(`${bareId}:${(curr == null ? void 0 : curr.quantity) ?? 1}`);
        }
        return prev;
      }, []);
    } else {
      throw new Error(MissingPropsErrorMessage);
    }
    if (ids.length === 0) {
      throw new Error(InvalidPropsErrorMessage);
    }
    const style = width ? {
      "--shop-pay-button-width": width
    } : void 0;
    return /* @__PURE__ */ React.createElement("div", { className, style }, shopPayLoadedStatus === "done" && /* @__PURE__ */ React.createElement(
      "shop-pay-button",
      {
        ...channelAttribution ? { channel: channelAttribution } : {},
        "store-url": storeDomain,
        variants: ids.join(",")
      }
    ));
  }
  const MissingStoreDomainErrorMessage = 'You must pass a "storeDomain" prop to the "ShopPayButton" component, or wrap it in a "ShopifyProvider" component.';
  const InvalidPropsErrorMessage = `You must pass in "variantIds" in the form of ["gid://shopify/ProductVariant/1"]`;
  const MissingPropsErrorMessage = `You must pass in either "variantIds" or "variantIdsAndQuantities" to ShopPayButton`;
  const DoublePropsErrorMessage = `You must provide either a variantIds or variantIdsAndQuantities prop, but not both in the ShopPayButton component`;
  const InvalidChannelErrorMessage = `Invalid channel attribution value. Must be either "headless" or "hydrogen"`;
  function useSelectedOptionInUrlParam(selectedOptions) {
    React$1.useEffect(() => {
      const optionsSearchParams = new URLSearchParams(
        mapSelectedProductOptionToObject(selectedOptions || [])
      );
      const currentSearchParams = new URLSearchParams(window.location.search);
      const combinedSearchParams = new URLSearchParams({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        ...Object.fromEntries(currentSearchParams),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        ...Object.fromEntries(optionsSearchParams)
      });
      if (combinedSearchParams.size > 0) {
        window.history.replaceState(
          {},
          "",
          `${window.location.pathname}?${combinedSearchParams.toString()}`
        );
      }
    }, [JSON.stringify(selectedOptions)]);
    return null;
  }
  const longTermLength = 60 * 60 * 24 * 360 * 1;
  const shortTermLength = 60 * 30;
  function useShopifyCookies(options) {
    const {
      hasUserConsent = false,
      domain = "",
      checkoutDomain = ""
    } = options || {};
    React$1.useEffect(() => {
      const cookies = getShopifyCookies(document.cookie);
      let currentDomain = domain || window.document.location.host;
      if (checkoutDomain) {
        const checkoutDomainParts = checkoutDomain.split(".").reverse();
        const currentDomainParts = currentDomain.split(".").reverse();
        const sameDomainParts = [];
        checkoutDomainParts.forEach((part, index2) => {
          if (part === currentDomainParts[index2]) {
            sameDomainParts.push(part);
          }
        });
        currentDomain = sameDomainParts.reverse().join(".");
      }
      if (/^localhost/.test(currentDomain)) currentDomain = "";
      const domainWithLeadingDot = currentDomain ? /^\./.test(currentDomain) ? currentDomain : `.${currentDomain}` : "";
      if (hasUserConsent) {
        setCookie(
          SHOPIFY_Y,
          cookies[SHOPIFY_Y] || buildUUID(),
          longTermLength,
          domainWithLeadingDot
        );
        setCookie(
          SHOPIFY_S,
          cookies[SHOPIFY_S] || buildUUID(),
          shortTermLength,
          domainWithLeadingDot
        );
      } else {
        setCookie(SHOPIFY_Y, "", 0, domainWithLeadingDot);
        setCookie(SHOPIFY_S, "", 0, domainWithLeadingDot);
      }
    }, [options, hasUserConsent, domain, checkoutDomain]);
  }
  function setCookie(name, value, maxage, domain) {
    document.cookie = l(name, value, {
      maxage,
      domain,
      samesite: "Lax",
      path: "/"
    });
  }
  exports2.AddToCartButton = AddToCartButton;
  exports2.AnalyticsEventName = AnalyticsEventName;
  exports2.AnalyticsPageType = AnalyticsPageType;
  exports2.BuyNowButton = BuyNowButton;
  exports2.CartCheckoutButton = CartCheckoutButton;
  exports2.CartCost = CartCost;
  exports2.CartLineProvider = CartLineProvider;
  exports2.CartLineQuantity = CartLineQuantity;
  exports2.CartLineQuantityAdjustButton = CartLineQuantityAdjustButton;
  exports2.CartProvider = CartProvider;
  exports2.ExternalVideo = ExternalVideo;
  exports2.IMAGE_FRAGMENT = IMAGE_FRAGMENT;
  exports2.Image = Image;
  exports2.MediaFile = MediaFile;
  exports2.ModelViewer = ModelViewer;
  exports2.Money = Money;
  exports2.ProductPrice = ProductPrice;
  exports2.ProductProvider = ProductProvider;
  exports2.RichText = RichText;
  exports2.SHOPIFY_S = SHOPIFY_S;
  exports2.SHOPIFY_STOREFRONT_ID_HEADER = SHOPIFY_STOREFRONT_ID_HEADER;
  exports2.SHOPIFY_STOREFRONT_S_HEADER = SHOPIFY_STOREFRONT_S_HEADER;
  exports2.SHOPIFY_STOREFRONT_Y_HEADER = SHOPIFY_STOREFRONT_Y_HEADER;
  exports2.SHOPIFY_Y = SHOPIFY_Y;
  exports2.ShopPayButton = ShopPayButton;
  exports2.ShopifyProvider = ShopifyProvider;
  exports2.ShopifySalesChannel = ShopifySalesChannel;
  exports2.Video = Video;
  exports2.createStorefrontClient = createStorefrontClient;
  exports2.customerAccountApiCustomScalars = customerAccountApiCustomScalars;
  exports2.decodeEncodedVariant = decodeEncodedVariant;
  exports2.flattenConnection = flattenConnection;
  exports2.getAdjacentAndFirstAvailableVariants = getAdjacentAndFirstAvailableVariants;
  exports2.getClientBrowserParameters = getClientBrowserParameters;
  exports2.getProductOptions = getProductOptions;
  exports2.getShopifyCookies = getShopifyCookies;
  exports2.isOptionValueCombinationInEncodedVariant = isOptionValueCombinationInEncodedVariant;
  exports2.mapSelectedProductOptionToObject = mapSelectedProductOptionToObject;
  exports2.parseGid = parseGid;
  exports2.parseMetafield = parseMetafield;
  exports2.sendShopifyAnalytics = sendShopifyAnalytics;
  exports2.storefrontApiCustomScalars = storefrontApiCustomScalars;
  exports2.useCart = useCart;
  exports2.useCartLine = useCartLine;
  exports2.useLoadScript = useLoadScript;
  exports2.useMoney = useMoney;
  exports2.useProduct = useProduct;
  exports2.useSelectedOptionInUrlParam = useSelectedOptionInUrlParam;
  exports2.useShop = useShop;
  exports2.useShopifyCookies = useShopifyCookies;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
}));
//# sourceMappingURL=hydrogen-react.dev.js.map
