import { interpret as v, createMachine as s, InterpreterStatus as n } from "../../fsm/es/index.mjs";
import { useRef, useState, useEffect, useCallback } from "react";
import useIsomorphicLayoutEffect from "use-isomorphic-layout-effect";
import { w as withSelectorExports } from "../../../../_virtual/with-selector.mjs";
import useConstant from "./useConstant.mjs";
var __read = function(o, n2) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
function identity(a) {
  return a;
}
var getServiceState = function(service) {
  var currentValue;
  service.subscribe(function(state) {
    currentValue = state;
  }).unsubscribe();
  return currentValue;
};
function useMachine(stateMachine, options) {
  var persistedStateRef = useRef();
  if (process.env.NODE_ENV !== "production") {
    var _a = __read(useState(stateMachine), 1), initialMachine = _a[0];
    if (stateMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var _b = __read(useConstant(function() {
    var queue2 = [];
    var service2 = v(s(stateMachine.config, options ? options : stateMachine._options));
    var send = service2.send;
    service2.send = function(event) {
      if (service2.status === n.NotStarted) {
        queue2.push(event);
        return;
      }
      send(event);
      persistedStateRef.current = service2.state;
    };
    return [service2, queue2];
  }), 2), service = _b[0], queue = _b[1];
  useIsomorphicLayoutEffect(function() {
    if (options) {
      service._machine._options = options;
    }
  });
  var useServiceResult = useService(service);
  useEffect(function() {
    service.start(persistedStateRef.current);
    queue.forEach(service.send);
    persistedStateRef.current = service.state;
    return function() {
      service.stop();
    };
  }, []);
  return useServiceResult;
}
var isEqual = function(_prevState, nextState) {
  return nextState.changed === false;
};
function useService(service) {
  var getSnapshot = useCallback(function() {
    return getServiceState(service);
  }, [service]);
  var subscribe = useCallback(function(handleStoreChange) {
    var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [service]);
  var storeSnapshot = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getSnapshot, identity, isEqual);
  return [storeSnapshot, service.send, service];
}
export {
  useMachine,
  useService
};
//# sourceMappingURL=fsm.mjs.map
