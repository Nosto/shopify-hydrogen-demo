import { fetchModule } from "vite";
import { fileURLToPath } from "node:url";
import {
  createMiniOxygen,
  Response,
  defaultLogRequestLine
} from "../worker/index.js";
import { Request as MiniflareRequest } from "miniflare";
import { pipeFromWeb, toURL, toWeb } from "./utils.js";
import {
  isEntrypointError,
  handleEntrypointError
} from "./entry-error.js";
const scriptPath = fileURLToPath(new URL("./worker-entry.js", import.meta.url));
const FETCH_MODULE_PATHNAME = "/__vite_fetch_module";
const WARMUP_PATHNAME = "/__vite_warmup";
function startMiniOxygenRuntime({
  viteDevServer,
  env,
  debug = false,
  inspectorPort,
  crossBoundarySetup,
  entry: workerEntryFile,
  requestHook,
  logRequestLine = defaultLogRequestLine,
  compatibilityDate
}) {
  const wrappedHook = requestHook || logRequestLine ? async (request) => {
    const info = await request.json();
    await Promise.all([requestHook?.(info), logRequestLine?.(info)]);
    return new Response("ok");
  } : null;
  const miniOxygen = createMiniOxygen({
    debug,
    inspectorPort,
    requestHook: null,
    workers: [
      {
        name: "vite-env",
        modulesRoot: "/",
        modules: [{ type: "ESModule", path: scriptPath }],
        serviceBindings: {
          ...wrappedHook && { __VITE_REQUEST_HOOK: wrappedHook }
        },
        bindings: {
          ...env,
          __VITE_ROOT: viteDevServer.config.root,
          __VITE_RUNTIME_EXECUTE_URL: workerEntryFile,
          __VITE_FETCH_MODULE_PATHNAME: FETCH_MODULE_PATHNAME,
          __VITE_WARMUP_PATHNAME: WARMUP_PATHNAME
        },
        unsafeEvalBinding: "__VITE_UNSAFE_EVAL",
        wrappedBindings: { __VITE_SETUP_ENV: "setup-environment" },
        ...compatibilityDate && { compatibilityDate }
      },
      {
        name: "setup-environment",
        modules: true,
        serviceBindings: crossBoundarySetup?.reduce(
          (acc, { binding }, index) => {
            if (binding) {
              acc[`wrapped_service_${index}`] = async (request) => {
                const payload = await request.json();
                const result = await binding(...payload);
                return new Response(JSON.stringify(result ?? ""));
              };
            }
            return acc;
          },
          {}
        ),
        script: `
          const setupScripts = [${crossBoundarySetup?.map((boundary) => boundary.script) ?? ""}];
          export default (env) => () => {
            setupScripts.forEach((setup, index) => {
              if (!setup) return;

              const service = env['wrapped_service_' + index];
              const wrappedBinding = service
                ? (...args) => {
                  return service.fetch(
                    new Request(
                      'http://localhost',
                      {method: 'POST', body: JSON.stringify(args)}
                    )
                  ).then(response => response.json());
                }
                : undefined;

              setup(wrappedBinding);
            });

            setupScripts.length = 0;
          }`
      }
    ]
  });
  const viteClose = viteDevServer.close;
  viteDevServer.close = async () => {
    await Promise.allSettled([viteClose(), miniOxygen.dispose()]);
  };
  return miniOxygen;
}
function setupOxygenMiddleware(viteDevServer, getMiniOxygenOptions) {
  viteDevServer.middlewares.use(
    FETCH_MODULE_PATHNAME,
    function o2HandleModuleFetch(req, res) {
      const url = toURL(req);
      const id = url.searchParams.get("id");
      const importer = url.searchParams.get("importer") ?? void 0;
      if (id) {
        res.setHeader("Cache-Control", "no-store");
        res.setHeader("Content-Type", "application/json");
        fetchModule(viteDevServer.environments["ssr"], id, importer).then((ssrModule) => res.end(JSON.stringify(ssrModule))).catch((error) => {
          console.error("Error during module fetch:", error);
          res.writeHead(500, { "Content-Type": "text/plain" });
          res.end("Internal server error");
        });
      } else {
        res.writeHead(400, { "Content-Type": "text/plain" });
        res.end("Invalid request");
      }
    }
  );
  let miniOxygen;
  let miniOxygenOptions;
  viteDevServer.middlewares.use(function o2HandleWorkerRequest(req, res) {
    const ready = miniOxygen && !miniOxygen.isDisposed ? Promise.resolve() : getMiniOxygenOptions().then((options) => {
      miniOxygenOptions = options;
      miniOxygen = startMiniOxygenRuntime(options);
    });
    ready.then(
      () => miniOxygen.dispatchFetch(toMiniflareRequest(toWeb(req))).then(async (webResponse) => {
        if (isEntrypointError(webResponse)) {
          await handleEntrypointError(
            viteDevServer,
            webResponse,
            res,
            miniOxygenOptions.entryPointErrorHandler
          );
        } else {
          await pipeFromWeb(webResponse, res);
        }
      }).catch((error) => {
        console.error("MiniOxygen: Error during evaluation:", error);
        res.writeHead(500);
        res.end();
      })
    );
  });
  const warmupWorkerdCache = async () => {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const viteUrl = getViteUrl(viteDevServer);
    if (viteUrl) {
      fetch(new URL(WARMUP_PATHNAME, viteUrl)).catch(() => {
      });
    }
  };
  viteDevServer.httpServer?.listening ? warmupWorkerdCache() : viteDevServer.httpServer?.once("listening", warmupWorkerdCache);
}
function getViteUrl(viteDevServer) {
  let viteUrl = viteDevServer.resolvedUrls?.local[0] ?? viteDevServer.resolvedUrls?.network[0];
  if (!viteUrl) {
    const address = viteDevServer.httpServer?.address?.();
    viteUrl = address && typeof address !== "string" ? `http://localhost:${address.port}` : address ?? void 0;
  }
  return viteUrl;
}
function toMiniflareRequest(request) {
  const host = request.headers.get("Host");
  if (host) {
    request.headers.set("X-Forwarded-Host", host);
  }
  return new MiniflareRequest(request.url, {
    method: request.method,
    headers: [["accept-encoding", "identity"], ...request.headers],
    body: request.body,
    duplex: "half"
  });
}
export {
  setupOxygenMiddleware
};
