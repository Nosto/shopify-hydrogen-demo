import {
  require_jsx_runtime
} from "./chunk-X56DDI2M.js";
import {
  Link,
  RouterContextProvider,
  createContext,
  useFetcher,
  useFetchers,
  useLocation,
  useMatches,
  useNavigate,
  useNavigation
} from "./chunk-DYIXNZ2D.js";
import {
  require_react
} from "./chunk-Y4TACGN2.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __template,
  __toESM
} from "./chunk-C5HKJHC6.js";

// node_modules/@shopify/hydrogen/dist/development/index.js
var import_react28 = __toESM(require_react());
var import_jsx_runtime22 = __toESM(require_jsx_runtime());

// node_modules/@shopify/hydrogen-react/dist/browser-dev/AddToCartButton.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartProvider.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/fsm/es/index.mjs
var n;
!function(t2) {
  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
}(n || (n = {}));
function i(t2) {
  return { type: "xstate.assign", assignment: t2 };
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/react/es/fsm.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/with-selector2.mjs
var withSelector = { exports: {} };

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/index.mjs
var shim = { exports: {} };

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/use-sync-external-store-shim.development.mjs
var useSyncExternalStoreShim_development = {};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.mjs
var import_react3 = __toESM(require_react(), 1);
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React3 = import_react3.default;
      var ReactSharedInternals = React3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useState10 = React3.useState, useEffect12 = React3.useEffect, useLayoutEffect2 = React3.useLayoutEffect, useDebugValue = React3.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React3.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            if (!objectIs(value, cachedValue)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState10({
          inst: {
            value,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect2(function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        }, [subscribe2, value, getSnapshot]);
        useEffect12(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          };
          return subscribe2(handleStoreChange);
        }, [subscribe2]);
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
      var useSyncExternalStore$2 = React3.useSyncExternalStore !== void 0 ? React3.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return useSyncExternalStoreShim_development;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/shim/index.mjs
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  if (false) {
    shim.exports = requireUseSyncExternalStoreShim_production_min();
  } else {
    shim.exports = requireUseSyncExternalStoreShim_development();
  }
  return shim.exports;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/with-selector.development.mjs
var withSelector_development = {};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.mjs
var import_react5 = __toESM(require_react(), 1);
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  if (hasRequiredWithSelector_development) return withSelector_development;
  hasRequiredWithSelector_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React3 = import_react5.default;
      var shim2 = requireShim();
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useSyncExternalStore = shim2.useSyncExternalStore;
      var useRef5 = React3.useRef, useEffect12 = React3.useEffect, useMemo10 = React3.useMemo, useDebugValue = React3.useDebugValue;
      function useSyncExternalStoreWithSelector(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef5(null);
        var inst;
        if (instRef.current === null) {
          inst = {
            hasValue: false,
            value: null
          };
          instRef.current = inst;
        } else {
          inst = instRef.current;
        }
        var _useMemo = useMemo10(function() {
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0) {
                if (inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            }
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              return prevSelection;
            }
            var nextSelection = selector(nextSnapshot);
            if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          };
          var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          var getSnapshotWithSelector = function() {
            return memoizedSelector(getSnapshot());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore(subscribe2, getSelection, getServerSelection);
        useEffect12(function() {
          inst.hasValue = true;
          inst.value = value;
        }, [value]);
        useDebugValue(value);
        return value;
      }
      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return withSelector_development;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/shim/with-selector.mjs
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  if (false) {
    withSelector.exports = requireWithSelector_production_min();
  } else {
    withSelector.exports = requireWithSelector_development();
  }
  return withSelector.exports;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/with-selector.mjs
var withSelectorExports = requireWithSelector();

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/react/es/useConstant.mjs
var React = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/flatten-connection.mjs
function flattenConnection(connection) {
  if (!connection) {
    const noConnectionErr = `flattenConnection(): needs a 'connection' to flatten, but received '${connection ?? ""}' instead.`;
    {
      throw new Error(noConnectionErr);
    }
  }
  if ("nodes" in connection) {
    return connection.nodes;
  }
  if ("edges" in connection && Array.isArray(connection.edges)) {
    return connection.edges.map((edge) => {
      if (!(edge == null ? void 0 : edge.node)) {
        throw new Error(
          "flattenConnection(): Connection edges must contain nodes"
        );
      }
      return edge.node;
    });
  }
  {
    console.warn(
      `flattenConnection(): The connection did not contain either "nodes" or "edges.node". Returning an empty array.`
    );
  }
  return [];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useCartActions.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cart-hooks.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ShopifyProvider.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/storefront-api-constants.mjs
var SFAPI_VERSION = "2025-07";

// node_modules/@shopify/hydrogen-react/dist/browser-dev/storefront-client.mjs
var MOCK_SHOP_DOMAIN = "mock.shop";
var isMockShop = (domain) => domain.includes(MOCK_SHOP_DOMAIN);
function createStorefrontClient({
  storeDomain,
  privateStorefrontToken,
  publicStorefrontToken,
  storefrontApiVersion = SFAPI_VERSION,
  contentType
}) {
  if (!storeDomain) {
    {
      storeDomain = MOCK_SHOP_DOMAIN;
      warnOnce(
        `storeDomain missing, defaulting to ${MOCK_SHOP_DOMAIN}`,
        "info"
      );
    }
  }
  if (storefrontApiVersion !== SFAPI_VERSION) {
    warnOnce(
      `The Storefront API version that you're using is different than the version this build of Hydrogen React is targeting.
You may run into unexpected errors if these versions don't match. Received version: "${storefrontApiVersion}"; expected version "${SFAPI_VERSION}"`
    );
  }
  if (!privateStorefrontToken && !globalThis.document && !isMockShop(storeDomain)) {
    warnOnce(
      `Using a private storefront token is recommended for server environments.
Refer to the authentication https://shopify.dev/api/storefront#authentication documentation for more details.`
    );
  }
  if (privateStorefrontToken && globalThis.document) {
    warnOnce(
      "You are attempting to use a private token in an environment where it can be easily accessed by anyone.\nThis is a security risk; please use the public token and the `publicStorefrontToken` prop"
    );
  }
  const getShopifyDomain = (overrideProps) => {
    const domain = (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? storeDomain;
    return domain.includes("://") ? domain : `https://${domain}`;
  };
  return {
    getShopifyDomain,
    getStorefrontApiUrl(overrideProps) {
      const domain = getShopifyDomain(overrideProps);
      const apiUrl = domain + (domain.endsWith("/") ? "api" : "/api");
      if (isMockShop(domain)) return apiUrl;
      return `${apiUrl}/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? storefrontApiVersion}/graphql.json`;
    },
    getPrivateTokenHeaders(overrideProps) {
      if (!privateStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) && !isMockShop(storeDomain)) {
        throw new Error(
          H2_PREFIX_ERROR + "You did not pass in a `privateStorefrontToken` while using `createStorefrontClient()` or `getPrivateTokenHeaders()`"
        );
      }
      if (!(overrideProps == null ? void 0 : overrideProps.buyerIp)) {
        warnOnce(
          "It is recommended to pass in the `buyerIp` property which improves analytics and data in the admin."
        );
      }
      const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType;
      return {
        // default to json
        "content-type": finalContentType === "graphql" ? "application/graphql" : "application/json",
        "X-SDK-Variant": "hydrogen-react",
        "X-SDK-Variant-Source": "react",
        "X-SDK-Version": storefrontApiVersion,
        "Shopify-Storefront-Private-Token": (overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) ?? privateStorefrontToken ?? "",
        ...(overrideProps == null ? void 0 : overrideProps.buyerIp) ? { "Shopify-Storefront-Buyer-IP": overrideProps.buyerIp } : {}
      };
    },
    getPublicTokenHeaders(overrideProps) {
      if (!publicStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) && !isMockShop(storeDomain)) {
        throw new Error(
          H2_PREFIX_ERROR + "You did not pass in a `publicStorefrontToken` while using `createStorefrontClient()` or `getPublicTokenHeaders()`"
        );
      }
      const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType ?? "json";
      return getPublicTokenHeadersRaw(
        finalContentType,
        storefrontApiVersion,
        (overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) ?? publicStorefrontToken ?? ""
      );
    }
  };
}
function getPublicTokenHeadersRaw(contentType, storefrontApiVersion, accessToken) {
  return {
    // default to json
    "content-type": contentType === "graphql" ? "application/graphql" : "application/json",
    "X-SDK-Variant": "hydrogen-react",
    "X-SDK-Variant-Source": "react",
    "X-SDK-Version": storefrontApiVersion,
    "X-Shopify-Storefront-Access-Token": accessToken
  };
}
var warnings = /* @__PURE__ */ new Set();
var H2_PREFIX_ERROR = "[h2:error:createStorefrontClient] ";
var warnOnce = (string, type = "warn") => {
  if (!warnings.has(string)) {
    console[type](`[h2:${type}:createStorefrontClient] ` + string);
    warnings.add(string);
  }
};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ShopifyProvider.mjs
var defaultShopifyContext = {
  storeDomain: "test",
  storefrontToken: "abc123",
  storefrontApiVersion: SFAPI_VERSION,
  countryIsoCode: "US",
  languageIsoCode: "EN",
  getStorefrontApiUrl() {
    return "";
  },
  getPublicTokenHeaders() {
    return {};
  },
  getShopifyDomain() {
    return "";
  }
};
var ShopifyContext = (0, import_react7.createContext)(
  defaultShopifyContext
);
function useShop() {
  const shopContext = (0, import_react7.useContext)(ShopifyContext);
  if (!shopContext) {
    throw new Error(`'useShop()' must be a descendent of <ShopifyProvider/>`);
  }
  return shopContext;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cart-constants.mjs
var SHOPIFY_STOREFRONT_ID_HEADER = "Shopify-Storefront-Id";
var SHOPIFY_STOREFRONT_Y_HEADER = "Shopify-Storefront-Y";
var SHOPIFY_STOREFRONT_S_HEADER = "Shopify-Storefront-S";
var SHOPIFY_Y = "_shopify_y";
var SHOPIFY_S = "_shopify_s";

// node_modules/worktop/cookie/index.mjs
var g = /* @__PURE__ */ new Set([
  "domain",
  "path",
  "max-age",
  "expires",
  "samesite",
  "secure",
  "httponly"
]);
function u(a) {
  let r = {}, e, t, n2 = 0, m = a.split(/;\s*/g), s2, i2;
  for (; n2 < m.length; n2++)
    if (t = m[n2], e = t.indexOf("="), ~e) {
      if (s2 = t.substring(0, e++).trim(), i2 = t.substring(e).trim(), i2[0] === '"' && (i2 = i2.substring(1, i2.length - 1)), ~i2.indexOf("%"))
        try {
          i2 = decodeURIComponent(i2);
        } catch (f) {
        }
      g.has(t = s2.toLowerCase()) ? t === "expires" ? r.expires = new Date(i2) : t === "max-age" ? r.maxage = +i2 : r[t] = i2 : r[s2] = i2;
    } else
      (s2 = t.trim().toLowerCase()) && (s2 === "httponly" || s2 === "secure") && (r[s2] = true);
  return r;
}
function l(a, r, e = {}) {
  let t = a + "=" + encodeURIComponent(r);
  return e.expires && (t += "; Expires=" + new Date(e.expires).toUTCString()), e.maxage != null && e.maxage >= 0 && (t += "; Max-Age=" + (e.maxage | 0)), e.domain && (t += "; Domain=" + e.domain), e.path && (t += "; Path=" + e.path), e.samesite && (t += "; SameSite=" + e.samesite), (e.secure || e.samesite === "None") && (t += "; Secure"), e.httponly && (t += "; HttpOnly"), t;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cookies-utils.mjs
var tokenHash = "xxxx-4xxx-xxxx-xxxxxxxxxxxx";
function buildUUID() {
  let hash = "";
  try {
    const crypto2 = window.crypto;
    const randomValuesArray = new Uint16Array(31);
    crypto2.getRandomValues(randomValuesArray);
    let i2 = 0;
    hash = tokenHash.replace(/[x]/g, (c) => {
      const r = randomValuesArray[i2] % 16;
      const v2 = c === "x" ? r : r & 3 | 8;
      i2++;
      return v2.toString(16);
    }).toUpperCase();
  } catch (err) {
    hash = tokenHash.replace(/[x]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v2 = c === "x" ? r : r & 3 | 8;
      return v2.toString(16);
    }).toUpperCase();
  }
  return `${hexTime()}-${hash}`;
}
function hexTime() {
  let dateNumber = 0;
  let perfNumber = 0;
  dateNumber = (/* @__PURE__ */ new Date()).getTime() >>> 0;
  try {
    perfNumber = performance.now() >>> 0;
  } catch (err) {
    perfNumber = 0;
  }
  const output = Math.abs(dateNumber + perfNumber).toString(16).toLowerCase();
  return output.padStart(8, "0");
}
function getShopifyCookies(cookies) {
  const cookieData = u(cookies);
  return {
    [SHOPIFY_Y]: cookieData[SHOPIFY_Y] || "",
    [SHOPIFY_S]: cookieData[SHOPIFY_S] || ""
  };
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useCartAPIStateMachine.mjs
var import_react10 = __toESM(require_react(), 1);
var INITIALIZING_CART_EVENTS = {
  CART_FETCH: {
    target: "cartFetching"
  },
  CART_CREATE: {
    target: "cartCreating"
  },
  CART_SET: {
    target: "idle",
    actions: [
      i({
        rawCartResult: (_, event) => event.payload.cart,
        cart: (_, event) => cartFromGraphQL(event.payload.cart)
      })
    ]
  }
};
function cartFromGraphQL(cart) {
  return {
    ...cart,
    lines: flattenConnection(cart == null ? void 0 : cart.lines),
    note: cart.note ?? void 0
  };
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartProvider.mjs
var CartContext = (0, import_react11.createContext)(null);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ProductProvider.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var ProductOptionsContext = (0, import_react12.createContext)(null);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/BaseButton.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-constants.mjs
var AnalyticsEventName = {
  PAGE_VIEW: "PAGE_VIEW",
  ADD_TO_CART: "ADD_TO_CART",
  PAGE_VIEW_2: "PAGE_VIEW_2",
  COLLECTION_VIEW: "COLLECTION_VIEW",
  PRODUCT_VIEW: "PRODUCT_VIEW",
  SEARCH_VIEW: "SEARCH_VIEW"
};
var AnalyticsPageType = {
  article: "article",
  blog: "blog",
  captcha: "captcha",
  cart: "cart",
  collection: "collection",
  customersAccount: "customers/account",
  customersActivateAccount: "customers/activate_account",
  customersAddresses: "customers/addresses",
  customersLogin: "customers/login",
  customersOrder: "customers/order",
  customersRegister: "customers/register",
  customersResetPassword: "customers/reset_password",
  giftCard: "gift_card",
  home: "index",
  listCollections: "list-collections",
  forbidden: "403",
  notFound: "404",
  page: "page",
  password: "password",
  product: "product",
  policy: "policy",
  search: "search"
};
var ShopifySalesChannel = {
  hydrogen: "hydrogen",
  headless: "headless"
};
var ShopifyAppId = {
  hydrogen: "6167201",
  headless: "12875497473"
};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-utils.mjs
function schemaWrapper(schemaId, payload) {
  return {
    schema_id: schemaId,
    payload,
    metadata: {
      event_created_at_ms: Date.now()
    }
  };
}
function parseGid(gid) {
  const defaultReturn = {
    id: "",
    resource: null,
    resourceId: null,
    search: "",
    searchParams: new URLSearchParams(),
    hash: ""
  };
  if (typeof gid !== "string") {
    return defaultReturn;
  }
  try {
    const { search, searchParams, pathname, hash } = new URL(gid);
    const pathnameParts = pathname.split("/");
    const lastPathnamePart = pathnameParts[pathnameParts.length - 1];
    const resourcePart = pathnameParts[pathnameParts.length - 2];
    if (!lastPathnamePart || !resourcePart) {
      return defaultReturn;
    }
    const id = `${lastPathnamePart}${search}${hash}` || "";
    const resourceId = lastPathnamePart || null;
    const resource = resourcePart ?? null;
    return { id, resource, resourceId, search, searchParams, hash };
  } catch {
    return defaultReturn;
  }
}
function addDataIf(keyValuePairs, formattedData) {
  if (typeof keyValuePairs !== "object") {
    return {};
  }
  Object.entries(keyValuePairs).forEach(([key, value]) => {
    if (value) {
      formattedData[key] = value;
    }
  });
  return formattedData;
}
function errorIfServer(fnName) {
  if (typeof document === "undefined") {
    console.error(
      `${fnName} should only be used within the useEffect callback or event handlers`
    );
    return true;
  }
  return false;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-schema-trekkie-storefront-page-view.mjs
var SCHEMA_ID = "trekkie_storefront_page_view/1.4";
var OXYGEN_DOMAIN = "myshopify.dev";
function pageView(payload) {
  const pageViewPayload = payload;
  const { id, resource } = parseGid(pageViewPayload.resourceId);
  const resourceType = resource ? resource.toLowerCase() : void 0;
  return [
    schemaWrapper(
      SCHEMA_ID,
      addDataIf(
        {
          pageType: pageViewPayload.pageType,
          customerId: parseInt(parseGid(pageViewPayload.customerId).id || "0"),
          resourceType,
          resourceId: parseInt(id)
        },
        formatPayload(pageViewPayload)
      )
    )
  ];
}
function formatPayload(payload) {
  return {
    appClientId: payload.shopifySalesChannel ? ShopifyAppId[payload.shopifySalesChannel] : ShopifyAppId.headless,
    isMerchantRequest: isMerchantRequest(payload.url),
    hydrogenSubchannelId: payload.storefrontId || payload.hydrogenSubchannelId || "0",
    isPersistentCookie: payload.hasUserConsent,
    uniqToken: payload.uniqueToken,
    visitToken: payload.visitToken,
    microSessionId: buildUUID(),
    microSessionCount: 1,
    url: payload.url,
    path: payload.path,
    search: payload.search,
    referrer: payload.referrer,
    title: payload.title,
    shopId: parseInt(parseGid(payload.shopId).id),
    currency: payload.currency,
    contentLanguage: payload.acceptedLanguage || "en"
  };
}
function isMerchantRequest(url) {
  if (typeof url !== "string") {
    return false;
  }
  const hostname = new URL(url).hostname;
  if (hostname.indexOf(OXYGEN_DOMAIN) !== -1 || hostname === "localhost") {
    return true;
  }
  return false;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/packages/hydrogen-react/package.json.mjs
var version = "2025.7.0";

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-schema-custom-storefront-customer-tracking.mjs
var SCHEMA_ID2 = "custom_storefront_customer_tracking/1.2";
var PAGE_RENDERED_EVENT_NAME = "page_rendered";
var COLLECTION_PAGE_RENDERED_EVENT_NAME = "collection_page_rendered";
var PRODUCT_PAGE_RENDERED_EVENT_NAME = "product_page_rendered";
var PRODUCT_ADDED_TO_CART_EVENT_NAME = "product_added_to_cart";
var SEARCH_SUBMITTED_EVENT_NAME = "search_submitted";
function prepareAdditionalPayload(payload) {
  return {
    canonical_url: payload.canonicalUrl || payload.url,
    customer_id: parseInt(parseGid(payload.customerId).id || "0")
  };
}
function pageView2(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  const pageType = pageViewPayload.pageType;
  const pageViewEvents = [];
  pageViewEvents.push(
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload
        },
        formatPayload2(pageViewPayload)
      )
    )
  );
  switch (pageType) {
    case AnalyticsPageType.collection:
      pageViewEvents.push(
        schemaWrapper(
          SCHEMA_ID2,
          addDataIf(
            {
              event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
              ...additionalPayload,
              collection_name: pageViewPayload.collectionHandle,
              collection_id: parseInt(
                parseGid(pageViewPayload.collectionId).id
              )
            },
            formatPayload2(pageViewPayload)
          )
        )
      );
      break;
    case AnalyticsPageType.product:
      pageViewEvents.push(
        schemaWrapper(
          SCHEMA_ID2,
          addDataIf(
            {
              event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
              ...additionalPayload,
              products: formatProductPayload(pageViewPayload.products),
              total_value: pageViewPayload.totalValue
            },
            formatPayload2(pageViewPayload)
          )
        )
      );
      break;
    case AnalyticsPageType.search:
      pageViewEvents.push(
        schemaWrapper(
          SCHEMA_ID2,
          addDataIf(
            {
              event_name: SEARCH_SUBMITTED_EVENT_NAME,
              ...additionalPayload,
              search_string: pageViewPayload.searchString
            },
            formatPayload2(pageViewPayload)
          )
        )
      );
      break;
  }
  return pageViewEvents;
}
function pageView22(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function collectionView(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload,
          collection_name: pageViewPayload.collectionHandle,
          collection_id: parseInt(parseGid(pageViewPayload.collectionId).id)
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function productView(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload,
          products: formatProductPayload(pageViewPayload.products),
          total_value: pageViewPayload.totalValue
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function searchView(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: SEARCH_SUBMITTED_EVENT_NAME,
          ...additionalPayload,
          search_string: pageViewPayload.searchString
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function addToCart(payload) {
  const addToCartPayload = payload;
  const cartToken = parseGid(addToCartPayload.cartId);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PRODUCT_ADDED_TO_CART_EVENT_NAME,
          customerId: addToCartPayload.customerId,
          cart_token: (cartToken == null ? void 0 : cartToken.id) ? `${cartToken.id}` : null,
          total_value: addToCartPayload.totalValue,
          products: formatProductPayload(addToCartPayload.products),
          customer_id: parseInt(
            parseGid(addToCartPayload.customerId).id || "0"
          )
        },
        formatPayload2(addToCartPayload)
      )
    )
  ];
}
function formatPayload2(payload) {
  return {
    source: payload.shopifySalesChannel || ShopifySalesChannel.headless,
    asset_version_id: payload.assetVersionId || version,
    hydrogenSubchannelId: payload.storefrontId || payload.hydrogenSubchannelId || "0",
    is_persistent_cookie: payload.hasUserConsent,
    deprecated_visit_token: payload.visitToken,
    unique_token: payload.uniqueToken,
    event_time: Date.now(),
    event_id: buildUUID(),
    event_source_url: payload.url,
    referrer: payload.referrer,
    user_agent: payload.userAgent,
    navigation_type: payload.navigationType,
    navigation_api: payload.navigationApi,
    shop_id: parseInt(parseGid(payload.shopId).id),
    currency: payload.currency,
    ccpa_enforced: payload.ccpaEnforced || false,
    gdpr_enforced: payload.gdprEnforced || false,
    gdpr_enforced_as_string: payload.gdprEnforced ? "true" : "false",
    analytics_allowed: payload.analyticsAllowed || false,
    marketing_allowed: payload.marketingAllowed || false,
    sale_of_data_allowed: payload.saleOfDataAllowed || false
  };
}
function formatProductPayload(products) {
  return products ? products.map((p) => {
    const product = addDataIf(
      {
        variant_gid: p.variantGid,
        category: p.category,
        sku: p.sku,
        product_id: parseInt(parseGid(p.productGid).id),
        variant_id: parseInt(parseGid(p.variantGid).id)
      },
      {
        product_gid: p.productGid,
        name: p.name,
        variant: p.variantName || "",
        brand: p.brand,
        price: parseFloat(p.price),
        quantity: Number(p.quantity || 0)
      }
    );
    return JSON.stringify(product);
  }) : [];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics.mjs
function sendShopifyAnalytics(event, shopDomain) {
  const { eventName, payload } = event;
  if (!payload.hasUserConsent) return Promise.resolve();
  let events = [];
  const pageViewPayload = payload;
  if (eventName === AnalyticsEventName.PAGE_VIEW) {
    events = events.concat(
      pageView(pageViewPayload),
      pageView2(pageViewPayload)
    );
  } else if (eventName === AnalyticsEventName.ADD_TO_CART) {
    events = events.concat(
      addToCart(payload)
    );
  } else if (eventName === AnalyticsEventName.PAGE_VIEW_2) {
    events = events.concat(
      pageView(pageViewPayload),
      pageView22(pageViewPayload)
    );
  } else if (eventName === AnalyticsEventName.COLLECTION_VIEW) {
    events = events.concat(collectionView(pageViewPayload));
  } else if (eventName === AnalyticsEventName.PRODUCT_VIEW) {
    events = events.concat(productView(pageViewPayload));
  } else if (eventName === AnalyticsEventName.SEARCH_VIEW) {
    events = events.concat(searchView(pageViewPayload));
  }
  if (events.length) {
    return sendToShopify(events, shopDomain);
  } else {
    return Promise.resolve();
  }
}
function isLighthouseUserAgent() {
  if (typeof window === "undefined" || !window.navigator) return false;
  return /Chrome-Lighthouse/.test(window.navigator.userAgent);
}
var ERROR_MESSAGE = "sendShopifyAnalytics request is unsuccessful";
function sendToShopify(events, shopDomain) {
  if (isLighthouseUserAgent()) {
    return Promise.resolve();
  }
  const eventsToBeSent = {
    events,
    metadata: {
      event_sent_at_ms: Date.now()
    }
  };
  try {
    return fetch(
      shopDomain ? `https://${shopDomain}/.well-known/shopify/monorail/unstable/produce_batch` : "https://monorail-edge.shopifysvc.com/unstable/produce_batch",
      {
        method: "post",
        headers: {
          "content-type": "text/plain"
        },
        body: JSON.stringify(eventsToBeSent)
      }
    ).then((response) => {
      if (!response.ok) {
        throw new Error("Response failed");
      }
      return response.text();
    }).then((data) => {
      if (data) {
        const jsonResponse = JSON.parse(data);
        jsonResponse.result.forEach((eventResponse) => {
          if (eventResponse.status !== 200) {
            console.error(ERROR_MESSAGE, "\n\n", eventResponse.message);
          }
        });
      }
    }).catch((err) => {
      console.error(ERROR_MESSAGE, err);
      if (true) {
        throw new Error(ERROR_MESSAGE);
      }
    });
  } catch (error) {
    return Promise.resolve();
  }
}
function getClientBrowserParameters() {
  if (errorIfServer("getClientBrowserParameters")) {
    return {
      uniqueToken: "",
      visitToken: "",
      url: "",
      path: "",
      search: "",
      referrer: "",
      title: "",
      userAgent: "",
      navigationType: "",
      navigationApi: ""
    };
  }
  const [navigationType, navigationApi] = getNavigationType();
  const cookies = getShopifyCookies(document.cookie);
  return {
    uniqueToken: cookies[SHOPIFY_Y],
    visitToken: cookies[SHOPIFY_S],
    url: location.href,
    path: location.pathname,
    search: location.search,
    referrer: document.referrer,
    title: document.title,
    userAgent: navigator.userAgent,
    navigationType,
    navigationApi
  };
}
function getNavigationTypeExperimental() {
  try {
    const navigationEntries = (performance == null ? void 0 : performance.getEntriesByType) && (performance == null ? void 0 : performance.getEntriesByType("navigation"));
    if (navigationEntries && navigationEntries[0]) {
      const rawType = window.performance.getEntriesByType(
        "navigation"
      )[0]["type"];
      const navType = rawType && rawType.toString();
      return navType;
    }
  } catch (err) {
  }
  return void 0;
}
function getNavigationTypeLegacy() {
  var _a3, _b;
  try {
    if (PerformanceNavigation && ((_a3 = performance == null ? void 0 : performance.navigation) == null ? void 0 : _a3.type) !== null && ((_b = performance == null ? void 0 : performance.navigation) == null ? void 0 : _b.type) !== void 0) {
      const rawType = performance.navigation.type;
      switch (rawType) {
        case PerformanceNavigation.TYPE_NAVIGATE:
          return "navigate";
        case PerformanceNavigation.TYPE_RELOAD:
          return "reload";
        case PerformanceNavigation.TYPE_BACK_FORWARD:
          return "back_forward";
        default:
          return `unknown: ${rawType}`;
      }
    }
  } catch (err) {
  }
  return void 0;
}
function getNavigationType() {
  try {
    let navApi = "PerformanceNavigationTiming";
    let navType = getNavigationTypeExperimental();
    if (!navType) {
      navType = getNavigationTypeLegacy();
      navApi = "performance.navigation";
    }
    if (navType) {
      return [navType, navApi];
    } else {
      return ["unknown", "unknown"];
    }
  } catch (err) {
  }
  return ["error", "error"];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/BuyNowButton.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartCheckoutButton.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartCost.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Money.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useMoney.mjs
var import_react17 = __toESM(require_react(), 1);
function useMoney(money) {
  const { countryIsoCode, languageIsoCode } = useShop();
  const locale = languageIsoCode.includes("_") ? languageIsoCode.replace("_", "-") : `${languageIsoCode}-${countryIsoCode}`;
  if (!locale) {
    throw new Error(
      `useMoney(): Unable to get 'locale' from 'useShop()', which means that 'locale' was not passed to '<ShopifyProvider/>'. 'locale' is required for 'useMoney()' to work`
    );
  }
  const amount = parseFloat(money.amount);
  let isCurrencySupported = true;
  try {
    new Intl.NumberFormat(locale, {
      style: "currency",
      currency: money.currencyCode
    });
  } catch (e) {
    if (e instanceof RangeError && e.message.includes("currency")) {
      isCurrencySupported = false;
    }
  }
  const {
    defaultFormatter,
    nameFormatter,
    narrowSymbolFormatter,
    withoutTrailingZerosFormatter,
    withoutCurrencyFormatter,
    withoutTrailingZerosOrCurrencyFormatter
  } = (0, import_react17.useMemo)(() => {
    const options = isCurrencySupported ? {
      style: "currency",
      currency: money.currencyCode
    } : {
      style: "decimal",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    };
    return {
      defaultFormatter: getLazyFormatter(locale, options),
      nameFormatter: getLazyFormatter(locale, {
        ...options,
        currencyDisplay: "name"
      }),
      narrowSymbolFormatter: getLazyFormatter(locale, {
        ...options,
        currencyDisplay: "narrowSymbol"
      }),
      withoutTrailingZerosFormatter: getLazyFormatter(locale, {
        ...options,
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      }),
      withoutCurrencyFormatter: getLazyFormatter(locale, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }),
      withoutTrailingZerosOrCurrencyFormatter: getLazyFormatter(locale, {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      })
    };
  }, [money.currencyCode, locale, isCurrencySupported]);
  const isPartCurrency = (part) => part.type === "currency";
  const lazyFormatters = (0, import_react17.useMemo)(
    () => ({
      original: () => money,
      currencyCode: () => money.currencyCode,
      localizedString: () => {
        const formatted = defaultFormatter().format(amount);
        return isCurrencySupported ? formatted : `${formatted} ${money.currencyCode}`;
      },
      parts: () => {
        const parts = defaultFormatter().formatToParts(amount);
        if (!isCurrencySupported) {
          parts.push(
            { type: "literal", value: " " },
            { type: "currency", value: money.currencyCode }
          );
        }
        return parts;
      },
      withoutTrailingZeros: () => {
        const formatted = amount % 1 === 0 ? withoutTrailingZerosFormatter().format(amount) : defaultFormatter().format(amount);
        return isCurrencySupported ? formatted : `${formatted} ${money.currencyCode}`;
      },
      withoutTrailingZerosAndCurrency: () => amount % 1 === 0 ? withoutTrailingZerosOrCurrencyFormatter().format(amount) : withoutCurrencyFormatter().format(amount),
      currencyName: () => {
        var _a3;
        return ((_a3 = nameFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a3.value) ?? money.currencyCode;
      },
      // e.g. "US dollars"
      currencySymbol: () => {
        var _a3;
        return ((_a3 = defaultFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a3.value) ?? money.currencyCode;
      },
      // e.g. "USD"
      currencyNarrowSymbol: () => {
        var _a3;
        return ((_a3 = narrowSymbolFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a3.value) ?? "";
      },
      // e.g. "$"
      amount: () => defaultFormatter().formatToParts(amount).filter(
        (part) => ["decimal", "fraction", "group", "integer", "literal"].includes(
          part.type
        )
      ).map((part) => part.value).join("")
    }),
    [
      money,
      amount,
      isCurrencySupported,
      nameFormatter,
      defaultFormatter,
      narrowSymbolFormatter,
      withoutCurrencyFormatter,
      withoutTrailingZerosFormatter,
      withoutTrailingZerosOrCurrencyFormatter
    ]
  );
  return (0, import_react17.useMemo)(
    () => new Proxy(lazyFormatters, {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
      get: (target, key) => {
        var _a3;
        return (_a3 = Reflect.get(target, key)) == null ? void 0 : _a3.call(null);
      }
    }),
    [lazyFormatters]
  );
}
var formatterCache = /* @__PURE__ */ new Map();
function getLazyFormatter(locale, options) {
  const key = JSON.stringify([locale, options]);
  return function() {
    let formatter = formatterCache.get(key);
    if (!formatter) {
      try {
        formatter = new Intl.NumberFormat(locale, options);
      } catch (error) {
        if (error instanceof RangeError && error.message.includes("currency")) {
          const fallbackOptions = { ...options };
          delete fallbackOptions.currency;
          delete fallbackOptions.currencyDisplay;
          delete fallbackOptions.currencySign;
          formatter = new Intl.NumberFormat(locale, fallbackOptions);
        } else {
          throw error;
        }
      }
      formatterCache.set(key, formatter);
    }
    return formatter;
  };
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Money.mjs
function Money({
  data,
  as,
  withoutCurrency,
  withoutTrailingZeros,
  measurement,
  measurementSeparator = "/",
  ...passthroughProps
}) {
  if (!isMoney(data)) {
    throw new Error(
      `<Money/> needs a valid 'data' prop that has 'amount' and 'currencyCode'`
    );
  }
  const moneyObject = useMoney(data);
  const Wrapper = as ?? "div";
  let output = moneyObject.localizedString;
  if (withoutCurrency || withoutTrailingZeros) {
    if (withoutCurrency && !withoutTrailingZeros) {
      output = moneyObject.amount;
    } else if (!withoutCurrency && withoutTrailingZeros) {
      output = moneyObject.withoutTrailingZeros;
    } else {
      output = moneyObject.withoutTrailingZerosAndCurrency;
    }
  }
  return (0, import_jsx_runtime8.jsxs)(Wrapper, { ...passthroughProps, children: [
    output,
    measurement && measurement.referenceUnit && (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
      measurementSeparator,
      measurement.referenceUnit
    ] })
  ] });
}
function isMoney(maybeMoney) {
  return typeof maybeMoney.amount === "string" && !!maybeMoney.amount && typeof maybeMoney.currencyCode === "string" && !!maybeMoney.currencyCode;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartLineProvider.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var CartLineContext = (0, import_react18.createContext)(null);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartLineQuantity.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartLineQuantityAdjustButton.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/codegen.helpers.mjs
var storefrontApiCustomScalars = {
  // Keep in sync with the definitions in the app/nextjs/codegen.ts!
  DateTime: "string",
  Decimal: "string",
  HTML: "string",
  URL: "string",
  Color: "string",
  UnsignedInt64: "string"
};
var customerAccountApiCustomScalars = {
  DateTime: "string",
  Decimal: "string",
  HTML: "string",
  ISO8601DateTime: "string",
  URL: "string",
  UnsignedInt64: "string"
};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ExternalVideo.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
var ExternalVideo = (0, import_react20.forwardRef)(
  (props, ref) => {
    const {
      data,
      options,
      id = data.id,
      frameBorder = "0",
      allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
      allowFullScreen = true,
      loading = "lazy",
      ...passthroughProps
    } = props;
    if (!data.embedUrl) {
      throw new Error(`<ExternalVideo/> requires the 'embedUrl' property`);
    }
    let finalUrl = data.embedUrl;
    if (options) {
      const urlObject = new URL(data.embedUrl);
      for (const [key, value] of Object.entries(options)) {
        if (typeof value === "undefined") {
          continue;
        }
        urlObject.searchParams.set(key, value.toString());
      }
      finalUrl = urlObject.toString();
    }
    return (0, import_jsx_runtime13.jsx)(
      "iframe",
      {
        ...passthroughProps,
        id: id ?? data.embedUrl,
        title: data.alt ?? data.id ?? "external video",
        frameBorder,
        allow,
        allowFullScreen,
        src: finalUrl,
        loading,
        ref
      }
    );
  }
);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/optionValueDecoder.mjs
var OPTION_VALUE_SEPARATOR = ",";
var V1_CONTROL_CHARS = {
  OPTION: ":",
  END_OF_PREFIX: ",",
  SEQUENCE_GAP: " ",
  RANGE: "-"
};
var isOptionValueCombinationInEncodedVariant = /* @__PURE__ */ (() => {
  const decodedOptionValues = /* @__PURE__ */ new Map();
  return function(targetOptionValueCombination, encodedVariantField) {
    var _a3;
    if (targetOptionValueCombination.length === 0) {
      return false;
    }
    if (!decodedOptionValues.has(encodedVariantField)) {
      const decodedOptionValuesSet = /* @__PURE__ */ new Set();
      for (const optionValue of decodeEncodedVariant(encodedVariantField)) {
        decodedOptionValuesSet.add(optionValue.join(OPTION_VALUE_SEPARATOR));
        for (let i2 = 0; i2 < optionValue.length; i2++) {
          decodedOptionValuesSet.add(
            optionValue.slice(0, i2 + 1).join(OPTION_VALUE_SEPARATOR)
          );
        }
      }
      decodedOptionValues.set(encodedVariantField, decodedOptionValuesSet);
    }
    return Boolean(
      (_a3 = decodedOptionValues.get(encodedVariantField)) == null ? void 0 : _a3.has(targetOptionValueCombination.join(OPTION_VALUE_SEPARATOR))
    );
  };
})();
function decodeEncodedVariant(encodedVariantField) {
  if (!encodedVariantField) return [];
  if (encodedVariantField.startsWith("v1_")) {
    return v1Decoder(stripVersion(encodedVariantField));
  }
  throw new Error("Unsupported option value encoding");
}
var stripVersion = (encodedVariantField) => encodedVariantField.replace(/^v1_/, "");
function v1Decoder(encodedVariantField) {
  const tokenizer = /[ :,-]/g;
  let index = 0;
  let token;
  const options = [];
  const currentOptionValue = [];
  let depth = 0;
  let rangeStart = null;
  while (token = tokenizer.exec(encodedVariantField)) {
    const operation = token[0];
    const optionValueIndex = Number.parseInt(encodedVariantField.slice(index, token.index)) || 0;
    if (rangeStart !== null) {
      for (; rangeStart < optionValueIndex; rangeStart++) {
        currentOptionValue[depth] = rangeStart;
        options.push([...currentOptionValue]);
      }
      rangeStart = null;
    }
    currentOptionValue[depth] = optionValueIndex;
    if (operation === V1_CONTROL_CHARS.RANGE) {
      rangeStart = optionValueIndex;
    } else if (operation === V1_CONTROL_CHARS.OPTION) {
      depth++;
    } else {
      if (operation === V1_CONTROL_CHARS.SEQUENCE_GAP || operation === V1_CONTROL_CHARS.END_OF_PREFIX && encodedVariantField[token.index - 1] !== V1_CONTROL_CHARS.END_OF_PREFIX) {
        options.push([...currentOptionValue]);
      }
      if (operation === V1_CONTROL_CHARS.END_OF_PREFIX) {
        currentOptionValue.pop();
        depth--;
      }
    }
    index = tokenizer.lastIndex;
  }
  const encodingEndsWithIndex = encodedVariantField.match(/\d+$/g);
  if (encodingEndsWithIndex) {
    const finalValueIndex = parseInt(encodingEndsWithIndex[0]);
    if (rangeStart != null) {
      for (; rangeStart <= finalValueIndex; rangeStart++) {
        currentOptionValue[depth] = rangeStart;
        options.push([...currentOptionValue]);
      }
    } else {
      options.push([finalValueIndex]);
    }
  }
  return options;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/getProductOptions.mjs
function mapProductOptions(options) {
  return Object.assign(
    {},
    ...options.map((option) => {
      return {
        [option.name]: Object.assign(
          {},
          ...(option == null ? void 0 : option.optionValues) ? option.optionValues.map((value, index) => {
            return { [value.name]: index };
          }) : []
        )
      };
    })
  );
}
function mapSelectedProductOptionToObject(options) {
  return Object.assign(
    {},
    ...options.map((key) => {
      return { [key.name]: key.value };
    })
  );
}
function mapSelectedProductOptionToObjectAsString(options) {
  return JSON.stringify(mapSelectedProductOptionToObject(options));
}
function encodeSelectedProductOptionAsKey(selectedOption) {
  if (Array.isArray(selectedOption)) {
    return JSON.stringify(
      Object.assign(
        {},
        ...selectedOption.map((option) => ({ [option.name]: option.value }))
      )
    );
  } else {
    return JSON.stringify(selectedOption);
  }
}
function buildEncodingArrayFromSelectedOptions(selectedOption, productOptionMappings) {
  const encoding = Object.keys(selectedOption).map((key) => {
    return productOptionMappings[key] ? productOptionMappings[key][selectedOption[key]] : null;
  });
  return encoding.filter((code) => code !== null);
}
function mapVariants(variants) {
  return Object.assign(
    {},
    ...variants.map((variant) => {
      const variantKey = encodeSelectedProductOptionAsKey(
        variant.selectedOptions || []
      );
      return { [variantKey]: variant };
    })
  );
}
var PRODUCT_INPUTS = [
  "options",
  "selectedOrFirstAvailableVariant",
  "adjacentVariants"
];
var PRODUCT_INPUTS_EXTRA = [
  "handle",
  "encodedVariantExistence",
  "encodedVariantAvailability"
];
function logErrorAndReturnFalse(key) {
  console.error(
    `[h2:error:getProductOptions] product.${key} is missing. Make sure you query for this field from the Storefront API.`
  );
  return false;
}
function checkProductParam(product, checkAll = false) {
  var _a3;
  let validParam = true;
  const productKeys = Object.keys(product);
  (checkAll ? [...PRODUCT_INPUTS, ...PRODUCT_INPUTS_EXTRA] : PRODUCT_INPUTS).forEach((key) => {
    if (!productKeys.includes(key)) {
      validParam = logErrorAndReturnFalse(key);
    }
  });
  if (product.options) {
    const firstOption = product == null ? void 0 : product.options[0];
    if (checkAll && !(firstOption == null ? void 0 : firstOption.name)) {
      validParam = logErrorAndReturnFalse("options.name");
    }
    if ((_a3 = product == null ? void 0 : product.options[0]) == null ? void 0 : _a3.optionValues) {
      let firstOptionValues = product.options[0].optionValues[0];
      if (checkAll && !(firstOptionValues == null ? void 0 : firstOptionValues.name)) {
        validParam = logErrorAndReturnFalse("options.optionValues.name");
      }
      firstOptionValues = product.options[0].optionValues.filter(
        (value) => !!(value == null ? void 0 : value.firstSelectableVariant)
      )[0];
      if (firstOptionValues == null ? void 0 : firstOptionValues.firstSelectableVariant) {
        validParam = checkProductVariantParam(
          firstOptionValues.firstSelectableVariant,
          "options.optionValues.firstSelectableVariant",
          validParam,
          checkAll
        );
      }
    } else {
      validParam = logErrorAndReturnFalse("options.optionValues");
    }
  }
  if (product.selectedOrFirstAvailableVariant) {
    validParam = checkProductVariantParam(
      product.selectedOrFirstAvailableVariant,
      "selectedOrFirstAvailableVariant",
      validParam,
      checkAll
    );
  }
  if (!!product.adjacentVariants && product.adjacentVariants[0]) {
    validParam = checkProductVariantParam(
      product.adjacentVariants[0],
      "adjacentVariants",
      validParam,
      checkAll
    );
  }
  return validParam ? product : {};
}
function checkProductVariantParam(variant, key, currentValidParamState, checkAll) {
  var _a3;
  let validParam = currentValidParamState;
  if (checkAll && !((_a3 = variant.product) == null ? void 0 : _a3.handle)) {
    validParam = logErrorAndReturnFalse(`${key}.product.handle`);
  }
  if (variant.selectedOptions) {
    const firstSelectedOption = variant.selectedOptions[0];
    if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.name)) {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions.name`);
    }
    if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.value)) {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions.value`);
    }
  } else {
    validParam = logErrorAndReturnFalse(`${key}.selectedOptions`);
  }
  return validParam;
}
function getAdjacentAndFirstAvailableVariants(product) {
  const checkedProduct = checkProductParam(product);
  if (!checkedProduct.options) return [];
  const availableVariants = {};
  checkedProduct.options.map((option) => {
    var _a3;
    (_a3 = option.optionValues) == null ? void 0 : _a3.map((value) => {
      if (value.firstSelectableVariant) {
        const variantKey = mapSelectedProductOptionToObjectAsString(
          value.firstSelectableVariant.selectedOptions
        );
        availableVariants[variantKey] = value.firstSelectableVariant;
      }
    });
  });
  checkedProduct.adjacentVariants.map((variant) => {
    const variantKey = mapSelectedProductOptionToObjectAsString(
      variant.selectedOptions
    );
    availableVariants[variantKey] = variant;
  });
  const selectedVariant = checkedProduct.selectedOrFirstAvailableVariant;
  if (selectedVariant) {
    const variantKey = mapSelectedProductOptionToObjectAsString(
      selectedVariant.selectedOptions
    );
    availableVariants[variantKey] = selectedVariant;
  }
  return Object.values(availableVariants);
}
function getProductOptions(product) {
  const checkedProduct = checkProductParam(product, true);
  if (!checkedProduct.options) return [];
  const {
    options,
    selectedOrFirstAvailableVariant: selectedVariant,
    adjacentVariants,
    encodedVariantExistence,
    encodedVariantAvailability,
    handle: productHandle
  } = checkedProduct;
  const selectedOptionKeys = selectedVariant == null ? void 0 : selectedVariant.selectedOptions.map(
    (option) => option.name
  );
  const filteredOptions = options.filter((option) => {
    return selectedOptionKeys && selectedOptionKeys.indexOf(option.name) >= 0;
  });
  const productOptionMappings = mapProductOptions(options);
  const variants = mapVariants(
    selectedVariant ? [selectedVariant, ...adjacentVariants] : adjacentVariants
  );
  const selectedOptions = mapSelectedProductOptionToObject(
    selectedVariant ? selectedVariant.selectedOptions : []
  );
  const productOptions = filteredOptions.map((option, optionIndex) => {
    return {
      ...option,
      optionValues: option.optionValues.map((value) => {
        var _a3;
        const targetOptionParams = { ...selectedOptions };
        targetOptionParams[option.name] = value.name;
        const targetKey = encodeSelectedProductOptionAsKey(
          targetOptionParams || []
        );
        const encodingKey = buildEncodingArrayFromSelectedOptions(
          targetOptionParams || [],
          productOptionMappings
        );
        const topDownKey = encodingKey.slice(0, optionIndex + 1);
        const exists = isOptionValueCombinationInEncodedVariant(
          topDownKey,
          encodedVariantExistence || ""
        );
        const available = isOptionValueCombinationInEncodedVariant(
          topDownKey,
          encodedVariantAvailability || ""
        );
        const variant = variants[targetKey] || value.firstSelectableVariant;
        let variantOptionParam = {};
        if (variant) {
          variantOptionParam = mapSelectedProductOptionToObject(
            variant.selectedOptions || []
          );
        }
        const searchParams = new URLSearchParams(variantOptionParam);
        const handle = ((_a3 = variant == null ? void 0 : variant.product) == null ? void 0 : _a3.handle) || productHandle;
        return {
          ...value,
          variant,
          handle,
          variantUriQuery: searchParams.toString(),
          selected: selectedOptions[option.name] === value.name,
          exists,
          available,
          isDifferentProduct: handle !== productHandle
        };
      })
    };
  });
  return productOptions;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Image.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var IMAGE_FRAGMENT = `#graphql
  fragment Image on Image {
    altText
    url
    width
    height
  }
`;
var Image = React2.forwardRef(
  ({
    alt,
    aspectRatio,
    crop = "center",
    data,
    decoding = "async",
    height = "auto",
    loader = shopifyLoader,
    loading = "lazy",
    sizes,
    src,
    srcSetOptions = {
      intervals: 15,
      startingWidth: 200,
      incrementSize: 200,
      placeholderWidth: 100
    },
    width = "100%",
    ...passthroughProps
  }, ref) => {
    const normalizedData = React2.useMemo(() => {
      const dataWidth = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.width : void 0;
      const dataHeight = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.height : void 0;
      return {
        width: dataWidth,
        height: dataHeight,
        unitsMatch: Boolean(unitsMatch(dataWidth, dataHeight))
      };
    }, [data]);
    const normalizedProps = React2.useMemo(() => {
      const nWidthProp = width || "100%";
      const widthParts = getUnitValueParts(nWidthProp.toString());
      const nWidth = `${widthParts.number}${widthParts.unit}`;
      const autoHeight = height === void 0 || height === null;
      const heightParts = autoHeight ? null : getUnitValueParts(height.toString());
      const fixedHeight = heightParts ? `${heightParts.number}${heightParts.unit}` : "";
      const nHeight = autoHeight ? "auto" : fixedHeight;
      const nSrc = src || (data == null ? void 0 : data.url);
      if (!nSrc) {
        console.warn(
          `No src or data.url provided to Image component.`,
          (passthroughProps == null ? void 0 : passthroughProps.key) || ""
        );
      }
      const nAlt = (data == null ? void 0 : data.altText) && !alt ? data == null ? void 0 : data.altText : alt || "";
      const nAspectRatio = aspectRatio ? aspectRatio : normalizedData.unitsMatch ? [
        getNormalizedFixedUnit(normalizedData.width),
        getNormalizedFixedUnit(normalizedData.height)
      ].join("/") : void 0;
      return {
        width: nWidth,
        height: nHeight,
        src: nSrc,
        alt: nAlt,
        aspectRatio: nAspectRatio
      };
    }, [
      width,
      height,
      src,
      data,
      alt,
      aspectRatio,
      normalizedData,
      passthroughProps == null ? void 0 : passthroughProps.key
    ]);
    const { intervals, startingWidth, incrementSize, placeholderWidth } = srcSetOptions;
    const imageWidths = React2.useMemo(() => {
      return generateImageWidths(
        width,
        intervals,
        startingWidth,
        incrementSize
      );
    }, [width, intervals, startingWidth, incrementSize]);
    const fixedWidth = isFixedWidth(normalizedProps.width);
    if (!sizes && !fixedWidth) {
      console.warn(
        [
          "No sizes prop provided to Image component,",
          "you may be loading unnecessarily large images.",
          `Image used is ${src || (data == null ? void 0 : data.url) || (passthroughProps == null ? void 0 : passthroughProps.key) || "unknown"}`
        ].join(" ")
      );
    }
    if (fixedWidth) {
      return (0, import_jsx_runtime14.jsx)(
        FixedWidthImage,
        {
          aspectRatio,
          crop,
          decoding,
          height,
          imageWidths,
          loader,
          loading,
          normalizedProps,
          passthroughProps,
          ref,
          width,
          data
        }
      );
    } else {
      return (0, import_jsx_runtime14.jsx)(
        FluidImage,
        {
          aspectRatio,
          crop,
          decoding,
          imageWidths,
          loader,
          loading,
          normalizedProps,
          passthroughProps,
          placeholderWidth,
          ref,
          sizes,
          data
        }
      );
    }
  }
);
var FixedWidthImage = React2.forwardRef(
  ({
    aspectRatio,
    crop,
    decoding,
    height,
    imageWidths,
    loader = shopifyLoader,
    loading,
    normalizedProps,
    passthroughProps,
    width,
    data
  }, ref) => {
    const fixed = React2.useMemo(() => {
      const intWidth = getNormalizedFixedUnit(width);
      const intHeight = getNormalizedFixedUnit(height);
      const fixedAspectRatio = aspectRatio ? aspectRatio : unitsMatch(normalizedProps.width, normalizedProps.height) ? [intWidth, intHeight].join("/") : normalizedProps.aspectRatio ? normalizedProps.aspectRatio : void 0;
      const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, fixedAspectRatio, crop, {
        width: (data == null ? void 0 : data.width) ?? void 0,
        height: (data == null ? void 0 : data.height) ?? void 0
      });
      const fixedHeight = intHeight ? intHeight : fixedAspectRatio && intWidth ? intWidth * (parseAspectRatio(fixedAspectRatio) ?? 1) : void 0;
      const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
      const src = loader({
        src: normalizedProps.src,
        width: intWidth,
        height: fixedHeight,
        crop: normalizedProps.height === "auto" ? void 0 : crop
      });
      return {
        width: intWidth,
        aspectRatio: fixedAspectRatio,
        height: fixedHeight,
        srcSet,
        src
      };
    }, [
      aspectRatio,
      crop,
      data,
      height,
      imageWidths,
      loader,
      normalizedProps,
      width
    ]);
    return (0, import_jsx_runtime14.jsx)(
      "img",
      {
        ref,
        alt: normalizedProps.alt,
        decoding,
        height: fixed.height,
        loading,
        src: fixed.src,
        srcSet: fixed.srcSet,
        width: fixed.width,
        style: {
          aspectRatio: fixed.aspectRatio,
          ...passthroughProps.style
        },
        ...passthroughProps
      }
    );
  }
);
var FluidImage = React2.forwardRef(
  ({
    crop,
    decoding,
    imageWidths,
    loader = shopifyLoader,
    loading,
    normalizedProps,
    passthroughProps,
    placeholderWidth,
    sizes,
    data
  }, ref) => {
    const fluid = React2.useMemo(() => {
      const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, normalizedProps.aspectRatio, crop, {
        width: (data == null ? void 0 : data.width) ?? void 0,
        height: (data == null ? void 0 : data.height) ?? void 0
      });
      const placeholderHeight = normalizedProps.aspectRatio && placeholderWidth ? placeholderWidth * (parseAspectRatio(normalizedProps.aspectRatio) ?? 1) : void 0;
      const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
      const src = loader({
        src: normalizedProps.src,
        width: placeholderWidth,
        height: placeholderHeight,
        crop
      });
      return {
        placeholderHeight,
        srcSet,
        src
      };
    }, [crop, data, imageWidths, loader, normalizedProps, placeholderWidth]);
    return (0, import_jsx_runtime14.jsx)(
      "img",
      {
        ref,
        alt: normalizedProps.alt,
        decoding,
        height: fluid.placeholderHeight,
        loading,
        sizes,
        src: fluid.src,
        srcSet: fluid.srcSet,
        width: placeholderWidth,
        ...passthroughProps,
        style: {
          width: normalizedProps.width,
          aspectRatio: normalizedProps.aspectRatio,
          ...passthroughProps.style
        }
      }
    );
  }
);
var PLACEHOLDER_DOMAIN = "https://placeholder.shopify.com";
function shopifyLoader({ src, width, height, crop }) {
  if (!src) {
    return "";
  }
  const url = new URL(src, PLACEHOLDER_DOMAIN);
  if (width) {
    url.searchParams.append("width", Math.round(width).toString());
  }
  if (height) {
    url.searchParams.append("height", Math.round(height).toString());
  }
  if (crop) {
    url.searchParams.append("crop", crop);
  }
  return url.href.replace(PLACEHOLDER_DOMAIN, "");
}
function unitsMatch(width = "100%", height = "auto") {
  return getUnitValueParts(width.toString()).unit === getUnitValueParts(height.toString()).unit;
}
function getUnitValueParts(value) {
  const unit = value.replace(/[0-9.]/g, "");
  const number = parseFloat(value.replace(unit, ""));
  return {
    unit: unit === "" ? number === void 0 ? "auto" : "px" : unit,
    number
  };
}
function getNormalizedFixedUnit(value) {
  if (value === void 0) {
    return;
  }
  const { unit, number } = getUnitValueParts(value.toString());
  switch (unit) {
    case "em":
      return number * 16;
    case "rem":
      return number * 16;
    case "px":
      return number;
    case "":
      return number;
    default:
      return;
  }
}
function isFixedWidth(width) {
  const fixedEndings = /\d(px|em|rem)$/;
  return typeof width === "number" || fixedEndings.test(width);
}
function generateSrcSet(src, sizesArray, loader = shopifyLoader) {
  if (!src) {
    return "";
  }
  if ((sizesArray == null ? void 0 : sizesArray.length) === 0 || !sizesArray) {
    return src;
  }
  return sizesArray.map(
    (size, i2) => `${loader({
      src,
      width: size.width,
      height: size.height,
      crop: size.crop
    })} ${sizesArray.length === 3 ? `${i2 + 1}x` : `${size.width ?? 0}w`}`
  ).join(`, `);
}
function generateImageWidths(width = "100%", intervals, startingWidth, incrementSize) {
  const responsive = Array.from(
    { length: intervals },
    (_, i2) => i2 * incrementSize + startingWidth
  );
  const fixed = Array.from(
    { length: 3 },
    (_, i2) => (i2 + 1) * (getNormalizedFixedUnit(width) ?? 0)
  );
  return isFixedWidth(width) ? fixed : responsive;
}
function parseAspectRatio(aspectRatio) {
  if (!aspectRatio) return;
  const [width, height] = aspectRatio.split("/");
  return 1 / (Number(width) / Number(height));
}
function generateSizes(imageWidths, aspectRatio, crop = "center", sourceDimensions) {
  if (!imageWidths) return;
  return imageWidths.map((width) => {
    return {
      width,
      height: aspectRatio ? width * (parseAspectRatio(aspectRatio) ?? 1) : void 0,
      crop
    };
  }).filter(({ width, height }) => {
    if ((sourceDimensions == null ? void 0 : sourceDimensions.width) && width > sourceDimensions.width) {
      return false;
    }
    if ((sourceDimensions == null ? void 0 : sourceDimensions.height) && height && height > sourceDimensions.height) {
      return false;
    }
    return true;
  });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/load-script.mjs
var import_react21 = __toESM(require_react(), 1);
var SCRIPTS_LOADED = {};
function loadScript(src, options) {
  const isScriptLoaded = SCRIPTS_LOADED[src];
  if (isScriptLoaded) {
    return isScriptLoaded;
  }
  const promise = new Promise((resolve, reject) => {
    const script = document.createElement("script");
    if (options == null ? void 0 : options.module) {
      script.type = "module";
    } else {
      script.type = "text/javascript";
    }
    script.src = src;
    script.onload = () => {
      resolve(true);
    };
    script.onerror = () => {
      reject(false);
    };
    if ((options == null ? void 0 : options.in) === "head") {
      document.head.appendChild(script);
    } else {
      document.body.appendChild(script);
    }
    const attributes = options == null ? void 0 : options.attributes;
    if (attributes) {
      Object.keys(attributes).forEach((key) => {
        script.setAttribute(key, attributes[key]);
      });
    }
  });
  SCRIPTS_LOADED[src] = promise;
  return promise;
}
function useLoadScript(url, options) {
  const [status, setStatus] = (0, import_react21.useState)("loading");
  (0, import_react21.useEffect)(
    () => {
      loadScript(url, options).then(() => setStatus("done")).catch(() => setStatus("error"));
    },
    // Ignore options changes since it won't trigger a new load.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [url]
  );
  return status;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/MediaFile.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Video.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var Video = (0, import_react22.forwardRef)((props, ref) => {
  var _a3;
  const {
    data,
    previewImageOptions,
    id = data.id,
    playsInline = true,
    controls = true,
    sourceProps = {},
    ...passthroughProps
  } = props;
  const posterUrl = shopifyLoader({
    src: ((_a3 = data.previewImage) == null ? void 0 : _a3.url) ?? "",
    ...previewImageOptions
  });
  if (!data.sources) {
    throw new Error(`<Video/> requires a 'data.sources' array`);
  }
  return (
    // eslint-disable-next-line jsx-a11y/media-has-caption
    (0, import_jsx_runtime15.jsx)(
      "video",
      {
        ...passthroughProps,
        id,
        playsInline,
        controls,
        poster: posterUrl,
        ref,
        children: data.sources.map((source) => {
          if (!((source == null ? void 0 : source.url) && (source == null ? void 0 : source.mimeType))) {
            throw new Error(`<Video/> needs 'source.url' and 'source.mimeType'`);
          }
          return (0, import_react22.createElement)(
            "source",
            {
              ...sourceProps,
              key: source.url,
              src: source.url,
              type: source.mimeType
            }
          );
        })
      }
    )
  );
});

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ModelViewer.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
function ModelViewer(props) {
  var _a3, _b, _c;
  const [modelViewer, setModelViewer] = (0, import_react23.useState)(
    void 0
  );
  const callbackRef = (0, import_react23.useCallback)((node) => {
    setModelViewer(node);
  }, []);
  const { data, children, className, ...passthroughProps } = props;
  const modelViewerLoadedStatus = useLoadScript(
    "https://unpkg.com/@google/model-viewer@v1.12.1/dist/model-viewer.min.js",
    {
      module: true
    }
  );
  (0, import_react23.useEffect)(() => {
    const hydrogenEventListener = {
      error: passthroughProps.onError,
      load: passthroughProps.onLoad,
      preload: passthroughProps.onPreload,
      "model-visibility": passthroughProps.onModelVisibility,
      progress: passthroughProps.onProgress,
      "ar-status": passthroughProps.onArStatus,
      "ar-tracking": passthroughProps.onArTracking,
      "quick-look-button-tapped": passthroughProps.onQuickLookButtonTapped,
      "camera-change": passthroughProps.onCameraChange,
      "environment-change": passthroughProps.onEnvironmentChange,
      play: passthroughProps.onPlay,
      pause: passthroughProps.onPause,
      "scene-graph-ready": passthroughProps.onSceneGraphReady
    };
    if (!modelViewer) {
      return;
    }
    Object.entries(hydrogenEventListener).forEach(
      ([eventName, callbackFunc]) => {
        if (callbackFunc) {
          modelViewer.addEventListener(eventName, callbackFunc);
        }
      }
    );
    return () => {
      if (modelViewer == null) {
        return;
      }
      Object.entries(hydrogenEventListener).forEach(
        ([eventName, callbackFunc]) => {
          if (callbackFunc) {
            modelViewer.removeEventListener(eventName, callbackFunc);
          }
        }
      );
    };
  }, [
    modelViewer,
    passthroughProps.onArStatus,
    passthroughProps.onArTracking,
    passthroughProps.onCameraChange,
    passthroughProps.onEnvironmentChange,
    passthroughProps.onError,
    passthroughProps.onLoad,
    passthroughProps.onModelVisibility,
    passthroughProps.onPause,
    passthroughProps.onPlay,
    passthroughProps.onPreload,
    passthroughProps.onProgress,
    passthroughProps.onQuickLookButtonTapped,
    passthroughProps.onSceneGraphReady
  ]);
  if (modelViewerLoadedStatus !== "done") {
    return null;
  }
  if (!((_b = (_a3 = data.sources) == null ? void 0 : _a3[0]) == null ? void 0 : _b.url)) {
    const sourcesUrlError = `<ModelViewer/> requires 'data.sources' prop to be an array, with an object that has a property 'url' on it. Rendering 'null'`;
    {
      throw new Error(sourcesUrlError);
    }
  }
  if (!data.alt) {
    console.warn(
      `<ModelViewer/> requires the 'data.alt' prop for accessibility`
    );
  }
  return (0, import_jsx_runtime16.jsx)(
    "model-viewer",
    {
      ref: callbackRef,
      ...passthroughProps,
      class: className,
      id: passthroughProps.id ?? data.id,
      src: data.sources[0].url,
      alt: data.alt ?? null,
      "camera-controls": passthroughProps.cameraControls ?? true,
      poster: (passthroughProps.poster || ((_c = data.previewImage) == null ? void 0 : _c.url)) ?? null,
      autoplay: passthroughProps.autoplay ?? true,
      loading: passthroughProps.loading,
      reveal: passthroughProps.reveal,
      ar: passthroughProps.ar,
      "ar-modes": passthroughProps.arModes,
      "ar-scale": passthroughProps.arScale,
      "ar-placement": passthroughProps.arPlacement,
      "ios-src": passthroughProps.iosSrc,
      "touch-action": passthroughProps.touchAction,
      "disable-zoom": passthroughProps.disableZoom,
      "orbit-sensitivity": passthroughProps.orbitSensitivity,
      "auto-rotate": passthroughProps.autoRotate,
      "auto-rotate-delay": passthroughProps.autoRotateDelay,
      "rotation-per-second": passthroughProps.rotationPerSecond,
      "interaction-policy": passthroughProps.interactionPolicy,
      "interaction-prompt": passthroughProps.interactionPrompt,
      "interaction-prompt-style": passthroughProps.interactionPromptStyle,
      "interaction-prompt-threshold": passthroughProps.interactionPromptThreshold,
      "camera-orbit": passthroughProps.cameraOrbit,
      "camera-target": passthroughProps.cameraTarget,
      "field-of-view": passthroughProps.fieldOfView,
      "max-camera-orbit": passthroughProps.maxCameraOrbit,
      "min-camera-orbit": passthroughProps.minCameraOrbit,
      "max-field-of-view": passthroughProps.maxFieldOfView,
      "min-field-of-view": passthroughProps.minFieldOfView,
      bounds: passthroughProps.bounds,
      "interpolation-decay": passthroughProps.interpolationDecay ?? 100,
      "skybox-image": passthroughProps.skyboxImage,
      "environment-image": passthroughProps.environmentImage,
      exposure: passthroughProps.exposure,
      "shadow-intensity": passthroughProps.shadowIntensity ?? 0,
      "shadow-softness": passthroughProps.shadowSoftness ?? 0,
      "animation-name": passthroughProps.animationName,
      "animation-crossfade-duration": passthroughProps.animationCrossfadeDuration,
      "variant-name": passthroughProps.variantName,
      orientation: passthroughProps.orientation,
      scale: passthroughProps.scale,
      children
    }
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/MediaFile.mjs
function MediaFile({
  data,
  mediaOptions,
  ...passthroughProps
}) {
  switch (data.__typename) {
    case "MediaImage": {
      if (!data.image) {
        const noDataImage = `<MediaFile/>: 'data.image' does not exist for __typename of 'MediaImage'; rendering 'null' by default.`;
        {
          throw new Error(noDataImage);
        }
      }
      return (0, import_jsx_runtime17.jsx)(
        Image,
        {
          ...passthroughProps,
          ...mediaOptions == null ? void 0 : mediaOptions.image,
          data: data.image
        }
      );
    }
    case "Video": {
      return (0, import_jsx_runtime17.jsx)(Video, { ...passthroughProps, ...mediaOptions == null ? void 0 : mediaOptions.video, data });
    }
    case "ExternalVideo": {
      return (0, import_jsx_runtime17.jsx)(
        ExternalVideo,
        {
          ...passthroughProps,
          ...mediaOptions == null ? void 0 : mediaOptions.externalVideo,
          data
        }
      );
    }
    case "Model3d": {
      return (
        // @ts-expect-error There are issues with the inferred HTML attribute types here for ModelViewer (and contentEditable), but I think that's a little bit beyond me at the moment
        (0, import_jsx_runtime17.jsx)(
          ModelViewer,
          {
            ...passthroughProps,
            ...mediaOptions == null ? void 0 : mediaOptions.modelViewer,
            data
          }
        )
      );
    }
    default: {
      const typenameMissingMessage = `<MediaFile /> requires the '__typename' property to exist on the 'data' prop in order to render the matching sub-component for this type of media.`;
      {
        throw new Error(typenameMissingMessage);
      }
    }
  }
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/parse-metafield.mjs
function parseMetafield(metafield) {
  if (!metafield.type) {
    const noTypeError = `parseMetafield(): The 'type' field is required in order to parse the Metafield.`;
    {
      throw new Error(noTypeError);
    }
  }
  switch (metafield.type) {
    case "boolean":
      return {
        ...metafield,
        parsedValue: metafield.value === "true"
      };
    case "collection_reference":
    case "file_reference":
    case "page_reference":
    case "product_reference":
    case "variant_reference":
      return {
        ...metafield,
        parsedValue: metafield.reference
      };
    case "color":
    case "multi_line_text_field":
    case "single_line_text_field":
    case "url":
      return {
        ...metafield,
        parsedValue: metafield.value
      };
    // TODO: 'money' should probably be parsed even further to like `useMoney()`, but that logic needs to be extracted first so it's not a hook
    case "money": {
      let parsedValue = null;
      try {
        const parsed = parseJSON(metafield.value ?? "");
        if (parsed && typeof parsed === "object" && "currency_code" in parsed) {
          const moneyData = parsed;
          parsedValue = {
            amount: moneyData.amount,
            currencyCode: moneyData.currency_code
          };
        } else if (parsed && typeof parsed === "object" && "currencyCode" in parsed) {
          parsedValue = parsed;
        } else {
          parsedValue = parsed;
        }
      } catch (err) {
        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
        {
          throw new Error(parseError);
        }
      }
      return {
        ...metafield,
        parsedValue
      };
    }
    case "dimension":
    case "json":
    case "rating":
    case "volume":
    case "weight":
    case "rich_text_field":
    case "list.color":
    case "list.dimension":
    case "list.number_integer":
    case "list.number_decimal":
    case "list.rating":
    case "list.single_line_text_field":
    case "list.url":
    case "list.volume":
    case "list.weight": {
      let parsedValue = null;
      try {
        parsedValue = parseJSON(metafield.value ?? "");
      } catch (err) {
        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
        {
          throw new Error(parseError);
        }
      }
      return {
        ...metafield,
        parsedValue
      };
    }
    case "date":
    case "date_time":
      return {
        ...metafield,
        parsedValue: new Date(metafield.value ?? "")
      };
    case "list.date":
    case "list.date_time": {
      const jsonParseValue = parseJSON((metafield == null ? void 0 : metafield.value) ?? "");
      return {
        ...metafield,
        parsedValue: jsonParseValue.map((dateString) => new Date(dateString))
      };
    }
    case "number_decimal":
    case "number_integer":
      return {
        ...metafield,
        parsedValue: Number(metafield.value)
      };
    case "list.collection_reference":
    case "list.file_reference":
    case "list.page_reference":
    case "list.product_reference":
    case "list.variant_reference":
      return {
        ...metafield,
        parsedValue: flattenConnection(metafield.references ?? void 0)
      };
    default: {
      const typeNotFoundError = `parseMetafield(): the 'metafield.type' you passed in is not supported. Your type: "${metafield.type}". If you believe this is an error, please open an issue on GitHub.`;
      {
        throw new Error(typeNotFoundError);
      }
    }
  }
}
function parseJSON(json) {
  if (String(json).includes("__proto__")) {
    return JSON.parse(json, (k, v2) => {
      if (k !== "__proto__") return v2;
    });
  }
  return JSON.parse(json);
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ProductPrice.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/RichText.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/RichText.components.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react24 = __toESM(require_react(), 1);
var RichTextComponents = {
  root: Root,
  heading: Heading,
  paragraph: Paragraph,
  text: Text,
  link: RichTextLink,
  list: List,
  "list-item": ListItem
};
function Root({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("div", { children: node.children });
}
function Heading({
  node
}) {
  return (0, import_react24.createElement)(`h${node.level ?? "1"}`, null, node.children);
}
function Paragraph({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("p", { children: node.children });
}
function Text({
  node
}) {
  if (node.bold && node.italic)
    return (0, import_jsx_runtime19.jsx)("em", { children: (0, import_jsx_runtime19.jsx)("strong", { children: node.value }) });
  if (node.bold) return (0, import_jsx_runtime19.jsx)("strong", { children: node.value });
  if (node.italic) return (0, import_jsx_runtime19.jsx)("em", { children: node.value });
  return node.value;
}
function RichTextLink({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("a", { href: node.url, title: node.title, target: node.target, children: node.children });
}
function List({
  node
}) {
  const List2 = node.listType === "unordered" ? "ul" : "ol";
  return (0, import_jsx_runtime19.jsx)(List2, { children: node.children });
}
function ListItem({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("li", { children: node.children });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/RichText.mjs
function RichText({
  as,
  data,
  plain,
  components,
  ...passthroughProps
}) {
  try {
    const Wrapper = as ?? "div";
    const parsedData = (0, import_react25.useMemo)(
      () => JSON.parse(data),
      [data]
    );
    return (0, import_jsx_runtime20.jsx)(Wrapper, { ...passthroughProps, children: plain ? richTextToString(parsedData) : serializeRichTextASTNode(components, parsedData) });
  } catch (e) {
    throw new Error(
      "[h2:error:RichText] Parsing error. Make sure to pass a JSON string of rich text metafield",
      {
        cause: e
      }
    );
  }
}
function serializeRichTextASTNode(components = {}, node, index = 0) {
  let children;
  if ("children" in node) {
    children = node.children.map(
      (child, childIndex) => serializeRichTextASTNode(components, child, childIndex)
    );
  }
  const Component = components[node.type === "list-item" ? "listItem" : node.type] ?? RichTextComponents[node.type];
  switch (node.type) {
    case "root":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index,
          node: {
            type: "root",
            children
          }
        }
      );
    case "heading":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index,
          node: {
            type: "heading",
            level: node.level,
            children
          }
        }
      );
    case "paragraph":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index,
          node: {
            type: "paragraph",
            children
          }
        }
      );
    case "text": {
      const elements = (node.value ?? "").split("\n").flatMap((value, subindex) => {
        const key = `${index}-${value}-${subindex}`;
        const textElement = (0, import_react25.createElement)(
          Component,
          {
            key,
            node: {
              type: "text",
              italic: node.italic,
              bold: node.bold,
              value
            }
          }
        );
        return subindex === 0 ? textElement : [(0, import_react25.createElement)("br", { key: `${key}-br` }), textElement];
      });
      return elements.length > 1 ? (0, import_react25.createElement)(import_react25.Fragment, { key: index }, elements) : elements[0];
    }
    case "link":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index,
          node: {
            type: "link",
            url: node.url,
            title: node.title,
            target: node.target,
            children
          }
        }
      );
    case "list":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index,
          node: {
            type: "list",
            listType: node.listType,
            children
          }
        }
      );
    case "list-item":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index,
          node: {
            type: "list-item",
            children
          }
        }
      );
  }
}
function richTextToString(node, result = []) {
  switch (node.type) {
    case "root":
      node.children.forEach((child) => richTextToString(child, result));
      break;
    case "heading":
    case "paragraph":
      node.children.forEach((child) => richTextToString(child, result));
      result.push(" ");
      break;
    case "text":
      result.push(node.value || "");
      break;
    case "link":
      node.children.forEach((child) => richTextToString(child, result));
      break;
    case "list":
      node.children.forEach((item) => {
        if (item.children) {
          item.children.forEach((child) => richTextToString(child, result));
        }
        result.push(" ");
      });
      break;
    default:
      throw new Error(`Unknown node encountered ${node.type}`);
  }
  return result.join("").trim();
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ShopPayButton.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var SHOPJS_URL = "https://cdn.shopify.com/shopifycloud/shop-js/v1.0/client.js";
function isChannel(channel) {
  return channel === "headless" || channel === "hydrogen";
}
function ShopPayButton({
  channel,
  variantIds,
  className,
  variantIdsAndQuantities,
  width,
  storeDomain: _storeDomain
}) {
  const shop = useShop();
  const storeDomain = _storeDomain || (shop == null ? void 0 : shop.storeDomain);
  const shopPayLoadedStatus = useLoadScript(SHOPJS_URL);
  let ids = [];
  let channelAttribution;
  if (!storeDomain || storeDomain === defaultShopifyContext.storeDomain) {
    throw new Error(MissingStoreDomainErrorMessage);
  }
  if (variantIds && variantIdsAndQuantities) {
    throw new Error(DoublePropsErrorMessage);
  }
  if (!variantIds && !variantIdsAndQuantities) {
    throw new Error(MissingPropsErrorMessage);
  }
  if (channel) {
    if (isChannel(channel)) {
      channelAttribution = channel;
    } else {
      throw new Error(InvalidChannelErrorMessage);
    }
  }
  if (variantIds) {
    ids = variantIds.reduce((prev, curr) => {
      const bareId = parseGid(curr).id;
      if (bareId) {
        prev.push(bareId);
      }
      return prev;
    }, []);
  } else if (variantIdsAndQuantities) {
    ids = variantIdsAndQuantities.reduce((prev, curr) => {
      const bareId = parseGid(curr == null ? void 0 : curr.id).id;
      if (bareId) {
        prev.push(`${bareId}:${(curr == null ? void 0 : curr.quantity) ?? 1}`);
      }
      return prev;
    }, []);
  } else {
    throw new Error(MissingPropsErrorMessage);
  }
  if (ids.length === 0) {
    throw new Error(InvalidPropsErrorMessage);
  }
  const style = width ? {
    "--shop-pay-button-width": width
  } : void 0;
  return (0, import_jsx_runtime21.jsx)("div", { className, style, children: shopPayLoadedStatus === "done" && (0, import_jsx_runtime21.jsx)(
    "shop-pay-button",
    {
      ...channelAttribution ? { channel: channelAttribution } : {},
      "store-url": storeDomain,
      variants: ids.join(",")
    }
  ) });
}
var MissingStoreDomainErrorMessage = 'You must pass a "storeDomain" prop to the "ShopPayButton" component, or wrap it in a "ShopifyProvider" component.';
var InvalidPropsErrorMessage = `You must pass in "variantIds" in the form of ["gid://shopify/ProductVariant/1"]`;
var MissingPropsErrorMessage = `You must pass in either "variantIds" or "variantIdsAndQuantities" to ShopPayButton`;
var DoublePropsErrorMessage = `You must provide either a variantIds or variantIdsAndQuantities prop, but not both in the ShopPayButton component`;
var InvalidChannelErrorMessage = `Invalid channel attribution value. Must be either "headless" or "hydrogen"`;

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useSelectedOptionInUrlParam.mjs
var import_react26 = __toESM(require_react(), 1);
function useSelectedOptionInUrlParam(selectedOptions) {
  (0, import_react26.useEffect)(() => {
    const optionsSearchParams = new URLSearchParams(
      mapSelectedProductOptionToObject(selectedOptions || [])
    );
    const currentSearchParams = new URLSearchParams(window.location.search);
    const combinedSearchParams = new URLSearchParams({
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ...Object.fromEntries(currentSearchParams),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ...Object.fromEntries(optionsSearchParams)
    });
    if (combinedSearchParams.size > 0) {
      window.history.replaceState(
        {},
        "",
        `${window.location.pathname}?${combinedSearchParams.toString()}`
      );
    }
  }, [JSON.stringify(selectedOptions)]);
  return null;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useShopifyCookies.mjs
var import_react27 = __toESM(require_react(), 1);
var longTermLength = 60 * 60 * 24 * 360 * 1;
var shortTermLength = 60 * 30;
function useShopifyCookies(options) {
  const {
    hasUserConsent = false,
    domain = "",
    checkoutDomain = ""
  } = options || {};
  (0, import_react27.useEffect)(() => {
    const cookies = getShopifyCookies(document.cookie);
    let currentDomain = domain || window.document.location.host;
    if (checkoutDomain) {
      const checkoutDomainParts = checkoutDomain.split(".").reverse();
      const currentDomainParts = currentDomain.split(".").reverse();
      const sameDomainParts = [];
      checkoutDomainParts.forEach((part, index) => {
        if (part === currentDomainParts[index]) {
          sameDomainParts.push(part);
        }
      });
      currentDomain = sameDomainParts.reverse().join(".");
    }
    if (/^localhost/.test(currentDomain)) currentDomain = "";
    const domainWithLeadingDot = currentDomain ? /^\./.test(currentDomain) ? currentDomain : `.${currentDomain}` : "";
    if (hasUserConsent) {
      setCookie(
        SHOPIFY_Y,
        cookies[SHOPIFY_Y] || buildUUID(),
        longTermLength,
        domainWithLeadingDot
      );
      setCookie(
        SHOPIFY_S,
        cookies[SHOPIFY_S] || buildUUID(),
        shortTermLength,
        domainWithLeadingDot
      );
    } else {
      setCookie(SHOPIFY_Y, "", 0, domainWithLeadingDot);
      setCookie(SHOPIFY_S, "", 0, domainWithLeadingDot);
    }
  }, [options, hasUserConsent, domain, checkoutDomain]);
}
function setCookie(name, value, maxage, domain) {
  document.cookie = l(name, value, {
    maxage,
    domain,
    samesite: "Lax",
    path: "/"
  });
}

// node_modules/@shopify/graphql-client/dist/graphql-client/constants.mjs
var CLIENT = "GraphQL Client";
var MIN_RETRIES = 0;
var MAX_RETRIES = 3;
var GQL_API_ERROR = "An error occurred while fetching from the API. Review 'graphQLErrors' for details.";
var UNEXPECTED_CONTENT_TYPE_ERROR = "Response returned unexpected Content-Type:";
var NO_DATA_OR_ERRORS_ERROR = "An unknown error has occurred. The API did not return a data object or any errors in its response.";
var CONTENT_TYPES = {
  json: "application/json",
  multipart: "multipart/mixed"
};
var SDK_VARIANT_HEADER = "X-SDK-Variant";
var SDK_VERSION_HEADER = "X-SDK-Version";
var DEFAULT_SDK_VARIANT = "shopify-graphql-client";
var DEFAULT_CLIENT_VERSION = "1.4.1";
var RETRY_WAIT_TIME = 1e3;
var RETRIABLE_STATUS_CODES = [429, 503];
var DEFER_OPERATION_REGEX = /@(defer)\b/i;
var NEWLINE_SEPARATOR = "\r\n";
var BOUNDARY_HEADER_REGEX = /boundary="?([^=";]+)"?/i;
var HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;

// node_modules/@shopify/graphql-client/dist/graphql-client/utilities.mjs
function formatErrorMessage(message, client = CLIENT) {
  return message.startsWith(`${client}`) ? message : `${client}: ${message}`;
}
function getErrorMessage(error) {
  return error instanceof Error ? error.message : JSON.stringify(error);
}
function getErrorCause(error) {
  return error instanceof Error && error.cause ? error.cause : void 0;
}
function combineErrors(dataArray) {
  return dataArray.flatMap(({ errors: errors2 }) => {
    return errors2 ?? [];
  });
}
function validateRetries({ client, retries }) {
  if (retries !== void 0 && (typeof retries !== "number" || retries < MIN_RETRIES || retries > MAX_RETRIES)) {
    throw new Error(`${client}: The provided "retries" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);
  }
}
function getKeyValueIfValid(key, value) {
  return value && (typeof value !== "object" || Array.isArray(value) || typeof value === "object" && Object.keys(value).length > 0) ? { [key]: value } : {};
}
function buildDataObjectByPath(path, data) {
  if (path.length === 0) {
    return data;
  }
  const key = path.pop();
  const newData = {
    [key]: data
  };
  if (path.length === 0) {
    return newData;
  }
  return buildDataObjectByPath(path, newData);
}
function combineObjects(baseObject, newObject) {
  return Object.keys(newObject || {}).reduce((acc, key) => {
    if ((typeof newObject[key] === "object" || Array.isArray(newObject[key])) && baseObject[key]) {
      acc[key] = combineObjects(baseObject[key], newObject[key]);
      return acc;
    }
    acc[key] = newObject[key];
    return acc;
  }, Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });
}
function buildCombinedDataObject([initialDatum, ...remainingData]) {
  return remainingData.reduce(combineObjects, { ...initialDatum });
}

// node_modules/@shopify/graphql-client/dist/graphql-client/http-fetch.mjs
function generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES }) {
  const httpFetch = async (requestParams, count, maxRetries) => {
    const nextCount = count + 1;
    const maxTries = maxRetries + 1;
    let response;
    try {
      response = await customFetchApi(...requestParams);
      clientLogger({
        type: "HTTP-Response",
        content: {
          requestParams,
          response
        }
      });
      if (!response.ok && retriableCodes.includes(response.status) && nextCount <= maxTries) {
        throw new Error();
      }
      const deprecationNotice = (response == null ? void 0 : response.headers.get("X-Shopify-API-Deprecated-Reason")) || "";
      if (deprecationNotice) {
        clientLogger({
          type: "HTTP-Response-GraphQL-Deprecation-Notice",
          content: {
            requestParams,
            deprecationNotice
          }
        });
      }
      return response;
    } catch (error) {
      if (nextCount <= maxTries) {
        const retryAfter = response == null ? void 0 : response.headers.get("Retry-After");
        await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);
        clientLogger({
          type: "HTTP-Retry",
          content: {
            requestParams,
            lastResponse: response,
            retryAttempt: count,
            maxRetries
          }
        });
        return httpFetch(requestParams, nextCount, maxRetries);
      }
      throw new Error(formatErrorMessage(`${maxRetries > 0 ? `Attempted maximum number of ${maxRetries} network retries. Last message - ` : ""}${getErrorMessage(error)}`, client));
    }
  };
  return httpFetch;
}
async function sleep(waitTime) {
  return new Promise((resolve) => setTimeout(resolve, waitTime));
}

// node_modules/@shopify/graphql-client/dist/graphql-client/graphql-client.mjs
function createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger }) {
  validateRetries({ client: CLIENT, retries });
  const config = {
    headers,
    url,
    retries
  };
  const clientLogger = generateClientLogger(logger);
  const httpFetch = generateHttpFetch({
    customFetchApi,
    clientLogger,
    defaultRetryWaitTime: RETRY_WAIT_TIME
  });
  const fetchFn = generateFetch(httpFetch, config);
  const request = generateRequest(fetchFn);
  const requestStream = generateRequestStream(fetchFn);
  return {
    config,
    fetch: fetchFn,
    request,
    requestStream
  };
}
function generateClientLogger(logger) {
  return (logContent) => {
    if (logger) {
      logger(logContent);
    }
  };
}
async function processJSONResponse(response) {
  const { errors: errors2, data, extensions } = await response.json();
  return {
    ...getKeyValueIfValid("data", data),
    ...getKeyValueIfValid("extensions", extensions),
    headers: response.headers,
    ...errors2 || !data ? {
      errors: {
        networkStatusCode: response.status,
        message: formatErrorMessage(errors2 ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),
        ...getKeyValueIfValid("graphQLErrors", errors2),
        response
      }
    } : {}
  };
}
function generateFetch(httpFetch, { url, headers, retries }) {
  return async (operation, options = {}) => {
    const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, keepalive, signal } = options;
    const body = JSON.stringify({
      query: operation,
      variables
    });
    validateRetries({ client: CLIENT, retries: overrideRetries });
    const flatHeaders = Object.entries({
      ...headers,
      ...overrideHeaders
    }).reduce((headers2, [key, value]) => {
      headers2[key] = Array.isArray(value) ? value.join(", ") : value.toString();
      return headers2;
    }, {});
    if (!flatHeaders[SDK_VARIANT_HEADER] && !flatHeaders[SDK_VERSION_HEADER]) {
      flatHeaders[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT;
      flatHeaders[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION;
    }
    const fetchParams = [
      overrideUrl ?? url,
      {
        method: "POST",
        headers: flatHeaders,
        body,
        signal,
        keepalive
      }
    ];
    return httpFetch(fetchParams, 1, overrideRetries ?? retries);
  };
}
function generateRequest(fetchFn) {
  return async (...props) => {
    if (DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation will result in a streamable response - use requestStream() instead."));
    }
    let response = null;
    try {
      response = await fetchFn(...props);
      const { status, statusText } = response;
      const contentType = response.headers.get("content-type") || "";
      if (!response.ok) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(statusText),
            response
          }
        };
      }
      if (!contentType.includes(CONTENT_TYPES.json)) {
        return {
          errors: {
            networkStatusCode: status,
            message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),
            response
          }
        };
      }
      return await processJSONResponse(response);
    } catch (error) {
      return {
        errors: {
          message: getErrorMessage(error),
          ...response == null ? {} : {
            networkStatusCode: response.status,
            response
          }
        }
      };
    }
  };
}
async function* getStreamBodyIterator(response) {
  const decoder = new TextDecoder();
  if (response.body[Symbol.asyncIterator]) {
    for await (const chunk of response.body) {
      yield decoder.decode(chunk);
    }
  } else {
    const reader = response.body.getReader();
    let readResult;
    try {
      while (!(readResult = await reader.read()).done) {
        yield decoder.decode(readResult.value);
      }
    } finally {
      reader.cancel();
    }
  }
}
function readStreamChunk(streamBodyIterator, boundary) {
  return {
    async *[Symbol.asyncIterator]() {
      try {
        let buffer = "";
        for await (const textChunk of streamBodyIterator) {
          buffer += textChunk;
          if (buffer.indexOf(boundary) > -1) {
            const lastBoundaryIndex = buffer.lastIndexOf(boundary);
            const fullResponses = buffer.slice(0, lastBoundaryIndex);
            const chunkBodies = fullResponses.split(boundary).filter((chunk) => chunk.trim().length > 0).map((chunk) => {
              const body = chunk.slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length).trim();
              return body;
            });
            if (chunkBodies.length > 0) {
              yield chunkBodies;
            }
            buffer = buffer.slice(lastBoundaryIndex + boundary.length);
            if (buffer.trim() === `--`) {
              buffer = "";
            }
          }
        }
      } catch (error) {
        throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);
      }
    }
  };
}
function createJsonResponseAsyncIterator(response) {
  return {
    async *[Symbol.asyncIterator]() {
      const processedResponse = await processJSONResponse(response);
      yield {
        ...processedResponse,
        hasNext: false
      };
    }
  };
}
function getResponseDataFromChunkBodies(chunkBodies) {
  return chunkBodies.map((value) => {
    try {
      return JSON.parse(value);
    } catch (error) {
      throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);
    }
  }).map((payload) => {
    const { data, incremental, hasNext, extensions, errors: errors2 } = payload;
    if (!incremental) {
      return {
        data: data || {},
        ...getKeyValueIfValid("errors", errors2),
        ...getKeyValueIfValid("extensions", extensions),
        hasNext
      };
    }
    const incrementalArray = incremental.map(({ data: data2, path, errors: errors3 }) => {
      return {
        data: data2 && path ? buildDataObjectByPath(path, data2) : {},
        ...getKeyValueIfValid("errors", errors3)
      };
    });
    return {
      data: incrementalArray.length === 1 ? incrementalArray[0].data : buildCombinedDataObject([
        ...incrementalArray.map(({ data: data2 }) => data2)
      ]),
      ...getKeyValueIfValid("errors", combineErrors(incrementalArray)),
      hasNext
    };
  });
}
function validateResponseData(responseErrors, combinedData) {
  if (responseErrors.length > 0) {
    throw new Error(GQL_API_ERROR, {
      cause: {
        graphQLErrors: responseErrors
      }
    });
  }
  if (Object.keys(combinedData).length === 0) {
    throw new Error(NO_DATA_OR_ERRORS_ERROR);
  }
}
function createMultipartResponseAsyncInterator(response, responseContentType) {
  var _a3, _b;
  const boundaryHeader = (responseContentType ?? "").match(BOUNDARY_HEADER_REGEX);
  const boundary = `--${boundaryHeader ? boundaryHeader[1] : "-"}`;
  if (!((_a3 = response.body) == null ? void 0 : _a3.getReader) && !((_b = response.body) == null ? void 0 : _b[Symbol.asyncIterator])) {
    throw new Error("API multipart response did not return an iterable body", {
      cause: response
    });
  }
  const streamBodyIterator = getStreamBodyIterator(response);
  let combinedData = {};
  let responseExtensions;
  return {
    async *[Symbol.asyncIterator]() {
      var _a4;
      try {
        let streamHasNext = true;
        for await (const chunkBodies of readStreamChunk(streamBodyIterator, boundary)) {
          const responseData = getResponseDataFromChunkBodies(chunkBodies);
          responseExtensions = ((_a4 = responseData.find((datum) => datum.extensions)) == null ? void 0 : _a4.extensions) ?? responseExtensions;
          const responseErrors = combineErrors(responseData);
          combinedData = buildCombinedDataObject([
            combinedData,
            ...responseData.map(({ data }) => data)
          ]);
          streamHasNext = responseData.slice(-1)[0].hasNext;
          validateResponseData(responseErrors, combinedData);
          yield {
            ...getKeyValueIfValid("data", combinedData),
            ...getKeyValueIfValid("extensions", responseExtensions),
            hasNext: streamHasNext
          };
        }
        if (streamHasNext) {
          throw new Error(`Response stream terminated unexpectedly`);
        }
      } catch (error) {
        const cause = getErrorCause(error);
        yield {
          ...getKeyValueIfValid("data", combinedData),
          ...getKeyValueIfValid("extensions", responseExtensions),
          errors: {
            message: formatErrorMessage(getErrorMessage(error)),
            networkStatusCode: response.status,
            ...getKeyValueIfValid("graphQLErrors", cause == null ? void 0 : cause.graphQLErrors),
            response
          },
          hasNext: false
        };
      }
    }
  };
}
function generateRequestStream(fetchFn) {
  return async (...props) => {
    if (!DEFER_OPERATION_REGEX.test(props[0])) {
      throw new Error(formatErrorMessage("This operation does not result in a streamable response - use request() instead."));
    }
    try {
      const response = await fetchFn(...props);
      const { statusText } = response;
      if (!response.ok) {
        throw new Error(statusText, { cause: response });
      }
      const responseContentType = response.headers.get("content-type") || "";
      switch (true) {
        case responseContentType.includes(CONTENT_TYPES.json):
          return createJsonResponseAsyncIterator(response);
        case responseContentType.includes(CONTENT_TYPES.multipart):
          return createMultipartResponseAsyncInterator(response, responseContentType);
        default:
          throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });
      }
    } catch (error) {
      return {
        async *[Symbol.asyncIterator]() {
          const response = getErrorCause(error);
          yield {
            errors: {
              message: formatErrorMessage(getErrorMessage(error)),
              ...getKeyValueIfValid("networkStatusCode", response == null ? void 0 : response.status),
              ...getKeyValueIfValid("response", response)
            },
            hasNext: false
          };
        }
      };
    }
  };
}

// node_modules/content-security-policy-builder/esm/mod.js
function buildContentSecurityPolicy({ directives }) {
  const result = [];
  const entries = directives instanceof Map ? directives.entries() : Object.entries(directives);
  const namesSeen = /* @__PURE__ */ new Set();
  for (const [rawName, rawValue] of entries) {
    const name = rawName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    if (namesSeen.has(name)) {
      throw new Error(`${rawName} is specified more than once`);
    }
    namesSeen.add(name);
    if (rawValue === true) {
      result.push(name);
      continue;
    }
    if (rawValue === false) {
      continue;
    }
    const value = typeof rawValue === "string" ? rawValue : rawValue.join(" ");
    result.push(value ? `${name} ${value}` : name);
  }
  return result.join("; ");
}

// node_modules/@shopify/hydrogen/dist/development/index.js
function AnalyticsView(props) {
  const { type, data = {}, customData } = props;
  const location2 = useLocation();
  const {
    publish: publish2,
    cart,
    prevCart,
    shop,
    customData: analyticProviderCustomData
  } = useAnalytics();
  const url = location2.pathname + location2.search;
  let viewPayload2 = {
    ...data,
    customData: {
      ...analyticProviderCustomData,
      ...customData
    },
    cart,
    prevCart,
    shop
  };
  (0, import_react28.useEffect)(() => {
    if (!(shop == null ? void 0 : shop.shopId)) return;
    viewPayload2 = {
      ...viewPayload2,
      url: window.location.href
    };
    publish2(type, viewPayload2);
  }, [publish2, url, shop == null ? void 0 : shop.shopId]);
  return null;
}
function AnalyticsPageView(props) {
  return (0, import_jsx_runtime22.jsx)(AnalyticsView, { ...props, type: "page_viewed" });
}
function AnalyticsProductView(props) {
  return (0, import_jsx_runtime22.jsx)(AnalyticsView, { ...props, type: "product_viewed" });
}
function AnalyticsCollectionView(props) {
  return (0, import_jsx_runtime22.jsx)(AnalyticsView, { ...props, type: "collection_viewed" });
}
function AnalyticsCartView(props) {
  return (0, import_jsx_runtime22.jsx)(AnalyticsView, { ...props, type: "cart_viewed" });
}
function AnalyticsSearchView(props) {
  return (0, import_jsx_runtime22.jsx)(AnalyticsView, { ...props, type: "search_viewed" });
}
function AnalyticsCustomView(props) {
  return (0, import_jsx_runtime22.jsx)(AnalyticsView, { ...props });
}
var AnalyticsEvent = {
  // Views
  PAGE_VIEWED: "page_viewed",
  PRODUCT_VIEWED: "product_viewed",
  COLLECTION_VIEWED: "collection_viewed",
  CART_VIEWED: "cart_viewed",
  SEARCH_VIEWED: "search_viewed",
  // Cart
  CART_UPDATED: "cart_updated",
  PRODUCT_ADD_TO_CART: "product_added_to_cart",
  PRODUCT_REMOVED_FROM_CART: "product_removed_from_cart",
  // Custom
  CUSTOM_EVENT: `custom_`
};
var CONSENT_API = "https://cdn.shopify.com/shopifycloud/consent-tracking-api/v0.1/consent-tracking-api.js";
var CONSENT_API_WITH_BANNER = "https://cdn.shopify.com/shopifycloud/privacy-banner/storefront-banner.js";
function logMissingConfig(fieldName) {
  console.error(
    `[h2:error:useCustomerPrivacy] Unable to setup Customer Privacy API: Missing consent.${fieldName} configuration.`
  );
}
function useCustomerPrivacy(props) {
  const {
    withPrivacyBanner = false,
    onVisitorConsentCollected,
    onReady,
    ...consentConfig
  } = props;
  useLoadScript(withPrivacyBanner ? CONSENT_API_WITH_BANNER : CONSENT_API, {
    attributes: {
      id: "customer-privacy-api"
    }
  });
  const { observing, setLoaded } = useApisLoaded({
    withPrivacyBanner,
    onLoaded: onReady
  });
  const config = (0, import_react28.useMemo)(() => {
    const { checkoutDomain, storefrontAccessToken } = consentConfig;
    if (!checkoutDomain) logMissingConfig("checkoutDomain");
    if (!storefrontAccessToken) logMissingConfig("storefrontAccessToken");
    if (storefrontAccessToken.startsWith("shpat_") || storefrontAccessToken.length !== 32) {
      console.error(
        `[h2:error:useCustomerPrivacy] It looks like you passed a private access token, make sure to use the public token`
      );
    }
    const config2 = {
      checkoutRootDomain: checkoutDomain,
      storefrontAccessToken,
      storefrontRootDomain: parseStoreDomain(checkoutDomain),
      country: consentConfig.country,
      locale: consentConfig.locale
    };
    return config2;
  }, [consentConfig, parseStoreDomain, logMissingConfig]);
  (0, import_react28.useEffect)(() => {
    const consentCollectedHandler = (event) => {
      if (onVisitorConsentCollected) {
        onVisitorConsentCollected(event.detail);
      }
    };
    document.addEventListener(
      "visitorConsentCollected",
      consentCollectedHandler
    );
    return () => {
      document.removeEventListener(
        "visitorConsentCollected",
        consentCollectedHandler
      );
    };
  }, [onVisitorConsentCollected]);
  (0, import_react28.useEffect)(() => {
    if (!withPrivacyBanner || observing.current.privacyBanner) return;
    observing.current.privacyBanner = true;
    let customPrivacyBanner = window.privacyBanner || void 0;
    const privacyBannerWatcher = {
      configurable: true,
      get() {
        return customPrivacyBanner;
      },
      set(value) {
        if (typeof value === "object" && value !== null && "showPreferences" in value && "loadBanner" in value) {
          const privacyBanner = value;
          privacyBanner.loadBanner(config);
          customPrivacyBanner = overridePrivacyBannerMethods({
            privacyBanner,
            config
          });
          setLoaded.privacyBanner();
          emitCustomerPrivacyApiLoaded();
        }
      }
    };
    Object.defineProperty(window, "privacyBanner", privacyBannerWatcher);
  }, [
    withPrivacyBanner,
    config,
    overridePrivacyBannerMethods,
    setLoaded.privacyBanner
  ]);
  (0, import_react28.useEffect)(() => {
    if (observing.current.customerPrivacy) return;
    observing.current.customerPrivacy = true;
    let customCustomerPrivacy = null;
    let customShopify = window.Shopify || void 0;
    Object.defineProperty(window, "Shopify", {
      configurable: true,
      get() {
        return customShopify;
      },
      set(value) {
        if (typeof value === "object" && value !== null && Object.keys(value).length === 0) {
          customShopify = value;
          Object.defineProperty(window.Shopify, "customerPrivacy", {
            configurable: true,
            get() {
              return customCustomerPrivacy;
            },
            set(value2) {
              if (typeof value2 === "object" && value2 !== null && "setTrackingConsent" in value2) {
                const customerPrivacy = value2;
                customCustomerPrivacy = {
                  ...customerPrivacy,
                  setTrackingConsent: overrideCustomerPrivacySetTrackingConsent(
                    { customerPrivacy, config }
                  )
                };
                customShopify = {
                  ...customShopify,
                  customerPrivacy: customCustomerPrivacy
                };
                setLoaded.customerPrivacy();
                emitCustomerPrivacyApiLoaded();
              }
            }
          });
        }
      }
    });
  }, [
    config,
    overrideCustomerPrivacySetTrackingConsent,
    setLoaded.customerPrivacy
  ]);
  const result = {
    customerPrivacy: getCustomerPrivacy()
  };
  if (withPrivacyBanner) {
    result.privacyBanner = getPrivacyBanner();
  }
  return result;
}
var hasEmitted = false;
function emitCustomerPrivacyApiLoaded() {
  if (hasEmitted) return;
  hasEmitted = true;
  const event = new CustomEvent("shopifyCustomerPrivacyApiLoaded");
  document.dispatchEvent(event);
}
function useApisLoaded({
  withPrivacyBanner,
  onLoaded
}) {
  const observing = (0, import_react28.useRef)({ customerPrivacy: false, privacyBanner: false });
  const [apisLoaded, setApisLoaded] = (0, import_react28.useState)(
    withPrivacyBanner ? [false, false] : [false]
  );
  const loaded = apisLoaded.every(Boolean);
  const setLoaded = {
    customerPrivacy: () => {
      if (withPrivacyBanner) {
        setApisLoaded((prev) => [true, prev[1]]);
      } else {
        setApisLoaded(() => [true]);
      }
    },
    privacyBanner: () => {
      if (!withPrivacyBanner) {
        return;
      }
      setApisLoaded((prev) => [prev[0], true]);
    }
  };
  (0, import_react28.useEffect)(() => {
    if (loaded && onLoaded) {
      onLoaded();
    }
  }, [loaded, onLoaded]);
  return { observing, setLoaded };
}
function parseStoreDomain(checkoutDomain) {
  if (typeof window === "undefined") return;
  const host = window.document.location.host;
  const checkoutDomainParts = checkoutDomain.split(".").reverse();
  const currentDomainParts = host.split(".").reverse();
  const sameDomainParts = [];
  checkoutDomainParts.forEach((part, index) => {
    if (part === currentDomainParts[index]) {
      sameDomainParts.push(part);
    }
  });
  return sameDomainParts.reverse().join(".");
}
function overrideCustomerPrivacySetTrackingConsent({
  customerPrivacy,
  config
}) {
  const original = customerPrivacy.setTrackingConsent;
  const { locale, country, ...rest } = config;
  function updatedSetTrackingConsent(consent, callback) {
    original(
      {
        ...rest,
        headlessStorefront: true,
        ...consent
      },
      callback
    );
  }
  return updatedSetTrackingConsent;
}
function overridePrivacyBannerMethods({
  privacyBanner,
  config
}) {
  const originalLoadBanner = privacyBanner.loadBanner;
  const originalShowPreferences = privacyBanner.showPreferences;
  function loadBanner(userConfig) {
    if (typeof userConfig === "object") {
      originalLoadBanner({ ...config, ...userConfig });
      return;
    }
    originalLoadBanner(config);
  }
  function showPreferences(userConfig) {
    if (typeof userConfig === "object") {
      originalShowPreferences({ ...config, ...userConfig });
      return;
    }
    originalShowPreferences(config);
  }
  return { loadBanner, showPreferences };
}
function getCustomerPrivacy() {
  var _a3;
  try {
    return window.Shopify && window.Shopify.customerPrivacy ? (_a3 = window.Shopify) == null ? void 0 : _a3.customerPrivacy : null;
  } catch (e) {
    return null;
  }
}
function getPrivacyBanner() {
  try {
    return window && (window == null ? void 0 : window.privacyBanner) ? window.privacyBanner : null;
  } catch (e) {
    return null;
  }
}
var version2 = "2025.7.0";
function getCustomerPrivacyRequired() {
  const customerPrivacy = getCustomerPrivacy();
  if (!customerPrivacy) {
    throw new Error(
      "Shopify Customer Privacy API not available. Must be used within a useEffect. Make sure to load the Shopify Customer Privacy API with useCustomerPrivacy() or <AnalyticsProvider>."
    );
  }
  return customerPrivacy;
}
function ShopifyAnalytics({
  consent,
  onReady,
  domain
}) {
  const { subscribe: subscribe2, register: register2, canTrack } = useAnalytics();
  const [shopifyReady, setShopifyReady] = (0, import_react28.useState)(false);
  const [privacyReady, setPrivacyReady] = (0, import_react28.useState)(false);
  const init = (0, import_react28.useRef)(false);
  const { checkoutDomain, storefrontAccessToken, language } = consent;
  const { ready: shopifyAnalyticsReady } = register2("Internal_Shopify_Analytics");
  useCustomerPrivacy({
    ...consent,
    locale: language,
    checkoutDomain: !checkoutDomain ? "mock.shop" : checkoutDomain,
    storefrontAccessToken: !storefrontAccessToken ? "abcdefghijklmnopqrstuvwxyz123456" : storefrontAccessToken,
    onVisitorConsentCollected: () => setPrivacyReady(true),
    onReady: () => setPrivacyReady(true)
  });
  useShopifyCookies({
    hasUserConsent: privacyReady ? canTrack() : true,
    // must be initialized with true
    domain,
    checkoutDomain
  });
  (0, import_react28.useEffect)(() => {
    if (init.current) return;
    init.current = true;
    subscribe2(AnalyticsEvent.PAGE_VIEWED, pageViewHandler);
    subscribe2(AnalyticsEvent.PRODUCT_VIEWED, productViewHandler);
    subscribe2(AnalyticsEvent.COLLECTION_VIEWED, collectionViewHandler);
    subscribe2(AnalyticsEvent.SEARCH_VIEWED, searchViewHandler);
    subscribe2(AnalyticsEvent.PRODUCT_ADD_TO_CART, productAddedToCartHandler);
    setShopifyReady(true);
  }, [subscribe2]);
  (0, import_react28.useEffect)(() => {
    if (shopifyReady && privacyReady) {
      shopifyAnalyticsReady();
      onReady();
    }
  }, [shopifyReady, privacyReady, onReady]);
  return null;
}
function logMissingConfig2(fieldName) {
  console.error(
    `[h2:error:ShopifyAnalytics] Unable to send Shopify analytics: Missing shop.${fieldName} configuration.`
  );
}
function prepareBasePageViewPayload(payload) {
  var _a3, _b, _c, _d;
  const customerPrivacy = getCustomerPrivacyRequired();
  const hasUserConsent = customerPrivacy.analyticsProcessingAllowed();
  if (!((_a3 = payload == null ? void 0 : payload.shop) == null ? void 0 : _a3.shopId)) {
    logMissingConfig2("shopId");
    return;
  }
  if (!((_b = payload == null ? void 0 : payload.shop) == null ? void 0 : _b.acceptedLanguage)) {
    logMissingConfig2("acceptedLanguage");
    return;
  }
  if (!((_c = payload == null ? void 0 : payload.shop) == null ? void 0 : _c.currency)) {
    logMissingConfig2("currency");
    return;
  }
  if (!((_d = payload == null ? void 0 : payload.shop) == null ? void 0 : _d.hydrogenSubchannelId)) {
    logMissingConfig2("hydrogenSubchannelId");
    return;
  }
  const eventPayload = {
    shopifySalesChannel: "hydrogen",
    assetVersionId: version2,
    ...payload.shop,
    hasUserConsent,
    ...getClientBrowserParameters(),
    ccpaEnforced: !customerPrivacy.saleOfDataAllowed(),
    gdprEnforced: !(customerPrivacy.marketingAllowed() && customerPrivacy.analyticsProcessingAllowed()),
    analyticsAllowed: customerPrivacy.analyticsProcessingAllowed(),
    marketingAllowed: customerPrivacy.marketingAllowed(),
    saleOfDataAllowed: customerPrivacy.saleOfDataAllowed()
  };
  return eventPayload;
}
function prepareBaseCartPayload(payload, cart) {
  if (cart === null) return;
  const pageViewPayload = prepareBasePageViewPayload(payload);
  if (!pageViewPayload) return;
  const eventPayload = {
    ...pageViewPayload,
    cartId: cart.id
  };
  return eventPayload;
}
var viewPayload = {};
function pageViewHandler(payload) {
  const eventPayload = prepareBasePageViewPayload(payload);
  if (!eventPayload) return;
  sendShopifyAnalytics({
    eventName: AnalyticsEventName.PAGE_VIEW_2,
    payload: {
      ...eventPayload,
      ...viewPayload
    }
  });
  viewPayload = {};
}
function productViewHandler(payload) {
  let eventPayload = prepareBasePageViewPayload(payload);
  if (eventPayload && validateProducts({
    type: "product",
    products: payload.products
  })) {
    const formattedProducts = formatProduct(payload.products);
    viewPayload = {
      pageType: AnalyticsPageType.product,
      resourceId: formattedProducts[0].productGid
    };
    eventPayload = {
      ...eventPayload,
      ...viewPayload,
      products: formatProduct(payload.products)
    };
    sendShopifyAnalytics({
      eventName: AnalyticsEventName.PRODUCT_VIEW,
      payload: eventPayload
    });
  }
}
function collectionViewHandler(payload) {
  let eventPayload = prepareBasePageViewPayload(payload);
  if (!eventPayload) return;
  viewPayload = {
    pageType: AnalyticsPageType.collection,
    resourceId: payload.collection.id
  };
  eventPayload = {
    ...eventPayload,
    ...viewPayload,
    collectionHandle: payload.collection.handle,
    collectionId: payload.collection.id
  };
  sendShopifyAnalytics({
    eventName: AnalyticsEventName.COLLECTION_VIEW,
    payload: eventPayload
  });
}
function searchViewHandler(payload) {
  let eventPayload = prepareBasePageViewPayload(payload);
  if (!eventPayload) return;
  viewPayload = {
    pageType: AnalyticsPageType.search
  };
  eventPayload = {
    ...eventPayload,
    ...viewPayload,
    searchString: payload.searchTerm
  };
  sendShopifyAnalytics({
    eventName: AnalyticsEventName.SEARCH_VIEW,
    payload: eventPayload
  });
}
function productAddedToCartHandler(payload) {
  const { cart, currentLine } = payload;
  const eventPayload = prepareBaseCartPayload(payload, cart);
  if (!eventPayload || !(currentLine == null ? void 0 : currentLine.id)) return;
  sendCartAnalytics({
    matchedLine: currentLine,
    eventPayload
  });
}
function sendCartAnalytics({
  matchedLine,
  eventPayload
}) {
  const product = {
    id: matchedLine.merchandise.product.id,
    variantId: matchedLine.merchandise.id,
    title: matchedLine.merchandise.product.title,
    variantTitle: matchedLine.merchandise.title,
    vendor: matchedLine.merchandise.product.vendor,
    price: matchedLine.merchandise.price.amount,
    quantity: matchedLine.quantity,
    productType: matchedLine.merchandise.product.productType,
    sku: matchedLine.merchandise.sku
  };
  if (validateProducts({
    type: "cart",
    products: [product]
  })) {
    sendShopifyAnalytics({
      eventName: AnalyticsEventName.ADD_TO_CART,
      payload: {
        ...eventPayload,
        products: formatProduct([product])
      }
    });
  }
}
function missingErrorMessage(type, fieldName, isVariantField, viewKeyName) {
  if (type === "cart") {
    const name = `${isVariantField ? "merchandise" : "merchandise.product"}.${fieldName}`;
    console.error(
      `[h2:error:ShopifyAnalytics] Can't set up cart analytics events because the \`cart.lines[].${name}\` value is missing from your GraphQL cart query. In your project, search for where \`fragment CartLine on CartLine\` is defined and make sure \`${name}\` is part of your cart query. Check the Hydrogen Skeleton template for reference: https://github.com/Shopify/hydrogen/blob/main/templates/skeleton/app/lib/fragments.ts#L25-L56.`
    );
  } else {
    const name = `${viewKeyName || fieldName}`;
    console.error(
      `[h2:error:ShopifyAnalytics] Can't set up product view analytics events because the \`${name}\` is missing from your \`<Analytics.ProductView>\`. Make sure \`${name}\` is part of your products data prop. Check the Hydrogen Skeleton template for reference: https://github.com/Shopify/hydrogen/blob/main/templates/skeleton/app/routes/products.%24handle.tsx#L159-L165.`
    );
  }
}
function validateProducts({
  type,
  products
}) {
  if (!products || products.length === 0) {
    missingErrorMessage(type, "", false, "data.products");
    return false;
  }
  products.forEach((product) => {
    if (!product.id) {
      missingErrorMessage(type, "id", false);
      return false;
    }
    if (!product.title) {
      missingErrorMessage(type, "title", false);
      return false;
    }
    if (!product.price) {
      missingErrorMessage(type, "price.amount", true, "price");
      return false;
    }
    if (!product.vendor) {
      missingErrorMessage(type, "vendor", false);
      return false;
    }
    if (!product.variantId) {
      missingErrorMessage(type, "id", true, "variantId");
      return false;
    }
    if (!product.variantTitle) {
      missingErrorMessage(type, "title", true, "variantTitle");
      return false;
    }
  });
  return true;
}
function formatProduct(products) {
  return products.map((product) => {
    const formattedProduct = {
      productGid: product.id,
      variantGid: product.variantId,
      name: product.title,
      variantName: product.variantTitle,
      brand: product.vendor,
      price: product.price,
      quantity: product.quantity || 1,
      category: product.productType
    };
    if (product.sku) formattedProduct.sku = product.sku;
    if (product.productType) formattedProduct.category = product.productType;
    return formattedProduct;
  });
}
function logMissingField(fieldName) {
  console.error(
    `[h2:error:CartAnalytics] Can't set up cart analytics events because the \`cart.${fieldName}\` value is missing from your GraphQL cart query. In your project, search for where \`fragment CartApiQuery on Cart\` is defined and make sure \`${fieldName}\` is part of your cart query. Check the Hydrogen Skeleton template for reference: https://github.com/Shopify/hydrogen/blob/main/templates/skeleton/app/lib/fragments.ts#L59.`
  );
}
function CartAnalytics({
  cart: currentCart,
  setCarts
}) {
  const { publish: publish2, shop, customData, canTrack, cart, prevCart } = useAnalytics();
  const lastEventId = (0, import_react28.useRef)(null);
  (0, import_react28.useEffect)(() => {
    if (!currentCart) return;
    Promise.resolve(currentCart).then((updatedCart) => {
      if (updatedCart && updatedCart.lines) {
        if (!updatedCart.id) {
          logMissingField("id");
          return;
        }
        if (!updatedCart.updatedAt) {
          logMissingField("updatedAt");
          return;
        }
      }
      setCarts(({ cart: cart2, prevCart: prevCart2 }) => {
        return (updatedCart == null ? void 0 : updatedCart.updatedAt) !== (cart2 == null ? void 0 : cart2.updatedAt) ? { cart: updatedCart, prevCart: cart2 } : { cart: cart2, prevCart: prevCart2 };
      });
    });
    return () => {
    };
  }, [setCarts, currentCart]);
  (0, import_react28.useEffect)(() => {
    if (!cart || !(cart == null ? void 0 : cart.updatedAt)) return;
    if ((cart == null ? void 0 : cart.updatedAt) === (prevCart == null ? void 0 : prevCart.updatedAt)) return;
    let cartLastUpdatedAt;
    try {
      cartLastUpdatedAt = JSON.parse(
        localStorage.getItem("cartLastUpdatedAt") || ""
      );
    } catch (e) {
      cartLastUpdatedAt = null;
    }
    if (cart.id === (cartLastUpdatedAt == null ? void 0 : cartLastUpdatedAt.id) && cart.updatedAt === (cartLastUpdatedAt == null ? void 0 : cartLastUpdatedAt.updatedAt))
      return;
    const payload = {
      eventTimestamp: Date.now(),
      cart,
      prevCart,
      shop,
      customData
    };
    if (cart.updatedAt === lastEventId.current) return;
    lastEventId.current = cart.updatedAt;
    publish2("cart_updated", payload);
    localStorage.setItem(
      "cartLastUpdatedAt",
      JSON.stringify({
        id: cart.id,
        updatedAt: cart.updatedAt
      })
    );
    const previousCartLines = (prevCart == null ? void 0 : prevCart.lines) ? flattenConnection(prevCart == null ? void 0 : prevCart.lines) : [];
    const currentCartLines = cart.lines ? flattenConnection(cart.lines) : [];
    previousCartLines == null ? void 0 : previousCartLines.forEach((prevLine) => {
      const matchedLineId = currentCartLines.filter(
        (line) => prevLine.id === line.id
      );
      if ((matchedLineId == null ? void 0 : matchedLineId.length) === 1) {
        const matchedLine = matchedLineId[0];
        if (prevLine.quantity < matchedLine.quantity) {
          publish2("product_added_to_cart", {
            ...payload,
            prevLine,
            currentLine: matchedLine
          });
        } else if (prevLine.quantity > matchedLine.quantity) {
          publish2("product_removed_from_cart", {
            ...payload,
            prevLine,
            currentLine: matchedLine
          });
        }
      } else {
        publish2("product_removed_from_cart", {
          ...payload,
          prevLine
        });
      }
    });
    currentCartLines == null ? void 0 : currentCartLines.forEach((line) => {
      const matchedLineId = previousCartLines.filter(
        (previousLine) => line.id === previousLine.id
      );
      if (!matchedLineId || matchedLineId.length === 0) {
        publish2("product_added_to_cart", {
          ...payload,
          currentLine: line
        });
      }
    });
  }, [cart, prevCart, publish2, shop, customData, canTrack]);
  return null;
}
var PERF_KIT_URL = "https://cdn.shopify.com/shopifycloud/perf-kit/shopify-perf-kit-spa.min.js";
function PerfKit({ shop }) {
  const loadedEvent = (0, import_react28.useRef)(false);
  const { subscribe: subscribe2, register: register2 } = useAnalytics();
  const { ready } = register2("Internal_Shopify_Perf_Kit");
  const scriptStatus = useLoadScript(PERF_KIT_URL, {
    attributes: {
      id: "perfkit",
      "data-application": "hydrogen",
      "data-shop-id": parseGid(shop.shopId).id.toString(),
      "data-storefront-id": shop.hydrogenSubchannelId,
      "data-monorail-region": "global",
      "data-spa-mode": "true",
      "data-resource-timing-sampling-rate": "100"
    }
  });
  (0, import_react28.useEffect)(() => {
    if (scriptStatus !== "done" || loadedEvent.current) return;
    loadedEvent.current = true;
    subscribe2(AnalyticsEvent.PAGE_VIEWED, () => {
      var _a3;
      (_a3 = window.PerfKit) == null ? void 0 : _a3.navigate();
    });
    subscribe2(AnalyticsEvent.PRODUCT_VIEWED, () => {
      var _a3;
      (_a3 = window.PerfKit) == null ? void 0 : _a3.setPageType("product");
    });
    subscribe2(AnalyticsEvent.COLLECTION_VIEWED, () => {
      var _a3;
      (_a3 = window.PerfKit) == null ? void 0 : _a3.setPageType("collection");
    });
    subscribe2(AnalyticsEvent.SEARCH_VIEWED, () => {
      var _a3;
      (_a3 = window.PerfKit) == null ? void 0 : _a3.setPageType("search");
    });
    subscribe2(AnalyticsEvent.CART_VIEWED, () => {
      var _a3;
      (_a3 = window.PerfKit) == null ? void 0 : _a3.setPageType("cart");
    });
    ready();
  }, [subscribe2, ready, scriptStatus]);
  return null;
}
var warnings2 = /* @__PURE__ */ new Set();
var warnOnce2 = (string) => {
  if (!warnings2.has(string)) {
    console.warn(string);
    warnings2.add(string);
  }
};
var errors = /* @__PURE__ */ new Set();
var errorOnce = (string) => {
  if (!errors.has(string)) {
    console.error(new Error(string));
    errors.add(string);
  }
};
var defaultAnalyticsContext = {
  canTrack: () => false,
  cart: null,
  customData: {},
  prevCart: null,
  publish: () => {
  },
  shop: null,
  subscribe: () => {
  },
  register: () => ({ ready: () => {
  } }),
  customerPrivacy: null,
  privacyBanner: null
};
var AnalyticsContext = (0, import_react28.createContext)(
  defaultAnalyticsContext
);
var subscribers = /* @__PURE__ */ new Map();
var registers = {};
function areRegistersReady() {
  return Object.values(registers).every(Boolean);
}
function subscribe(event, callback) {
  var _a3;
  if (!subscribers.has(event)) {
    subscribers.set(event, /* @__PURE__ */ new Map());
  }
  (_a3 = subscribers.get(event)) == null ? void 0 : _a3.set(callback.toString(), callback);
}
var waitForReadyQueue = /* @__PURE__ */ new Map();
function publish(event, payload) {
  if (!areRegistersReady()) {
    waitForReadyQueue.set(event, payload);
    return;
  }
  publishEvent(event, payload);
}
function publishEvent(event, payload) {
  (subscribers.get(event) ?? /* @__PURE__ */ new Map()).forEach((callback, subscriber) => {
    try {
      callback(payload);
    } catch (error) {
      if (typeof error === "object" && error instanceof Error) {
        console.error(
          "Analytics publish error",
          error.message,
          subscriber,
          error.stack
        );
      } else {
        console.error("Analytics publish error", error, subscriber);
      }
    }
  });
}
function register(key) {
  if (!registers.hasOwnProperty(key)) {
    registers[key] = false;
  }
  return {
    ready: () => {
      registers[key] = true;
      if (areRegistersReady() && waitForReadyQueue.size > 0) {
        waitForReadyQueue.forEach((queuePayload, queueEvent) => {
          publishEvent(queueEvent, queuePayload);
        });
        waitForReadyQueue.clear();
      }
    }
  };
}
function shopifyCanTrack() {
  try {
    return window.Shopify.customerPrivacy.analyticsProcessingAllowed();
  } catch (e) {
  }
  return false;
}
function messageOnError(field, envVar) {
  return `[h2:error:Analytics.Provider] - ${field} is required. Make sure ${envVar} is defined in your environment variables. See https://h2o.fyi/analytics/consent to learn how to setup environment variables in the Shopify admin.`;
}
function AnalyticsProvider({
  canTrack: customCanTrack,
  cart: currentCart,
  children,
  consent,
  customData = {},
  shop: shopProp = null,
  cookieDomain
}) {
  var _a3;
  const listenerSet = (0, import_react28.useRef)(false);
  const { shop } = useShopAnalytics(shopProp);
  const [analyticsLoaded, setAnalyticsLoaded] = (0, import_react28.useState)(
    customCanTrack ? true : false
  );
  const [carts, setCarts] = (0, import_react28.useState)({ cart: null, prevCart: null });
  const [canTrack, setCanTrack] = (0, import_react28.useState)(
    customCanTrack ? () => customCanTrack : () => shopifyCanTrack
  );
  if (!!shop) {
    if (/\/68817551382$/.test(shop.shopId)) {
      warnOnce2(
        "[h2:error:Analytics.Provider] - Mock shop is used. Analytics will not work properly."
      );
    } else {
      if (!consent.checkoutDomain) {
        const errorMsg = messageOnError(
          "consent.checkoutDomain",
          "PUBLIC_CHECKOUT_DOMAIN"
        );
        errorOnce(errorMsg);
      }
      if (!consent.storefrontAccessToken) {
        const errorMsg = messageOnError(
          "consent.storefrontAccessToken",
          "PUBLIC_STOREFRONT_API_TOKEN"
        );
        errorOnce(errorMsg);
      }
      if (!(consent == null ? void 0 : consent.country)) {
        consent.country = "US";
      }
      if (!(consent == null ? void 0 : consent.language)) {
        consent.language = "EN";
      }
      if (consent.withPrivacyBanner === void 0) {
        consent.withPrivacyBanner = false;
      }
    }
  }
  const value = (0, import_react28.useMemo)(() => {
    return {
      canTrack,
      ...carts,
      customData,
      publish: canTrack() ? publish : () => {
      },
      shop,
      subscribe,
      register,
      customerPrivacy: getCustomerPrivacy(),
      privacyBanner: getPrivacyBanner()
    };
  }, [
    analyticsLoaded,
    canTrack,
    carts,
    (_a3 = carts.cart) == null ? void 0 : _a3.updatedAt,
    carts.prevCart,
    publish,
    subscribe,
    customData,
    shop,
    register,
    JSON.stringify(registers),
    getCustomerPrivacy,
    getPrivacyBanner
  ]);
  return (0, import_jsx_runtime22.jsxs)(AnalyticsContext.Provider, { value, children: [
    children,
    !!shop && (0, import_jsx_runtime22.jsx)(AnalyticsPageView, {}),
    !!shop && !!currentCart && (0, import_jsx_runtime22.jsx)(CartAnalytics, { cart: currentCart, setCarts }),
    !!shop && consent.checkoutDomain && (0, import_jsx_runtime22.jsx)(
      ShopifyAnalytics,
      {
        consent,
        onReady: () => {
          listenerSet.current = true;
          setAnalyticsLoaded(true);
          setCanTrack(
            customCanTrack ? () => customCanTrack : () => shopifyCanTrack
          );
        },
        domain: cookieDomain
      }
    ),
    !!shop && (0, import_jsx_runtime22.jsx)(PerfKit, { shop })
  ] });
}
function useAnalytics() {
  const analyticsContext = (0, import_react28.useContext)(AnalyticsContext);
  if (!analyticsContext) {
    throw new Error(
      `[h2:error:useAnalytics] 'useAnalytics()' must be a descendent of <AnalyticsProvider/>`
    );
  }
  return analyticsContext;
}
function useShopAnalytics(shopProp) {
  const [shop, setShop] = (0, import_react28.useState)(null);
  (0, import_react28.useEffect)(() => {
    Promise.resolve(shopProp).then(setShop);
    return () => {
    };
  }, [setShop, shopProp]);
  return { shop };
}
async function getShopAnalytics({
  storefront,
  publicStorefrontId = "0"
}) {
  return storefront.query(SHOP_QUERY, {
    cache: storefront.CacheLong()
  }).then(({ shop, localization }) => {
    return {
      shopId: shop.id,
      acceptedLanguage: localization.language.isoCode,
      currency: localization.country.currency.isoCode,
      hydrogenSubchannelId: publicStorefrontId
    };
  });
}
var SHOP_QUERY = `#graphql
  query ShopData(
    $country: CountryCode
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    shop {
      id
    }
    localization {
      country {
        currency {
          isoCode
        }
      }
      language {
        isoCode
      }
    }
  }
`;
var Analytics = {
  CartView: AnalyticsCartView,
  CollectionView: AnalyticsCollectionView,
  CustomView: AnalyticsCustomView,
  ProductView: AnalyticsProductView,
  Provider: AnalyticsProvider,
  SearchView: AnalyticsSearchView
};
function getHeader(request, key) {
  return getHeaderValue(request.headers, key);
}
function getHeaderValue(headers, key) {
  var _a3;
  const value = ((_a3 = headers == null ? void 0 : headers.get) == null ? void 0 : _a3.call(headers, key)) ?? (headers == null ? void 0 : headers[key]);
  return typeof value === "string" ? value : null;
}
function getDebugHeaders(request) {
  return {
    requestId: request ? getHeader(request, "request-id") : void 0,
    purpose: request ? getHeader(request, "purpose") : void 0
  };
}
function withSyncStack(promise, options = {}) {
  const syncError = new Error();
  const getSyncStack = (message, name = "Error") => {
    const syncStack = (syncError.stack ?? "").split("\n").slice(3 + (options.stackOffset ?? 0)).join("\n").replace(/ at loader(\d+) \(/, (all, m1) => all.replace(m1, ""));
    return `${name}: ${message}
` + syncStack;
  };
  return promise.then((result) => {
    if ((result == null ? void 0 : result.errors) && Array.isArray(result.errors)) {
      const logErrors = typeof options.logErrors === "function" ? options.logErrors : () => options.logErrors ?? false;
      result.errors.forEach((error) => {
        if (error) {
          error.stack = getSyncStack(error.message, error.name);
          if (logErrors(error)) console.error(error);
        }
      });
    }
    return result;
  }).catch((error) => {
    if (error) error.stack = getSyncStack(error.message, error.name);
    throw error;
  });
}
var getCallerStackLine = (stackOffset = 0) => {
  let stackInfo = void 0;
  const original = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, callsites) => {
    const cs = callsites[2 + stackOffset];
    stackInfo = cs && {
      file: cs.getFileName() ?? void 0,
      func: cs.getFunctionName() ?? void 0,
      line: cs.getLineNumber() ?? void 0,
      column: cs.getColumnNumber() ?? void 0
    };
    return "";
  };
  const err = { stack: "" };
  Error.captureStackTrace(err);
  err.stack;
  Error.prepareStackTrace = original;
  return stackInfo;
};
var PUBLIC = "public";
var PRIVATE = "private";
var NO_STORE = "no-store";
var optionMapping = {
  maxAge: "max-age",
  staleWhileRevalidate: "stale-while-revalidate",
  sMaxAge: "s-maxage",
  staleIfError: "stale-if-error"
};
function generateCacheControlHeader(cacheOptions) {
  const cacheControl = [];
  Object.keys(cacheOptions).forEach((key) => {
    if (key === "mode") {
      cacheControl.push(cacheOptions[key]);
    } else if (optionMapping[key]) {
      cacheControl.push(
        `${optionMapping[key]}=${cacheOptions[key]}`
      );
    }
  });
  return cacheControl.join(", ");
}
function CacheNone() {
  return {
    mode: NO_STORE
  };
}
function guardExpirableModeType(overrideOptions) {
  if ((overrideOptions == null ? void 0 : overrideOptions.mode) && (overrideOptions == null ? void 0 : overrideOptions.mode) !== PUBLIC && (overrideOptions == null ? void 0 : overrideOptions.mode) !== PRIVATE) {
    throw Error("'mode' must be either 'public' or 'private'");
  }
}
function CacheShort(overrideOptions) {
  guardExpirableModeType(overrideOptions);
  return {
    mode: PUBLIC,
    maxAge: 1,
    staleWhileRevalidate: 9,
    ...overrideOptions
  };
}
function CacheLong(overrideOptions) {
  guardExpirableModeType(overrideOptions);
  return {
    mode: PUBLIC,
    maxAge: 3600,
    // 1 hour
    staleWhileRevalidate: 82800,
    // 23 Hours
    ...overrideOptions
  };
}
function CacheDefault(overrideOptions) {
  guardExpirableModeType(overrideOptions);
  return {
    mode: PUBLIC,
    maxAge: 1,
    staleWhileRevalidate: 86399,
    // 1 second less than 24 hours
    ...overrideOptions
  };
}
function CacheCustom(overrideOptions) {
  return overrideOptions;
}
function parseJSON2(json) {
  if (String(json).includes("__proto__")) return JSON.parse(json, noproto);
  return JSON.parse(json);
}
function noproto(k, v2) {
  if (k !== "__proto__") return v2;
}
function getCacheControlSetting(userCacheOptions, options) {
  if (userCacheOptions && options) {
    return {
      ...userCacheOptions,
      ...options
    };
  } else {
    return userCacheOptions || CacheDefault();
  }
}
function generateDefaultCacheControlHeader(userCacheOptions) {
  return generateCacheControlHeader(getCacheControlSetting(userCacheOptions));
}
async function getItem(cache, request) {
  if (!cache) return;
  const response = await cache.match(request);
  if (!response) {
    return;
  }
  return response;
}
async function setItem(cache, request, response, userCacheOptions) {
  if (!cache) return;
  const cacheControl = getCacheControlSetting(userCacheOptions);
  const paddedCacheControlString = generateDefaultCacheControlHeader(
    getCacheControlSetting(cacheControl, {
      maxAge: (cacheControl.maxAge || 0) + (cacheControl.staleWhileRevalidate || 0)
    })
  );
  const cacheControlString = generateDefaultCacheControlHeader(
    getCacheControlSetting(cacheControl)
  );
  response.headers.set("cache-control", paddedCacheControlString);
  response.headers.set("real-cache-control", cacheControlString);
  response.headers.set("cache-put-date", String(Date.now()));
  await cache.put(request, response);
}
async function deleteItem(cache, request) {
  if (!cache) return;
  await cache.delete(request);
}
function calculateAge(response, responseDate) {
  const cacheControl = response.headers.get("real-cache-control");
  let responseMaxAge = 0;
  if (cacheControl) {
    const maxAgeMatch = cacheControl.match(/max-age=(\d*)/);
    if (maxAgeMatch && maxAgeMatch.length > 1) {
      responseMaxAge = parseFloat(maxAgeMatch[1]);
    }
  }
  const ageInMs = Date.now() - Number(responseDate);
  return [ageInMs / 1e3, responseMaxAge];
}
function isStale(request, response) {
  const responseDate = response.headers.get("cache-put-date");
  if (!responseDate) {
    return false;
  }
  const [age, responseMaxAge] = calculateAge(response, responseDate);
  const result = age > responseMaxAge;
  return result;
}
var CacheAPI = {
  get: getItem,
  set: setItem,
  delete: deleteItem,
  generateDefaultCacheControlHeader,
  isStale
};
function getKeyUrl(key) {
  return `https://shopify.dev/?${key}`;
}
function getCacheOption(userCacheOptions) {
  return userCacheOptions || CacheDefault();
}
async function getItemFromCache(cache, key) {
  if (!cache) return;
  const url = getKeyUrl(key);
  const request = new Request(url);
  const response = await CacheAPI.get(cache, request);
  if (!response) {
    return;
  }
  const text = await response.text();
  try {
    return [parseJSON2(text), response];
  } catch {
    return [text, response];
  }
}
async function setItemInCache(cache, key, value, userCacheOptions) {
  if (!cache) return;
  const url = getKeyUrl(key);
  const request = new Request(url);
  const response = new Response(JSON.stringify(value));
  await CacheAPI.set(
    cache,
    request,
    response,
    getCacheOption(userCacheOptions)
  );
}
function isStale2(key, response) {
  return CacheAPI.isStale(new Request(getKeyUrl(key)), response);
}
function hashKey(queryKey) {
  const rawKeys = Array.isArray(queryKey) ? queryKey : [queryKey];
  let hash = "";
  for (const key of rawKeys) {
    if (key != null) {
      if (typeof key === "object") {
        hash += JSON.stringify(key);
      } else {
        hash += key.toString();
      }
    }
  }
  return encodeURIComponent(hash);
}
var swrLock = /* @__PURE__ */ new Set();
async function runWithCache(cacheKey, actionFn, {
  strategy = CacheShort(),
  cacheInstance,
  shouldCacheResult = () => true,
  waitUntil,
  debugInfo
}) {
  const startTime = Date.now();
  const key = hashKey([
    // '__HYDROGEN_CACHE_ID__', // TODO purgeQueryCacheOnBuild
    ...typeof cacheKey === "string" ? [cacheKey] : cacheKey
  ]);
  let cachedDebugInfo;
  let userDebugInfo;
  const addDebugData = (info) => {
    var _a3, _b, _c, _d;
    userDebugInfo = {
      displayName: info.displayName,
      url: (_a3 = info.response) == null ? void 0 : _a3.url,
      responseInit: {
        status: ((_b = info.response) == null ? void 0 : _b.status) || 0,
        statusText: ((_c = info.response) == null ? void 0 : _c.statusText) || "",
        headers: Array.from(((_d = info.response) == null ? void 0 : _d.headers.entries()) || [])
      }
    };
  };
  const mergeDebugInfo = () => ({
    ...cachedDebugInfo,
    ...debugInfo,
    url: (userDebugInfo == null ? void 0 : userDebugInfo.url) || (debugInfo == null ? void 0 : debugInfo.url) || (cachedDebugInfo == null ? void 0 : cachedDebugInfo.url) || getKeyUrl(key),
    displayName: (debugInfo == null ? void 0 : debugInfo.displayName) || (userDebugInfo == null ? void 0 : userDebugInfo.displayName) || (cachedDebugInfo == null ? void 0 : cachedDebugInfo.displayName)
  });
  const logSubRequestEvent2 = ({
    result: result2,
    cacheStatus,
    overrideStartTime
  }) => {
    var _a3;
    (_a3 = globalThis.__H2O_LOG_EVENT) == null ? void 0 : _a3.call(globalThis, {
      ...mergeDebugInfo(),
      eventType: "subrequest",
      startTime: overrideStartTime || startTime,
      endTime: Date.now(),
      cacheStatus,
      responsePayload: result2 && result2[0] || result2,
      responseInit: result2 && result2[1] || (userDebugInfo == null ? void 0 : userDebugInfo.responseInit),
      cache: {
        status: cacheStatus,
        strategy: generateCacheControlHeader(strategy || {}),
        key
      },
      waitUntil
    });
  };
  if (!cacheInstance || !strategy || strategy.mode === NO_STORE) {
    const result2 = await actionFn({ addDebugData });
    logSubRequestEvent2 == null ? void 0 : logSubRequestEvent2({ result: result2 });
    return result2;
  }
  const storeInCache = (value) => setItemInCache(
    cacheInstance,
    key,
    {
      value,
      debugInfo: mergeDebugInfo()
    },
    strategy
  );
  const cachedItem = await getItemFromCache(cacheInstance, key);
  if (cachedItem && typeof cachedItem[0] !== "string") {
    const [{ value: cachedResult, debugInfo: debugInfo2 }, cacheInfo] = cachedItem;
    cachedDebugInfo = debugInfo2;
    const cacheStatus = isStale2(key, cacheInfo) ? "STALE" : "HIT";
    if (!swrLock.has(key) && cacheStatus === "STALE") {
      swrLock.add(key);
      const revalidatingPromise = Promise.resolve().then(async () => {
        const revalidateStartTime = Date.now();
        try {
          const result2 = await actionFn({ addDebugData });
          if (shouldCacheResult(result2)) {
            await storeInCache(result2);
            logSubRequestEvent2 == null ? void 0 : logSubRequestEvent2({
              result: result2,
              cacheStatus: "PUT",
              overrideStartTime: revalidateStartTime
            });
          }
        } catch (error) {
          if (error.message) {
            error.message = "SWR in sub-request failed: " + error.message;
          }
          console.error(error);
        } finally {
          swrLock.delete(key);
        }
      });
      waitUntil == null ? void 0 : waitUntil(revalidatingPromise);
    }
    logSubRequestEvent2 == null ? void 0 : logSubRequestEvent2({
      result: cachedResult,
      cacheStatus
    });
    return cachedResult;
  }
  const result = await actionFn({ addDebugData });
  logSubRequestEvent2 == null ? void 0 : logSubRequestEvent2({
    result,
    cacheStatus: "MISS"
  });
  if (shouldCacheResult(result)) {
    const cacheStoringPromise = Promise.resolve().then(async () => {
      const putStartTime = Date.now();
      await storeInCache(result);
      logSubRequestEvent2 == null ? void 0 : logSubRequestEvent2({
        result,
        cacheStatus: "PUT",
        overrideStartTime: putStartTime
      });
    });
    waitUntil == null ? void 0 : waitUntil(cacheStoringPromise);
  }
  return result;
}
function toSerializableResponse(body, response) {
  return [
    body,
    {
      status: response.status,
      statusText: response.statusText,
      headers: Array.from(response.headers.entries())
    }
  ];
}
function fromSerializableResponse([body, init]) {
  return [body, new Response(body, init)];
}
async function fetchWithServerCache(url, requestInit, {
  cacheInstance,
  cache: cacheOptions,
  cacheKey = [url, requestInit],
  shouldCacheResponse,
  waitUntil,
  debugInfo,
  streamConfig
}) {
  if (!cacheOptions && (!requestInit.method || requestInit.method === "GET")) {
    cacheOptions = CacheShort();
  }
  return runWithCache(
    cacheKey,
    async () => {
      if (streamConfig) {
        let rawResponse = null;
        const client = createGraphQLClient({
          url,
          customFetchApi: async (url2, options) => {
            rawResponse = await fetch(url2, options);
            return rawResponse;
          },
          headers: requestInit.headers
        });
        const responseStream = await client.requestStream(streamConfig.query, {
          variables: streamConfig.variables
        });
        let allData;
        let allErrors;
        for await (const response2 of responseStream) {
          const { data: data2, errors: errors2 } = response2;
          allData = data2;
          allErrors = (errors2 == null ? void 0 : errors2.graphQLErrors) ?? errors2;
        }
        if (!(rawResponse == null ? void 0 : rawResponse.ok)) {
          return rawResponse;
        }
        return toSerializableResponse(
          { data: allData, errors: allErrors },
          rawResponse
        );
      }
      const response = await fetch(url, requestInit);
      if (!response.ok) {
        return response;
      }
      let data = await response.text().catch(() => "");
      try {
        if (data) data = parseJSON2(data);
      } catch {
      }
      return toSerializableResponse(data, response);
    },
    {
      cacheInstance,
      waitUntil,
      strategy: cacheOptions ?? null,
      debugInfo,
      shouldCacheResult: (payload) => {
        return "ok" in payload ? false : shouldCacheResponse(...fromSerializableResponse(payload));
      }
    }
  ).then((payload) => {
    return "ok" in payload ? [null, payload] : fromSerializableResponse(payload);
  });
}
function createWithCache(cacheOptions) {
  const { cache, waitUntil, request } = cacheOptions;
  return {
    run: ({ cacheKey, cacheStrategy, shouldCacheResult }, fn) => {
      return runWithCache(cacheKey, fn, {
        shouldCacheResult,
        strategy: cacheStrategy,
        cacheInstance: cache,
        waitUntil,
        debugInfo: {
          ...getDebugHeaders(request),
          stackInfo: getCallerStackLine == null ? void 0 : getCallerStackLine()
        }
      });
    },
    fetch: (url, requestInit, options) => {
      return fetchWithServerCache(url, requestInit ?? {}, {
        waitUntil,
        cacheKey: [url, requestInit],
        cacheInstance: cache,
        debugInfo: {
          url,
          ...getDebugHeaders(request),
          stackInfo: getCallerStackLine == null ? void 0 : getCallerStackLine(),
          displayName: options == null ? void 0 : options.displayName
        },
        cache: options.cacheStrategy,
        ...options
      }).then(([data, response]) => ({ data, response }));
    }
  };
}
var _store, _a;
var InMemoryCache = (_a = class {
  constructor() {
    __privateAdd(this, _store);
    __privateSet(this, _store, /* @__PURE__ */ new Map());
  }
  add(request) {
    throw new Error("Method not implemented. Use `put` instead.");
  }
  addAll(requests) {
    throw new Error("Method not implemented. Use `put` instead.");
  }
  matchAll(request, options) {
    throw new Error("Method not implemented. Use `match` instead.");
  }
  async put(request, response) {
    var _a3;
    if (request.method !== "GET") {
      throw new TypeError("Cannot cache response to non-GET request.");
    }
    if (response.status === 206) {
      throw new TypeError(
        "Cannot cache response to a range request (206 Partial Content)."
      );
    }
    if ((_a3 = response.headers.get("vary")) == null ? void 0 : _a3.includes("*")) {
      throw new TypeError("Cannot cache response with 'Vary: *' header.");
    }
    __privateGet(this, _store).set(request.url, {
      body: new Uint8Array(await response.arrayBuffer()),
      status: response.status,
      headers: [...response.headers],
      timestamp: Date.now()
    });
  }
  async match(request) {
    var _a3, _b;
    if (request.method !== "GET") return;
    const match = __privateGet(this, _store).get(request.url);
    if (!match) {
      return;
    }
    const { body, timestamp, ...metadata } = match;
    const headers = new Headers(metadata.headers);
    const cacheControl = headers.get("cache-control") || headers.get("real-cache-control") || "";
    const maxAge = parseInt(
      ((_a3 = cacheControl.match(/max-age=(\d+)/)) == null ? void 0 : _a3[1]) || "0",
      10
    );
    const swr = parseInt(
      ((_b = cacheControl.match(/stale-while-revalidate=(\d+)/)) == null ? void 0 : _b[1]) || "0",
      10
    );
    const age = (Date.now() - timestamp) / 1e3;
    const isMiss = age > maxAge + swr;
    if (isMiss) {
      __privateGet(this, _store).delete(request.url);
      return;
    }
    const isStale3 = age > maxAge;
    headers.set("cache", isStale3 ? "STALE" : "HIT");
    headers.set("date", new Date(timestamp).toUTCString());
    return new Response(body, {
      status: metadata.status ?? 200,
      headers
    });
  }
  async delete(request) {
    if (__privateGet(this, _store).has(request.url)) {
      __privateGet(this, _store).delete(request.url);
      return true;
    }
    return false;
  }
  keys(request) {
    const cacheKeys = [];
    for (const url of __privateGet(this, _store).keys()) {
      if (!request || request.url === url) {
        cacheKeys.push(new Request(url));
      }
    }
    return Promise.resolve(cacheKeys);
  }
}, _store = new WeakMap(), _a);
var INPUT_NAME = "cartFormInput";
function CartForm({
  children,
  action,
  inputs,
  route,
  fetcherKey
}) {
  const fetcher = useFetcher({ key: fetcherKey });
  return (0, import_jsx_runtime22.jsxs)(fetcher.Form, { action: route || "", method: "post", children: [
    (action || inputs) && (0, import_jsx_runtime22.jsx)(
      "input",
      {
        type: "hidden",
        name: INPUT_NAME,
        value: JSON.stringify({ action, inputs })
      }
    ),
    typeof children === "function" ? children(fetcher) : children
  ] });
}
CartForm.INPUT_NAME = INPUT_NAME;
CartForm.ACTIONS = {
  AttributesUpdateInput: "AttributesUpdateInput",
  BuyerIdentityUpdate: "BuyerIdentityUpdate",
  Create: "Create",
  DiscountCodesUpdate: "DiscountCodesUpdate",
  GiftCardCodesUpdate: "GiftCardCodesUpdate",
  GiftCardCodesRemove: "GiftCardCodesRemove",
  LinesAdd: "LinesAdd",
  LinesRemove: "LinesRemove",
  LinesUpdate: "LinesUpdate",
  NoteUpdate: "NoteUpdate",
  SelectedDeliveryOptionsUpdate: "SelectedDeliveryOptionsUpdate",
  MetafieldsSet: "MetafieldsSet",
  MetafieldDelete: "MetafieldDelete",
  DeliveryAddressesAdd: "DeliveryAddressesAdd",
  DeliveryAddressesUpdate: "DeliveryAddressesUpdate",
  DeliveryAddressesRemove: "DeliveryAddressesRemove"
};
function getFormInput(formData) {
  const data = {};
  for (const pair of formData.entries()) {
    const key = pair[0];
    const values = formData.getAll(key);
    data[key] = values.length > 1 ? values : pair[1];
    if (data[key] === "on") {
      data[key] = true;
    } else if (data[key] === "off") {
      data[key] = false;
    }
  }
  const { cartFormInput, ...otherData } = data;
  const { action, inputs } = cartFormInput ? JSON.parse(String(cartFormInput)) : {};
  return {
    action,
    inputs: {
      ...inputs,
      ...otherData
    }
  };
}
CartForm.getFormInput = getFormInput;
var cartGetIdDefault = (requestHeaders) => {
  const cookies = u(getHeaderValue(requestHeaders, "Cookie") || "");
  return () => {
    return cookies.cart ? `gid://shopify/Cart/${cookies.cart}` : void 0;
  };
};
var cartSetIdDefault = (cookieOptions) => {
  return (cartId) => {
    const headers = new Headers();
    headers.append(
      "Set-Cookie",
      l("cart", cartId.split("/").pop() || "", {
        path: "/",
        ...cookieOptions
      })
    );
    return headers;
  };
};
var STOREFRONT_REQUEST_GROUP_ID_HEADER = "Custom-Storefront-Request-Group-ID";
var STOREFRONT_ACCESS_TOKEN_HEADER = "X-Shopify-Storefront-Access-Token";
var SDK_VARIANT_HEADER2 = "X-SDK-Variant";
var SDK_VARIANT_SOURCE_HEADER = "X-SDK-Variant-Source";
var SDK_VERSION_HEADER2 = "X-SDK-Version";
function generateUUID() {
  if (typeof crypto !== "undefined" && !!crypto.randomUUID) {
    return crypto.randomUUID();
  } else {
    return `weak-${Math.random().toString(16).substring(2)}`;
  }
}
var LIB_VERSION = "2025.7.0";
function minifyQuery(string) {
  return string.replace(/\s*#.*$/gm, "").replace(/\s+/gm, " ").trim();
}
var IS_QUERY_RE = /(^|}\s)query[\s({]/im;
var IS_MUTATION_RE = /(^|}\s)mutation[\s({]/im;
function assertQuery(query, callerName) {
  if (!IS_QUERY_RE.test(query)) {
    throw new Error(`[h2:error:${callerName}] Can only execute queries`);
  }
}
function assertMutation(query, callerName) {
  if (!IS_MUTATION_RE.test(query)) {
    throw new Error(`[h2:error:${callerName}] Can only execute mutations`);
  }
}
var GraphQLError = class extends Error {
  constructor(message, options = {}) {
    const h2Prefix = options.clientOperation ? `[h2:error:${options.clientOperation}] ` : "";
    const enhancedMessage = h2Prefix + message + (options.requestId ? ` - Request ID: ${options.requestId}` : "");
    super(enhancedMessage);
    /**
     * If an error can be associated to a particular point in the requested
     * GraphQL document, it should contain a list of locations.
     */
    __publicField(this, "locations");
    /**
     * If an error can be associated to a particular field in the GraphQL result,
     * it _must_ contain an entry with the key `path` that details the path of
     * the response field which experienced the error. This allows clients to
     * identify whether a null result is intentional or caused by a runtime error.
     */
    __publicField(this, "path");
    /**
     * Reserved for implementors to extend the protocol however they see fit,
     * and hence there are no additional restrictions on its contents.
     */
    __publicField(this, "extensions");
    this.name = "GraphQLError";
    this.extensions = options.extensions;
    this.locations = options.locations;
    this.path = options.path;
    this.stack = options.stack || void 0;
    try {
      this.cause = JSON.stringify({
        ...typeof options.cause === "object" ? options.cause : {},
        requestId: options.requestId,
        ...{
          path: options.path,
          extensions: options.extensions,
          graphql: h2Prefix && options.query && {
            query: options.query,
            variables: JSON.stringify(options.queryVariables)
          }
        }
      });
    } catch {
      if (options.cause) this.cause = options.cause;
    }
  }
  get [Symbol.toStringTag]() {
    return this.name;
  }
  /**
   * Note: `toString()` is internally used by `console.log(...)` / `console.error(...)`
   * when ingesting logs in Oxygen production. Therefore, we want to make sure that
   * the error message is as informative as possible instead of `[object Object]`.
   */
  toString() {
    let result = `${this.name}: ${this.message}`;
    if (this.path) {
      try {
        result += ` | path: ${JSON.stringify(this.path)}`;
      } catch {
      }
    }
    if (this.extensions) {
      try {
        result += ` | extensions: ${JSON.stringify(this.extensions)}`;
      } catch {
      }
    }
    result += "\n";
    if (this.stack) {
      result += `${this.stack.slice(this.stack.indexOf("\n") + 1)}
`;
    }
    return result;
  }
  /**
   * Note: toJSON` is internally used by `JSON.stringify(...)`.
   * The most common scenario when this error instance is going to be stringified is
   * when it's passed to Remix' `json` and `defer` functions: e.g. `{promise: storefront.query(...)}`.
   * In this situation, we don't want to expose private error information to the browser so we only
   * do it in development.
   */
  toJSON() {
    const formatted = { name: "Error", message: "" };
    {
      formatted.name = this.name;
      formatted.message = "Development: " + this.message;
      if (this.path) formatted.path = this.path;
      if (this.locations) formatted.locations = this.locations;
      if (this.extensions) formatted.extensions = this.extensions;
    }
    return formatted;
  }
};
function throwErrorWithGqlLink({
  url,
  response,
  errors: errors2,
  type,
  query,
  queryVariables,
  ErrorConstructor = Error,
  client = "storefront"
}) {
  var _a3;
  const errorMessage = (typeof errors2 === "string" ? errors2 : (_a3 = errors2 == null ? void 0 : errors2.map) == null ? void 0 : _a3.call(errors2, (error) => error.message).join("\n")) || `URL: ${url}
API response error: ${response.status}`;
  const gqlError = new GraphQLError(errorMessage, {
    query,
    queryVariables,
    cause: { errors: errors2 },
    clientOperation: `${client}.${type}`,
    requestId: response.headers.get("x-request-id")
  });
  throw new ErrorConstructor(gqlError.message, { cause: gqlError.cause });
}
var defaultI18n = {
  language: "EN",
  country: "US"
};
function createStorefrontClient2(options) {
  const {
    storefrontHeaders,
    cache,
    waitUntil,
    i18n,
    storefrontId,
    logErrors = true,
    ...clientOptions
  } = options;
  const H2_PREFIX_WARN = "[h2:warn:createStorefrontClient] ";
  if (!cache) {
    warnOnce2(
      H2_PREFIX_WARN + "Storefront API client created without a cache instance. This may slow down your sub-requests."
    );
  }
  const {
    getPublicTokenHeaders,
    getPrivateTokenHeaders,
    getStorefrontApiUrl,
    getShopifyDomain
  } = createStorefrontClient(clientOptions);
  const getHeaders = clientOptions.privateStorefrontToken ? getPrivateTokenHeaders : getPublicTokenHeaders;
  const defaultHeaders = getHeaders({
    contentType: "json",
    buyerIp: (storefrontHeaders == null ? void 0 : storefrontHeaders.buyerIp) || ""
  });
  defaultHeaders[STOREFRONT_REQUEST_GROUP_ID_HEADER] = (storefrontHeaders == null ? void 0 : storefrontHeaders.requestGroupId) || generateUUID();
  if (storefrontId) defaultHeaders[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
  defaultHeaders["user-agent"] = `Hydrogen ${LIB_VERSION}`;
  if (storefrontHeaders && storefrontHeaders.cookie) {
    const cookies = getShopifyCookies(storefrontHeaders.cookie ?? "");
    if (cookies[SHOPIFY_Y])
      defaultHeaders[SHOPIFY_STOREFRONT_Y_HEADER] = cookies[SHOPIFY_Y];
    if (cookies[SHOPIFY_S])
      defaultHeaders[SHOPIFY_STOREFRONT_S_HEADER] = cookies[SHOPIFY_S];
  }
  const cacheKeyHeader = JSON.stringify({
    "content-type": defaultHeaders["content-type"],
    "user-agent": defaultHeaders["user-agent"],
    [SDK_VARIANT_HEADER2]: defaultHeaders[SDK_VARIANT_HEADER2],
    [SDK_VARIANT_SOURCE_HEADER]: defaultHeaders[SDK_VARIANT_SOURCE_HEADER],
    [SDK_VERSION_HEADER2]: defaultHeaders[SDK_VERSION_HEADER2],
    [STOREFRONT_ACCESS_TOKEN_HEADER]: defaultHeaders[STOREFRONT_ACCESS_TOKEN_HEADER]
  });
  async function fetchStorefrontApi({
    query,
    mutation,
    variables,
    cache: cacheOptions,
    headers = [],
    storefrontApiVersion,
    displayName,
    stackInfo
  }) {
    const userHeaders = headers instanceof Headers ? Object.fromEntries(headers.entries()) : Array.isArray(headers) ? Object.fromEntries(headers) : headers;
    const document2 = query ?? mutation;
    const queryVariables = { ...variables };
    if (i18n) {
      if (!(variables == null ? void 0 : variables.country) && /\$country/.test(document2)) {
        queryVariables.country = i18n.country;
      }
      if (!(variables == null ? void 0 : variables.language) && /\$language/.test(document2)) {
        queryVariables.language = i18n.language;
      }
    }
    const url = getStorefrontApiUrl({ storefrontApiVersion });
    const graphqlData = JSON.stringify({
      query: document2,
      variables: queryVariables
    });
    const requestInit = {
      method: "POST",
      headers: { ...defaultHeaders, ...userHeaders },
      body: graphqlData
    };
    const cacheKey = [
      url,
      requestInit.method,
      cacheKeyHeader,
      requestInit.body
    ];
    const streamConfig = document2.includes("@defer") ? {
      query: document2,
      variables: queryVariables
    } : void 0;
    const [body, response] = await fetchWithServerCache(url, requestInit, {
      cacheInstance: mutation ? void 0 : cache,
      cache: cacheOptions || CacheDefault(),
      cacheKey,
      waitUntil,
      // Check if the response body has GraphQL errors:
      // https://spec.graphql.org/June2018/#sec-Response-Format
      shouldCacheResponse: (body2) => !(body2 == null ? void 0 : body2.errors),
      // Optional information for the subrequest profiler:
      debugInfo: {
        requestId: requestInit.headers[STOREFRONT_REQUEST_GROUP_ID_HEADER],
        displayName,
        url,
        stackInfo,
        graphql: graphqlData,
        purpose: storefrontHeaders == null ? void 0 : storefrontHeaders.purpose
      },
      streamConfig
    });
    const errorOptions = {
      url,
      response,
      type: mutation ? "mutation" : "query",
      query: document2,
      queryVariables,
      errors: void 0
    };
    if (!response.ok) {
      let errors3;
      let bodyText = body;
      try {
        bodyText ?? (bodyText = await response.text());
        errors3 = parseJSON2(bodyText);
      } catch (_e) {
        errors3 = [
          { message: bodyText ?? "Could not parse Storefront API response" }
        ];
      }
      throwErrorWithGqlLink({ ...errorOptions, errors: errors3 });
    }
    let { data, errors: errors2 } = body;
    errors2 = errors2 ? Array.isArray(errors2) ? errors2 : [errors2] : void 0;
    const gqlErrors = errors2 == null ? void 0 : errors2.map(
      ({ message, ...rest }) => new GraphQLError(message, {
        ...rest,
        clientOperation: `storefront.${errorOptions.type}`,
        requestId: response.headers.get("x-request-id"),
        queryVariables,
        query: document2
      })
    );
    return formatAPIResult(data, gqlErrors);
  }
  return {
    storefront: {
      /**
       * Sends a GraphQL query to the Storefront API.
       *
       * Example:
       *
       * ```js
       * async function loader ({context: {storefront}}) {
       *   const data = await storefront.query('query { ... }', {
       *     variables: {},
       *     cache: storefront.CacheLong()
       *   });
       * }
       * ```
       */
      query(query, options2) {
        query = minifyQuery(query);
        assertQuery(query, "storefront.query");
        const stackOffset = getStackOffset == null ? void 0 : getStackOffset(query);
        return withSyncStack(
          fetchStorefrontApi({
            ...options2,
            query,
            stackInfo: getCallerStackLine == null ? void 0 : getCallerStackLine(stackOffset)
          }),
          { stackOffset, logErrors }
        );
      },
      /**
       * Sends a GraphQL mutation to the Storefront API.
       *
       * Example:
       *
       * ```js
       * async function loader ({context: {storefront}}) {
       *   await storefront.mutate('mutation { ... }', {
       *     variables: {},
       *   });
       * }
       * ```
       */
      mutate(mutation, options2) {
        mutation = minifyQuery(mutation);
        assertMutation(mutation, "storefront.mutate");
        const stackOffset = getStackOffset == null ? void 0 : getStackOffset(mutation);
        return withSyncStack(
          fetchStorefrontApi({
            ...options2,
            mutation,
            stackInfo: getCallerStackLine == null ? void 0 : getCallerStackLine(stackOffset)
          }),
          { stackOffset, logErrors }
        );
      },
      cache,
      CacheNone,
      CacheLong,
      CacheShort,
      CacheCustom,
      generateCacheControlHeader,
      getPublicTokenHeaders,
      getPrivateTokenHeaders,
      getShopifyDomain,
      getApiUrl: getStorefrontApiUrl,
      i18n: i18n ?? defaultI18n
    }
  };
}
var getStackOffset = (query) => {
  let stackOffset = 0;
  if (/fragment CartApi(Query|Mutation) on Cart/.test(query)) {
    stackOffset = 1;
  }
  return stackOffset;
};
function formatAPIResult(data, errors2) {
  return {
    ...data,
    ...errors2 && { errors: errors2 }
  };
}
function cartGetDefault({
  storefront,
  customerAccount,
  getCartId,
  cartFragment
}) {
  return async (cartInput) => {
    const cartId = getCartId();
    if (!cartId) return null;
    const [isCustomerLoggedIn, { cart, errors: errors2 }] = await Promise.all([
      customerAccount ? customerAccount.isLoggedIn() : false,
      storefront.query(CART_QUERY(cartFragment), {
        variables: { cartId, ...cartInput },
        cache: storefront.CacheNone()
      })
    ]);
    if (isCustomerLoggedIn && (cart == null ? void 0 : cart.checkoutUrl)) {
      const finalCheckoutUrl = new URL(cart.checkoutUrl);
      finalCheckoutUrl.searchParams.set("logged_in", "true");
      cart.checkoutUrl = finalCheckoutUrl.toString();
    }
    return cart || errors2 ? formatAPIResult(cart, errors2) : null;
  };
}
var CART_QUERY = (cartFragment = DEFAULT_CART_FRAGMENT) => `#graphql
  query CartQuery(
    $cartId: ID!
    $numCartLines: Int = 100
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cart(id: $cartId) {
      ...CartApiQuery
    }
  }

  ${cartFragment}
`;
var DEFAULT_CART_FRAGMENT = `#graphql
  fragment CartApiQuery on Cart {
    updatedAt
    id
    checkoutUrl
    totalQuantity
    buyerIdentity {
      countryCode
      customer {
        id
        email
        firstName
        lastName
        displayName
      }
      email
      phone
    }
    lines(first: $numCartLines) {
      edges {
        node {
          id
          quantity
          attributes {
            key
            value
          }
          cost {
            totalAmount {
              amount
              currencyCode
            }
            amountPerQuantity {
              amount
              currencyCode
            }
            compareAtAmountPerQuantity {
              amount
              currencyCode
            }
          }
          merchandise {
            ... on ProductVariant {
              id
              availableForSale
              compareAtPrice {
                ...CartApiMoney
              }
              price {
                ...CartApiMoney
              }
              requiresShipping
              title
              image {
                ...CartApiImage
              }
              product {
                handle
                title
                id
                vendor
              }
              selectedOptions {
                name
                value
              }
            }
          }
        }
      }
    }
    cost {
      subtotalAmount {
        ...CartApiMoney
      }
      totalAmount {
        ...CartApiMoney
      }
      totalDutyAmount {
        ...CartApiMoney
      }
      totalTaxAmount {
        ...CartApiMoney
      }
    }
    note
    attributes {
      key
      value
    }
    discountCodes {
      applicable
      code
    }
    appliedGiftCards {
      id
      lastCharacters
      amountUsed {
        ...CartApiMoney
      }
    }
  }

  fragment CartApiMoney on MoneyV2 {
    currencyCode
    amount
  }

  fragment CartApiImage on Image {
    id
    url
    altText
    width
    height
  }
`;
var USER_ERROR_FRAGMENT = `#graphql
  fragment CartApiError on CartUserError {
    message
    field
    code
  }
`;
var MINIMAL_CART_FRAGMENT = `#graphql
  fragment CartApiMutation on Cart {
    id
    totalQuantity
    checkoutUrl
  }
`;
var CART_WARNING_FRAGMENT = `#graphql
  fragment CartApiWarning on CartWarning {
    code
    message
    target
  }
`;
function cartCreateDefault(options) {
  return async (input, optionalParams) => {
    const buyer = options.customerAccount ? await options.customerAccount.getBuyer() : void 0;
    const { cartId, ...restOfOptionalParams } = optionalParams || {};
    const { buyerIdentity, ...restOfInput } = input;
    const { cartCreate, errors: errors2 } = await options.storefront.mutate(CART_CREATE_MUTATION(options.cartFragment), {
      variables: {
        input: {
          ...restOfInput,
          buyerIdentity: {
            ...buyer,
            ...buyerIdentity
          }
        },
        ...restOfOptionalParams
      }
    });
    return formatAPIResult(cartCreate, errors2);
  };
}
var CART_CREATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartCreate(
    $input: CartInput!
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartCreate(input: $input) {
      cart {
        ...CartApiMutation
        checkoutUrl
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartLinesAddDefault(options) {
  return async (lines, optionalParams) => {
    const { cartLinesAdd, errors: errors2 } = await options.storefront.mutate(CART_LINES_ADD_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        lines,
        ...optionalParams
      }
    });
    return formatAPIResult(cartLinesAdd, errors2);
  };
}
var CART_LINES_ADD_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartLinesAdd(
    $cartId: ID!
    $lines: [CartLineInput!]!
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
var PENDING_PREFIX = "__h_pending_";
function getOptimisticLineId(variantId) {
  return PENDING_PREFIX + variantId;
}
function isOptimisticLineId(lineId) {
  return lineId.startsWith(PENDING_PREFIX);
}
function throwIfLinesAreOptimistic(type, lines) {
  if (lines.some(
    (line) => isOptimisticLineId(typeof line === "string" ? line : line.id)
  )) {
    throw new Error(
      `Tried to perform an action on an optimistic line. Make sure to disable your "${type}" CartForm action when the line is optimistic.`
    );
  }
}
function cartLinesUpdateDefault(options) {
  return async (lines, optionalParams) => {
    throwIfLinesAreOptimistic("updateLines", lines);
    const { cartLinesUpdate, errors: errors2 } = await options.storefront.mutate(CART_LINES_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        lines,
        ...optionalParams
      }
    });
    return formatAPIResult(cartLinesUpdate, errors2);
  };
}
var CART_LINES_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartLinesUpdate(
    $cartId: ID!
    $lines: [CartLineUpdateInput!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartLinesUpdate(cartId: $cartId, lines: $lines) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartLinesRemoveDefault(options) {
  return async (lineIds, optionalParams) => {
    throwIfLinesAreOptimistic("removeLines", lineIds);
    const { cartLinesRemove, errors: errors2 } = await options.storefront.mutate(CART_LINES_REMOVE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        lineIds,
        ...optionalParams
      }
    });
    return formatAPIResult(cartLinesRemove, errors2);
  };
}
var CART_LINES_REMOVE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartLinesRemove(
    $cartId: ID!
    $lineIds: [ID!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartLinesRemove(cartId: $cartId, lineIds: $lineIds) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartDiscountCodesUpdateDefault(options) {
  return async (discountCodes, optionalParams) => {
    const uniqueCodes = discountCodes.filter((value, index, array) => {
      return array.indexOf(value) === index;
    });
    const { cartDiscountCodesUpdate, errors: errors2 } = await options.storefront.mutate(CART_DISCOUNT_CODE_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        discountCodes: uniqueCodes,
        ...optionalParams
      }
    });
    return formatAPIResult(cartDiscountCodesUpdate, errors2);
  };
}
var CART_DISCOUNT_CODE_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartDiscountCodesUpdate(
    $cartId: ID!
    $discountCodes: [String!]
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartDiscountCodesUpdate(cartId: $cartId, discountCodes: $discountCodes) {
      ... @defer {
        cart {
          ...CartApiMutation
        }
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartBuyerIdentityUpdateDefault(options) {
  return async (buyerIdentity, optionalParams) => {
    if (buyerIdentity.companyLocationId && options.customerAccount) {
      options.customerAccount.setBuyer({
        companyLocationId: buyerIdentity.companyLocationId
      });
    }
    const buyer = options.customerAccount ? await options.customerAccount.getBuyer() : void 0;
    const { cartBuyerIdentityUpdate, errors: errors2 } = await options.storefront.mutate(CART_BUYER_IDENTITY_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        buyerIdentity: {
          ...buyer,
          ...buyerIdentity
        },
        ...optionalParams
      }
    });
    return formatAPIResult(cartBuyerIdentityUpdate, errors2);
  };
}
var CART_BUYER_IDENTITY_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartBuyerIdentityUpdate(
    $cartId: ID!
    $buyerIdentity: CartBuyerIdentityInput!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartBuyerIdentityUpdate(cartId: $cartId, buyerIdentity: $buyerIdentity) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartNoteUpdateDefault(options) {
  return async (note, optionalParams) => {
    const { cartNoteUpdate, errors: errors2 } = await options.storefront.mutate(CART_NOTE_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        note,
        ...optionalParams
      }
    });
    return formatAPIResult(cartNoteUpdate, errors2);
  };
}
var CART_NOTE_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartNoteUpdate(
    $cartId: ID!
    $note: String!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartNoteUpdate(cartId: $cartId, note: $note) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartSelectedDeliveryOptionsUpdateDefault(options) {
  return async (selectedDeliveryOptions, optionalParams) => {
    const { cartSelectedDeliveryOptionsUpdate, errors: errors2 } = await options.storefront.mutate(CART_SELECTED_DELIVERY_OPTIONS_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        selectedDeliveryOptions,
        ...optionalParams
      }
    });
    return formatAPIResult(cartSelectedDeliveryOptionsUpdate, errors2);
  };
}
var CART_SELECTED_DELIVERY_OPTIONS_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartSelectedDeliveryOptionsUpdate(
    $cartId: ID!
    $selectedDeliveryOptions: [CartSelectedDeliveryOptionInput!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartSelectedDeliveryOptionsUpdate(cartId: $cartId, selectedDeliveryOptions: $selectedDeliveryOptions) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartAttributesUpdateDefault(options) {
  return async (attributes, optionalParams) => {
    const { cartAttributesUpdate, errors: errors2 } = await options.storefront.mutate(CART_ATTRIBUTES_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: (optionalParams == null ? void 0 : optionalParams.cartId) || options.getCartId(),
        attributes
      }
    });
    return formatAPIResult(cartAttributesUpdate, errors2);
  };
}
var CART_ATTRIBUTES_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartAttributesUpdate(
    $cartId: ID!
    $attributes: [AttributeInput!]!
  ) {
    cartAttributesUpdate(cartId: $cartId, attributes: $attributes) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartMetafieldsSetDefault(options) {
  return async (metafields, optionalParams) => {
    const ownerId = (optionalParams == null ? void 0 : optionalParams.cartId) || options.getCartId();
    const metafieldsWithOwnerId = metafields.map(
      (metafield) => ({
        ...metafield,
        ownerId
      })
    );
    const { cartMetafieldsSet, errors: errors2 } = await options.storefront.mutate(CART_METAFIELD_SET_MUTATION(), {
      variables: { metafields: metafieldsWithOwnerId }
    });
    return formatAPIResult(
      {
        cart: {
          id: ownerId
        },
        ...cartMetafieldsSet
      },
      errors2
    );
  };
}
var CART_METAFIELD_SET_MUTATION = () => `#graphql
  mutation cartMetafieldsSet(
    $metafields: [CartMetafieldsSetInput!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartMetafieldsSet(metafields: $metafields) {
      userErrors {
        code
        elementIndex
        field
        message
      }
    }
  }
`;
function cartMetafieldDeleteDefault(options) {
  return async (key, optionalParams) => {
    const ownerId = (optionalParams == null ? void 0 : optionalParams.cartId) || options.getCartId();
    const { cartMetafieldDelete, errors: errors2 } = await options.storefront.mutate(CART_METAFIELD_DELETE_MUTATION(), {
      variables: {
        input: {
          ownerId,
          key
        }
      }
    });
    return formatAPIResult(
      {
        cart: {
          id: ownerId
        },
        ...cartMetafieldDelete
      },
      errors2
    );
  };
}
var CART_METAFIELD_DELETE_MUTATION = () => `#graphql
  mutation cartMetafieldDelete(
    $input: CartMetafieldDeleteInput!
  ) {
    cartMetafieldDelete(input: $input) {
      userErrors {
        code
        field
        message
      }
    }
  }
`;
function cartGiftCardCodesUpdateDefault(options) {
  return async (giftCardCodes, optionalParams) => {
    const uniqueCodes = giftCardCodes.filter((value, index, array) => {
      return array.indexOf(value) === index;
    });
    const { cartGiftCardCodesUpdate, errors: errors2 } = await options.storefront.mutate(CART_GIFT_CARD_CODE_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        giftCardCodes: uniqueCodes,
        ...optionalParams
      }
    });
    return formatAPIResult(cartGiftCardCodesUpdate, errors2);
  };
}
var CART_GIFT_CARD_CODE_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartGiftCardCodesUpdate(
    $cartId: ID!
    $giftCardCodes: [String!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartGiftCardCodesUpdate(cartId: $cartId, giftCardCodes: $giftCardCodes) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartGiftCardCodesRemoveDefault(options) {
  return async (appliedGiftCardIds, optionalParams) => {
    const { cartGiftCardCodesRemove, errors: errors2 } = await options.storefront.mutate(CART_GIFT_CARD_CODES_REMOVE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        appliedGiftCardIds,
        ...optionalParams
      }
    });
    return formatAPIResult(cartGiftCardCodesRemove, errors2);
  };
}
var CART_GIFT_CARD_CODES_REMOVE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartGiftCardCodesRemove(
    $cartId: ID!
    $appliedGiftCardIds: [ID!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartGiftCardCodesRemove(cartId: $cartId, appliedGiftCardIds: $appliedGiftCardIds) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartDeliveryAddressesAddDefault(options) {
  return async (addresses, optionalParams) => {
    const { cartDeliveryAddressesAdd, errors: errors2 } = await options.storefront.mutate(CART_DELIVERY_ADDRESSES_ADD_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        addresses,
        ...optionalParams
      }
    });
    return formatAPIResult(cartDeliveryAddressesAdd, errors2);
  };
}
var CART_DELIVERY_ADDRESSES_ADD_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartDeliveryAddressesAdd(
    $cartId: ID!
    $addresses: [CartSelectableAddressInput!]!,
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartDeliveryAddressesAdd(addresses: $addresses, cartId: $cartId) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartDeliveryAddressesRemoveDefault(options) {
  return async (addressIds, optionalParams) => {
    const { cartDeliveryAddressesRemove, errors: errors2 } = await options.storefront.mutate(CART_DELIVERY_ADDRESSES_REMOVE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        addressIds,
        ...optionalParams
      }
    });
    return formatAPIResult(cartDeliveryAddressesRemove, errors2);
  };
}
var CART_DELIVERY_ADDRESSES_REMOVE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartDeliveryAddressesRemove(
    $cartId: ID!
    $addressIds: [ID!]!,
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartDeliveryAddressesRemove(addressIds: $addressIds, cartId: $cartId) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function cartDeliveryAddressesUpdateDefault(options) {
  return async (addresses, optionalParams) => {
    const { cartDeliveryAddressesUpdate, errors: errors2 } = await options.storefront.mutate(CART_DELIVERY_ADDRESSES_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        addresses,
        ...optionalParams
      }
    });
    return formatAPIResult(cartDeliveryAddressesUpdate, errors2);
  };
}
var CART_DELIVERY_ADDRESSES_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartDeliveryAddressesUpdate(
    $cartId: ID!
    $addresses: [CartSelectableAddressUpdateInput!]!,
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartDeliveryAddressesUpdate(addresses: $addresses, cartId: $cartId) {
      cart {
        ...CartApiMutation
      }
      userErrors {
        ...CartApiError
      }
      warnings {
        ...CartApiWarning
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
  ${CART_WARNING_FRAGMENT}
`;
function createCartHandler(options) {
  const {
    getCartId: _getCartId,
    setCartId,
    storefront,
    customerAccount,
    cartQueryFragment,
    cartMutateFragment,
    buyerIdentity
  } = options;
  let cartId = _getCartId();
  const getCartId = () => cartId || _getCartId();
  const mutateOptions = {
    storefront,
    getCartId,
    cartFragment: cartMutateFragment,
    customerAccount
  };
  const _cartCreate = cartCreateDefault(mutateOptions);
  const cartCreate = async function(...args) {
    var _a3;
    args[0].buyerIdentity = {
      ...buyerIdentity,
      ...args[0].buyerIdentity
    };
    const result = await _cartCreate(...args);
    cartId = (_a3 = result == null ? void 0 : result.cart) == null ? void 0 : _a3.id;
    return result;
  };
  const methods = {
    get: cartGetDefault({
      storefront,
      customerAccount,
      getCartId,
      cartFragment: cartQueryFragment
    }),
    getCartId,
    setCartId,
    create: cartCreate,
    addLines: async (linesWithOptimisticData, optionalParams) => {
      const lines = linesWithOptimisticData.map((line) => {
        return {
          attributes: line.attributes,
          quantity: line.quantity,
          merchandiseId: line.merchandiseId,
          sellingPlanId: line.sellingPlanId
        };
      });
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartLinesAddDefault(mutateOptions)(lines, optionalParams) : await cartCreate({ lines, buyerIdentity }, optionalParams);
    },
    updateLines: cartLinesUpdateDefault(mutateOptions),
    removeLines: cartLinesRemoveDefault(mutateOptions),
    updateDiscountCodes: async (discountCodes, optionalParams) => {
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartDiscountCodesUpdateDefault(mutateOptions)(
        discountCodes,
        optionalParams
      ) : await cartCreate({ discountCodes }, optionalParams);
    },
    updateGiftCardCodes: async (giftCardCodes, optionalParams) => {
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartGiftCardCodesUpdateDefault(mutateOptions)(
        giftCardCodes,
        optionalParams
      ) : await cartCreate({ giftCardCodes }, optionalParams);
    },
    removeGiftCardCodes: cartGiftCardCodesRemoveDefault(mutateOptions),
    updateBuyerIdentity: async (buyerIdentity2, optionalParams) => {
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartBuyerIdentityUpdateDefault(mutateOptions)(
        buyerIdentity2,
        optionalParams
      ) : await cartCreate({ buyerIdentity: buyerIdentity2 }, optionalParams);
    },
    updateNote: async (note, optionalParams) => {
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartNoteUpdateDefault(mutateOptions)(note, optionalParams) : await cartCreate({ note }, optionalParams);
    },
    updateSelectedDeliveryOption: cartSelectedDeliveryOptionsUpdateDefault(mutateOptions),
    updateAttributes: async (attributes, optionalParams) => {
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartAttributesUpdateDefault(mutateOptions)(
        attributes,
        optionalParams
      ) : await cartCreate({ attributes }, optionalParams);
    },
    setMetafields: async (metafields, optionalParams) => {
      return cartId || (optionalParams == null ? void 0 : optionalParams.cartId) ? await cartMetafieldsSetDefault(mutateOptions)(
        metafields,
        optionalParams
      ) : await cartCreate({ metafields }, optionalParams);
    },
    deleteMetafield: cartMetafieldDeleteDefault(mutateOptions),
    addDeliveryAddresses: cartDeliveryAddressesAddDefault(mutateOptions),
    removeDeliveryAddresses: cartDeliveryAddressesRemoveDefault(mutateOptions),
    updateDeliveryAddresses: cartDeliveryAddressesUpdateDefault(mutateOptions)
  };
  if ("customMethods" in options) {
    return {
      ...methods,
      ...options.customMethods ?? {}
    };
  } else {
    return methods;
  }
}
function useOptimisticCart(cart) {
  const fetchers = useFetchers();
  if (!fetchers || !fetchers.length) return cart;
  const optimisticCart = (cart == null ? void 0 : cart.lines) ? structuredClone(cart) : { lines: { nodes: [] } };
  const cartLines = optimisticCart.lines.nodes;
  let isOptimistic = false;
  for (const { formData } of fetchers) {
    if (!formData) continue;
    const cartFormData = CartForm.getFormInput(formData);
    if (cartFormData.action === CartForm.ACTIONS.LinesAdd) {
      for (const input of cartFormData.inputs.lines) {
        if (!input.selectedVariant) {
          console.error(
            "[h2:error:useOptimisticCart] No selected variant was passed in the cart action. Make sure to pass the selected variant if you want to use an optimistic cart"
          );
          continue;
        }
        const existingLine = cartLines.find(
          (line) => {
            var _a3;
            return line.merchandise.id === ((_a3 = input.selectedVariant) == null ? void 0 : _a3.id);
          }
        );
        isOptimistic = true;
        if (existingLine) {
          existingLine.quantity = (existingLine.quantity || 1) + (input.quantity || 1);
          existingLine.isOptimistic = true;
        } else {
          cartLines.unshift({
            id: getOptimisticLineId(input.selectedVariant.id),
            merchandise: input.selectedVariant,
            isOptimistic: true,
            quantity: input.quantity || 1
          });
        }
      }
    } else if (cartFormData.action === CartForm.ACTIONS.LinesRemove) {
      for (const lineId of cartFormData.inputs.lineIds) {
        const index = cartLines.findIndex((line) => line.id === lineId);
        if (index !== -1) {
          if (isOptimisticLineId(cartLines[index].id)) {
            console.error(
              "[h2:error:useOptimisticCart] Tried to remove an optimistic line that has not been added to the cart yet"
            );
            continue;
          }
          cartLines.splice(index, 1);
          isOptimistic = true;
        } else {
          console.warn(
            `[h2:warn:useOptimisticCart] Tried to remove line '${lineId}' but it doesn't exist in the cart`
          );
        }
      }
    } else if (cartFormData.action === CartForm.ACTIONS.LinesUpdate) {
      for (const line of cartFormData.inputs.lines) {
        const index = cartLines.findIndex(
          (optimisticLine) => line.id === optimisticLine.id
        );
        if (index > -1) {
          if (isOptimisticLineId(cartLines[index].id)) {
            console.error(
              "[h2:error:useOptimisticCart] Tried to update an optimistic line that has not been added to the cart yet"
            );
            continue;
          }
          cartLines[index].quantity = line.quantity;
          if (cartLines[index].quantity === 0) {
            cartLines.splice(index, 1);
          }
          isOptimistic = true;
        } else {
          console.warn(
            `[h2:warn:useOptimisticCart] Tried to update line '${line.id}' but it doesn't exist in the cart`
          );
        }
      }
    }
  }
  if (isOptimistic) {
    optimisticCart.isOptimistic = isOptimistic;
  }
  optimisticCart.totalQuantity = cartLines.reduce(
    (sum, line) => sum + line.quantity,
    0
  );
  return optimisticCart;
}
var DEFAULT_GITHUB_CHANGELOG_URL = "https://raw.githubusercontent.com/Shopify/hydrogen/main/docs/changelog.json";
async function changelogHandler({
  request,
  changelogUrl
}) {
  new URL(request.url).searchParams;
  const GITHUB_CHANGELOG_URL = changelogUrl || DEFAULT_GITHUB_CHANGELOG_URL;
  return fetch(GITHUB_CHANGELOG_URL);
}
var storefrontContext = createContext();
var cartContext = createContext();
var customerAccountContext = createContext();
var envContext = createContext();
var sessionContext = createContext();
var waitUntilContext = createContext();
var hydrogenContext = {
  storefront: storefrontContext,
  cart: cartContext,
  customerAccount: customerAccountContext,
  env: envContext,
  session: sessionContext,
  waitUntil: waitUntilContext
};
var DEFAULT_CUSTOMER_API_VERSION = "2025-07";
var USER_AGENT = `Shopify Hydrogen ${LIB_VERSION}`;
var CUSTOMER_API_CLIENT_ID = "30243aa5-17c1-465a-8493-944bcc4e88aa";
var CUSTOMER_ACCOUNT_SESSION_KEY = "customerAccount";
var BUYER_SESSION_KEY = "buyer";
var BadRequest = class extends Response {
  constructor(message, helpMessage, headers) {
    if (helpMessage && true) {
      console.error("Customer Account API Error: " + helpMessage);
    }
    super(`Bad request: ${message}`, { status: 400, headers });
  }
};
var logSubRequestEvent = ({
  url,
  response,
  startTime,
  query,
  variables,
  ...debugInfo
}) => {
  var _a3;
  (_a3 = globalThis.__H2O_LOG_EVENT) == null ? void 0 : _a3.call(globalThis, {
    ...debugInfo,
    eventType: "subrequest",
    url,
    startTime,
    graphql: query ? JSON.stringify({ query, variables, schema: "customer-account" }) : void 0,
    responseInit: {
      status: response.status || 0,
      statusText: response.statusText || "",
      headers: Array.from(response.headers.entries() || [])
    }
  });
};
function redirect(path, options = {}) {
  const headers = options.headers ? new Headers(options.headers) : new Headers({});
  headers.set("location", path);
  return new Response(null, { status: options.status || 302, headers });
}
async function refreshToken({
  session,
  customerAccountId,
  customerAccountTokenExchangeUrl,
  httpsOrigin,
  debugInfo
}) {
  const newBody = new URLSearchParams();
  const customerAccount = session.get(CUSTOMER_ACCOUNT_SESSION_KEY);
  const refreshToken2 = customerAccount == null ? void 0 : customerAccount.refreshToken;
  const idToken = customerAccount == null ? void 0 : customerAccount.idToken;
  if (!refreshToken2)
    throw new BadRequest(
      "Unauthorized",
      "No refreshToken found in the session. Make sure your session is configured correctly and passed to `createCustomerAccountClient`."
    );
  newBody.append("grant_type", "refresh_token");
  newBody.append("refresh_token", refreshToken2);
  newBody.append("client_id", customerAccountId);
  const headers = {
    "content-type": "application/x-www-form-urlencoded",
    "User-Agent": USER_AGENT,
    Origin: httpsOrigin
  };
  const startTime = (/* @__PURE__ */ new Date()).getTime();
  const url = customerAccountTokenExchangeUrl;
  const response = await fetch(url, {
    method: "POST",
    headers,
    body: newBody
  });
  logSubRequestEvent == null ? void 0 : logSubRequestEvent({
    displayName: "Customer Account API: access token refresh",
    url,
    startTime,
    response,
    ...debugInfo
  });
  if (!response.ok) {
    const text = await response.text();
    throw new Response(text, {
      status: response.status,
      headers: {
        "Content-Type": "text/html; charset=utf-8"
      }
    });
  }
  const {
    access_token,
    expires_in,
    refresh_token
  } = await response.json();
  if (!access_token || access_token.length === 0) {
    throw new BadRequest("Unauthorized", "Invalid access token received.");
  }
  session.set(CUSTOMER_ACCOUNT_SESSION_KEY, {
    accessToken: access_token,
    // Store the date in future the token expires, separated by two minutes
    expiresAt: new Date((/* @__PURE__ */ new Date()).getTime() + (expires_in - 120) * 1e3).getTime() + "",
    refreshToken: refresh_token,
    idToken
  });
}
function clearSession(session) {
  session.unset(CUSTOMER_ACCOUNT_SESSION_KEY);
  session.unset(BUYER_SESSION_KEY);
}
async function checkExpires({
  locks,
  expiresAt,
  session,
  customerAccountId,
  customerAccountTokenExchangeUrl,
  httpsOrigin,
  debugInfo
}) {
  if (parseInt(expiresAt, 10) - 1e3 < (/* @__PURE__ */ new Date()).getTime()) {
    try {
      if (!locks.refresh)
        locks.refresh = refreshToken({
          session,
          customerAccountId,
          customerAccountTokenExchangeUrl,
          httpsOrigin,
          debugInfo
        });
      await locks.refresh;
      delete locks.refresh;
    } catch (error) {
      clearSession(session);
      if (error && error.status !== 401) {
        throw error;
      } else {
        throw new BadRequest(
          "Unauthorized",
          "Login before querying the Customer Account API."
        );
      }
    }
  }
}
function generateCodeVerifier() {
  const rando = generateRandomCode();
  return base64UrlEncode(rando);
}
async function generateCodeChallenge(codeVerifier) {
  const digestOp = await crypto.subtle.digest(
    { name: "SHA-256" },
    new TextEncoder().encode(codeVerifier)
  );
  const hash = convertBufferToString(digestOp);
  return base64UrlEncode(hash);
}
function generateRandomCode() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return String.fromCharCode.apply(null, Array.from(array));
}
function base64UrlEncode(str) {
  const base64 = btoa(str);
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function convertBufferToString(hash) {
  const uintArray = new Uint8Array(hash);
  const numberArray = Array.from(uintArray);
  return String.fromCharCode(...numberArray);
}
function generateState() {
  const timestamp = Date.now().toString();
  const randomString = Math.random().toString(36).substring(2);
  return timestamp + randomString;
}
async function exchangeAccessToken(authAccessToken, customerAccountId, customerAccountTokenExchangeUrl, httpsOrigin, debugInfo) {
  const clientId = customerAccountId;
  if (!authAccessToken)
    throw new BadRequest(
      "Unauthorized",
      "oAuth access token was not provided during token exchange."
    );
  const body = new URLSearchParams();
  body.append("grant_type", "urn:ietf:params:oauth:grant-type:token-exchange");
  body.append("client_id", clientId);
  body.append("audience", CUSTOMER_API_CLIENT_ID);
  body.append("subject_token", authAccessToken);
  body.append(
    "subject_token_type",
    "urn:ietf:params:oauth:token-type:access_token"
  );
  body.append("scopes", "https://api.customers.com/auth/customer.graphql");
  const headers = {
    "content-type": "application/x-www-form-urlencoded",
    "User-Agent": USER_AGENT,
    Origin: httpsOrigin
  };
  const startTime = (/* @__PURE__ */ new Date()).getTime();
  const url = customerAccountTokenExchangeUrl;
  const response = await fetch(url, {
    method: "POST",
    headers,
    body
  });
  logSubRequestEvent == null ? void 0 : logSubRequestEvent({
    displayName: "Customer Account API: access token exchange",
    url,
    startTime,
    response,
    ...debugInfo
  });
  const data = await response.json();
  if (data.error) {
    throw new BadRequest(data.error_description);
  }
  return data.access_token;
}
function getNonce(token) {
  return decodeJwt(token).payload.nonce;
}
function decodeJwt(token) {
  const [header, payload, signature] = token.split(".");
  const decodedHeader = JSON.parse(atob(header));
  const decodedPayload = JSON.parse(atob(payload));
  return {
    header: decodedHeader,
    payload: decodedPayload,
    signature
  };
}
function generateNonce() {
  return toHexString(randomUint8Array());
}
function randomUint8Array() {
  try {
    return crypto.getRandomValues(new Uint8Array(16));
  } catch (e) {
    return new Uint8Array(16).map(() => Math.random() * 255 | 0);
  }
}
function toHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}
function getRedirectUrl(requestUrl) {
  if (!requestUrl) return;
  const { pathname, search } = new URL(requestUrl);
  const redirectFrom = pathname + search;
  const searchParams = new URLSearchParams(search);
  const redirectTo = searchParams.get("return_to") || searchParams.get("redirect");
  if (redirectTo) {
    if (isLocalPath(requestUrl, redirectTo)) {
      return redirectTo;
    } else {
      console.warn(
        `Cross-domain redirects are not supported. Tried to redirect from ${redirectFrom} to ${redirectTo}`
      );
    }
  }
}
function isLocalPath(requestUrl, redirectUrl) {
  try {
    return new URL(requestUrl).origin === new URL(redirectUrl, requestUrl).origin;
  } catch (e) {
    return false;
  }
}
function ensureLocalRedirectUrl({
  requestUrl,
  defaultUrl,
  redirectUrl
}) {
  const fromUrl = requestUrl;
  const defautlUrl = buildURLObject(requestUrl, defaultUrl);
  const toUrl = redirectUrl ? buildURLObject(requestUrl, redirectUrl) : defautlUrl;
  if (isLocalPath(requestUrl, toUrl.toString())) {
    return toUrl.toString();
  } else {
    console.warn(
      `Cross-domain redirects are not supported. Tried to redirect from ${fromUrl} to ${toUrl}. Default url ${defautlUrl} is used instead.`
    );
    return defautlUrl.toString();
  }
}
function buildURLObject(requestUrl, relativeOrAbsoluteUrl) {
  return isAbsoluteUrl(relativeOrAbsoluteUrl) ? new URL(relativeOrAbsoluteUrl) : new URL(relativeOrAbsoluteUrl, new URL(requestUrl).origin);
}
function isAbsoluteUrl(url) {
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
}
function createCustomerAccountHelper(customerApiVersion, shopId) {
  const customerAccountUrl = `https://shopify.com/${shopId}`;
  const customerAccountAuthUrl = `https://shopify.com/authentication/${shopId}`;
  return function getCustomerAccountUrl(urlType) {
    switch (urlType) {
      case "CA_BASE_URL":
        return customerAccountUrl;
      case "CA_BASE_AUTH_URL":
        return customerAccountAuthUrl;
      case "GRAPHQL":
        return `${customerAccountUrl}/account/customer/api/${customerApiVersion}/graphql`;
      case "AUTH":
        return `${customerAccountAuthUrl}/oauth/authorize`;
      case "LOGIN_SCOPE":
        return shopId ? "openid email customer-account-api:full" : "openid email https://api.customers.com/auth/customer.graphql";
      case "TOKEN_EXCHANGE":
        return `${customerAccountAuthUrl}/oauth/token`;
      case "LOGOUT":
        return `${customerAccountAuthUrl}/logout`;
    }
  };
}
function defaultAuthStatusHandler(request, defaultLoginUrl) {
  if (!request.url) return defaultLoginUrl;
  const { pathname } = new URL(request.url);
  const cleanedPathname = pathname.replace(/\.data$/, "").replace(/\/_root$/, "/").replace(/(.+)\/$/, "$1");
  const redirectTo = defaultLoginUrl + `?${new URLSearchParams({ return_to: cleanedPathname }).toString()}`;
  return redirect(redirectTo);
}
function createCustomerAccountClient({
  session,
  customerAccountId,
  shopId,
  customerApiVersion = DEFAULT_CUSTOMER_API_VERSION,
  request,
  waitUntil,
  authUrl,
  customAuthStatusHandler,
  logErrors = true,
  loginPath = "/account/login",
  authorizePath = "/account/authorize",
  defaultRedirectPath = "/account",
  language
}) {
  if (customerApiVersion !== DEFAULT_CUSTOMER_API_VERSION) {
    console.warn(
      `[h2:warn:createCustomerAccountClient] You are using Customer Account API version ${customerApiVersion} when this version of Hydrogen was built for ${DEFAULT_CUSTOMER_API_VERSION}.`
    );
  }
  if (!session) {
    console.warn(
      `[h2:warn:createCustomerAccountClient] session is required to use Customer Account API. Ensure the session object passed in exist.`
    );
  }
  if (!(request == null ? void 0 : request.url)) {
    throw new Error(
      "[h2:error:createCustomerAccountClient] The request object does not contain a URL."
    );
  }
  const authStatusHandler = customAuthStatusHandler ? customAuthStatusHandler : () => defaultAuthStatusHandler(request, loginPath);
  const requestUrl = new URL(request.url);
  const httpsOrigin = requestUrl.protocol === "http:" ? requestUrl.origin.replace("http", "https") : requestUrl.origin;
  const redirectUri = ensureLocalRedirectUrl({
    requestUrl: httpsOrigin,
    defaultUrl: authorizePath,
    redirectUrl: authUrl
  });
  const getCustomerAccountUrl = createCustomerAccountHelper(
    customerApiVersion,
    shopId
  );
  const ifInvalidCredentialThrowError = createIfInvalidCredentialThrowError(
    getCustomerAccountUrl,
    customerAccountId
  );
  const customerAccountApiUrl = getCustomerAccountUrl(
    "GRAPHQL"
    /* GRAPHQL */
  );
  const locks = {};
  async function fetchCustomerAPI({
    query: query2,
    type,
    variables = {}
  }) {
    const accessToken = await getAccessToken();
    if (!accessToken) {
      throw authStatusHandler();
    }
    const stackInfo = getCallerStackLine == null ? void 0 : getCallerStackLine();
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    const response = await fetch(customerAccountApiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": USER_AGENT,
        Origin: httpsOrigin,
        Authorization: accessToken
      },
      body: JSON.stringify({ query: query2, variables })
    });
    logSubRequestEvent == null ? void 0 : logSubRequestEvent({
      url: customerAccountApiUrl,
      startTime,
      response,
      waitUntil,
      stackInfo,
      query: query2,
      variables,
      ...getDebugHeaders(request)
    });
    const body = await response.text();
    const errorOptions = {
      url: customerAccountApiUrl,
      response,
      type,
      query: query2,
      queryVariables: variables,
      errors: void 0,
      client: "customer"
    };
    if (!response.ok) {
      if (response.status === 401) {
        clearSession(session);
        const authFailResponse = authStatusHandler();
        throw authFailResponse;
      }
      let errors2;
      try {
        errors2 = parseJSON2(body);
      } catch (_e) {
        errors2 = [{ message: body }];
      }
      throwErrorWithGqlLink({ ...errorOptions, errors: errors2 });
    }
    try {
      const APIresponse = parseJSON2(body);
      const { errors: errors2 } = APIresponse;
      const gqlErrors = errors2 == null ? void 0 : errors2.map(
        ({ message, ...rest }) => new GraphQLError(message, {
          ...rest,
          clientOperation: `customerAccount.${errorOptions.type}`,
          requestId: response.headers.get("x-request-id"),
          queryVariables: variables,
          query: query2
        })
      );
      return { ...APIresponse, ...errors2 && { errors: gqlErrors } };
    } catch (e) {
      throwErrorWithGqlLink({ ...errorOptions, errors: [{ message: body }] });
    }
  }
  async function isLoggedIn() {
    if (!shopId) return false;
    const customerAccount = session.get(CUSTOMER_ACCOUNT_SESSION_KEY);
    const accessToken = customerAccount == null ? void 0 : customerAccount.accessToken;
    const expiresAt = customerAccount == null ? void 0 : customerAccount.expiresAt;
    if (!accessToken || !expiresAt) return false;
    const stackInfo = getCallerStackLine == null ? void 0 : getCallerStackLine();
    try {
      await checkExpires({
        locks,
        expiresAt,
        session,
        customerAccountId,
        customerAccountTokenExchangeUrl: getCustomerAccountUrl(
          "TOKEN_EXCHANGE"
          /* TOKEN_EXCHANGE */
        ),
        httpsOrigin,
        debugInfo: {
          waitUntil,
          stackInfo,
          ...getDebugHeaders(request)
        }
      });
    } catch {
      return false;
    }
    return true;
  }
  async function handleAuthStatus() {
    if (!await isLoggedIn()) {
      throw authStatusHandler();
    }
  }
  async function getAccessToken() {
    var _a3;
    const hasAccessToken = await isLoggedIn();
    if (hasAccessToken)
      return (_a3 = session.get(CUSTOMER_ACCOUNT_SESSION_KEY)) == null ? void 0 : _a3.accessToken;
  }
  async function mutate(mutation, options) {
    ifInvalidCredentialThrowError();
    mutation = minifyQuery(mutation);
    assertMutation(mutation, "customer.mutate");
    return withSyncStack(
      fetchCustomerAPI({ query: mutation, type: "mutation", ...options }),
      { logErrors }
    );
  }
  async function query(query2, options) {
    ifInvalidCredentialThrowError();
    query2 = minifyQuery(query2);
    assertQuery(query2, "customer.query");
    return withSyncStack(fetchCustomerAPI({ query: query2, type: "query", ...options }), {
      logErrors
    });
  }
  function setBuyer(buyer) {
    session.set(BUYER_SESSION_KEY, {
      ...session.get(BUYER_SESSION_KEY),
      ...buyer
    });
  }
  async function getBuyer() {
    const customerAccessToken = await getAccessToken();
    if (!customerAccessToken) {
      return;
    }
    return { ...session.get(BUYER_SESSION_KEY), customerAccessToken };
  }
  return {
    i18n: { language: language ?? "EN" },
    login: async (options) => {
      ifInvalidCredentialThrowError();
      const loginUrl = new URL(getCustomerAccountUrl(
        "AUTH"
        /* AUTH */
      ));
      const state = generateState();
      const nonce = generateNonce();
      loginUrl.searchParams.set("client_id", customerAccountId);
      loginUrl.searchParams.set("scope", "openid email");
      loginUrl.searchParams.append("response_type", "code");
      loginUrl.searchParams.append("redirect_uri", redirectUri);
      loginUrl.searchParams.set(
        "scope",
        getCustomerAccountUrl(
          "LOGIN_SCOPE"
          /* LOGIN_SCOPE */
        )
      );
      loginUrl.searchParams.append("state", state);
      loginUrl.searchParams.append("nonce", nonce);
      const uiLocales = getMaybeUILocales({
        contextLanguage: language ?? null,
        uiLocalesOverride: (options == null ? void 0 : options.uiLocales) ?? null
      });
      if (uiLocales != null) {
        loginUrl.searchParams.append("ui_locales", uiLocales);
      }
      if (options == null ? void 0 : options.countryCode) {
        loginUrl.searchParams.append("region_country", options.countryCode);
      }
      const verifier = generateCodeVerifier();
      const challenge = await generateCodeChallenge(verifier);
      session.set(CUSTOMER_ACCOUNT_SESSION_KEY, {
        ...session.get(CUSTOMER_ACCOUNT_SESSION_KEY),
        codeVerifier: verifier,
        state,
        nonce,
        redirectPath: getRedirectUrl(request.url) || getHeader(request, "Referer") || defaultRedirectPath
      });
      loginUrl.searchParams.append("code_challenge", challenge);
      loginUrl.searchParams.append("code_challenge_method", "S256");
      return redirect(loginUrl.toString());
    },
    logout: async (options) => {
      var _a3;
      ifInvalidCredentialThrowError();
      const idToken = (_a3 = session.get(CUSTOMER_ACCOUNT_SESSION_KEY)) == null ? void 0 : _a3.idToken;
      const postLogoutRedirectUri = ensureLocalRedirectUrl({
        requestUrl: httpsOrigin,
        defaultUrl: httpsOrigin,
        redirectUrl: options == null ? void 0 : options.postLogoutRedirectUri
      });
      const logoutUrl = idToken ? new URL(
        `${getCustomerAccountUrl(
          "LOGOUT"
          /* LOGOUT */
        )}?${new URLSearchParams([
          ["id_token_hint", idToken],
          ["post_logout_redirect_uri", postLogoutRedirectUri]
        ]).toString()}`
      ).toString() : postLogoutRedirectUri;
      clearSession(session);
      const headers = (options == null ? void 0 : options.headers) instanceof Headers ? options == null ? void 0 : options.headers : new Headers(options == null ? void 0 : options.headers);
      if (!(options == null ? void 0 : options.keepSession)) {
        if (session.destroy) {
          headers.set("Set-Cookie", await session.destroy());
        } else {
          console.warn(
            "[h2:warn:customerAccount] session.destroy is not available on your session implementation. All session data might not be cleared on logout."
          );
        }
        session.isPending = false;
      }
      return redirect(logoutUrl, { headers });
    },
    isLoggedIn,
    handleAuthStatus,
    getAccessToken,
    getApiUrl: () => customerAccountApiUrl,
    mutate,
    query,
    authorize: async () => {
      var _a3, _b, _c, _d;
      ifInvalidCredentialThrowError();
      const code = requestUrl.searchParams.get("code");
      const state = requestUrl.searchParams.get("state");
      if (!code || !state) {
        clearSession(session);
        throw new BadRequest(
          "Unauthorized",
          "No code or state parameter found in the redirect URL."
        );
      }
      if (((_a3 = session.get(CUSTOMER_ACCOUNT_SESSION_KEY)) == null ? void 0 : _a3.state) !== state) {
        clearSession(session);
        throw new BadRequest(
          "Unauthorized",
          "The session state does not match the state parameter. Make sure that the session is configured correctly and passed to `createCustomerAccountClient`."
        );
      }
      const clientId = customerAccountId;
      const body = new URLSearchParams();
      body.append("grant_type", "authorization_code");
      body.append("client_id", clientId);
      body.append("redirect_uri", redirectUri);
      body.append("code", code);
      const codeVerifier = (_b = session.get(
        CUSTOMER_ACCOUNT_SESSION_KEY
      )) == null ? void 0 : _b.codeVerifier;
      if (!codeVerifier)
        throw new BadRequest(
          "Unauthorized",
          "No code verifier found in the session. Make sure that the session is configured correctly and passed to `createCustomerAccountClient`."
        );
      body.append("code_verifier", codeVerifier);
      const headers = {
        "content-type": "application/x-www-form-urlencoded",
        "User-Agent": USER_AGENT,
        Origin: httpsOrigin
      };
      const stackInfo = getCallerStackLine == null ? void 0 : getCallerStackLine();
      const startTime = (/* @__PURE__ */ new Date()).getTime();
      const url = getCustomerAccountUrl(
        "TOKEN_EXCHANGE"
        /* TOKEN_EXCHANGE */
      );
      const response = await fetch(url, {
        method: "POST",
        headers,
        body
      });
      logSubRequestEvent == null ? void 0 : logSubRequestEvent({
        url,
        displayName: "Customer Account API: authorize",
        startTime,
        response,
        waitUntil,
        stackInfo,
        ...getDebugHeaders(request)
      });
      if (!response.ok) {
        throw new Response(await response.text(), {
          status: response.status,
          headers: {
            "Content-Type": "text/html; charset=utf-8"
          }
        });
      }
      const {
        access_token,
        expires_in,
        id_token,
        refresh_token
      } = await response.json();
      const sessionNonce = (_c = session.get(CUSTOMER_ACCOUNT_SESSION_KEY)) == null ? void 0 : _c.nonce;
      const responseNonce = await getNonce(id_token);
      if (sessionNonce !== responseNonce) {
        throw new BadRequest(
          "Unauthorized",
          `Returned nonce does not match: ${sessionNonce} !== ${responseNonce}`
        );
      }
      let customerAccessToken = access_token;
      if (!shopId) {
        customerAccessToken = await exchangeAccessToken(
          access_token,
          customerAccountId,
          getCustomerAccountUrl(
            "TOKEN_EXCHANGE"
            /* TOKEN_EXCHANGE */
          ),
          httpsOrigin,
          {
            waitUntil,
            stackInfo,
            ...getDebugHeaders(request)
          }
        );
      }
      const redirectPath = (_d = session.get(
        CUSTOMER_ACCOUNT_SESSION_KEY
      )) == null ? void 0 : _d.redirectPath;
      session.set(CUSTOMER_ACCOUNT_SESSION_KEY, {
        accessToken: customerAccessToken,
        expiresAt: new Date((/* @__PURE__ */ new Date()).getTime() + (expires_in - 120) * 1e3).getTime() + "",
        refreshToken: refresh_token,
        idToken: id_token
      });
      return redirect(redirectPath || defaultRedirectPath);
    },
    setBuyer,
    getBuyer,
    UNSTABLE_setBuyer: (buyer) => {
      warnOnce2(
        "[h2:warn:customerAccount] `customerAccount.UNSTABLE_setBuyer` is deprecated. Please use `customerAccount.setBuyer`."
      );
      setBuyer(buyer);
    },
    UNSTABLE_getBuyer: () => {
      warnOnce2(
        "[h2:warn:customerAccount] `customerAccount.UNSTABLE_getBuyer` is deprecated. Please use `customerAccount.getBuyer`."
      );
      return getBuyer();
    }
  };
}
function createIfInvalidCredentialThrowError(getCustomerAccountUrl, customerAccountId) {
  return function ifInvalidCredentialThrowError() {
    try {
      if (!customerAccountId) throw Error();
      new URL(getCustomerAccountUrl(
        "CA_BASE_URL"
        /* CA_BASE_URL */
      ));
      new URL(getCustomerAccountUrl(
        "CA_BASE_AUTH_URL"
        /* CA_BASE_AUTH_URL */
      ));
    } catch {
      console.error(
        new Error(
          "[h2:error:customerAccount] You do not have the valid credential to use Customer Account API.\nRun `h2 env pull` to link your store credentials."
        )
      );
      const publicMessage = "You do not have the valid credential to use Customer Account API (/account).";
      throw new Response(publicMessage, { status: 500 });
    }
  };
}
function getMaybeUILocales(params) {
  const contextLocale = toMaybeLocaleString(params.contextLanguage ?? null);
  const optionsLocale = toMaybeLocaleString(params.uiLocalesOverride);
  return optionsLocale ?? contextLocale ?? null;
}
function toMaybeLocaleString(language) {
  if (language == null) {
    return null;
  }
  const normalizedLanguage = maybeEnforceRegionalVariant(language);
  const base = normalizedLanguage.toLowerCase().replaceAll("_", "-");
  const tokens = base.split("-");
  const langToken = tokens.at(0) ?? null;
  const regionToken = tokens.at(1) ?? null;
  if (regionToken) {
    return `${langToken}-${regionToken.toUpperCase()}`;
  }
  return langToken;
}
var regionalLanguageOverrides = {
  PT: "PT_PT",
  ZH: "ZH_CN"
};
function maybeEnforceRegionalVariant(language) {
  return regionalLanguageOverrides[language] ?? language;
}
function createHydrogenContext(options, additionalContext) {
  const {
    env,
    request,
    cache,
    waitUntil,
    i18n,
    session,
    logErrors,
    storefront: storefrontOptions = {},
    customerAccount: customerAccountOptions,
    cart: cartOptions = {},
    buyerIdentity
  } = options;
  if (!session) {
    console.warn(
      `[h2:warn:createHydrogenContext] A session object is required to create hydrogen context.`
    );
  }
  if (customerAccountOptions == null ? void 0 : customerAccountOptions.unstableB2b) {
    warnOnce2(
      "[h2:warn:createHydrogenContext] `customerAccount.unstableB2b` is now stable. Please remove the `unstableB2b` option."
    );
  }
  const { storefront } = createStorefrontClient2({
    // share options
    cache,
    waitUntil,
    i18n,
    logErrors,
    // storefrontOptions
    storefrontHeaders: storefrontOptions.headers || getStorefrontHeaders(request),
    storefrontApiVersion: storefrontOptions.apiVersion,
    // defaults
    storefrontId: env.PUBLIC_STOREFRONT_ID,
    storeDomain: env.PUBLIC_STORE_DOMAIN,
    privateStorefrontToken: env.PRIVATE_STOREFRONT_API_TOKEN,
    publicStorefrontToken: env.PUBLIC_STOREFRONT_API_TOKEN
  });
  const customerAccount = createCustomerAccountClient({
    // share options
    session,
    request,
    waitUntil,
    logErrors,
    // customerAccountOptions
    customerApiVersion: customerAccountOptions == null ? void 0 : customerAccountOptions.apiVersion,
    authUrl: customerAccountOptions == null ? void 0 : customerAccountOptions.authUrl,
    customAuthStatusHandler: customerAccountOptions == null ? void 0 : customerAccountOptions.customAuthStatusHandler,
    // locale - i18n.language is a union of StorefrontLanguageCode | CustomerLanguageCode
    // We cast here because createCustomerAccountClient expects CustomerLanguageCode specifically,
    // but the union type is compatible since most language codes overlap between the two APIs
    language: i18n == null ? void 0 : i18n.language,
    // defaults
    customerAccountId: env.PUBLIC_CUSTOMER_ACCOUNT_API_CLIENT_ID,
    shopId: env.SHOP_ID
  });
  const cart = createCartHandler({
    // cartOptions
    getCartId: cartOptions.getId || cartGetIdDefault(request.headers),
    setCartId: cartOptions.setId || cartSetIdDefault(),
    cartQueryFragment: cartOptions.queryFragment,
    cartMutateFragment: cartOptions.mutateFragment,
    customMethods: cartOptions.customMethods,
    buyerIdentity,
    // defaults
    storefront,
    customerAccount
  });
  const routerProvider = new RouterContextProvider();
  routerProvider.set(storefrontContext, storefront);
  routerProvider.set(cartContext, cart);
  routerProvider.set(customerAccountContext, customerAccount);
  routerProvider.set(envContext, env);
  routerProvider.set(sessionContext, session);
  if (waitUntil) {
    routerProvider.set(waitUntilContext, waitUntil);
  }
  const services = {
    storefront,
    cart,
    customerAccount,
    env,
    session,
    waitUntil,
    // Merge additional context properties (CMS clients, 3P SDKs, etc.)
    ...additionalContext || {}
  };
  const hybridProvider = new Proxy(routerProvider, {
    get(target, prop, receiver) {
      if (prop in target) {
        const value = target[prop];
        return typeof value === "function" ? value.bind(target) : value;
      }
      if (prop in services) {
        return services[prop];
      }
      return Reflect.get(target, prop, receiver);
    },
    has(target, prop) {
      return prop in target || prop in services;
    },
    ownKeys(target) {
      return [...Reflect.ownKeys(target), ...Object.keys(services)];
    },
    getOwnPropertyDescriptor(target, prop) {
      if (prop in target) {
        return Reflect.getOwnPropertyDescriptor(target, prop);
      }
      if (prop in services) {
        return {
          enumerable: true,
          configurable: true,
          writable: false,
          value: services[prop]
        };
      }
      return void 0;
    }
  });
  return hybridProvider;
}
function getStorefrontHeaders(request) {
  return {
    requestGroupId: getHeader(request, "request-id"),
    buyerIp: getHeader(request, "oxygen-buyer-ip"),
    cookie: getHeader(request, "cookie"),
    purpose: getHeader(request, "purpose")
  };
}
var NonceContext = (0, import_react28.createContext)(void 0);
var NonceProvider = NonceContext.Provider;
var useNonce = () => (0, import_react28.useContext)(NonceContext);
function createContentSecurityPolicy(props) {
  const nonce = generateNonce();
  const header = createCSPHeader(nonce, props);
  const Provider = ({ children }) => {
    return (0, import_react28.createElement)(NonceProvider, { value: nonce }, children);
  };
  return {
    nonce,
    header,
    NonceProvider: Provider
  };
}
function createCSPHeader(nonce, props) {
  const { shop, ...directives } = props ?? {};
  const nonceString = `'nonce-${nonce}'`;
  const styleSrc = ["'self'", "'unsafe-inline'", "https://cdn.shopify.com"];
  const connectSrc = [
    "'self'",
    "https://cdn.shopify.com/",
    "https://monorail-edge.shopifysvc.com"
  ];
  if (shop && shop.checkoutDomain) {
    connectSrc.push(`https://${shop.checkoutDomain}`);
  }
  if (shop && shop.storeDomain) {
    connectSrc.push(`https://${shop.storeDomain}`);
  }
  const defaultSrc = [
    "'self'",
    nonceString,
    "https://cdn.shopify.com",
    // Used for the Customer Account API
    "https://shopify.com"
  ];
  const defaultDirectives = {
    baseUri: ["'self'"],
    defaultSrc,
    frameAncestors: ["'none'"],
    styleSrc,
    connectSrc
  };
  {
    defaultDirectives.styleSrc = [...styleSrc, "http://localhost:*"];
    defaultDirectives.defaultSrc = [...defaultSrc, "http://localhost:*"];
    defaultDirectives.connectSrc = [
      ...connectSrc,
      "http://localhost:*",
      // For HMR:
      "ws://localhost:*",
      "ws://127.0.0.1:*",
      "ws://*.tryhydrogen.dev:*"
    ];
  }
  const combinedDirectives = Object.assign({}, defaultDirectives, directives);
  for (const key in defaultDirectives) {
    const directive = directives[key];
    if (key && directive) {
      combinedDirectives[key] = addCspDirective(
        directive,
        defaultDirectives[key]
      );
    }
  }
  if (combinedDirectives.scriptSrc instanceof Array) {
    combinedDirectives.scriptSrc = [
      ...combinedDirectives.scriptSrc.filter((ss) => !ss.startsWith(`'nonce`)),
      nonceString
    ];
  } else if (combinedDirectives.defaultSrc instanceof Array) {
    combinedDirectives.defaultSrc = [
      ...combinedDirectives.defaultSrc.filter((ss) => !ss.startsWith(`'nonce`)),
      nonceString
    ];
  }
  return buildContentSecurityPolicy({
    directives: combinedDirectives
  });
}
function addCspDirective(currentValue, value) {
  const normalizedValue = typeof value === "string" ? [value] : value;
  const normalizedCurrentValue = Array.isArray(currentValue) ? currentValue : [String(currentValue)];
  const newValue = Array.isArray(normalizedValue) ? (
    // If the default directive is `none`, don't
    // merge the override with the default value.
    normalizedValue.every((a) => a === `'none'`) ? normalizedCurrentValue : [...normalizedCurrentValue, ...normalizedValue]
  ) : normalizedValue;
  return newValue;
}
var Script = (0, import_react28.forwardRef)(
  (props, ref) => {
    const { waitForHydration, src, ...rest } = props;
    const nonce = useNonce();
    if (waitForHydration) return (0, import_jsx_runtime22.jsx)(LazyScript, { src, options: rest });
    return (0, import_jsx_runtime22.jsx)(
      "script",
      {
        suppressHydrationWarning: true,
        ...rest,
        src,
        nonce,
        ref
      }
    );
  }
);
function LazyScript({
  src,
  options
}) {
  if (!src)
    throw new Error(
      "`waitForHydration` with the Script component requires a `src` prop"
    );
  useLoadScript(src, {
    attributes: options
  });
  return null;
}
async function hydrogenRoutes(currentRoutes) {
  const { getVirtualRoutesV3 } = await import("./get-virtual-routes-6PVSMJPH-OTZNXGSY.js");
  const { layout, routes: virtualRoutes } = await getVirtualRoutesV3();
  const childVirtualRoutes = virtualRoutes.map(({ path, file, index, id }) => {
    return {
      file,
      id,
      index,
      path
    };
  });
  const virtualLayout = {
    file: layout.file,
    children: childVirtualRoutes
  };
  return [...currentRoutes, virtualLayout];
}
function useOptimisticData(identifier) {
  const fetchers = useFetchers();
  const data = {};
  for (const { formData } of fetchers) {
    if ((formData == null ? void 0 : formData.get("optimistic-identifier")) === identifier) {
      try {
        if (formData.has("optimistic-data")) {
          const dataInForm = JSON.parse(
            String(formData.get("optimistic-data"))
          );
          Object.assign(data, dataInForm);
        }
      } catch {
      }
    }
  }
  return data;
}
function OptimisticInput({ id, data }) {
  return (0, import_jsx_runtime22.jsxs)(import_jsx_runtime22.Fragment, { children: [
    (0, import_jsx_runtime22.jsx)("input", { type: "hidden", name: "optimistic-identifier", value: id }),
    (0, import_jsx_runtime22.jsx)(
      "input",
      {
        type: "hidden",
        name: "optimistic-data",
        value: JSON.stringify(data)
      }
    )
  ] });
}
function Pagination({
  connection,
  children = () => {
    console.warn("<Pagination> requires children to work properly");
    return null;
  },
  namespace = ""
}) {
  const [isLoading, setIsLoading] = (0, import_react28.useState)(false);
  const transition = useNavigation();
  const location2 = useLocation();
  useNavigate();
  (0, import_react28.useEffect)(() => {
    if (transition.state === "idle") {
      setIsLoading(false);
    }
  }, [transition.state]);
  const {
    endCursor,
    hasNextPage,
    hasPreviousPage,
    nextPageUrl,
    nodes,
    previousPageUrl,
    startCursor
  } = usePagination(connection, namespace);
  const state = (0, import_react28.useMemo)(
    () => {
      var _a3;
      return {
        ...location2.state,
        pagination: {
          ...((_a3 = location2.state) == null ? void 0 : _a3.pagination) || {},
          [namespace]: {
            pageInfo: {
              endCursor,
              hasPreviousPage,
              hasNextPage,
              startCursor
            },
            nodes
          }
        }
      };
    },
    [
      endCursor,
      hasNextPage,
      hasPreviousPage,
      startCursor,
      nodes,
      namespace,
      location2.state
    ]
  );
  const NextLink = (0, import_react28.useMemo)(
    () => (0, import_react28.forwardRef)(
      function NextLink2(props, ref) {
        return hasNextPage ? (0, import_react28.createElement)(Link, {
          preventScrollReset: true,
          ...props,
          to: nextPageUrl,
          state,
          replace: true,
          ref,
          onClick: () => setIsLoading(true)
        }) : null;
      }
    ),
    [hasNextPage, nextPageUrl, state]
  );
  const PreviousLink = (0, import_react28.useMemo)(
    () => (0, import_react28.forwardRef)(
      function PrevLink(props, ref) {
        return hasPreviousPage ? (0, import_react28.createElement)(Link, {
          preventScrollReset: true,
          ...props,
          to: previousPageUrl,
          state,
          replace: true,
          ref,
          onClick: () => setIsLoading(true)
        }) : null;
      }
    ),
    [hasPreviousPage, previousPageUrl, state]
  );
  return children({
    state,
    hasNextPage,
    hasPreviousPage,
    isLoading,
    nextPageUrl,
    nodes,
    previousPageUrl,
    NextLink,
    PreviousLink
  });
}
function getParamsWithoutPagination(paramsString, state) {
  const params = new URLSearchParams(paramsString);
  const activeNamespaces = Object.keys((state == null ? void 0 : state.pagination) || {});
  activeNamespaces.forEach((namespace) => {
    const namespacePrefix = namespace === "" ? "" : `${namespace}_`;
    const cursorParam = `${namespacePrefix}cursor`;
    const directionParam = `${namespacePrefix}direction`;
    params.delete(cursorParam);
    params.delete(directionParam);
  });
  return params.toString();
}
function makeError(prop) {
  throw new Error(
    `The Pagination component requires ${"`" + prop + "`"} to be a part of your query. See the guide on how to setup your query to include ${"`" + prop + "`"}: https://shopify.dev/docs/custom-storefronts/hydrogen/data-fetching/pagination#setup-the-paginated-query`
  );
}
function usePagination(connection, namespace = "") {
  if (!connection.pageInfo) {
    makeError("pageInfo");
  }
  if (typeof connection.pageInfo.startCursor === "undefined") {
    makeError("pageInfo.startCursor");
  }
  if (typeof connection.pageInfo.endCursor === "undefined") {
    makeError("pageInfo.endCursor");
  }
  if (typeof connection.pageInfo.hasNextPage === "undefined") {
    makeError("pageInfo.hasNextPage");
  }
  if (typeof connection.pageInfo.hasPreviousPage === "undefined") {
    makeError("pageInfo.hasPreviousPage");
  }
  const transition = useNavigation();
  const navigate = useNavigate();
  const { state, search, pathname } = useLocation();
  const cursorParam = namespace ? `${namespace}_cursor` : "cursor";
  const directionParam = namespace ? `${namespace}_direction` : "direction";
  const params = new URLSearchParams(search);
  const direction = params.get(directionParam);
  const isPrevious = direction === "previous";
  const nodes = (0, import_react28.useMemo)(() => {
    var _a3, _b, _c;
    if (!((_a3 = globalThis == null ? void 0 : globalThis.window) == null ? void 0 : _a3.__hydrogenHydrated) || !((_c = (_b = state == null ? void 0 : state.pagination) == null ? void 0 : _b[namespace]) == null ? void 0 : _c.nodes)) {
      return flattenConnection(connection);
    }
    if (isPrevious) {
      return [
        ...flattenConnection(connection),
        ...state.pagination[namespace].nodes || []
      ];
    } else {
      return [
        ...state.pagination[namespace].nodes || [],
        ...flattenConnection(connection)
      ];
    }
  }, [state, connection, namespace]);
  const currentPageInfo = (0, import_react28.useMemo)(() => {
    var _a3, _b, _c, _d, _e;
    const hydrogenHydrated = (_a3 = globalThis == null ? void 0 : globalThis.window) == null ? void 0 : _a3.__hydrogenHydrated;
    const stateInfo = (_c = (_b = state == null ? void 0 : state.pagination) == null ? void 0 : _b[namespace]) == null ? void 0 : _c.pageInfo;
    let pageStartCursor = !hydrogenHydrated || (stateInfo == null ? void 0 : stateInfo.startCursor) === void 0 ? connection.pageInfo.startCursor : stateInfo.startCursor;
    let pageEndCursor = !hydrogenHydrated || (stateInfo == null ? void 0 : stateInfo.endCursor) === void 0 ? connection.pageInfo.endCursor : stateInfo.endCursor;
    let previousPageExists = !hydrogenHydrated || (stateInfo == null ? void 0 : stateInfo.hasPreviousPage) === void 0 ? connection.pageInfo.hasPreviousPage : stateInfo.hasPreviousPage;
    let nextPageExists = !hydrogenHydrated || (stateInfo == null ? void 0 : stateInfo.hasNextPage) === void 0 ? connection.pageInfo.hasNextPage : stateInfo.hasNextPage;
    if ((_e = (_d = state == null ? void 0 : state.pagination) == null ? void 0 : _d[namespace]) == null ? void 0 : _e.nodes) {
      if (isPrevious) {
        pageStartCursor = connection.pageInfo.startCursor;
        previousPageExists = connection.pageInfo.hasPreviousPage;
      } else {
        pageEndCursor = connection.pageInfo.endCursor;
        nextPageExists = connection.pageInfo.hasNextPage;
      }
    }
    return {
      startCursor: pageStartCursor,
      endCursor: pageEndCursor,
      hasPreviousPage: previousPageExists,
      hasNextPage: nextPageExists
    };
  }, [
    isPrevious,
    state,
    namespace,
    connection.pageInfo.hasNextPage,
    connection.pageInfo.hasPreviousPage,
    connection.pageInfo.startCursor,
    connection.pageInfo.endCursor
  ]);
  const urlRef = (0, import_react28.useRef)({
    params: getParamsWithoutPagination(search, state),
    pathname
  });
  (0, import_react28.useEffect)(() => {
    window.__hydrogenHydrated = true;
  }, []);
  (0, import_react28.useEffect)(() => {
    const currentParams = getParamsWithoutPagination(search, state);
    const previousParams = urlRef.current.params;
    const pathChanged = pathname !== urlRef.current.pathname;
    const nonPaginationParamsChanged = currentParams !== previousParams;
    if (
      // Only clean up if the base URL or non-pagination params change
      (pathChanged || nonPaginationParamsChanged) && // And we're not on the initial load
      !(transition.state === "idle" && !transition.location)
    ) {
      urlRef.current = {
        pathname,
        params: getParamsWithoutPagination(search, state)
      };
      navigate(`${pathname}?${getParamsWithoutPagination(search, state)}`, {
        replace: true,
        preventScrollReset: true,
        state: { nodes: void 0, pageInfo: void 0 }
      });
    }
  }, [pathname, search, state]);
  const previousPageUrl = (0, import_react28.useMemo)(() => {
    const params2 = new URLSearchParams(search);
    params2.set(directionParam, "previous");
    currentPageInfo.startCursor && params2.set(cursorParam, currentPageInfo.startCursor);
    return `?${params2.toString()}`;
  }, [search, currentPageInfo.startCursor]);
  const nextPageUrl = (0, import_react28.useMemo)(() => {
    const params2 = new URLSearchParams(search);
    params2.set(directionParam, "next");
    currentPageInfo.endCursor && params2.set(cursorParam, currentPageInfo.endCursor);
    return `?${params2.toString()}`;
  }, [search, currentPageInfo.endCursor]);
  return { ...currentPageInfo, previousPageUrl, nextPageUrl, nodes };
}
function getPaginationVariables(request, options = { pageBy: 20 }) {
  if (typeof (request == null ? void 0 : request.url) === "undefined") {
    throw new Error(
      "getPaginationVariables must be called with the Request object passed to your loader function"
    );
  }
  const { pageBy, namespace = "" } = options;
  const searchParams = new URLSearchParams(new URL(request.url).search);
  const cursorParam = namespace ? `${namespace}_cursor` : "cursor";
  const directionParam = namespace ? `${namespace}_direction` : "direction";
  const cursor = searchParams.get(cursorParam) ?? void 0;
  const direction = searchParams.get(directionParam) === "previous" ? "previous" : "next";
  const isPrevious = direction === "previous";
  const prevPage = {
    last: pageBy,
    startCursor: cursor ?? null
  };
  const nextPage = {
    first: pageBy,
    endCursor: cursor ?? null
  };
  const variables = isPrevious ? prevPage : nextPage;
  return variables;
}
function useOptimisticVariant(selectedVariant, variants) {
  const navigation = useNavigation();
  const [resolvedVariants, setResolvedVariants] = (0, import_react28.useState)([]);
  (0, import_react28.useEffect)(() => {
    Promise.resolve(variants).then((productWithVariants) => {
      var _a3, _b;
      if (productWithVariants) {
        setResolvedVariants(
          productWithVariants instanceof Array ? productWithVariants : ((_b = (_a3 = productWithVariants.product) == null ? void 0 : _a3.variants) == null ? void 0 : _b.nodes) || []
        );
      }
    }).catch((error) => {
      reportError(
        new Error(
          "[h2:error:useOptimisticVariant] An error occurred while resolving the variants for the optimistic product hook.",
          {
            cause: error
          }
        )
      );
    });
  }, [JSON.stringify(variants)]);
  if (navigation.state === "loading") {
    const queryParams = new URLSearchParams(navigation.location.search);
    let reportedError = false;
    const matchingVariant = resolvedVariants.find((variant) => {
      if (!variant.selectedOptions) {
        if (!reportedError) {
          reportedError = true;
          reportError(
            new Error(
              "[h2:error:useOptimisticVariant] The optimistic product hook requires your product query to include variants with the selectedOptions field."
            )
          );
        }
        return false;
      }
      return variant.selectedOptions.every((option) => {
        return queryParams.get(option.name) === option.value;
      });
    });
    if (matchingVariant) {
      return {
        ...matchingVariant,
        isOptimistic: true
      };
    }
  }
  return selectedVariant;
}
function VariantSelector({
  handle,
  options: _options = [],
  variants: _variants = [],
  productPath = "products",
  waitForNavigation = false,
  selectedVariant,
  children
}) {
  var _a3, _b;
  let options = _options;
  if ((_a3 = options[0]) == null ? void 0 : _a3.values) {
    warnOnce2(
      "[h2:warn:VariantSelector] product.options.values is deprecated. Use product.options.optionValues instead."
    );
    if (!!options[0] && !options[0].optionValues) {
      options = _options.map((option) => {
        var _a4;
        return {
          ...option,
          optionValues: ((_a4 = option.values) == null ? void 0 : _a4.map((value) => ({ name: value }))) || []
        };
      });
    }
  }
  const variants = _variants instanceof Array ? _variants : flattenConnection(_variants);
  const { searchParams, path, alreadyOnProductPage } = useVariantPath(
    handle,
    productPath,
    waitForNavigation
  );
  const optionsWithOnlyOneValue = options.filter(
    (option) => {
      var _a4;
      return ((_a4 = option == null ? void 0 : option.optionValues) == null ? void 0 : _a4.length) === 1;
    }
  );
  const selectedVariantOptions = selectedVariant ? (_b = selectedVariant == null ? void 0 : selectedVariant.selectedOptions) == null ? void 0 : _b.reduce(
    (selectedValues, item) => {
      selectedValues[item.name] = item.value;
      return selectedValues;
    },
    {}
  ) : {};
  return (0, import_react28.createElement)(
    import_react28.Fragment,
    null,
    ...(0, import_react28.useMemo)(() => {
      return options.map((option) => {
        let activeValue;
        let availableValues = [];
        for (let value of option.optionValues) {
          const clonedSearchParams = new URLSearchParams(
            alreadyOnProductPage ? searchParams : void 0
          );
          clonedSearchParams.set(option.name, value.name);
          optionsWithOnlyOneValue.forEach((option2) => {
            if (option2.optionValues[0].name)
              clonedSearchParams.set(
                option2.name,
                option2.optionValues[0].name
              );
          });
          const variant = variants.find((variant2) => {
            var _a4;
            return (_a4 = variant2 == null ? void 0 : variant2.selectedOptions) == null ? void 0 : _a4.every((selectedOption) => {
              const selectedValue2 = clonedSearchParams.get(selectedOption == null ? void 0 : selectedOption.name) || (selectedVariantOptions == null ? void 0 : selectedVariantOptions[selectedOption == null ? void 0 : selectedOption.name]);
              return selectedValue2 === (selectedOption == null ? void 0 : selectedOption.value);
            });
          });
          let selectedValue = searchParams.get(option.name);
          if (!selectedValue && selectedVariant) {
            selectedValue = (selectedVariantOptions == null ? void 0 : selectedVariantOptions[option.name]) || null;
          }
          const calculatedActiveValue = selectedValue ? (
            // If a URL parameter exists for the current option, check if it equals the current value
            selectedValue === value.name
          ) : false;
          if (calculatedActiveValue) {
            activeValue = value.name;
          }
          const searchString = "?" + clonedSearchParams.toString();
          availableValues.push({
            value: value.name,
            optionValue: value,
            isAvailable: variant ? variant.availableForSale : true,
            to: path + searchString,
            search: searchString,
            isActive: calculatedActiveValue,
            variant
          });
        }
        return children({
          option: {
            name: option.name,
            value: activeValue,
            values: availableValues
          }
        });
      });
    }, [options, variants, children])
  );
}
var getSelectedProductOptions = (request) => {
  if (typeof (request == null ? void 0 : request.url) === "undefined")
    throw new TypeError(`Expected a Request instance, got ${typeof request}`);
  const searchParams = new URL(request.url).searchParams;
  const selectedOptions = [];
  searchParams.forEach((value, name) => {
    selectedOptions.push({ name, value });
  });
  return selectedOptions;
};
function useVariantPath(handle, productPath, waitForNavigation) {
  const { pathname, search } = useLocation();
  const navigation = useNavigation();
  return (0, import_react28.useMemo)(() => {
    const match = /(\/[a-zA-Z]{2}-[a-zA-Z]{2}\/)/g.exec(pathname);
    const isLocalePathname = match && match.length > 0;
    productPath = productPath.startsWith("/") ? productPath.substring(1) : productPath;
    const path = isLocalePathname ? `${match[0]}${productPath}/${handle}` : `/${productPath}/${handle}`;
    const searchParams = new URLSearchParams(
      // Remix doesn't update the location until pending loaders complete.
      // By default we use the destination search params to make selecting a variant
      // instant, but `waitForNavigation` makes the UI wait to update by only using
      // the active browser search params.
      waitForNavigation || navigation.state !== "loading" ? search : navigation.location.search
    );
    return {
      searchParams,
      // If the current pathname matches the product page, we need to make sure
      // that we append to the current search params. Otherwise all the search
      // params can be generated new.
      alreadyOnProductPage: path === pathname,
      path
    };
  }, [pathname, search, waitForNavigation, handle, productPath, navigation]);
}
function hydrogenPreset() {
  return {
    name: "hydrogen-2025.7.0",
    reactRouterConfig: () => ({
      appDirectory: "app",
      buildDirectory: "dist",
      ssr: true,
      future: {
        v8_middleware: true,
        unstable_optimizeDeps: true,
        unstable_splitRouteModules: true,
        unstable_subResourceIntegrity: false,
        unstable_viteEnvironmentApi: false
      }
    }),
    reactRouterConfigResolved: ({ reactRouterConfig }) => {
      var _a3;
      if (reactRouterConfig.basename && reactRouterConfig.basename !== "/") {
        throw new Error(
          "[Hydrogen Preset] basename is not supported in Hydrogen 2025.7.0.\nReason: Requires major CLI infrastructure modernization.\nWorkaround: Use reverse proxy or CDN path rewriting for subdirectory hosting."
        );
      }
      if (reactRouterConfig.prerender) {
        throw new Error(
          "[Hydrogen Preset] prerender is not supported in Hydrogen 2025.7.0.\nReason: React Router plugin incompatibility with Hydrogen CLI build pipeline.\nWorkaround: Use external static generation tools or server-side caching."
        );
      }
      if (reactRouterConfig.serverBundles) {
        throw new Error(
          "[Hydrogen Preset] serverBundles is not supported in Hydrogen 2025.7.0.\nReason: React Router plugin manifest incompatibility with Hydrogen CLI.\nAlternative: Route-level code splitting via unstable_splitRouteModules is enabled."
        );
      }
      if (reactRouterConfig.buildEnd) {
        throw new Error(
          "[Hydrogen Preset] buildEnd is not supported in Hydrogen 2025.7.0.\nReason: Hydrogen CLI bypasses React Router buildEnd hook execution.\nWorkaround: Use external build scripts or package.json post-build hooks."
        );
      }
      if (((_a3 = reactRouterConfig.future) == null ? void 0 : _a3.unstable_subResourceIntegrity) === true) {
        throw new Error(
          "[Hydrogen Preset] unstable_subResourceIntegrity cannot be enabled.\nReason: Conflicts with Hydrogen CSP nonce-based authentication.\nImpact: Would break Content Security Policy and cause script execution failures."
        );
      }
    }
  };
}
var RichText2 = function(props) {
  return (0, import_jsx_runtime22.jsx)(
    RichText,
    {
      ...props,
      components: {
        link: ({ node }) => (0, import_jsx_runtime22.jsx)(
          Link,
          {
            to: node.url,
            title: node.title,
            target: node.target,
            prefetch: "intent",
            children: node.children
          }
        ),
        ...props.components
      }
    }
  );
};
var _a2;
var graphiqlLoader = async function graphiqlLoader2({
  request,
  context
}) {
  const storefront = context.storefront;
  const customerAccount = context.customerAccount;
  const url = new URL(request.url);
  if (!storefront) {
    throw new Error(
      `GraphiQL: Hydrogen's storefront client must be injected in the loader context.`
    );
  }
  const schemas = {};
  if (storefront) {
    const authHeader = "X-Shopify-Storefront-Access-Token";
    schemas.storefront = {
      name: "Storefront API",
      authHeader,
      accessToken: storefront.getPublicTokenHeaders()[authHeader],
      apiUrl: storefront.getApiUrl(),
      icon: "SF"
    };
  }
  if (customerAccount) {
    const customerAccountSchema = await (await fetch(url.origin + "/graphiql/customer-account.schema.json")).json();
    const accessToken = await customerAccount.getAccessToken();
    if (customerAccountSchema) {
      schemas["customer-account"] = {
        name: "Customer Account API",
        value: customerAccountSchema,
        authHeader: "Authorization",
        accessToken,
        apiUrl: customerAccount.getApiUrl(),
        icon: "CA"
      };
    }
  }
  const favicon = `https://avatars.githubusercontent.com/u/12972006?s=48&v=4`;
  const html = String.raw;
  return new Response(
    html(_a2 || (_a2 = __template(['\n      <!DOCTYPE html>\n      <html lang="en">\n        <head>\n          <title>GraphiQL</title>\n          <link rel="icon" type="image/x-icon" href="', `" />
          <meta charset="utf-8" />
          <style>
            body {
              height: 100%;
              margin: 0;
              width: 100%;
              overflow: hidden;
              background-color: hsl(219, 29%, 18%);
            }

            #graphiql {
              height: 100vh;
            }

            #graphiql > .placeholder {
              color: slategray;
              width: fit-content;
              margin: 40px auto;
              font-family: Arial;
            }

            .graphiql-api-toolbar-label {
              position: absolute;
              bottom: -6px;
              right: -4px;
              font-size: 8px;
            }
          </style>

          <link
            rel="stylesheet"
            href="https://esm.sh/graphiql/dist/style.css"
          />

          <link
            rel="stylesheet"
            href="https://esm.sh/@graphiql/plugin-explorer/dist/style.css"
          />
          <script type="importmap">
            {
              "imports": {
                "react": "https://esm.sh/react@19.1.0",
                "react/jsx-runtime": "https://esm.sh/react@19.1.0/jsx-runtime",
                "react-dom": "https://esm.sh/react-dom@19.1.0",
                "react-dom/client": "https://esm.sh/react-dom@19.1.0/client",

                "graphql": "https://esm.sh/graphql@16.11.0",

                "graphiql": "https://esm.sh/graphiql?standalone&external=react,react-dom,@graphiql/react,graphql",
                "@graphiql/plugin-explorer": "https://esm.sh/@graphiql/plugin-explorer?standalone&external=react,@graphiql/react,graphql",
                "@graphiql/react": "https://esm.sh/@graphiql/react?standalone&external=react,react-dom,graphql",
                "@graphiql/toolkit": "https://esm.sh/@graphiql/toolkit?standalone&external=graphql"
              }
            }
          <\/script>
          <script type="module">
            // Import React and ReactDOM
            import React from 'react';
            import ReactDOM from 'react-dom/client';

            // Import GraphiQL and the Explorer plugin
            import {GraphiQL, HISTORY_PLUGIN} from 'graphiql';
            import {createGraphiQLFetcher} from '@graphiql/toolkit';
            import {explorerPlugin} from '@graphiql/plugin-explorer';
            import {ToolbarButton} from '@graphiql/react';

            import createJSONWorker from 'https://esm.sh/monaco-editor/esm/vs/language/json/json.worker.js?worker';
            import createGraphQLWorker from 'https://esm.sh/monaco-graphql/esm/graphql.worker.js?worker';
            import createEditorWorker from 'https://esm.sh/monaco-editor/esm/vs/editor/editor.worker.js?worker';
            import {parse, print} from 'graphql';

            globalThis.MonacoEnvironment = {
              getWorker(_workerId, label) {
                switch (label) {
                  case 'json':
                    return createJSONWorker();
                  case 'graphql':
                    return createGraphQLWorker();
                }
                return createEditorWorker();
              },
            };

            const windowUrl = new URL(document.URL);
            const startingSchemaKey =
              windowUrl.searchParams.get('schema') || 'storefront';

            let initialQuery = '{ shop { name } }';
            if (windowUrl.searchParams.has('query')) {
              initialQuery = decodeURIComponent(
                windowUrl.searchParams.get('query') ?? query,
              );
            }

            // Prettify query
            initialQuery = print(parse(initialQuery));

            let variables;
            if (windowUrl.searchParams.has('variables')) {
              variables = decodeURIComponent(
                windowUrl.searchParams.get('variables') ?? '',
              );
            }

            // Prettify variables
            if (variables) {
              variables = JSON.stringify(JSON.parse(variables), null, 2);
            }

            const schemas = `, `;

            let lastActiveTabIndex = -1;
            let lastTabAmount = -1;

            const TAB_STATE_KEY = 'graphiql:tabState';
            const storage = {
              getTabState: () =>
                JSON.parse(localStorage.getItem(TAB_STATE_KEY)),
              setTabState: (state) =>
                localStorage.setItem(TAB_STATE_KEY, JSON.stringify(state)),
            };

            let nextSchemaKey;

            function App() {
              const [activeSchema, setActiveSchema] =
                React.useState(startingSchemaKey);

              const schema = schemas[activeSchema];

              if (!schema) {
                throw new Error('No schema found for ' + activeSchema);
              }

              const fetcher = createGraphiQLFetcher({
                url: schema.apiUrl,
                headers: {[schema.authHeader]: schema.accessToken},
                enableIncrementalDelivery: false,
              });

              // We create a custom fetcher because createGraphiQLFetcher attempts to introspect the schema
              // and the Customer Account API does not support introspection.
              // We  override the fetcher to return the schema directly only for the CAAPI introspection query.
              function createJsonFetcher(options, httpFetch) {
                if (activeSchema === 'storefront') {
                  return fetcher(options, httpFetch);
                } else {
                  // CAAPI requires a custom fetcher
                  if (options.operationName === 'IntrospectionQuery') {
                    return {data: schema.value};
                  } else {
                    return fetcher(options, httpFetch);
                  }
                }
              }

              const keys = Object.keys(schemas);

              function onTabChange(state) {
                const {activeTabIndex, tabs} = state;
                const activeTab = tabs[activeTabIndex];

                if (
                  activeTabIndex === lastActiveTabIndex &&
                  lastTabAmount === tabs.length
                ) {
                  if (
                    nextSchemaKey &&
                    activeTab &&
                    activeTab.schemaKey !== nextSchemaKey
                  ) {
                    activeTab.schemaKey = nextSchemaKey;
                    nextSchemaKey = undefined;

                    // Sync state to localStorage. GraphiQL resets the state
                    // asynchronously, so we need to do it in a timeout.
                    storage.setTabState(state);
                    setTimeout(() => storage.setTabState(state), 500);
                  }

                  // React rerrendering, skip
                  return;
                }

                if (activeTab) {
                  if (!activeTab.schemaKey) {
                    // Creating a new tab
                    if (lastTabAmount < tabs.length) {
                      activeTab.schemaKey = activeSchema;
                      storage.setTabState(state);
                    }
                  }

                  const nextSchema = activeTab.schemaKey || 'storefront';

                  if (nextSchema !== activeSchema) {
                    setActiveSchema(nextSchema);
                  }
                }

                lastActiveTabIndex = activeTabIndex;
                lastTabAmount = tabs.length;
              }

              const plugins = [HISTORY_PLUGIN, explorerPlugin()];

              const props = {
                fetcher: createJsonFetcher,
                defaultEditorToolsVisibility: true,
                initialQuery,
                variables,
                schema: schema.value,
                plugins,
                onTabChange,
              };

              function toggleSelectedApi() {
                const activeKeyIndex = keys.indexOf(activeSchema);
                nextSchemaKey = keys[(activeKeyIndex + 1) % keys.length];

                // This triggers onTabChange
                if (nextSchemaKey) setActiveSchema(nextSchemaKey);
              }

              const CustomToolbar = React.createElement(
                GraphiQL.Toolbar,
                {
                  key: 'Custom Toolbar',
                },
                [
                  React.createElement(
                    ToolbarButton,
                    {
                      key: 'api-wrapper',
                      onClick: toggleSelectedApi,
                      label: 'Toggle between different API schemas',
                    },
                    [
                      React.createElement(
                        'div',
                        {
                          key: 'icon',
                          style: {
                            textAlign: 'center',
                          },
                        },
                        [
                          schema.icon,
                          React.createElement(
                            'div',
                            {
                              key: 'icon-label',
                              className: 'graphiql-api-toolbar-label',
                            },
                            'API',
                          ),
                        ],
                      ),
                    ],
                  ),
                ],
              );

              const CustomLogo = React.createElement(
                GraphiQL.Logo,
                {
                  key: 'Logo replacement',
                },
                [
                  React.createElement(
                    'div',
                    {
                      key: 'Logo wrapper',
                      style: {display: 'flex', alignItems: 'center'},
                    },
                    [
                      React.createElement(
                        'div',
                        {
                          key: 'api',
                          className: 'graphiql-logo',
                          style: {
                            paddingRight: 0,
                            whiteSpace: 'nowrap',
                          },
                        },
                        [schema.name],
                      ),
                      React.createElement(GraphiQL.Logo, {key: 'logo'}),
                    ],
                  ),
                ],
              );

              const children = [CustomToolbar, CustomLogo];

              return React.createElement(GraphiQL, props, children);
            }

            const container = document.getElementById('graphiql');

            const root = ReactDOM.createRoot(container);

            root.render(React.createElement(App));
          <\/script>
        </head>

        <body>
          <div id="graphiql">
            <div class="placeholder">Loading GraphiQL...</div>
          </div>
        </body>
      </html>
    `])), favicon, JSON.stringify(schemas)),
    { status: 200, headers: { "content-type": "text/html" } }
  );
};
async function storefrontRedirect(options) {
  var _a3, _b, _c;
  const {
    storefront,
    request,
    noAdminRedirect,
    matchQueryParams,
    response = new Response("Not Found", { status: 404 })
  } = options;
  const url = new URL(request.url);
  const { pathname, searchParams } = url;
  const isSoftNavigation = searchParams.has("_data");
  searchParams.delete("redirect");
  searchParams.delete("return_to");
  searchParams.delete("_data");
  const redirectFrom = (matchQueryParams ? url.toString().replace(url.origin, "") : pathname).toLowerCase();
  if (url.pathname === "/admin" && !noAdminRedirect) {
    return createRedirectResponse(
      `${storefront.getShopifyDomain()}/admin`,
      isSoftNavigation,
      searchParams,
      matchQueryParams
    );
  }
  try {
    const { urlRedirects } = await storefront.query(REDIRECT_QUERY, {
      // The admin doesn't allow redirects to have a
      // trailing slash, so strip them all off
      variables: { query: "path:" + redirectFrom.replace(/\/+$/, "") }
    });
    const location2 = (_c = (_b = (_a3 = urlRedirects == null ? void 0 : urlRedirects.edges) == null ? void 0 : _a3[0]) == null ? void 0 : _b.node) == null ? void 0 : _c.target;
    if (location2) {
      return createRedirectResponse(
        location2,
        isSoftNavigation,
        searchParams,
        matchQueryParams
      );
    }
    const redirectTo = getRedirectUrl(request.url);
    if (redirectTo) {
      return createRedirectResponse(
        redirectTo,
        isSoftNavigation,
        searchParams,
        matchQueryParams
      );
    }
  } catch (error) {
    console.error(
      `Failed to fetch redirects from Storefront API for route ${redirectFrom}`,
      error
    );
  }
  return response;
}
var TEMP_DOMAIN = "https://example.com";
function createRedirectResponse(location2, isSoftNavigation, searchParams, matchQueryParams) {
  const url = new URL(location2, TEMP_DOMAIN);
  if (!matchQueryParams) {
    for (const [key, value] of searchParams) {
      url.searchParams.append(key, value);
    }
  }
  if (isSoftNavigation) {
    return new Response(null, {
      status: 200,
      headers: {
        "X-Remix-Redirect": url.toString().replace(TEMP_DOMAIN, ""),
        "X-Remix-Status": "301"
      }
    });
  } else {
    return new Response(null, {
      status: 301,
      headers: { location: url.toString().replace(TEMP_DOMAIN, "") }
    });
  }
}
var REDIRECT_QUERY = `#graphql
  query redirects($query: String) {
    urlRedirects(first: 1, query: $query) {
      edges {
        node {
          target
        }
      }
    }
  }
`;
var ESCAPE_LOOKUP = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
var ERROR_PREFIX = "Error in SEO input: ";
var schema = {
  title: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(ERROR_PREFIX.concat("`title` should be a string"));
      }
      if (typeof value === "string" && value.length > 120) {
        throw new Error(
          ERROR_PREFIX.concat(
            "`title` should not be longer than 120 characters"
          )
        );
      }
      return value;
    }
  },
  description: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(
          ERROR_PREFIX.concat("`description` should be a string")
        );
      }
      if (typeof value === "string" && value.length > 155) {
        throw new Error(
          ERROR_PREFIX.concat(
            "`description` should not be longer than 155 characters"
          )
        );
      }
      return value;
    }
  },
  url: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(ERROR_PREFIX.concat("`url` should be a string"));
      }
      if (typeof value === "string" && !value.startsWith("http")) {
        throw new Error(ERROR_PREFIX.concat("`url` should be a valid URL"));
      }
      return value;
    }
  },
  handle: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(ERROR_PREFIX.concat("`handle` should be a string"));
      }
      if (typeof value === "string" && !value.startsWith("@")) {
        throw new Error(ERROR_PREFIX.concat("`handle` should start with `@`"));
      }
      return value;
    }
  }
};
function generateSeoTags(seoInput) {
  const tagResults = [];
  for (const seoKey of Object.keys(seoInput)) {
    switch (seoKey) {
      case "title": {
        const content = validate(schema.title, seoInput.title);
        const title = renderTitle(seoInput == null ? void 0 : seoInput.titleTemplate, content);
        if (!title) {
          break;
        }
        tagResults.push(
          generateTag("title", { title }),
          generateTag("meta", { property: "og:title", content: title }),
          generateTag("meta", { name: "twitter:title", content: title })
        );
        break;
      }
      case "description": {
        const content = validate(schema.description, seoInput.description);
        if (!content) {
          break;
        }
        tagResults.push(
          generateTag("meta", {
            name: "description",
            content
          }),
          generateTag("meta", {
            property: "og:description",
            content
          }),
          generateTag("meta", {
            name: "twitter:description",
            content
          })
        );
        break;
      }
      case "url": {
        const content = validate(schema.url, seoInput.url);
        if (!content) {
          break;
        }
        const urlWithoutParams = content.split("?")[0];
        const urlWithoutTrailingSlash = urlWithoutParams.replace(/\/$/, "");
        tagResults.push(
          generateTag("link", {
            rel: "canonical",
            href: urlWithoutTrailingSlash
          }),
          generateTag("meta", {
            property: "og:url",
            content: urlWithoutTrailingSlash
          })
        );
        break;
      }
      case "handle": {
        const content = validate(schema.handle, seoInput.handle);
        if (!content) {
          break;
        }
        tagResults.push(
          generateTag("meta", { name: "twitter:site", content }),
          generateTag("meta", { name: "twitter:creator", content })
        );
        break;
      }
      case "media": {
        let content;
        const values = ensureArray(seoInput.media);
        for (const media of values) {
          if (typeof media === "string") {
            tagResults.push(
              generateTag("meta", { name: "og:image", content: media })
            );
          }
          if (media && typeof media === "object") {
            const type = media.type || "image";
            const normalizedMedia = media ? {
              url: media == null ? void 0 : media.url,
              secure_url: media == null ? void 0 : media.url,
              type: inferMimeType(media.url),
              width: media == null ? void 0 : media.width,
              height: media == null ? void 0 : media.height,
              alt: media == null ? void 0 : media.altText
            } : {};
            for (const key of Object.keys(normalizedMedia)) {
              if (normalizedMedia[key]) {
                content = normalizedMedia[key];
                tagResults.push(
                  generateTag(
                    "meta",
                    {
                      property: `og:${type}:${key}`,
                      content
                    },
                    normalizedMedia.url
                  )
                );
              }
            }
          }
        }
        break;
      }
      case "jsonLd": {
        const jsonLdBlocks = ensureArray(seoInput.jsonLd);
        let index = 0;
        for (const block of jsonLdBlocks) {
          if (typeof block !== "object") {
            continue;
          }
          const tag = generateTag(
            "script",
            {
              type: "application/ld+json",
              children: JSON.stringify(block, (k, value) => {
                return typeof value === "string" ? escapeHtml(value) : value;
              })
            },
            // @ts-expect-error
            `json-ld-${(block == null ? void 0 : block["@type"]) || (block == null ? void 0 : block.name) || index++}`
          );
          tagResults.push(tag);
        }
        break;
      }
      case "alternates": {
        const alternates = ensureArray(seoInput.alternates);
        for (const alternate of alternates) {
          if (!alternate) {
            continue;
          }
          const { language, url, default: defaultLang } = alternate;
          const hrefLang = language ? `${language}${defaultLang ? "-default" : ""}` : void 0;
          tagResults.push(
            generateTag("link", {
              rel: "alternate",
              hrefLang,
              href: url
            })
          );
        }
        break;
      }
      case "robots": {
        if (!seoInput.robots) {
          break;
        }
        const {
          maxImagePreview,
          maxSnippet,
          maxVideoPreview,
          noArchive,
          noFollow,
          noImageIndex,
          noIndex,
          noSnippet,
          noTranslate,
          unavailableAfter
        } = seoInput.robots;
        const robotsParams = [
          noArchive && "noarchive",
          noImageIndex && "noimageindex",
          noSnippet && "nosnippet",
          noTranslate && `notranslate`,
          maxImagePreview && `max-image-preview:${maxImagePreview}`,
          maxSnippet && `max-snippet:${maxSnippet}`,
          maxVideoPreview && `max-video-preview:${maxVideoPreview}`,
          unavailableAfter && `unavailable_after:${unavailableAfter}`
        ];
        let robotsParam = (noIndex ? "noindex" : "index") + "," + (noFollow ? "nofollow" : "follow");
        for (let param of robotsParams) {
          if (param) {
            robotsParam += `,${param}`;
          }
        }
        tagResults.push(
          generateTag("meta", { name: "robots", content: robotsParam })
        );
        break;
      }
    }
  }
  return tagResults.flat().sort((a, b) => a.key.localeCompare(b.key));
}
function generateTag(tagName, input, group) {
  const tag = { tag: tagName, props: {}, key: "" };
  if (tagName === "title") {
    tag.children = input.title;
    tag.key = generateKey(tag);
    return tag;
  }
  if (tagName === "script") {
    tag.children = typeof input.children === "string" ? input.children : "";
    tag.key = generateKey(tag, group);
    delete input.children;
    tag.props = input;
    return tag;
  }
  tag.props = input;
  Object.keys(tag.props).forEach(
    (key) => !tag.props[key] && delete tag.props[key]
  );
  tag.key = generateKey(tag, group);
  return tag;
}
function generateKey(tag, group) {
  const { tag: tagName, props } = tag;
  if (tagName === "title") {
    return "0-title";
  }
  if (tagName === "meta") {
    const priority = props.content === group && typeof props.property === "string" && !props.property.endsWith("secure_url") && "0";
    const groupName = [group, priority];
    return [tagName, ...groupName, props.property || props.name].filter((x) => x).join("-");
  }
  if (tagName === "link") {
    const key = [tagName, props.rel, props.hrefLang || props.media].filter((x) => x).join("-");
    return key.replace(/\s+/g, "-");
  }
  if (tagName === "script") {
    return `${tagName}-${group}`;
  }
  return `${tagName}-${props.type}`;
}
function renderTitle(template, title) {
  if (!title) {
    return void 0;
  }
  if (!template) {
    return title;
  }
  if (typeof template === "function") {
    return template(title);
  }
  return template.replace("%s", title ?? "");
}
function inferMimeType(url) {
  const ext = url && url.split(".").pop();
  switch (ext) {
    case "svg":
      return "image/svg+xml";
    case "png":
      return "image/png";
    case "gif":
      return "image/gif";
    case "swf":
      return "application/x-shockwave-flash";
    case "mp3":
      return "audio/mpeg";
    case "jpg":
    case "jpeg":
    default:
      return "image/jpeg";
  }
}
function ensureArray(value) {
  return Array.isArray(value) ? value : [value];
}
function validate(schema2, data) {
  try {
    return schema2.validate(data);
  } catch (error) {
    console.warn(error.message);
    return data;
  }
}
function getSeoMeta(...seoInputs) {
  let tagResults = [];
  const dedupedSeoInput = seoInputs.reduce((acc, current) => {
    if (!current) return acc;
    Object.keys(current).forEach(
      (key) => !current[key] && delete current[key]
    );
    const { jsonLd } = current;
    if (!jsonLd) {
      return { ...acc, ...current };
    }
    if (!(acc == null ? void 0 : acc.jsonLd)) {
      return { ...acc, ...current, jsonLd: [jsonLd] };
    } else {
      return {
        ...acc,
        ...current,
        jsonLd: ensureArray(acc.jsonLd).concat(jsonLd)
      };
    }
  }, {}) || {};
  for (const seoKey of Object.keys(dedupedSeoInput)) {
    switch (seoKey) {
      case "title": {
        const content = validate(schema.title, dedupedSeoInput.title);
        const title = renderTitle(dedupedSeoInput == null ? void 0 : dedupedSeoInput.titleTemplate, content);
        if (!title) {
          break;
        }
        tagResults.push(
          { title },
          { property: "og:title", content: title },
          { property: "twitter:title", content: title }
        );
        break;
      }
      case "description": {
        const content = validate(
          schema.description,
          dedupedSeoInput.description
        );
        if (!content) {
          break;
        }
        tagResults.push(
          {
            name: "description",
            content
          },
          {
            property: "og:description",
            content
          },
          {
            property: "twitter:description",
            content
          }
        );
        break;
      }
      case "url": {
        const content = validate(schema.url, dedupedSeoInput.url);
        if (!content) {
          break;
        }
        const urlWithoutParams = content.split("?")[0];
        const urlWithoutTrailingSlash = urlWithoutParams.replace(/\/$/, "");
        tagResults.push(
          {
            tagName: "link",
            rel: "canonical",
            href: urlWithoutTrailingSlash
          },
          {
            property: "og:url",
            content: urlWithoutTrailingSlash
          }
        );
        break;
      }
      case "handle": {
        const content = validate(schema.handle, dedupedSeoInput.handle);
        if (!content) {
          break;
        }
        tagResults.push(
          { property: "twitter:site", content },
          { property: "twitter:creator", content }
        );
        break;
      }
      case "media": {
        let content;
        const values = ensureArray(dedupedSeoInput.media);
        for (const media of values) {
          if (typeof media === "string") {
            tagResults.push({ property: "og:image", content: media });
          }
          if (media && typeof media === "object") {
            const type = media.type || "image";
            const normalizedMedia = media ? {
              url: media == null ? void 0 : media.url,
              secure_url: media == null ? void 0 : media.url,
              type: inferMimeType(media.url),
              width: media == null ? void 0 : media.width,
              height: media == null ? void 0 : media.height,
              alt: media == null ? void 0 : media.altText
            } : {};
            for (const key of Object.keys(normalizedMedia)) {
              if (normalizedMedia[key]) {
                content = normalizedMedia[key];
                tagResults.push({
                  property: `og:${type}:${key}`,
                  content
                });
              }
            }
          }
        }
        break;
      }
      case "jsonLd": {
        const jsonLdBlocks = ensureArray(dedupedSeoInput.jsonLd);
        for (const block of jsonLdBlocks) {
          if (typeof block !== "object" || Object.keys(block).length === 0) {
            continue;
          }
          tagResults.push({
            "script:ld+json": block
          });
        }
        break;
      }
      case "alternates": {
        const alternates = ensureArray(dedupedSeoInput.alternates);
        for (const alternate of alternates) {
          if (!alternate) {
            continue;
          }
          const { language, url, default: defaultLang } = alternate;
          const hrefLang = language ? `${language}${defaultLang ? "-default" : ""}` : void 0;
          tagResults.push({
            tagName: "link",
            rel: "alternate",
            hrefLang,
            href: url
          });
        }
        break;
      }
      case "robots": {
        if (!dedupedSeoInput.robots) {
          break;
        }
        const {
          maxImagePreview,
          maxSnippet,
          maxVideoPreview,
          noArchive,
          noFollow,
          noImageIndex,
          noIndex,
          noSnippet,
          noTranslate,
          unavailableAfter
        } = dedupedSeoInput.robots;
        const robotsParams = [
          noArchive && "noarchive",
          noImageIndex && "noimageindex",
          noSnippet && "nosnippet",
          noTranslate && `notranslate`,
          maxImagePreview && `max-image-preview:${maxImagePreview}`,
          maxSnippet && `max-snippet:${maxSnippet}`,
          maxVideoPreview && `max-video-preview:${maxVideoPreview}`,
          unavailableAfter && `unavailable_after:${unavailableAfter}`
        ];
        let robotsParam = (noIndex ? "noindex" : "index") + "," + (noFollow ? "nofollow" : "follow");
        for (let param of robotsParams) {
          if (param) {
            robotsParam += `,${param}`;
          }
        }
        tagResults.push({ name: "robots", content: robotsParam });
        break;
      }
    }
  }
  return tagResults;
}
var SeoLogger = (0, import_react28.lazy)(() => import("./log-seo-tags-IG37ONQ2-BOAVULAS.js"));
function Seo({ debug }) {
  const matches = useMatches();
  const location2 = useLocation();
  console.warn(
    "[h2:warn:Seo] The `<Seo/>` component is deprecated. Use `getSeoMeta` instead.\nSee: https://shopify.dev/docs/api/hydrogen/utilities/getseometa"
  );
  const seoConfig = (0, import_react28.useMemo)(() => {
    return matches.flatMap((match) => {
      var _a3;
      const { handle, ...routeMatch } = match;
      const routeData = { ...routeMatch, ...location2 };
      const handleSeo = handle == null ? void 0 : handle.seo;
      const loaderSeo = (_a3 = routeMatch == null ? void 0 : routeMatch.data) == null ? void 0 : _a3.seo;
      if (!handleSeo && !loaderSeo) {
        return [];
      }
      if (handleSeo) {
        return recursivelyInvokeOrReturn(handleSeo, routeData);
      } else {
        return [loaderSeo];
      }
    }).reduce((acc, current) => {
      Object.keys(current).forEach(
        (key) => !current[key] && delete current[key]
      );
      const { jsonLd } = current;
      if (!jsonLd) {
        return { ...acc, ...current };
      }
      if (!(acc == null ? void 0 : acc.jsonLd)) {
        return { ...acc, ...current, jsonLd: [jsonLd] };
      } else {
        if (Array.isArray(jsonLd)) {
          return {
            ...acc,
            ...current,
            jsonLd: [...acc.jsonLd, ...jsonLd]
          };
        } else {
          return {
            ...acc,
            ...current,
            jsonLd: [...acc.jsonLd, jsonLd]
          };
        }
      }
    }, {});
  }, [matches, location2]);
  const { html, loggerMarkup } = (0, import_react28.useMemo)(() => {
    const headTags = generateSeoTags(seoConfig);
    const html2 = headTags.map((tag) => {
      if (tag.tag === "script") {
        return (0, import_react28.createElement)(tag.tag, {
          ...tag.props,
          key: tag.key,
          dangerouslySetInnerHTML: { __html: tag.children }
        });
      }
      return (0, import_react28.createElement)(tag.tag, { ...tag.props, key: tag.key }, tag.children);
    });
    const loggerMarkup2 = (0, import_react28.createElement)(
      import_react28.Suspense,
      { fallback: null },
      (0, import_react28.createElement)(SeoLogger, { headTags })
    );
    return { html: html2, loggerMarkup: loggerMarkup2 };
  }, [seoConfig]);
  return (0, import_react28.createElement)(import_react28.Fragment, null, html, debug && loggerMarkup);
}
function recursivelyInvokeOrReturn(value, ...rest) {
  if (value instanceof Function) {
    return recursivelyInvokeOrReturn(value(...rest), ...rest);
  }
  let result = {};
  if (Array.isArray(value)) {
    result = value.reduce((acc, item) => {
      return [...acc, recursivelyInvokeOrReturn(item)];
    }, []);
    return result;
  }
  if (value instanceof Object) {
    const entries = Object.entries(value);
    entries.forEach(([key, val]) => {
      result[key] = recursivelyInvokeOrReturn(val, ...rest);
    });
    return result;
  }
  return value;
}
function ShopPayButton2(props) {
  return (0, import_jsx_runtime22.jsx)(ShopPayButton, { channel: "hydrogen", ...props });
}
var SITEMAP_INDEX_PREFIX = `<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
`;
var SITEMAP_INDEX_SUFFIX = `
</sitemapindex>`;
var SITEMAP_PREFIX = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9" xmlns:xhtml="http://www.w3.org/1999/xhtml">`;
var SITEMAP_SUFFIX = `</urlset>`;
async function getSitemapIndex(options) {
  const {
    storefront,
    request,
    types = [
      "products",
      "pages",
      "collections",
      "metaObjects",
      "articles",
      "blogs"
    ],
    customChildSitemaps = []
  } = options;
  if (!request || !request.url)
    throw new Error("A request object is required to generate a sitemap index");
  if (!storefront || !storefront.query)
    throw new Error(
      "A storefront client is required to generate a sitemap index"
    );
  const data = await storefront.query(SITEMAP_INDEX_QUERY);
  if (!data) {
    console.warn(
      "[h2:sitemap:warning] Sitemap index is available in API version 2024-10 and later"
    );
    throw new Response("Sitemap index not found.", { status: 404 });
  }
  const baseUrl = new URL(request.url).origin;
  const body = SITEMAP_INDEX_PREFIX + types.map((type) => {
    if (!data[type]) {
      throw new Error(
        `[h2:sitemap:error] No data found for type ${type}. Check types passed to \`getSitemapIndex\``
      );
    }
    return getSiteMapLinks(type, data[type].pagesCount.count, baseUrl);
  }).join("\n") + customChildSitemaps.map(
    (url) => "  <sitemap><loc>" + (baseUrl + (url.startsWith("/") ? url : "/" + url)) + "</loc></sitemap>"
  ).join("\n") + SITEMAP_INDEX_SUFFIX;
  return new Response(body, {
    headers: {
      "Content-Type": "application/xml",
      "Cache-Control": `max-age=${60 * 60 * 24}`
    }
  });
}
async function getSitemap(options) {
  var _a3, _b, _c;
  const {
    storefront,
    request,
    params,
    getLink,
    locales = [],
    getChangeFreq,
    noItemsFallback = "/"
  } = options;
  if (!params)
    throw new Error(
      "[h2:sitemap:error] Remix params object is required to generate a sitemap"
    );
  if (!request || !request.url)
    throw new Error("A request object is required to generate a sitemap");
  if (!storefront || !storefront.query)
    throw new Error("A storefront client is required to generate a index");
  if (!getLink)
    throw new Error(
      "A `getLink` function to generate each resource is required to build a sitemap"
    );
  if (!params.type || !params.page)
    throw new Response("No data found", { status: 404 });
  const type = params.type;
  const query = QUERIES[type];
  if (!query) throw new Response("Not found", { status: 404 });
  const data = await storefront.query(query, {
    variables: {
      page: parseInt(params.page, 10)
    }
  });
  if (!data) {
    console.warn(
      "[h2:sitemap:warning] Sitemap is available in API version 2024-10 and later"
    );
    throw new Response("Sitemap not found.", { status: 404 });
  }
  const baseUrl = new URL(request.url).origin;
  let body = "";
  if (!((_c = (_b = (_a3 = data == null ? void 0 : data.sitemap) == null ? void 0 : _a3.resources) == null ? void 0 : _b.items) == null ? void 0 : _c.length)) {
    body = SITEMAP_PREFIX + `
  <url><loc>${baseUrl + noItemsFallback}</loc></url>
` + SITEMAP_SUFFIX;
  } else {
    body = SITEMAP_PREFIX + data.sitemap.resources.items.map((item) => {
      return renderUrlTag({
        getChangeFreq,
        url: getLink({
          type: item.type ?? type,
          baseUrl,
          handle: item.handle
        }),
        type,
        getLink,
        updatedAt: item.updatedAt,
        handle: item.handle,
        metaobjectType: item.type,
        locales,
        baseUrl
      });
    }).join("\n") + SITEMAP_SUFFIX;
  }
  return new Response(body, {
    headers: {
      "Content-Type": "application/xml",
      "Cache-Control": `max-age=${60 * 60 * 24}`
    }
  });
}
function getSiteMapLinks(resource, count, baseUrl) {
  let links = ``;
  for (let i2 = 1; i2 <= count; i2++) {
    links += `  <sitemap><loc>${baseUrl}/sitemap/${resource}/${i2}.xml</loc></sitemap>
`;
  }
  return links;
}
function renderUrlTag({
  url,
  updatedAt,
  locales,
  type,
  getLink,
  baseUrl,
  handle,
  getChangeFreq,
  metaobjectType
}) {
  return `<url>
  <loc>${url}</loc>
  <lastmod>${updatedAt}</lastmod>
  <changefreq>${getChangeFreq ? getChangeFreq({ type: metaobjectType ?? type, handle }) : "weekly"}</changefreq>
${locales.map(
    (locale) => renderAlternateTag(
      getLink({ type: metaobjectType ?? type, baseUrl, handle, locale }),
      locale
    )
  ).join("\n")}
</url>
  `.trim();
}
function renderAlternateTag(url, locale) {
  return `  <xhtml:link rel="alternate" hreflang="${locale}" href="${url}" />`;
}
var PRODUCT_SITEMAP_QUERY = `#graphql
    query SitemapProducts($page: Int!) {
      sitemap(type: PRODUCT) {
        resources(page: $page) {
          items {
            handle
            updatedAt
          }
        }
      }
    }
`;
var COLLECTION_SITEMAP_QUERY = `#graphql
    query SitemapCollections($page: Int!) {
      sitemap(type: COLLECTION) {
        resources(page: $page) {
          items {
            handle
            updatedAt
          }
        }
      }
    }
`;
var ARTICLE_SITEMAP_QUERY = `#graphql
    query SitemapArticles($page: Int!) {
      sitemap(type: ARTICLE) {
        resources(page: $page) {
          items {
            handle
            updatedAt
          }
        }
      }
    }
`;
var PAGE_SITEMAP_QUERY = `#graphql
    query SitemapPages($page: Int!) {
      sitemap(type: PAGE) {
        resources(page: $page) {
          items {
            handle
            updatedAt
          }
        }
      }
    }
`;
var BLOG_SITEMAP_QUERY = `#graphql
    query SitemapBlogs($page: Int!) {
      sitemap(type: BLOG) {
        resources(page: $page) {
          items {
            handle
            updatedAt
          }
        }
      }
    }
`;
var METAOBJECT_SITEMAP_QUERY = `#graphql
    query SitemapMetaobjects($page: Int!) {
      sitemap(type: METAOBJECT) {
        resources(page: $page) {
          items {
            handle
            updatedAt
            ... on SitemapResourceMetaobject {
              type
            }
          }
        }
      }
    }
`;
var SITEMAP_INDEX_QUERY = `#graphql
query SitemapIndex {
  products: sitemap(type: PRODUCT) {
    pagesCount {
      count
    }
  }
  collections: sitemap(type: COLLECTION) {
    pagesCount {
      count
    }
  }
  articles: sitemap(type: ARTICLE) {
    pagesCount {
      count
    }
  }
  pages: sitemap(type: PAGE) {
    pagesCount {
      count
    }
  }
  blogs: sitemap(type: BLOG) {
    pagesCount {
      count
    }
  }
  metaObjects: sitemap(type: METAOBJECT) {
    pagesCount {
      count
    }
  }
}
`;
var QUERIES = {
  products: PRODUCT_SITEMAP_QUERY,
  articles: ARTICLE_SITEMAP_QUERY,
  collections: COLLECTION_SITEMAP_QUERY,
  pages: PAGE_SITEMAP_QUERY,
  blogs: BLOG_SITEMAP_QUERY,
  metaObjects: METAOBJECT_SITEMAP_QUERY
};

export {
  flattenConnection,
  getShopifyCookies,
  AnalyticsEventName,
  AnalyticsPageType,
  ShopifySalesChannel,
  parseGid,
  sendShopifyAnalytics,
  getClientBrowserParameters,
  useMoney,
  Money,
  storefrontApiCustomScalars,
  customerAccountApiCustomScalars,
  ExternalVideo,
  isOptionValueCombinationInEncodedVariant,
  decodeEncodedVariant,
  mapSelectedProductOptionToObject,
  getAdjacentAndFirstAvailableVariants,
  getProductOptions,
  IMAGE_FRAGMENT,
  Image,
  useLoadScript,
  Video,
  ModelViewer,
  MediaFile,
  parseMetafield,
  useSelectedOptionInUrlParam,
  useShopifyCookies,
  AnalyticsEvent,
  useCustomerPrivacy,
  useAnalytics,
  getShopAnalytics,
  Analytics,
  generateCacheControlHeader,
  CacheNone,
  CacheShort,
  CacheLong,
  CacheCustom,
  createWithCache,
  InMemoryCache,
  CartForm,
  cartGetIdDefault,
  cartSetIdDefault,
  createStorefrontClient2 as createStorefrontClient,
  formatAPIResult,
  cartGetDefault,
  cartCreateDefault,
  cartLinesAddDefault,
  cartLinesUpdateDefault,
  cartLinesRemoveDefault,
  cartDiscountCodesUpdateDefault,
  cartBuyerIdentityUpdateDefault,
  cartNoteUpdateDefault,
  cartSelectedDeliveryOptionsUpdateDefault,
  cartAttributesUpdateDefault,
  cartMetafieldsSetDefault,
  cartMetafieldDeleteDefault,
  cartGiftCardCodesUpdateDefault,
  cartGiftCardCodesRemoveDefault,
  createCartHandler,
  useOptimisticCart,
  changelogHandler,
  hydrogenContext,
  createCustomerAccountClient,
  createHydrogenContext,
  NonceProvider,
  useNonce,
  createContentSecurityPolicy,
  Script,
  hydrogenRoutes,
  useOptimisticData,
  OptimisticInput,
  Pagination,
  getPaginationVariables,
  useOptimisticVariant,
  VariantSelector,
  getSelectedProductOptions,
  hydrogenPreset,
  RichText2 as RichText,
  graphiqlLoader,
  storefrontRedirect,
  getSeoMeta,
  Seo,
  ShopPayButton2 as ShopPayButton,
  getSitemapIndex,
  getSitemap
};
/*! Bundled license information:

@xstate/fsm/es/index.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.min.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.mjs:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.mjs:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@shopify/hydrogen/dist/development/index.js:
  (*! @see https://shopify.dev/docs/api/storefront/latest/queries/cart *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartCreate *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartLinesAdd *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartLinesUpdate *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartLinesRemove *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartDiscountCodesUpdate *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartBuyerIdentityUpdate *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartNoteUpdate *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartSelectedDeliveryOptionsUpdate *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartMetafieldsSet *)
  (*! @see https://shopify.dev/docs/api/storefront/2025-07/mutations/cartMetafieldDelete *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartGiftCardCodesUpdate *)
  (*! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartGiftCardCodesRemove *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartDeliveryAddressesAdd *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartDeliveryAddressesRemove *)
  (*! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartDeliveryAddressesUpdate *)
*/
//# sourceMappingURL=chunk-4VU4HVP4.js.map
